(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.domToPptx = {}));
})(this, (function (exports) { 'use strict';

  var global = typeof self !== "undefined" ? self : this; 
        var process = { env: { NODE_ENV: "production" } };
      

  var global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read$1 (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write$2 (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString$3 = {}.toString;

  var isArray$2 = Array.isArray || function (arr) {
    return toString$3.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  /*
   * Export kMaxLength after typed array support is determined.
   */
  kMaxLength();

  function kMaxLength () {
    return Buffer.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer (arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray$2(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }
  Buffer.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer.concat = function concat (list, length) {
    if (!isArray$2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer.compare(this, b) === 0
  };

  Buffer.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read$1(this, offset, true, 23, 4)
  };

  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read$1(this, offset, false, 23, 4)
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read$1(this, offset, true, 52, 8)
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read$1(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write$2(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write$2(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, '__esModule')) return n;
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function a () {
  			var isInstance = false;
        try {
          isInstance = this instanceof a;
        } catch {}
  			if (isInstance) {
          return Reflect.construct(f, arguments, this.constructor);
  			}
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function commonjsRequire(path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var _polyfillNode_fs = {};

  var _polyfillNode_fs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _polyfillNode_fs
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_fs$1);

  // shim for using process in browser
  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;
  if (typeof global$1.setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
  }
  if (typeof global$1.clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }


  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }



  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }

  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  function nextTick(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  }
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  var title = 'browser';
  var platform$1 = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version = ''; // empty string to avoid regexp issues
  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;

  function binding(name) {
      throw new Error('process.binding is not supported');
  }

  function cwd () { return '/' }
  function chdir (dir) {
      throw new Error('process.chdir is not supported');
  }function umask() { return 0; }

  // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
  var performance = global$1.performance || {};
  var performanceNow =
    performance.now        ||
    performance.mozNow     ||
    performance.msNow      ||
    performance.oNow       ||
    performance.webkitNow  ||
    function(){ return (new Date()).getTime() };

  // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime
  function hrtime(previousTimestamp){
    var clocktime = performanceNow.call(performance)*1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor((clocktime%1)*1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds<0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }
    return [seconds,nanoseconds]
  }

  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }

  var browser$1 = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform$1,
    release: release,
    config: config,
    uptime: uptime
  };

  var hasFetch = isFunction$1(global$1.fetch) && isFunction$1(global$1.ReadableStream);

  var _blobConstructor;
  function blobConstructor() {
    if (typeof _blobConstructor !== 'undefined') {
      return _blobConstructor;
    }
    try {
      new global$1.Blob([new ArrayBuffer(1)]);
      _blobConstructor = true;
    } catch (e) {
      _blobConstructor = false;
    }
    return _blobConstructor
  }
  var xhr;

  function checkTypeSupport(type) {
    if (!xhr) {
      xhr = new global$1.XMLHttpRequest();
      // If location.host is empty, e.g. if this page/worker was loaded
      // from a Blob, then use example.com to avoid an error
      xhr.open('GET', global$1.location.host ? '/' : 'https://example.com');
    }
    try {
      xhr.responseType = type;
      return xhr.responseType === type
    } catch (e) {
      return false
    }

  }

  // For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
  // Safari 7.1 appears to have fixed this bug.
  var haveArrayBuffer = typeof global$1.ArrayBuffer !== 'undefined';
  var haveSlice = haveArrayBuffer && isFunction$1(global$1.ArrayBuffer.prototype.slice);

  var arraybuffer = haveArrayBuffer && checkTypeSupport('arraybuffer');
    // These next two tests unavoidably show warnings in Chrome. Since fetch will always
    // be used if it's available, just return false for these to avoid the warnings.
  var msstream = !hasFetch && haveSlice && checkTypeSupport('ms-stream');
  var mozchunkedarraybuffer = !hasFetch && haveArrayBuffer &&
    checkTypeSupport('moz-chunked-arraybuffer');
  var overrideMimeType = isFunction$1(xhr.overrideMimeType);
  var vbArray = isFunction$1(global$1.VBArray);

  function isFunction$1(value) {
    return typeof value === 'function'
  }

  xhr = null; // Help gc

  var inherits;
  if (typeof Object.create === 'function'){
    inherits = function inherits(ctor, superCtor) {
      // implementation from standard node.js 'util' module
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    };
  } else {
    inherits = function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    };
  }
  var inherits$1 = inherits;

  var formatRegExp = /%[sdj%]/g;
  function format$1(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(' ');
    }

    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
      if (x === '%%') return '%';
      if (i >= len) return x;
      switch (x) {
        case '%s': return String(args[i++]);
        case '%d': return Number(args[i++]);
        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }
        default:
          return x;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += ' ' + x;
      } else {
        str += ' ' + inspect(x);
      }
    }
    return str;
  }

  // Mark that a method should not be used.
  // Returns a modified function which warns once by default.
  // If --no-deprecation is set, then it is a no-op.
  function deprecate(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global$1.process)) {
      return function() {
        return deprecate(fn, msg).apply(this, arguments);
      };
    }

    if (browser$1.noDeprecation === true) {
      return fn;
    }

    var warned = false;
    function deprecated() {
      if (!warned) {
        if (browser$1.throwDeprecation) {
          throw new Error(msg);
        } else if (browser$1.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }

    return deprecated;
  }

  var debugs = {};
  var debugEnviron;
  function debuglog(set) {
    if (isUndefined(debugEnviron))
      debugEnviron = browser$1.env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
        var pid = 0;
        debugs[set] = function() {
          var msg = format$1.apply(null, arguments);
          console.error('%s %d: %s', set, pid, msg);
        };
      } else {
        debugs[set] = function() {};
      }
    }
    return debugs[set];
  }

  /**
   * Echos the value of a value. Trys to print the value out
   * in the best way possible given the different types.
   *
   * @param {Object} obj The object to print out.
   * @param {Object} opts Optional options object that alters the output.
   */
  /* legacy: obj, showHidden, depth, colors*/
  function inspect(obj, opts) {
    // default options
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      // legacy...
      ctx.showHidden = opts;
    } else if (opts) {
      // got an "options" object
      _extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }

  // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
  inspect.colors = {
    'bold' : [1, 22],
    'italic' : [3, 23],
    'underline' : [4, 24],
    'inverse' : [7, 27],
    'white' : [37, 39],
    'grey' : [90, 39],
    'black' : [30, 39],
    'blue' : [34, 39],
    'cyan' : [36, 39],
    'green' : [32, 39],
    'magenta' : [35, 39],
    'red' : [31, 39],
    'yellow' : [33, 39]
  };

  // Don't use 'blue' not visible on cmd.exe
  inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
  };


  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];

    if (style) {
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +
             '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
      return str;
    }
  }


  function stylizeNoColor(str, styleType) {
    return str;
  }


  function arrayToHash(array) {
    var hash = {};

    array.forEach(function(val, idx) {
      hash[val] = true;
    });

    return hash;
  }


  function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect &&
        value &&
        isFunction(value.inspect) &&
        // Filter out the util module, it's inspect function is special
        value.inspect !== inspect &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }

    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }

    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);

    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }

    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value)
        && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
      return formatError(value);
    }

    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ': ' + value.name : '';
        return ctx.stylize('[Function' + name + ']', 'special');
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), 'date');
      }
      if (isError(value)) {
        return formatError(value);
      }
    }

    var base = '', array = false, braces = ['{', '}'];

    // Make Array say that they are Array
    if (isArray$1(value)) {
      array = true;
      braces = ['[', ']'];
    }

    // Make functions say that they are functions
    if (isFunction(value)) {
      var n = value.name ? ': ' + value.name : '';
      base = ' [Function' + n + ']';
    }

    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
      base = ' ' + RegExp.prototype.toString.call(value);
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + Date.prototype.toUTCString.call(value);
    }

    // Make error with message first say the error
    if (isError(value)) {
      base = ' ' + formatError(value);
    }

    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
      } else {
        return ctx.stylize('[Object]', 'special');
      }
    }

    ctx.seen.push(value);

    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }

    ctx.seen.pop();

    return reduceToSingleString(output, base, braces);
  }


  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                               .replace(/'/g, "\\'")
                                               .replace(/\\"/g, '"') + '\'';
      return ctx.stylize(simple, 'string');
    }
    if (isNumber(value))
      return ctx.stylize('' + value, 'number');
    if (isBoolean(value))
      return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value))
      return ctx.stylize('null', 'null');
  }


  function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
  }


  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty$1(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            String(i), true));
      } else {
        output.push('');
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
            key, true));
      }
    });
    return output;
  }


  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize('[Getter/Setter]', 'special');
      } else {
        str = ctx.stylize('[Getter]', 'special');
      }
    } else {
      if (desc.set) {
        str = ctx.stylize('[Setter]', 'special');
      }
    }
    if (!hasOwnProperty$1(visibleKeys, key)) {
      name = '[' + key + ']';
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf('\n') > -1) {
          if (array) {
            str = str.split('\n').map(function(line) {
              return '  ' + line;
            }).join('\n').substr(2);
          } else {
            str = '\n' + str.split('\n').map(function(line) {
              return '   ' + line;
            }).join('\n');
          }
        }
      } else {
        str = ctx.stylize('[Circular]', 'special');
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify('' + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, 'name');
      } else {
        name = name.replace(/'/g, "\\'")
                   .replace(/\\"/g, '"')
                   .replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, 'string');
      }
    }

    return name + ': ' + str;
  }


  function reduceToSingleString(output, base, braces) {
    var length = output.reduce(function(prev, cur) {
      if (cur.indexOf('\n') >= 0) ;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);

    if (length > 60) {
      return braces[0] +
             (base === '' ? '' : base + '\n ') +
             ' ' +
             output.join(',\n  ') +
             ' ' +
             braces[1];
    }

    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
  }


  // NOTE: These type checking functions intentionally don't use `instanceof`
  // because it is fragile and can be easily faked with `Object.create()`.
  function isArray$1(ar) {
    return Array.isArray(ar);
  }

  function isBoolean(arg) {
    return typeof arg === 'boolean';
  }

  function isNull(arg) {
    return arg === null;
  }

  function isNullOrUndefined(arg) {
    return arg == null;
  }

  function isNumber(arg) {
    return typeof arg === 'number';
  }

  function isString(arg) {
    return typeof arg === 'string';
  }

  function isUndefined(arg) {
    return arg === void 0;
  }

  function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
  }

  function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  }

  function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
  }

  function isError(e) {
    return isObject(e) &&
        (objectToString(e) === '[object Error]' || e instanceof Error);
  }

  function isFunction(arg) {
    return typeof arg === 'function';
  }

  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }

  function _extend(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;

    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  function hasOwnProperty$1(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var domain;

  // This constructor is used to store event handlers. Instantiating this is
  // faster than explicitly calling `Object.create(null)` to get a "clean" empty
  // object (tested with v8 v4.9).
  function EventHandlers() {}
  EventHandlers.prototype = Object.create(null);

  function EventEmitter() {
    EventEmitter.init.call(this);
  }

  // nodejs oddity
  // require('events') === require('events').EventEmitter
  EventEmitter.EventEmitter = EventEmitter;

  EventEmitter.usingDomains = false;

  EventEmitter.prototype.domain = undefined;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;

  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  EventEmitter.defaultMaxListeners = 10;

  EventEmitter.init = function() {
    this.domain = null;
    if (EventEmitter.usingDomains) {
      // if there is an active domain, then attach to it.
      if (domain.active ) ;
    }

    if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  };

  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };

  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };

  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      handler.call(self);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      handler.call(self, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      handler.call(self, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2, arg3);
    }
  }

  function emitMany(handler, isFn, self, args) {
    if (isFn)
      handler.apply(self, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self, args);
    }
  }

  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events, domain;
    var doError = (type === 'error');

    events = this._events;
    if (events)
      doError = (doError && events.error == null);
    else if (!doError)
      return false;

    domain = this.domain;

    // If there is no 'error' event listener then throw.
    if (doError) {
      er = arguments[1];
      if (domain) {
        if (!er)
          er = new Error('Uncaught, unspecified "error" event');
        er.domainEmitter = this;
        er.domain = domain;
        er.domainThrown = false;
        domain.emit('error', er);
      } else if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }

    handler = events[type];

    if (!handler)
      return false;

    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
      // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
      // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;

    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');

    events = target._events;
    if (!events) {
      events = target._events = new EventHandlers();
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
                    listener.listener ? listener.listener : listener);

        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }

    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] :
                                            [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }

      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
                              existing.length + ' ' + type + ' listeners added. ' +
                              'Use emitter.setMaxListeners() to increase limit');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          emitWarning(w);
        }
      }
    }

    return target;
  }
  function emitWarning(e) {
    typeof console.warn === 'function' ? console.warn(e) : console.log(e);
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

  function _onceWrap(target, type, listener) {
    var fired = false;
    function g() {
      target.removeListener(type, g);
      if (!fired) {
        fired = true;
        listener.apply(target, arguments);
      }
    }
    g.listener = listener;
    return g;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };

  // emits a 'removeListener' event iff the listener was removed
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;

        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');

        events = this._events;
        if (!events)
          return this;

        list = events[type];
        if (!list)
          return this;

        if (list === listener || (list.listener && list.listener === listener)) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length; i-- > 0;) {
            if (list[i] === listener ||
                (list[i].listener && list[i].listener === listener)) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0)
            return this;

          if (list.length === 1) {
            list[0] = undefined;
            if (--this._eventsCount === 0) {
              this._events = new EventHandlers();
              return this;
            } else {
              delete events[type];
            }
          } else {
            spliceOne(list, position);
          }

          if (events.removeListener)
            this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };
      
  // Alias for removeListener added in NodeJS 10.0
  // https://nodejs.org/api/events.html#events_emitter_off_eventname_listener
  EventEmitter.prototype.off = function(type, listener){
      return this.removeListener(type, listener);
  };

  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events;

        events = this._events;
        if (!events)
          return this;

        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = new EventHandlers();
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = new EventHandlers();
            else
              delete events[type];
          }
          return this;
        }

        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          for (var i = 0, key; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = new EventHandlers();
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          do {
            this.removeListener(type, listeners[listeners.length - 1]);
          } while (listeners[0]);
        }

        return this;
      };

  EventEmitter.prototype.listeners = function listeners(type) {
    var evlistener;
    var ret;
    var events = this._events;

    if (!events)
      ret = [];
    else {
      evlistener = events[type];
      if (!evlistener)
        ret = [];
      else if (typeof evlistener === 'function')
        ret = [evlistener.listener || evlistener];
      else
        ret = unwrapListeners(evlistener);
    }

    return ret;
  };

  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount$1.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount$1;
  function listenerCount$1(type) {
    var events = this._events;

    if (events) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };

  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }

  function arrayClone(arr, i) {
    var copy = new Array(i);
    while (i--)
      copy[i] = arr[i];
    return copy;
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }

  function BufferList() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function (v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function (v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function () {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function () {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function (s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function (n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      p.data.copy(ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  // Copyright Joyent, Inc. and other Node contributors.
  var isBufferEncoding = Buffer.isEncoding
    || function(encoding) {
         switch (encoding && encoding.toLowerCase()) {
           case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
           default: return false;
         }
       };


  function assertEncoding(encoding) {
    if (encoding && !isBufferEncoding(encoding)) {
      throw new Error('Unknown encoding: ' + encoding);
    }
  }

  // StringDecoder provides an interface for efficiently splitting a series of
  // buffers into a series of JS strings without breaking apart multi-byte
  // characters. CESU-8 is handled as part of the UTF-8 encoding.
  //
  // @TODO Handling all encodings inside a single object makes it very difficult
  // to reason about this code, so it should be split up in the future.
  // @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
  // points as used by CESU-8.
  function StringDecoder(encoding) {
    this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
    assertEncoding(encoding);
    switch (this.encoding) {
      case 'utf8':
        // CESU-8 represents each of Surrogate Pair by 3-bytes
        this.surrogateSize = 3;
        break;
      case 'ucs2':
      case 'utf16le':
        // UTF-16 represents each of Surrogate Pair by 2-bytes
        this.surrogateSize = 2;
        this.detectIncompleteChar = utf16DetectIncompleteChar;
        break;
      case 'base64':
        // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
        this.surrogateSize = 3;
        this.detectIncompleteChar = base64DetectIncompleteChar;
        break;
      default:
        this.write = passThroughWrite;
        return;
    }

    // Enough space to store all bytes of a single character. UTF-8 needs 4
    // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
    this.charBuffer = new Buffer(6);
    // Number of bytes received for the current incomplete multi-byte character.
    this.charReceived = 0;
    // Number of bytes expected for the current incomplete multi-byte character.
    this.charLength = 0;
  }

  // write decodes the given buffer and returns it as JS string that is
  // guaranteed to not contain any partial multi-byte characters. Any partial
  // character found at the end of the buffer is buffered up, and will be
  // returned when calling write again with the remaining bytes.
  //
  // Note: Converting a Buffer containing an orphan surrogate to a String
  // currently works, but converting a String to a Buffer (via `new Buffer`, or
  // Buffer#write) will replace incomplete surrogates with the unicode
  // replacement character. See https://codereview.chromium.org/121173009/ .
  StringDecoder.prototype.write = function(buffer) {
    var charStr = '';
    // if our last write ended with an incomplete multibyte character
    while (this.charLength) {
      // determine how many remaining bytes this buffer has to offer for this char
      var available = (buffer.length >= this.charLength - this.charReceived) ?
          this.charLength - this.charReceived :
          buffer.length;

      // add the new bytes to the char buffer
      buffer.copy(this.charBuffer, this.charReceived, 0, available);
      this.charReceived += available;

      if (this.charReceived < this.charLength) {
        // still not enough chars in this buffer? wait for more ...
        return '';
      }

      // remove bytes belonging to the current character from the buffer
      buffer = buffer.slice(available, buffer.length);

      // get the character that was split
      charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

      // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
      var charCode = charStr.charCodeAt(charStr.length - 1);
      if (charCode >= 0xD800 && charCode <= 0xDBFF) {
        this.charLength += this.surrogateSize;
        charStr = '';
        continue;
      }
      this.charReceived = this.charLength = 0;

      // if there are no more bytes in this buffer, just emit our char
      if (buffer.length === 0) {
        return charStr;
      }
      break;
    }

    // determine and set charLength / charReceived
    this.detectIncompleteChar(buffer);

    var end = buffer.length;
    if (this.charLength) {
      // buffer the incomplete character bytes we got
      buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
      end -= this.charReceived;
    }

    charStr += buffer.toString(this.encoding, 0, end);

    var end = charStr.length - 1;
    var charCode = charStr.charCodeAt(end);
    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      var size = this.surrogateSize;
      this.charLength += size;
      this.charReceived += size;
      this.charBuffer.copy(this.charBuffer, size, 0, size);
      buffer.copy(this.charBuffer, 0, 0, size);
      return charStr.substring(0, end);
    }

    // or just emit the charStr
    return charStr;
  };

  // detectIncompleteChar determines if there is an incomplete UTF-8 character at
  // the end of the given buffer. If so, it sets this.charLength to the byte
  // length that character, and sets this.charReceived to the number of bytes
  // that are available for this character.
  StringDecoder.prototype.detectIncompleteChar = function(buffer) {
    // determine how many bytes we have to check at the end of this buffer
    var i = (buffer.length >= 3) ? 3 : buffer.length;

    // Figure out if one of the last i bytes of our buffer announces an
    // incomplete char.
    for (; i > 0; i--) {
      var c = buffer[buffer.length - i];

      // See http://en.wikipedia.org/wiki/UTF-8#Description

      // 110XXXXX
      if (i == 1 && c >> 5 == 0x06) {
        this.charLength = 2;
        break;
      }

      // 1110XXXX
      if (i <= 2 && c >> 4 == 0x0E) {
        this.charLength = 3;
        break;
      }

      // 11110XXX
      if (i <= 3 && c >> 3 == 0x1E) {
        this.charLength = 4;
        break;
      }
    }
    this.charReceived = i;
  };

  StringDecoder.prototype.end = function(buffer) {
    var res = '';
    if (buffer && buffer.length)
      res = this.write(buffer);

    if (this.charReceived) {
      var cr = this.charReceived;
      var buf = this.charBuffer;
      var enc = this.encoding;
      res += buf.slice(0, cr).toString(enc);
    }

    return res;
  };

  function passThroughWrite(buffer) {
    return buffer.toString(this.encoding);
  }

  function utf16DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 2;
    this.charLength = this.charReceived ? 2 : 0;
  }

  function base64DetectIncompleteChar(buffer) {
    this.charReceived = buffer.length % 3;
    this.charLength = this.charReceived ? 3 : 0;
  }

  Readable.ReadableState = ReadableState;

  var debug = debuglog('stream');
  inherits$1(Readable, EventEmitter);

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function') {
      return emitter.prependListener(event, fn);
    } else {
      // This is a hack to make sure that our error handler is attached before any
      // userland ones.  NEVER DO THIS. This is here only because this code needs
      // to continue to work with older versions of Node.js that do not include
      // the prependListener() method. The goal is to eventually remove this hack.
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
  }
  function listenerCount (emitter, type) {
    return emitter.listeners(type).length;
  }
  function ReadableState(options, stream) {

    options = options || {};

    // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

    // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // when piping, we only care about 'readable' events that happen
    // after read()ing all the bytes and not getting any pushback.
    this.ranOut = false;

    // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0;

    // if true, a maybeReadMore has been scheduled
    this.readingMore = false;

    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {

    if (!(this instanceof Readable)) return new Readable(options);

    this._readableState = new ReadableState(options, this);

    // legacy
    this.readable = true;

    if (options && typeof options.read === 'function') this._read = options.read;

    EventEmitter.call(this);
  }

  // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.
  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;

    if (!state.objectMode && typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
    }

    return readableAddChunk(this, state, chunk, encoding, false);
  };

  // Unshift should *always* be something directly out of read()
  Readable.prototype.unshift = function (chunk) {
    var state = this._readableState;
    return readableAddChunk(this, state, chunk, '', true);
  };

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  };

  function readableAddChunk(stream, state, chunk, encoding, addToFront) {
    var er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (state.ended && !addToFront) {
        var e = new Error('stream.push() after EOF');
        stream.emit('error', e);
      } else if (state.endEmitted && addToFront) {
        var _e = new Error('stream.unshift() after end event');
        stream.emit('error', _e);
      } else {
        var skipAdd;
        if (state.decoder && !addToFront && !encoding) {
          chunk = state.decoder.write(chunk);
          skipAdd = !state.objectMode && chunk.length === 0;
        }

        if (!addToFront) state.reading = false;

        // Don't add to the buffer if we've decoded to an empty string chunk and
        // we're not in object mode
        if (!skipAdd) {
          // if we want the data now, just emit it.
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit('data', chunk);
            stream.read(0);
          } else {
            // update the buffer info.
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

            if (state.needReadable) emitReadable(stream);
          }
        }

        maybeReadMore(stream, state);
      }
    } else if (!addToFront) {
      state.reading = false;
    }

    return needMoreData(state);
  }

  // if it's past the high water mark, we can push in some more.
  // Also, if we have no data yet, we can stand some
  // more bytes.  This is to work around cases where hwm=0,
  // such as the repl.  Also, if the push() triggered a
  // readable event, and the user called read(largeNumber) such that
  // needReadable was set, then we ought to push more, so that another
  // 'readable' event will be triggered.
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }

  // backwards compatibility.
  Readable.prototype.setEncoding = function (enc) {
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };

  // Don't raise the hwm > 8MB
  var MAX_HWM = 0x800000;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }

  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    }
    // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n;
    // Don't have enough
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }

  // you can override either this method, or the async _read(n) below.
  Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;

    if (n !== 0) state.emittedReadable = false;

    // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      debug('read: emitReadable', state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state);

    // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }

    // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.

    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead);

    // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug('length less than watermark', doRead);
    }

    // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
      doRead = false;
      debug('reading or ended', doRead);
    } else if (doRead) {
      debug('do read');
      state.reading = true;
      state.sync = true;
      // if the length is currently zero, then we *need* a readable event.
      if (state.length === 0) state.needReadable = true;
      // call internal read method
      this._read(state.highWaterMark);
      state.sync = false;
      // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.
      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = true;
      n = 0;
    } else {
      state.length -= n;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true;

      // If we tried to read() past the EOF, then emit end on the next tick.
      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit('data', ret);

    return ret;
  };

  function chunkInvalid(state, chunk) {
    var er = null;
    if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    return er;
  }

  function onEofChunk(stream, state) {
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;

    // emit 'readable' now to make sure it gets picked up.
    emitReadable(stream);
  }

  // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.
  function emitReadable(stream) {
    var state = stream._readableState;
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug('emitReadable', state.flowing);
      state.emittedReadable = true;
      if (state.sync) nextTick(emitReadable_, stream);else emitReadable_(stream);
    }
  }

  function emitReadable_(stream) {
    debug('emit readable');
    stream.emit('readable');
    flow(stream);
  }

  // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      nextTick(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
      debug('maybeReadMore read 0');
      stream.read(0);
      if (len === state.length)
        // didn't get any data, stop spinning.
        break;else len = state.length;
    }
    state.readingMore = false;
  }

  // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.
  Readable.prototype._read = function (n) {
    this.emit('error', new Error('not implemented'));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

    var doEnd = (!pipeOpts || pipeOpts.end !== false);

    var endFn = doEnd ? onend : cleanup;
    if (state.endEmitted) nextTick(endFn);else src.once('end', endFn);

    dest.on('unpipe', onunpipe);
    function onunpipe(readable) {
      debug('onunpipe');
      if (readable === src) {
        cleanup();
      }
    }

    function onend() {
      debug('onend');
      dest.end();
    }

    // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);

    var cleanedUp = false;
    function cleanup() {
      debug('cleanup');
      // cleanup event handlers once the pipe is broken
      dest.removeListener('close', onclose);
      dest.removeListener('finish', onfinish);
      dest.removeListener('drain', ondrain);
      dest.removeListener('error', onerror);
      dest.removeListener('unpipe', onunpipe);
      src.removeListener('end', onend);
      src.removeListener('end', cleanup);
      src.removeListener('data', ondata);

      cleanedUp = true;

      // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    // If the user pushes more data while we're writing to dest then we'll end up
    // in ondata again. However, we only want to increase awaitDrain once because
    // dest will only emit one 'drain' event for the multiple writes.
    // => Introduce a guard on increasing awaitDrain.
    var increasedAwaitDrain = false;
    src.on('data', ondata);
    function ondata(chunk) {
      debug('ondata');
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug('false write response, pause', src._readableState.awaitDrain);
          src._readableState.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src.pause();
      }
    }

    // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
      debug('onerror', er);
      unpipe();
      dest.removeListener('error', onerror);
      if (listenerCount(dest, 'error') === 0) dest.emit('error', er);
    }

    // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror);

    // Both close and finish should trigger unpipe, but only once.
    function onclose() {
      dest.removeListener('finish', onfinish);
      unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
      debug('onfinish');
      dest.removeListener('close', onclose);
      unpipe();
    }
    dest.once('finish', onfinish);

    function unpipe() {
      debug('unpipe');
      src.unpipe(dest);
    }

    // tell the dest that it's being piped to
    dest.emit('pipe', src);

    // start the flow if it hasn't been started already.
    if (!state.flowing) {
      debug('pipe resume');
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function () {
      var state = src._readableState;
      debug('pipeOnDrain', state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && src.listeners('data').length) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;

    // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0) return this;

    // just one destination.  most common case.
    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;

      if (!dest) dest = state.pipes;

      // got a match.
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit('unpipe', this);
      return this;
    }

    // slow case. multiple pipe destinations.

    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var _i = 0; _i < len; _i++) {
        dests[_i].emit('unpipe', this);
      }return this;
    }

    // try to find the right one.
    var i = indexOf(state.pipes, dest);
    if (i === -1) return this;

    state.pipes.splice(i, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];

    dest.emit('unpipe', this);

    return this;
  };

  // set up data events if they are asked for
  // Ensure readable listeners eventually get something
  Readable.prototype.on = function (ev, fn) {
    var res = EventEmitter.prototype.on.call(this, ev, fn);

    if (ev === 'data') {
      // Start flowing on next tick if stream isn't explicitly paused
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === 'readable') {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.emittedReadable = false;
        if (!state.reading) {
          nextTick(nReadingNextTick, this);
        } else if (state.length) {
          emitReadable(this);
        }
      }
    }

    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;

  function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
  }

  // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.
  Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
      debug('resume');
      state.flowing = true;
      resume(this, state);
    }
    return this;
  };

  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      nextTick(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    if (!state.reading) {
      debug('resume read 0');
      stream.read(0);
    }

    state.resumeScheduled = false;
    state.awaitDrain = 0;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug('pause');
      this._readableState.flowing = false;
      this.emit('pause');
    }
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {}
  }

  // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.
  Readable.prototype.wrap = function (stream) {
    var state = this._readableState;
    var paused = false;

    var self = this;
    stream.on('end', function () {
      debug('wrapped end');
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) self.push(chunk);
      }

      self.push(null);
    });

    stream.on('data', function (chunk) {
      debug('wrapped data');
      if (state.decoder) chunk = state.decoder.write(chunk);

      // don't skip over falsy values in objectMode
      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = self.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });

    // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === 'function') {
        this[i] = function (method) {
          return function () {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }

    // proxy certain important events.
    var events = ['error', 'close', 'destroy', 'pause', 'resume'];
    forEach(events, function (ev) {
      stream.on(ev, self.emit.bind(self, ev));
    });

    // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    self._read = function (n) {
      debug('wrapped _read', n);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return self;
  };

  // exposed for testing purposes only.
  Readable._fromList = fromList;

  // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;

    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = fromListPartial(n, state.buffer, state.decoder);
    }

    return ret;
  }

  // Extracts only enough buffered data to satisfy the amount requested.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      // slice is the same for buffers and strings
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      // first chunk is a perfect match
      ret = list.shift();
    } else {
      // result spans more than one buffer
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }

  // Copies a specified amount of characters from the list of buffered data
  // chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  // Copies a specified amount of bytes from the list of buffered data chunks.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.
  function copyFromBuffer(n, list) {
    var ret = Buffer.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;

    // If we get here before consuming all the bytes, then that is a
    // bug in node.  Should never happen.
    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

    if (!state.endEmitted) {
      state.ended = true;
      nextTick(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit('end');
    }
  }

  function forEach(xs, f) {
    for (var i = 0, l = xs.length; i < l; i++) {
      f(xs[i], i);
    }
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }

  // A bit simpler than readable streams.
  Writable.WritableState = WritableState;
  inherits$1(Writable, EventEmitter);

  function nop() {}

  function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
  }

  function WritableState(options, stream) {
    Object.defineProperty(this, 'buffer', {
      get: deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
    });
    options = options || {};

    // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;

    if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

    // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    var hwm = options.highWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

    // cast to ints.
    this.highWaterMark = ~ ~this.highWaterMark;

    this.needDrain = false;
    // at the start of calling end()
    this.ending = false;
    // when end() has been called, and returned
    this.ended = false;
    // when 'finish' is emitted
    this.finished = false;

    // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;

    // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8';

    // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0;

    // a flag to see when we're in the middle of a write.
    this.writing = false;

    // when true all writes will be buffered until .uncork() call
    this.corked = 0;

    // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true;

    // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false;

    // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
      onwrite(stream, er);
    };

    // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null;

    // the amount that is being written when _write is called.
    this.writelen = 0;

    this.bufferedRequest = null;
    this.lastBufferedRequest = null;

    // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0;

    // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false;

    // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false;

    // count buffered requests
    this.bufferedRequestCount = 0;

    // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function writableStateGetBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  function Writable(options) {

    // Writable ctor is applied to Duplexes, though they're not
    // instanceof Writable, they're instanceof Readable.
    if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);

    this._writableState = new WritableState(options, this);

    // legacy.
    this.writable = true;

    if (options) {
      if (typeof options.write === 'function') this._write = options.write;

      if (typeof options.writev === 'function') this._writev = options.writev;
    }

    EventEmitter.call(this);
  }

  // Otherwise people can pipe Writable streams, which is just wrong.
  Writable.prototype.pipe = function () {
    this.emit('error', new Error('Cannot pipe, not readable'));
  };

  function writeAfterEnd(stream, cb) {
    var er = new Error('write after end');
    // TODO: defer error events consistently everywhere, not just the cb
    stream.emit('error', er);
    nextTick(cb, er);
  }

  // If we get something that is not a buffer, string, null, or undefined,
  // and we're not in objectMode, then that's an error.
  // Otherwise stream chunks are all considered to be of length=1, and the
  // watermarks determine how many objects to keep in the buffer, rather than
  // how many bytes or characters.
  function validChunk(stream, state, chunk, cb) {
    var valid = true;
    var er = false;
    // Always throw error if a null is written
    // if we are not in object mode then throw
    // if it is not a buffer, string, or undefined.
    if (chunk === null) {
      er = new TypeError('May not write null values to stream');
    } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
      er = new TypeError('Invalid non-string/buffer chunk');
    }
    if (er) {
      stream.emit('error', er);
      nextTick(cb, er);
      valid = false;
    }
    return valid;
  }

  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

    if (typeof cb !== 'function') cb = nop;

    if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, chunk, encoding, cb);
    }

    return ret;
  };

  Writable.prototype.cork = function () {
    var state = this._writableState;

    state.corked++;
  };

  Writable.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;

      if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string') encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
      chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
  }

  // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.
  function writeOrBuffer(stream, state, chunk, encoding, cb) {
    chunk = decodeChunk(state, chunk, encoding);

    if (Buffer.isBuffer(chunk)) encoding = 'buffer';
    var len = state.objectMode ? 1 : chunk.length;

    state.length += len;

    var ret = state.length < state.highWaterMark;
    // we must ensure that previous needDrain will not be reset to false.
    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) nextTick(cb, er);else cb(er);

    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;

    onwriteStateUpdate(state);

    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state);

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        /*<replacement>*/
          nextTick(afterWrite, stream, state, finished, cb);
        /*</replacement>*/
      } else {
          afterWrite(stream, state, finished, cb);
        }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }

  // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit('drain');
    }
  }

  // if there's something in the buffer waiting, then process it
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;

      var count = 0;
      while (entry) {
        buffer[count] = entry;
        entry = entry.next;
        count += 1;
      }

      doWrite(stream, state, true, state.length, buffer, '', holder.finish);

      // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;

        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.
        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequestCount = 0;
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new Error('not implemented'));
  };

  Writable.prototype._writev = null;

  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === 'function') {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === 'function') {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

    // .end() fully uncorks
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }

    // ignore unnecessary end() calls.
    if (!state.ending && !state.finished) endWritable(this, state, cb);
  };

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function prefinish(stream, state) {
    if (!state.prefinished) {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (state.pendingcb === 0) {
        prefinish(stream, state);
        state.finished = true;
        stream.emit('finish');
      } else {
        prefinish(stream, state);
      }
    }
    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) nextTick(cb);else stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
  }

  // It seems a linked list but it is not
  // there will be only 2 of these for each stream
  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function (err) {
      var entry = _this.entry;
      _this.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = _this;
      } else {
        state.corkedRequestsFree = _this;
      }
    };
  }

  inherits$1(Duplex, Readable);

  var keys = Object.keys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);

    Readable.call(this, options);
    Writable.call(this, options);

    if (options && options.readable === false) this.readable = false;

    if (options && options.writable === false) this.writable = false;

    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

    this.once('end', onend);
  }

  // the no-half-open enforcer
  function onend() {
    // if we allow half-open state, or if the writable side ended,
    // then we're ok.
    if (this.allowHalfOpen || this._writableState.ended) return;

    // no more data can be written.
    // But allow more writes to happen in this tick.
    nextTick(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  // a transform stream is a readable/writable stream where you do
  inherits$1(Transform, Duplex);

  function TransformState(stream) {
    this.afterTransform = function (er, data) {
      return afterTransform(stream, er, data);
    };

    this.needTransform = false;
    this.transforming = false;
    this.writecb = null;
    this.writechunk = null;
    this.writeencoding = null;
  }

  function afterTransform(stream, er, data) {
    var ts = stream._transformState;
    ts.transforming = false;

    var cb = ts.writecb;

    if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

    ts.writechunk = null;
    ts.writecb = null;

    if (data !== null && data !== undefined) stream.push(data);

    cb(er);

    var rs = stream._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      stream._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);

    Duplex.call(this, options);

    this._transformState = new TransformState(this);

    // when the writable side finishes, then flush out anything remaining.
    var stream = this;

    // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true;

    // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === 'function') this._transform = options.transform;

      if (typeof options.flush === 'function') this._flush = options.flush;
    }

    this.once('prefinish', function () {
      if (typeof this._flush === 'function') this._flush(function (er) {
        done(stream, er);
      });else done(stream);
    });
  }

  Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };

  // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.
  Transform.prototype._transform = function (chunk, encoding, cb) {
    throw new Error('Not implemented');
  };

  Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };

  // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.
  Transform.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  function done(stream, er) {
    if (er) return stream.emit('error', er);

    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    var ws = stream._writableState;
    var ts = stream._transformState;

    if (ws.length) throw new Error('Calling transform done when ws.length != 0');

    if (ts.transforming) throw new Error('Calling transform done when still transforming');

    return stream.push(null);
  }

  inherits$1(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);

    Transform.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  inherits$1(Stream, EventEmitter);
  Stream.Readable = Readable;
  Stream.Writable = Writable;
  Stream.Duplex = Duplex;
  Stream.Transform = Transform;
  Stream.PassThrough = PassThrough;

  // Backwards-compat with node 0.4.x
  Stream.Stream = Stream;

  // old-style streams.  Note that the pipe method (the only relevant
  // part of this class) is overridden in the Readable class.

  function Stream() {
    EventEmitter.call(this);
  }

  Stream.prototype.pipe = function(dest, options) {
    var source = this;

    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }

    source.on('data', ondata);

    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }

    dest.on('drain', ondrain);

    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on('end', onend);
      source.on('close', onclose);
    }

    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;

      dest.end();
    }


    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;

      if (typeof dest.destroy === 'function') dest.destroy();
    }

    // don't leave dangling pipes when there are errors.
    function onerror(er) {
      cleanup();
      if (EventEmitter.listenerCount(this, 'error') === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }

    source.on('error', onerror);
    dest.on('error', onerror);

    // remove all the event listeners that were added.
    function cleanup() {
      source.removeListener('data', ondata);
      dest.removeListener('drain', ondrain);

      source.removeListener('end', onend);
      source.removeListener('close', onclose);

      source.removeListener('error', onerror);
      dest.removeListener('error', onerror);

      source.removeListener('end', cleanup);
      source.removeListener('close', cleanup);

      dest.removeListener('close', cleanup);
    }

    source.on('end', cleanup);
    source.on('close', cleanup);

    dest.on('close', cleanup);

    dest.emit('pipe', source);

    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
  };

  var rStates = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  };
  function IncomingMessage(xhr, response, mode) {
    var self = this;
    Readable.call(self);

    self._mode = mode;
    self.headers = {};
    self.rawHeaders = [];
    self.trailers = {};
    self.rawTrailers = [];

    // Fake the 'close' event, but only once 'end' fires
    self.on('end', function() {
      // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
      browser$1.nextTick(function() {
        self.emit('close');
      });
    });
    var read;
    if (mode === 'fetch') {
      self._fetchResponse = response;

      self.url = response.url;
      self.statusCode = response.status;
      self.statusMessage = response.statusText;
        // backwards compatible version of for (<item> of <iterable>):
        // for (var <item>,_i,_it = <iterable>[Symbol.iterator](); <item> = (_i = _it.next()).value,!_i.done;)
      for (var header, _i, _it = response.headers[Symbol.iterator](); header = (_i = _it.next()).value, !_i.done;) {
        self.headers[header[0].toLowerCase()] = header[1];
        self.rawHeaders.push(header[0], header[1]);
      }

      // TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
      var reader = response.body.getReader();

      read = function () {
        reader.read().then(function(result) {
          if (self._destroyed)
            return
          if (result.done) {
            self.push(null);
            return
          }
          self.push(new Buffer(result.value));
          read();
        });
      };
      read();

    } else {
      self._xhr = xhr;
      self._pos = 0;

      self.url = xhr.responseURL;
      self.statusCode = xhr.status;
      self.statusMessage = xhr.statusText;
      var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
      headers.forEach(function(header) {
        var matches = header.match(/^([^:]+):\s*(.*)/);
        if (matches) {
          var key = matches[1].toLowerCase();
          if (key === 'set-cookie') {
            if (self.headers[key] === undefined) {
              self.headers[key] = [];
            }
            self.headers[key].push(matches[2]);
          } else if (self.headers[key] !== undefined) {
            self.headers[key] += ', ' + matches[2];
          } else {
            self.headers[key] = matches[2];
          }
          self.rawHeaders.push(matches[1], matches[2]);
        }
      });

      self._charset = 'x-user-defined';
      if (!overrideMimeType) {
        var mimeType = self.rawHeaders['mime-type'];
        if (mimeType) {
          var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
          if (charsetMatch) {
            self._charset = charsetMatch[1].toLowerCase();
          }
        }
        if (!self._charset)
          self._charset = 'utf-8'; // best guess
      }
    }
  }

  inherits$1(IncomingMessage, Readable);

  IncomingMessage.prototype._read = function() {};

  IncomingMessage.prototype._onXHRProgress = function() {
    var self = this;

    var xhr = self._xhr;

    var response = null;
    switch (self._mode) {
    case 'text:vbarray': // For IE9
      if (xhr.readyState !== rStates.DONE)
        break
      try {
        // This fails in IE8
        response = new global$1.VBArray(xhr.responseBody).toArray();
      } catch (e) {
        // pass
      }
      if (response !== null) {
        self.push(new Buffer(response));
        break
      }
      // Falls through in IE8
    case 'text':
      try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
        response = xhr.responseText;
      } catch (e) {
        self._mode = 'text:vbarray';
        break
      }
      if (response.length > self._pos) {
        var newData = response.substr(self._pos);
        if (self._charset === 'x-user-defined') {
          var buffer = new Buffer(newData.length);
          for (var i = 0; i < newData.length; i++)
            buffer[i] = newData.charCodeAt(i) & 0xff;

          self.push(buffer);
        } else {
          self.push(newData, self._charset);
        }
        self._pos = response.length;
      }
      break
    case 'arraybuffer':
      if (xhr.readyState !== rStates.DONE || !xhr.response)
        break
      response = xhr.response;
      self.push(new Buffer(new Uint8Array(response)));
      break
    case 'moz-chunked-arraybuffer': // take whole
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING || !response)
        break
      self.push(new Buffer(new Uint8Array(response)));
      break
    case 'ms-stream':
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING)
        break
      var reader = new global$1.MSStreamReader();
      reader.onprogress = function() {
        if (reader.result.byteLength > self._pos) {
          self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
          self._pos = reader.result.byteLength;
        }
      };
      reader.onload = function() {
        self.push(null);
      };
        // reader.onerror = ??? // TODO: this
      reader.readAsArrayBuffer(response);
      break
    }

    // The ms-stream case handles end separately in reader.onload()
    if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
      self.push(null);
    }
  };

  // from https://github.com/jhiesey/to-arraybuffer/blob/6502d9850e70ba7935a7df4ad86b358fc216f9f0/index.js
  function toArrayBuffer (buf) {
    // If the buffer is backed by a Uint8Array, a faster version will work
    if (buf instanceof Uint8Array) {
      // If the buffer isn't a subarray, return the underlying ArrayBuffer
      if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer
      } else if (typeof buf.buffer.slice === 'function') {
        // Otherwise we need to get a proper copy
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
      }
    }

    if (isBuffer(buf)) {
      // This is the slow version that will work with any Buffer
      // implementation (even in old browsers)
      var arrayCopy = new Uint8Array(buf.length);
      var len = buf.length;
      for (var i = 0; i < len; i++) {
        arrayCopy[i] = buf[i];
      }
      return arrayCopy.buffer
    } else {
      throw new Error('Argument must be a Buffer')
    }
  }

  function decideMode(preferBinary, useFetch) {
    if (hasFetch && useFetch) {
      return 'fetch'
    } else if (mozchunkedarraybuffer) {
      return 'moz-chunked-arraybuffer'
    } else if (msstream) {
      return 'ms-stream'
    } else if (arraybuffer && preferBinary) {
      return 'arraybuffer'
    } else if (vbArray && preferBinary) {
      return 'text:vbarray'
    } else {
      return 'text'
    }
  }

  function ClientRequest(opts) {
    var self = this;
    Writable.call(self);

    self._opts = opts;
    self._body = [];
    self._headers = {};
    if (opts.auth)
      self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'));
    Object.keys(opts.headers).forEach(function(name) {
      self.setHeader(name, opts.headers[name]);
    });

    var preferBinary;
    var useFetch = true;
    if (opts.mode === 'disable-fetch') {
      // If the use of XHR should be preferred and includes preserving the 'content-type' header
      useFetch = false;
      preferBinary = true;
    } else if (opts.mode === 'prefer-streaming') {
      // If streaming is a high priority but binary compatibility and
      // the accuracy of the 'content-type' header aren't
      preferBinary = false;
    } else if (opts.mode === 'allow-wrong-content-type') {
      // If streaming is more important than preserving the 'content-type' header
      preferBinary = !overrideMimeType;
    } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
      // Use binary if text streaming may corrupt data or the content-type header, or for speed
      preferBinary = true;
    } else {
      throw new Error('Invalid value for opts.mode')
    }
    self._mode = decideMode(preferBinary, useFetch);

    self.on('finish', function() {
      self._onFinish();
    });
  }

  inherits$1(ClientRequest, Writable);
  // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
  var unsafeHeaders = [
    'accept-charset',
    'accept-encoding',
    'access-control-request-headers',
    'access-control-request-method',
    'connection',
    'content-length',
    'cookie',
    'cookie2',
    'date',
    'dnt',
    'expect',
    'host',
    'keep-alive',
    'origin',
    'referer',
    'te',
    'trailer',
    'transfer-encoding',
    'upgrade',
    'user-agent',
    'via'
  ];
  ClientRequest.prototype.setHeader = function(name, value) {
    var self = this;
    var lowerName = name.toLowerCase();
      // This check is not necessary, but it prevents warnings from browsers about setting unsafe
      // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
      // http-browserify did it, so I will too.
    if (unsafeHeaders.indexOf(lowerName) !== -1)
      return

    self._headers[lowerName] = {
      name: name,
      value: value
    };
  };

  ClientRequest.prototype.getHeader = function(name) {
    var self = this;
    return self._headers[name.toLowerCase()].value
  };

  ClientRequest.prototype.removeHeader = function(name) {
    var self = this;
    delete self._headers[name.toLowerCase()];
  };

  ClientRequest.prototype._onFinish = function() {
    var self = this;

    if (self._destroyed)
      return
    var opts = self._opts;

    var headersObj = self._headers;
    var body;
    if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
      if (blobConstructor()) {
        body = new global$1.Blob(self._body.map(function(buffer) {
          return toArrayBuffer(buffer)
        }), {
          type: (headersObj['content-type'] || {}).value || ''
        });
      } else {
        // get utf8 string
        body = Buffer.concat(self._body).toString();
      }
    }

    if (self._mode === 'fetch') {
      var headers = Object.keys(headersObj).map(function(name) {
        return [headersObj[name].name, headersObj[name].value]
      });

      global$1.fetch(self._opts.url, {
        method: self._opts.method,
        headers: headers,
        body: body,
        mode: 'cors',
        credentials: opts.withCredentials ? 'include' : 'same-origin'
      }).then(function(response) {
        self._fetchResponse = response;
        self._connect();
      }, function(reason) {
        self.emit('error', reason);
      });
    } else {
      var xhr = self._xhr = new global$1.XMLHttpRequest();
      try {
        xhr.open(self._opts.method, self._opts.url, true);
      } catch (err) {
        browser$1.nextTick(function() {
          self.emit('error', err);
        });
        return
      }

      // Can't set responseType on really old browsers
      if ('responseType' in xhr)
        xhr.responseType = self._mode.split(':')[0];

      if ('withCredentials' in xhr)
        xhr.withCredentials = !!opts.withCredentials;

      if (self._mode === 'text' && 'overrideMimeType' in xhr)
        xhr.overrideMimeType('text/plain; charset=x-user-defined');

      Object.keys(headersObj).forEach(function(name) {
        xhr.setRequestHeader(headersObj[name].name, headersObj[name].value);
      });

      self._response = null;
      xhr.onreadystatechange = function() {
        switch (xhr.readyState) {
        case rStates.LOADING:
        case rStates.DONE:
          self._onXHRProgress();
          break
        }
      };
        // Necessary for streaming in Firefox, since xhr.response is ONLY defined
        // in onprogress, not in onreadystatechange with xhr.readyState = 3
      if (self._mode === 'moz-chunked-arraybuffer') {
        xhr.onprogress = function() {
          self._onXHRProgress();
        };
      }

      xhr.onerror = function() {
        if (self._destroyed)
          return
        self.emit('error', new Error('XHR error'));
      };

      try {
        xhr.send(body);
      } catch (err) {
        browser$1.nextTick(function() {
          self.emit('error', err);
        });
        return
      }
    }
  };

  /**
   * Checks if xhr.status is readable and non-zero, indicating no error.
   * Even though the spec says it should be available in readyState 3,
   * accessing it throws an exception in IE8
   */
  function statusValid(xhr) {
    try {
      var status = xhr.status;
      return (status !== null && status !== 0)
    } catch (e) {
      return false
    }
  }

  ClientRequest.prototype._onXHRProgress = function() {
    var self = this;

    if (!statusValid(self._xhr) || self._destroyed)
      return

    if (!self._response)
      self._connect();

    self._response._onXHRProgress();
  };

  ClientRequest.prototype._connect = function() {
    var self = this;

    if (self._destroyed)
      return

    self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode);
    self.emit('response', self._response);
  };

  ClientRequest.prototype._write = function(chunk, encoding, cb) {
    var self = this;

    self._body.push(chunk);
    cb();
  };

  ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
    var self = this;
    self._destroyed = true;
    if (self._response)
      self._response._destroyed = true;
    if (self._xhr)
      self._xhr.abort();
      // Currently, there isn't a way to truly abort a fetch.
      // If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
  };

  ClientRequest.prototype.end = function(data, encoding, cb) {
    var self = this;
    if (typeof data === 'function') {
      cb = data;
      data = undefined;
    }

    Writable.prototype.end.call(self, data, encoding, cb);
  };

  ClientRequest.prototype.flushHeaders = function() {};
  ClientRequest.prototype.setTimeout = function() {};
  ClientRequest.prototype.setNoDelay = function() {};
  ClientRequest.prototype.setSocketKeepAlive = function() {};

  /*! https://mths.be/punycode v1.4.1 by @mathias */


  /** Highest positive signed 32-bit float value */
  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80
  var delimiter = '-'; // '\x2D'
  var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */
  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };

  /** Convenience shortcuts */
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;

  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */
  function error$1(type) {
    throw new RangeError(errors[type]);
  }

  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */
  function map$1(array, fn) {
    var length = array.length;
    var result = [];
    while (length--) {
      result[length] = fn(array[length]);
    }
    return result;
  }

  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */
  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';
    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    }
    // Avoid `split(regex)` for IE8 compatibility. See #17.
    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map$1(labels, fn).join('.');
    return result + encoded;
  }

  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */
  function ucs2decode(string) {
    var output = [],
      counter = 0,
      length = string.length,
      value,
      extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) { // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */
  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }

  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */
  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }

  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */
  function encode$1(input) {
    var n,
      delta,
      handledCPCount,
      basicLength,
      bias,
      j,
      m,
      q,
      k,
      t,
      currentValue,
      output = [],
      /** `inputLength` will hold the number of code points in `input`. */
      inputLength,
      /** Cached calculation results */
      handledCPCountPlusOne,
      baseMinusT,
      qMinusT;

    // Convert the input in UCS-2 to Unicode
    input = ucs2decode(input);

    // Cache the length
    inputLength = input.length;

    // Initialize the state
    n = initialN;
    delta = 0;
    bias = initialBias;

    // Handle the basic code points
    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];
      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length;

    // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.

    // Finish the basic string - if it is not empty - with a delimiter
    if (basicLength) {
      output.push(delimiter);
    }

    // Main encoding loop:
    while (handledCPCount < inputLength) {

      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      }

      // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow
      handledCPCountPlusOne = handledCPCount + 1;
      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error$1('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error$1('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base; /* no condition */ ; k += base) {
            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
            if (q < t) {
              break;
            }
            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(
              stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
            );
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;

    }
    return output.join('');
  }

  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */
  function toASCII(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ?
        'xn--' + encode$1(string) :
        string;
    });
  }

  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.


  // If obj.hasOwnProperty has been overridden, then calling
  // obj.hasOwnProperty(prop) will break.
  // See: https://github.com/joyent/node/issues/1707
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
  };
  function stringifyPrimitive(v) {
    switch (typeof v) {
      case 'string':
        return v;

      case 'boolean':
        return v ? 'true' : 'false';

      case 'number':
        return isFinite(v) ? v : '';

      default:
        return '';
    }
  }

  function stringify (obj, sep, eq, name) {
    sep = sep || '&';
    eq = eq || '=';
    if (obj === null) {
      obj = undefined;
    }

    if (typeof obj === 'object') {
      return map(objectKeys(obj), function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (isArray(obj[k])) {
          return map(obj[k], function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);

    }

    if (!name) return '';
    return encodeURIComponent(stringifyPrimitive(name)) + eq +
           encodeURIComponent(stringifyPrimitive(obj));
  }
  function map (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      res.push(f(xs[i], i));
    }
    return res;
  }

  var objectKeys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
  };

  function parse$4(qs, sep, eq, options) {
    sep = sep || '&';
    eq = eq || '=';
    var obj = {};

    if (typeof qs !== 'string' || qs.length === 0) {
      return obj;
    }

    var regexp = /\+/g;
    qs = qs.split(sep);

    var maxKeys = 1000;
    if (options && typeof options.maxKeys === 'number') {
      maxKeys = options.maxKeys;
    }

    var len = qs.length;
    // maxKeys <= 0 means that we should not limit keys count
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }

    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, '%20'),
          idx = x.indexOf(eq),
          kstr, vstr, k, v;

      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = '';
      }

      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);

      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }

    return obj;
  }

  // Copyright Joyent, Inc. and other Node contributors.
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }

  // Reference: RFC 3986, RFC 1808, RFC 2396

  // define these here so at least they only have to be
  // compiled once on the first module load.
  var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };

  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && isObject(url) && url instanceof Url) return url;

    var u = new Url;
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    return parse$3(this, url, parseQueryString, slashesDenoteHost);
  };

  function parse$3(self, url, parseQueryString, slashesDenoteHost) {
    if (!isString(url)) {
      throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    var queryIndex = url.indexOf('?'),
      splitter =
      (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, '/');
    url = uSplit.join(splitter);

    var rest = url;

    // trim before proceeding.
    // This is to support parse stuff like "  http://foo.com  \n"
    rest = rest.trim();

    if (!slashesDenoteHost && url.split('#').length === 1) {
      // Try fast path regexp
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        self.path = rest;
        self.href = rest;
        self.pathname = simplePath[1];
        if (simplePath[2]) {
          self.search = simplePath[2];
          if (parseQueryString) {
            self.query = parse$4(self.search.substr(1));
          } else {
            self.query = self.search.substr(1);
          }
        } else if (parseQueryString) {
          self.search = '';
          self.query = {};
        }
        return self;
      }
    }

    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      self.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }

    // figure out if it's got a host
    // user@server is *always* interpreted as a hostname, and url
    // resolution will treat //foo/bar as host=foo,path=bar because that's
    // how the browser resolves relative URLs.
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === '//';
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        self.slashes = true;
      }
    }
    var i, hec, l, p;
    if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

      // there's a hostname.
      // the first instance of /, ?, ;, or # ends the host.
      //
      // If there is an @ in the hostname, then non-host chars *are* allowed
      // to the left of the last @ sign, unless some host-ending character
      // comes *before* the @-sign.
      // URLs are obnoxious.
      //
      // ex:
      // http://a@b@c/ => user:a@b host:c
      // http://a@b?@c => user:a host:c path:/?@c

      // v0.12 TODO(isaacs): This is not quite how Chrome does things.
      // Review our test case against browsers more comprehensively.

      // find the first instance of any hostEndingChars
      var hostEnd = -1;
      for (i = 0; i < hostEndingChars.length; i++) {
        hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }

      // at this point, either we have an explicit point where the
      // auth portion cannot go past, or the last @ char is the decider.
      var auth, atSign;
      if (hostEnd === -1) {
        // atSign can be anywhere.
        atSign = rest.lastIndexOf('@');
      } else {
        // atSign must be in auth portion.
        // http://a@b/c@d => host:b auth:a path:/c@d
        atSign = rest.lastIndexOf('@', hostEnd);
      }

      // Now we have a portion which is definitely the auth.
      // Pull that off.
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        self.auth = decodeURIComponent(auth);
      }

      // the host is the remaining to the left of the first non-host char
      hostEnd = -1;
      for (i = 0; i < nonHostChars.length; i++) {
        hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      // if we still have not hit it, then the entire thing is a host.
      if (hostEnd === -1)
        hostEnd = rest.length;

      self.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);

      // pull out port.
      parseHost(self);

      // we've indicated that there is a hostname,
      // so even if it's empty, it has to be present.
      self.hostname = self.hostname || '';

      // if hostname begins with [ and ends with ]
      // assume that it's an IPv6 address.
      var ipv6Hostname = self.hostname[0] === '[' &&
        self.hostname[self.hostname.length - 1] === ']';

      // validate a little.
      if (!ipv6Hostname) {
        var hostparts = self.hostname.split(/\./);
        for (i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part) continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = '';
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                // we replace non-ASCII char with a temporary placeholder
                // we need this to make sure size of hostname is not
                // broken by replacing non-ASCII by nothing
                newpart += 'x';
              } else {
                newpart += part[j];
              }
            }
            // we test again with ASCII char only
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = '/' + notHost.join('.') + rest;
              }
              self.hostname = validParts.join('.');
              break;
            }
          }
        }
      }

      if (self.hostname.length > hostnameMaxLen) {
        self.hostname = '';
      } else {
        // hostnames are always lower case.
        self.hostname = self.hostname.toLowerCase();
      }

      if (!ipv6Hostname) {
        // IDNA Support: Returns a punycoded representation of "domain".
        // It only converts parts of the domain name that
        // have non-ASCII characters, i.e. it doesn't matter if
        // you call it with a domain that already is ASCII-only.
        self.hostname = toASCII(self.hostname);
      }

      p = self.port ? ':' + self.port : '';
      var h = self.hostname || '';
      self.host = h + p;
      self.href += self.host;

      // strip [ and ] from the hostname
      // the host field still retains them, though
      if (ipv6Hostname) {
        self.hostname = self.hostname.substr(1, self.hostname.length - 2);
        if (rest[0] !== '/') {
          rest = '/' + rest;
        }
      }
    }

    // now rest is set to the post-host stuff.
    // chop off any delim chars.
    if (!unsafeProtocol[lowerProto]) {

      // First, make 100% sure that any "autoEscape" chars get
      // escaped, even if encodeURIComponent doesn't think they
      // need to be.
      for (i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }


    // chop off from the tail first.
    var hash = rest.indexOf('#');
    if (hash !== -1) {
      // got a fragment string.
      self.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf('?');
    if (qm !== -1) {
      self.search = rest.substr(qm);
      self.query = rest.substr(qm + 1);
      if (parseQueryString) {
        self.query = parse$4(self.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      // no query string, but parseQueryString still requested
      self.search = '';
      self.query = {};
    }
    if (rest) self.pathname = rest;
    if (slashedProtocol[lowerProto] &&
      self.hostname && !self.pathname) {
      self.pathname = '/';
    }

    //to support http.request
    if (self.pathname || self.search) {
      p = self.pathname || '';
      var s = self.search || '';
      self.path = p + s;
    }

    // finally, reconstruct the href based on what has been validated.
    self.href = format(self);
    return self;
  }

  function format(self) {
    var auth = self.auth || '';
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ':');
      auth += '@';
    }

    var protocol = self.protocol || '',
      pathname = self.pathname || '',
      hash = self.hash || '',
      host = false,
      query = '';

    if (self.host) {
      host = auth + self.host;
    } else if (self.hostname) {
      host = auth + (self.hostname.indexOf(':') === -1 ?
        self.hostname :
        '[' + this.hostname + ']');
      if (self.port) {
        host += ':' + self.port;
      }
    }

    if (self.query &&
      isObject(self.query) &&
      Object.keys(self.query).length) {
      query = stringify(self.query);
    }

    var search = self.search || (query && ('?' + query)) || '';

    if (protocol && protocol.substr(-1) !== ':') protocol += ':';

    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
    // unless they had them to begin with.
    if (self.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = '//' + (host || '');
      if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
    } else if (!host) {
      host = '';
    }

    if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
    if (search && search.charAt(0) !== '?') search = '?' + search;

    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace('#', '%23');

    return protocol + host + pathname + search + hash;
  }

  Url.prototype.format = function() {
    return format(this);
  };

  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };

  Url.prototype.resolveObject = function(relative) {
    if (isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }

    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }

    // hash is always overridden, no matter what.
    // even href="" will remove it.
    result.hash = relative.hash;

    // if the relative url is empty, then there's nothing left to do here.
    if (relative.href === '') {
      result.href = result.format();
      return result;
    }

    // hrefs like //foo/bar always cut to the protocol.
    if (relative.slashes && !relative.protocol) {
      // take everything except the protocol from relative
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== 'protocol')
          result[rkey] = relative[rkey];
      }

      //urlParse appends trailing / to urls like http://www.example.com
      if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
        result.path = result.pathname = '/';
      }

      result.href = result.format();
      return result;
    }
    var relPath;
    if (relative.protocol && relative.protocol !== result.protocol) {
      // if it's a known url protocol, then changing
      // the protocol does weird things
      // first, if it's not file:, then we MUST have a host,
      // and if there was a path
      // to begin with, then we MUST have a path.
      // if it is file:, then the host is dropped,
      // because that's known to be hostless.
      // anything else is assumed to be absolute.
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v = 0; v < keys.length; v++) {
          var k = keys[v];
          result[k] = relative[k];
        }
        result.href = result.format();
        return result;
      }

      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        relPath = (relative.pathname || '').split('/');
        while (relPath.length && !(relative.host = relPath.shift()));
        if (!relative.host) relative.host = '';
        if (!relative.hostname) relative.hostname = '';
        if (relPath[0] !== '') relPath.unshift('');
        if (relPath.length < 2) relPath.unshift('');
        result.pathname = relPath.join('/');
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || '';
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      // to support http.request
      if (result.pathname || result.search) {
        var p = result.pathname || '';
        var s = result.search || '';
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }

    var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
        relative.host ||
        relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
        (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];
    relPath = relative.pathname && relative.pathname.split('/') || [];
    // if the url is a non-slashed url, then relative
    // links like ../.. should be able
    // to crawl up to the hostname, as well.  This is strange.
    // result.protocol has already been set by now.
    // Later on, put the first path part into the host field.
    if (psychotic) {
      result.hostname = '';
      result.port = null;
      if (result.host) {
        if (srcPath[0] === '') srcPath[0] = result.host;
        else srcPath.unshift(result.host);
      }
      result.host = '';
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === '') relPath[0] = relative.host;
          else relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
    }
    var authInHost;
    if (isRelAbs) {
      // it's absolute.
      result.host = (relative.host || relative.host === '') ?
        relative.host : result.host;
      result.hostname = (relative.hostname || relative.hostname === '') ?
        relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
      // fall through to the dot-handling below.
    } else if (relPath.length) {
      // it's relative
      // throw away the existing file, and take the new path instead.
      if (!srcPath) srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!isNullOrUndefined(relative.search)) {
      // just pull out the search.
      // like href='?foo'.
      // Put this after the other two cases because it simplifies the booleans
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        authInHost = result.host && result.host.indexOf('@') > 0 ?
          result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      //to support http.request
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
          (result.search ? result.search : '');
      }
      result.href = result.format();
      return result;
    }

    if (!srcPath.length) {
      // no path at all.  easy.
      // we've already handled the other stuff above.
      result.pathname = null;
      //to support http.request
      if (result.search) {
        result.path = '/' + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }

    // if a url ENDs in . or .., then it must get a trailing slash.
    // however, if it ends in anything else non-slashy,
    // then it must NOT get a trailing slash.
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

    // strip single dots, resolve double dots to parent dir
    // if the path tries to go above the root, `up` ends up > 0
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === '.') {
        srcPath.splice(i, 1);
      } else if (last === '..') {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }

    // if the path is allowed to go above the root, restore leading ..s
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift('..');
      }
    }

    if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
      srcPath.unshift('');
    }

    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
      srcPath.push('');
    }

    var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

    // put the host back
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? '' :
        srcPath.length ? srcPath.shift() : '';
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      authInHost = result.host && result.host.indexOf('@') > 0 ?
        result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    mustEndAbs = mustEndAbs || (result.host && srcPath.length);

    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift('');
    }

    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join('/');
    }

    //to support request.http
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
        (result.search ? result.search : '');
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };

  Url.prototype.parseHost = function() {
    return parseHost(this);
  };

  function parseHost(self) {
    var host = self.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ':') {
        self.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) self.hostname = host;
  }

  function request(opts, cb) {
    if (typeof opts === 'string')
      opts = urlParse(opts);


    // Normally, the page is loaded from http or https, so not specifying a protocol
    // will result in a (valid) protocol-relative url. However, this won't work if
    // the protocol is something else, like 'file:'
    var defaultProtocol = global$1.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';

    var protocol = opts.protocol || defaultProtocol;
    var host = opts.hostname || opts.host;
    var port = opts.port;
    var path = opts.path || '/';

    // Necessary for IPv6 addresses
    if (host && host.indexOf(':') !== -1)
      host = '[' + host + ']';

    // This may be a relative url. The browser should always be able to interpret it correctly.
    opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path;
    opts.method = (opts.method || 'GET').toUpperCase();
    opts.headers = opts.headers || {};

    // Also valid opts.auth, opts.mode

    var req = new ClientRequest(opts);
    if (cb)
      req.on('response', cb);
    return req
  }

  function get(opts, cb) {
    var req = request(opts, cb);
    req.end();
    return req
  }

  function Agent() {}
  Agent.defaultMaxSockets = 4;

  var METHODS = [
    'CHECKOUT',
    'CONNECT',
    'COPY',
    'DELETE',
    'GET',
    'HEAD',
    'LOCK',
    'M-SEARCH',
    'MERGE',
    'MKACTIVITY',
    'MKCOL',
    'MOVE',
    'NOTIFY',
    'OPTIONS',
    'PATCH',
    'POST',
    'PROPFIND',
    'PROPPATCH',
    'PURGE',
    'PUT',
    'REPORT',
    'SEARCH',
    'SUBSCRIBE',
    'TRACE',
    'UNLOCK',
    'UNSUBSCRIBE'
  ];
  var STATUS_CODES = {
    100: 'Continue',
    101: 'Switching Protocols',
    102: 'Processing', // RFC 2518, obsoleted by RFC 4918
    200: 'OK',
    201: 'Created',
    202: 'Accepted',
    203: 'Non-Authoritative Information',
    204: 'No Content',
    205: 'Reset Content',
    206: 'Partial Content',
    207: 'Multi-Status', // RFC 4918
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Moved Temporarily',
    303: 'See Other',
    304: 'Not Modified',
    305: 'Use Proxy',
    307: 'Temporary Redirect',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Time-out',
    409: 'Conflict',
    410: 'Gone',
    411: 'Length Required',
    412: 'Precondition Failed',
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Large',
    415: 'Unsupported Media Type',
    416: 'Requested Range Not Satisfiable',
    417: 'Expectation Failed',
    418: 'I\'m a teapot', // RFC 2324
    422: 'Unprocessable Entity', // RFC 4918
    423: 'Locked', // RFC 4918
    424: 'Failed Dependency', // RFC 4918
    425: 'Unordered Collection', // RFC 4918
    426: 'Upgrade Required', // RFC 2817
    428: 'Precondition Required', // RFC 6585
    429: 'Too Many Requests', // RFC 6585
    431: 'Request Header Fields Too Large', // RFC 6585
    500: 'Internal Server Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Gateway Time-out',
    505: 'HTTP Version Not Supported',
    506: 'Variant Also Negotiates', // RFC 2295
    507: 'Insufficient Storage', // RFC 4918
    509: 'Bandwidth Limit Exceeded',
    510: 'Not Extended', // RFC 2774
    511: 'Network Authentication Required' // RFC 6585
  };

  var _polyfillNode_https = {
    request,
    get,
    Agent,
    METHODS,
    STATUS_CODES
  };

  var _polyfillNode_https$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    request: request,
    get: get,
    Agent: Agent,
    METHODS: METHODS,
    STATUS_CODES: STATUS_CODES,
    'default': _polyfillNode_https
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_https$1);

  var jszip_min = {exports: {}};

  jszip_min.exports;

  var hasRequiredJszip_min;

  function requireJszip_min () {
  	if (hasRequiredJszip_min) return jszip_min.exports;
  	hasRequiredJszip_min = 1;
  	(function (module, exports) {
  		!function(e){module.exports=e();}(function(){return function s(a,o,h){function u(r,e){if(!o[r]){if(!a[r]){var t="function"==typeof commonjsRequire&&commonjsRequire;if(!e&&t)return t(r,!0);if(l)return l(r,!0);var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return u(t||e)},i,i.exports,s,a,o,h);}return o[r].exports}for(var l="function"==typeof commonjsRequire&&commonjsRequire,e=0;e<h.length;e++)u(h[e]);return u}({1:[function(e,t,r){var d=e("./utils"),c=e("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(e){for(var t,r,n,i,s,a,o,h=[],u=0,l=e.length,f=l,c="string"!==d.getTypeOf(e);u<e.length;)f=l-u,n=c?(t=e[u++],r=u<l?e[u++]:0,u<l?e[u++]:0):(t=e.charCodeAt(u++),r=u<l?e.charCodeAt(u++):0,u<l?e.charCodeAt(u++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<f?(15&r)<<2|n>>6:64,o=2<f?63&n:64,h.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(e){var t,r,n,i,s,a,o=0,h=0,u="data:";if(e.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(e=e.replace(/[^A-Za-z0-9+/=]/g,"")).length/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=c.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),l[h++]=t,64!==s&&(l[h++]=r),64!==a&&(l[h++]=n);return l};},{"./support":30,"./utils":32}],2:[function(e,t,r){var n=e("./external"),i=e("./stream/DataWorker"),s=e("./stream/Crc32Probe"),a=e("./stream/DataLengthProbe");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i;}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),t=this;return e.on("end",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a("uncompressedSize")).pipe(t.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",t)},t.exports=o;},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(e,t,r){var n=e("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(){return new n("STORE compression")},uncompressWorker:function(){return new n("STORE decompression")}},r.DEFLATE=e("./flate");},{"./flate":7,"./stream/GenericWorker":28}],4:[function(e,t,r){var n=e("./utils");var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t){return void 0!==e&&e.length?"string"!==n.getTypeOf(e)?function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e}(0|t,e,e.length,0):function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t.charCodeAt(a))];return -1^e}(0|t,e,e.length,0):0};},{"./utils":32}],5:[function(e,t,r){r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null;},{}],6:[function(e,t,r){var n=null;n="undefined"!=typeof Promise?Promise:e("lie"),t.exports={Promise:n};},{lie:37}],7:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,i=e("pako"),s=e("./utils"),a=e("./stream/GenericWorker"),o=n?"uint8array":"array";function h(e,t){a.call(this,"FlateWorker/"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={};}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1);},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0);},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null;},h.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta});};},r.compressWorker=function(e){return new h("Deflate",e)},r.uncompressWorker=function(){return new h("Inflate",{})};},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(e,t,r){function A(e,t){var r,n="";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function n(e,t,r,n,i,s){var a,o,h=e.file,u=e.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),c=I.transformTo("string",O.utf8encode(h.name)),d=h.comment,p=I.transformTo("string",s(d)),m=I.transformTo("string",O.utf8encode(d)),_=c.length!==h.name.length,g=m.length!==d.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===i?(C=798,z|=function(e,t){var r=e;return e||(r=t?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(e){return 63&(e||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+c,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(n,4)+f+b+p}}var I=e("../utils"),i=e("../stream/GenericWorker"),O=e("../utf8"),B=e("../crc32"),R=e("../signature");function s(e,t,r,n){i.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[];}I.inherits(s,i),s.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,i.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))/r:100}}));},s.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=n(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}});}else this.accumulate=!0;},s.prototype.closedSource=function(e){this.accumulate=!1;var t=this.streamFiles&&!e.file.dir,r=n(e,t,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),t)this.push({data:function(e){return R.DATA_DESCRIPTOR+A(e.crc32,4)+A(e.compressedSize,4)+A(e.uncompressedSize,4)}(e),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null;},s.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r=this.bytesWritten-e,n=function(e,t,r,n,i){var s=I.transformTo("string",i(n));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(e,2)+A(e,2)+A(t,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,e,this.zipComment,this.encodeFileName);this.push({data:n,meta:{percent:100}});},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume();},s.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end();}),e.on("error",function(e){t.error(e);}),this},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(e){var t=this._sources;if(!i.prototype.error.call(this,e))return !1;for(var r=0;r<t.length;r++)try{t[r].error(e);}catch(e){}return !0},s.prototype.lock=function(){i.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock();},t.exports=s;},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(e,t,r){var u=e("../compressions"),n=e("./ZipFileWorker");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),h=0;try{e.forEach(function(e,t){h++;var r=function(e,t){var r=e||t,n=u[r];if(!n)throw new Error(r+" is not a valid compression method !");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo("file",{name:e,dir:i,date:s,comment:t.comment||"",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o);}),o.entriesCount=h;}catch(e){o.error(e);}return o};},{"../compressions":3,"./ZipFileWorker":8}],10:[function(e,t,r){function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var e=new n;for(var t in this)"function"!=typeof this[t]&&(e[t]=this[t]);return e};}(n.prototype=e("./object")).loadAsync=e("./load"),n.support=e("./support"),n.defaults=e("./defaults"),n.version="3.10.1",n.loadAsync=function(e,t){return (new n).loadAsync(e,t)},n.external=e("./external"),t.exports=n;},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(e,t,r){var u=e("./utils"),i=e("./external"),n=e("./utf8"),s=e("./zipEntries"),a=e("./stream/Crc32Probe"),l=e("./nodejsUtils");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new a);r.on("error",function(e){t(e);}).on("end",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error("Corrupted zip : CRC32 mismatch")):e();}).resume();})}t.exports=function(e,o){var h=this;return o=u.extend(o||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:n.utf8decode}),l.isNode&&l.isStream(e)?i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):u.prepareContent("the loaded zip file",e,!0,o.optimizedBinaryString,o.base64).then(function(e){var t=new s(o);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(o.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n],s=i.fileNameStr,a=u.resolve(i.fileNameStr);h.file(a,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:o.createFolders}),i.dir||(h.file(a).unsafeOriginalName=s);}return t.zipComment.length&&(h.comment=t.zipComment),h})};},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(e,t,r){var n=e("../utils"),i=e("../stream/GenericWorker");function s(e,t){i.call(this,"Nodejs stream input adapter for "+e),this._upstreamEnded=!1,this._bindStream(t);}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on("data",function(e){t.push({data:e,meta:{percent:0}});}).on("error",function(e){t.isPaused?this.generatedError=e:t.error(e);}).on("end",function(){t.isPaused?t._upstreamEnded=!0:t.end();});},s.prototype.pause=function(){return !!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s;},{"../stream/GenericWorker":28,"../utils":32}],13:[function(e,t,r){var i=e("readable-stream").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on("data",function(e,t){n.push(e)||n._helper.pause(),r&&r(t);}).on("error",function(e){n.emit("error",e);}).on("end",function(){n.push(null);});}e("../utils").inherits(n,i),n.prototype._read=function(){this._helper.resume();},t.exports=n;},{"../utils":32,"readable-stream":16}],14:[function(e,t,r){t.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if("number"==typeof e)throw new Error('The "data" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&"function"==typeof e.on&&"function"==typeof e.pause&&"function"==typeof e.resume}};},{}],15:[function(e,t,r){function s(e,t,r){var n,i=u.getTypeOf(t),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=g(e)),s.createFolders&&(n=_(e))&&b.call(this,n,!0);var a="string"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t="",s.compression="STORE",i="string");var o=null;o=t instanceof c||t instanceof l?t:p.isNode&&p.isStream(t)?new m(e,t):u.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var h=new d(e,o,s);this.files[e]=h;}var i=e("./utf8"),u=e("./utils"),l=e("./stream/GenericWorker"),a=e("./stream/StreamHelper"),f=e("./defaults"),c=e("./compressedObject"),d=e("./zipObject"),o=e("./generate"),p=e("./nodejsUtils"),m=e("./nodejs/NodejsStreamInputAdapter"),_=function(e){"/"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf("/");return 0<t?e.substring(0,t):""},g=function(e){return "/"!==e.slice(-1)&&(e+="/"),e},b=function(e,t){return t=void 0!==t?t:f.createFolders,e=g(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function h(e){return "[object RegExp]"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(e){var t,r,n;for(t in this.files)n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n);},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t);}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(h(e)){var n=e;return this.filter(function(e,t){return !t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=b.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||("/"!==r.slice(-1)&&(r+="/"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(e){var t,r={};try{if((r=u.extend(e||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var n=r.comment||this.comment||"";t=o.generateWorker(this,r,n);}catch(e){(t=new l("error")).error(e);}return new a(t,r.type||"string",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return (e=e||{}).type||(e.type="nodebuffer"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n;},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(e,t,r){t.exports=e("stream");},{stream:void 0}],17:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t];}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return -1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return [];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],18:[function(e,t,r){var n=e("../utils");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0;}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e);},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+e+"). Corrupted zip ?")},setIndex:function(e){this.checkIndex(e),this.index=e;},skip:function(e){this.setIndex(this.index+e);},byteAt:function(){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo("string",this.readData(e))},readData:function(){},lastIndexOfSignature:function(){},readAndCheckSignature:function(){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i;},{"../utils":32}],19:[function(e,t,r){var n=e("./Uint8ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(e,t,r){var n=e("./DataReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./DataReader":18}],21:[function(e,t,r){var n=e("./ArrayReader");function i(e){n.call(this,e);}e("../utils").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i;},{"../utils":32,"./ArrayReader":17}],22:[function(e,t,r){var n=e("../utils"),i=e("../support"),s=e("./ArrayReader"),a=e("./StringReader"),o=e("./NodeBufferReader"),h=e("./Uint8ArrayReader");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),"string"!==t||i.uint8array?"nodebuffer"===t?new o(e):i.uint8array?new h(n.transformTo("uint8array",e)):new s(n.transformTo("array",e)):new a(e)};},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(e,t,r){r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b";},{}],24:[function(e,t,r){var n=e("./GenericWorker"),i=e("../utils");function s(e){n.call(this,"ConvertWorker to "+e),this.destType=e;}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta});},t.exports=s;},{"../utils":32,"./GenericWorker":28}],25:[function(e,t,r){var n=e("./GenericWorker"),i=e("../crc32");function s(){n.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0);}e("../utils").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e);},t.exports=s;},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataLengthProbe for "+e),this.propName=e,this.withStreamInfo(e,0);}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length;}i.prototype.processChunk.call(this,e);},t.exports=s;},{"../utils":32,"./GenericWorker":28}],27:[function(e,t,r){var n=e("../utils"),i=e("./GenericWorker");function s(e){i.call(this,"DataWorker");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat();},function(e){t.error(e);});}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null;},s.prototype.resume=function(){return !!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0));},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return !1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":e=this.data.substring(this.index,t);break;case"uint8array":e=this.data.subarray(this.index,t);break;case"array":case"nodebuffer":e=this.data.slice(this.index,t);}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index/this.max*100:0}})},t.exports=s;},{"../utils":32,"./GenericWorker":28}],28:[function(e,t,r){function n(e){this.name=e||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null;}n.prototype={push:function(e){this.emit("data",e);},end:function(){if(this.isFinished)return !1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0;}catch(e){this.emit("error",e);}return !0},error:function(e){return !this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit("error",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[];},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t);},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on("data",function(e){t.processChunk(e);}),e.on("end",function(){t.end();}),e.on("error",function(e){t.error(e);}),this},pause:function(){return !this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return !1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e);},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)Object.prototype.hasOwnProperty.call(this.extraStreamInfo,e)&&(this.streamInfo[e]=this.extraStreamInfo[e]);},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock();},toString:function(){var e="Worker "+this.name;return this.previous?this.previous+" -> "+e:e}},t.exports=n;},{}],29:[function(e,t,r){var h=e("../utils"),i=e("./ConvertWorker"),s=e("./GenericWorker"),u=e("../base64"),n=e("../support"),a=e("../external"),o=null;if(n.nodestream)try{o=e("../nodejs/NodejsStreamOutputAdapter");}catch(e){}function l(e,o){return new a.Promise(function(t,r){var n=[],i=e._internalType,s=e._outputType,a=e._mimeType;e.on("data",function(e,t){n.push(e),o&&o(t);}).on("error",function(e){n=[],r(e);}).on("end",function(){try{var e=function(e,t,r){switch(e){case"blob":return h.newBlob(h.transformTo("arraybuffer",t),r);case"base64":return u.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case"string":return t.join("");case"array":return Array.prototype.concat.apply([],t);case"uint8array":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case"nodebuffer":return Buffer.concat(t);default:throw new Error("concat : unsupported type '"+e+"'")}}(i,n),a);t(e);}catch(e){r(e);}n=[];}).resume();})}function f(e,t,r){var n=t;switch(t){case"blob":case"arraybuffer":n="uint8array";break;case"base64":n="string";}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock();}catch(e){this._worker=new s("error"),this._worker.error(e);}}f.prototype={accumulate:function(e){return l(this,e)},on:function(e,t){var r=this;return "data"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta);}):this._worker.on(e,function(){h.delay(t,arguments,r);}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},e)}},t.exports=f;},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(e,t,r){if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else {var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:"application/zip"}).size;}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob("application/zip").size;}catch(e){r.blob=!1;}}}try{r.nodestream=!!e("readable-stream").Readable;}catch(e){r.nodestream=!1;}},{"readable-stream":16}],31:[function(e,t,s){for(var o=e("./utils"),h=e("./support"),r=e("./nodejsUtils"),n=e("./stream/GenericWorker"),u=new Array(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;u[254]=u[254]=1;function a(){n.call(this,"utf-8 decode"),this.leftOver=null;}function l(){n.call(this,"utf-8 encode");}s.utf8encode=function(e){return h.nodebuffer?r.newBufferFrom(e,"utf-8"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=h.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return h.nodebuffer?o.transformTo("nodebuffer",e).toString("utf-8"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=u[n]))a[r++]=65533,t+=i-1;else {for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n);}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(h.uint8array?"uint8array":"array",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(h.uint8array?"uint8array":"array",e.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length);}else t=this.leftOver.concat(t);this.leftOver=null;}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t}(t),i=t;n!==t.length&&(h.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta});},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null);},s.Utf8DecodeWorker=a,o.inherits(l,n),l.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta});},s.Utf8EncodeWorker=l;},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(e,t,a){var o=e("./support"),h=e("./base64"),r=e("./nodejsUtils"),u=e("./external");function n(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}e("setimmediate"),a.newBlob=function(t,r){a.checkSupport("blob");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error("Bug : can't construct the Blob.")}}};var i={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)"array"===t||"nodebuffer"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join("")},stringifyByChar:function(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return !1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return !1}}()}};function s(e){var t=65536,r=a.getTypeOf(e),n=!0;if("uint8array"===r?n=i.applyCanBeUsed.uint8array:"nodebuffer"===r&&(n=i.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return i.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t/2);}return i.stringifyByChar(e)}function f(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}a.applyFromCharCode=s;var c={};c.string={string:n,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:s,array:n,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return s(new Uint8Array(e))},array:function(e){return f(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:n,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:n,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:s,array:function(e){return f(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return f(e,new Uint8Array(e.length))},nodebuffer:n},a.transformTo=function(e,t){if(t=t||"",!e)return t;a.checkSupport(e);var r=a.getTypeOf(t);return c[r][e](t)},a.resolve=function(e){for(var t=e.split("/"),r=[],n=0;n<t.length;n++){var i=t[n];"."===i||""===i&&0!==n&&n!==t.length-1||(".."===i?r.pop():r.push(i));}return r.join("/")},a.getTypeOf=function(e){return "string"==typeof e?"string":"[object Array]"===Object.prototype.toString.call(e)?"array":o.nodebuffer&&r.isBuffer(e)?"nodebuffer":o.uint8array&&e instanceof Uint8Array?"uint8array":o.arraybuffer&&e instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(e){if(!o[e.toLowerCase()])throw new Error(e+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(e){var t,r,n="";for(r=0;r<(e||"").length;r++)n+="\\x"+((t=e.charCodeAt(r))<16?"0":"")+t.toString(16).toUpperCase();return n},a.delay=function(e,t,r){setImmediate(function(){e.apply(r||null,t||[]);});},a.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r;},a.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])Object.prototype.hasOwnProperty.call(arguments[e],t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},a.prepareContent=function(r,e,n,i,s){return u.Promise.resolve(e).then(function(n){return o.blob&&(n instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(n)))&&"undefined"!=typeof FileReader?new u.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result);},e.onerror=function(e){r(e.target.error);},e.readAsArrayBuffer(n);}):n}).then(function(e){var t=a.getTypeOf(e);return t?("arraybuffer"===t?e=a.transformTo("uint8array",e):"string"===t&&(s?e=h.decode(e):n&&!0!==i&&(e=function(e){return l(e,o.uint8array?new Uint8Array(e.length):new Array(e.length))}(e))),e):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})};},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,setimmediate:54}],33:[function(e,t,r){var n=e("./reader/readerFor"),i=e("./utils"),s=e("./signature"),a=e("./zipEntry"),o=e("./support");function h(e){this.files=[],this.loadOptions=e;}h.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+i.pretty(t)+", expected "+i.pretty(e)+")")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?"uint8array":"array",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r);},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r};},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes();},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw !this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral();}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error("Corrupted zip: missing "+Math.abs(n)+" bytes.")},prepareReader:function(e){this.reader=n(e);},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles();}},t.exports=h;},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utils":32,"./zipEntry":34}],34:[function(e,t,r){var n=e("./reader/readerFor"),s=e("./utils"),i=e("./compressedObject"),a=e("./crc32"),o=e("./utf8"),h=e("./compressions"),u=e("./support");function l(e,t){this.options=e,this.loadOptions=t;}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(t=function(e){for(var t in h)if(Object.prototype.hasOwnProperty.call(h,t)&&h[t].magic===e)return h[t];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize));},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength);},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0);},parseZIP64ExtraField:function(){if(this.extraFields[1]){var e=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4));}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i);},handleUTF8:function(){var e=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else {var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else {var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r);}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else {var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i);}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=l;},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(e,t,r){function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions};}var s=e("./stream/StreamHelper"),i=e("./stream/DataWorker"),a=e("./utf8"),o=e("./compressedObject"),h=e("./stream/GenericWorker");n.prototype={internalStream:function(e){var t=null,r="string";try{if(!e)throw new Error("No output type specified.");var n="string"===(r=e.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker));}catch(e){(t=new h("error")).error(e);}return new s(t,r,"")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||"nodebuffer").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new i(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)n.prototype[u[f]]=l;t.exports=n;},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(e,l,t){(function(t){var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(u),a=t.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2;};}else if(t.setImmediate||void 0===t.MessageChannel)r="document"in t&&"onreadystatechange"in t.document.createElement("script")?function(){var e=t.document.createElement("script");e.onreadystatechange=function(){u(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null;},t.document.documentElement.appendChild(e);}:function(){setTimeout(u,0);};else {var o=new t.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0);};}var h=[];function u(){var e,t;n=!0;for(var r=h.length;r;){for(t=h,h=[],e=-1;++e<r;)t[e]();r=h.length;}n=!1;}l.exports=function(e){1!==h.push(e)||n||r();};}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}],37:[function(e,t,r){var i=e("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],n=["PENDING"];function o(e){if("function"!=typeof e)throw new TypeError("resolver must be a function");this.state=n,this.queue=[],this.outcome=void 0,e!==u&&d(this,e);}function h(e,t,r){this.promise=e,"function"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected);}function f(t,r,n){i(function(){var e;try{e=r(n);}catch(e){return l.reject(t,e)}e===t?l.reject(t,new TypeError("Cannot resolve promise with itself")):l.resolve(t,e);});}function c(e){var t=e&&e.then;if(e&&("object"==typeof e||"function"==typeof e)&&"function"==typeof t)return function(){t.apply(e,arguments);}}function d(t,e){var r=!1;function n(e){r||(r=!0,l.reject(t,e));}function i(e){r||(r=!0,l.resolve(t,e));}var s=p(function(){e(i,n);});"error"===s.status&&n(s.value);}function p(e,t){var r={};try{r.value=e(t),r.status="success";}catch(e){r.status="error",r.value=e;}return r}(t.exports=o).prototype.finally=function(t){if("function"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if("function"!=typeof e&&this.state===a||"function"!=typeof t&&this.state===s)return this;var r=new this.constructor(u);this.state!==n?f(r,this.state===a?e:t,this.outcome):this.queue.push(new h(r,e,t));return r},h.prototype.callFulfilled=function(e){l.resolve(this.promise,e);},h.prototype.otherCallFulfilled=function(e){f(this.promise,this.onFulfilled,e);},h.prototype.callRejected=function(e){l.reject(this.promise,e);},h.prototype.otherCallRejected=function(e){f(this.promise,this.onRejected,e);},l.resolve=function(e,t){var r=p(c,t);if("error"===r.status)return l.reject(e,r.value);var n=r.value;if(n)d(e,n);else {e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t);}return e},l.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){if(e instanceof this)return e;return l.resolve(new this(u),e)},o.reject=function(e){var t=new this(u);return l.reject(t,e)},o.all=function(e){var r=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var n=e.length,i=!1;if(!n)return this.resolve([]);var s=new Array(n),a=0,t=-1,o=new this(u);for(;++t<n;)h(e[t],t);return o;function h(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,l.resolve(o,s));},function(e){i||(i=!0,l.reject(o,e));});}},o.race=function(e){var t=this;if("[object Array]"!==Object.prototype.toString.call(e))return this.reject(new TypeError("must be an array"));var r=e.length,n=!1;if(!r)return this.resolve([]);var i=-1,s=new this(u);for(;++i<r;)a=e[i],t.resolve(a).then(function(e){n||(n=!0,l.resolve(s,e));},function(e){n||(n=!0,l.reject(s,e));});var a;return s};},{immediate:36}],38:[function(e,t,r){var n={};(0, e("./lib/utils/common").assign)(n,e("./lib/deflate"),e("./lib/inflate"),e("./lib/zlib/constants")),t.exports=n;},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(e,t,r){var a=e("./zlib/deflate"),o=e("./utils/common"),h=e("./utils/strings"),i=e("./zlib/messages"),s=e("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,c=0,d=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:f,method:d,chunkSize:16384,windowBits:15,memLevel:8,strategy:c,to:""},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==l)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n="string"==typeof t.dictionary?h.string2buf(t.dictionary):"[object ArrayBuffer]"===u.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==l)throw new Error(i[r]);this._dict_set=!0;}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return !1;n=t===~~t?t:!0===t?4:0,"string"==typeof e?i.input=h.string2buf(e):"[object ArrayBuffer]"===u.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)));}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==n||(this.onEnd(l),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e);},p.prototype.onEnd=function(e){e===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return (t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return (t=t||{}).gzip=!0,n(e,t)};},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(e,t,r){var c=e("./zlib/inflate"),d=e("./utils/common"),p=e("./utils/strings"),m=e("./zlib/constants"),n=e("./zlib/messages"),i=e("./zlib/zstream"),s=e("./zlib/gzheader"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=d.assign({chunkSize:16384,windowBits:0,to:""},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=c.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,c.inflateGetHeader(this.strm,this.header);}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return !1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof e?h.input=p.binstring2buf(e):"[object ArrayBuffer]"===_.call(e)?h.input=new Uint8Array(e):h.input=e,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new d.Buf8(u),h.next_out=0,h.avail_out=u),(r=c.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=c.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(i=p.utf8border(h.output,h.next_out),s=h.next_out-i,a=p.buf2string(h.output,i),h.next_out=s,h.avail_out=u-s,s&&d.arraySet(h.output,h.output,i,s,0),this.onData(a)):this.onData(d.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0);}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=c.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e);},a.prototype.onEnd=function(e){e===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=d.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return (t=t||{}).raw=!0,o(e,t)},r.ungzip=o;},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(e,t,r){var n="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n]);}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s];},flattenChunks:function(e){return [].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s));},r.setTyped(n);},{}],42:[function(e,t,r){var h=e("./common"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0]);}catch(e){i=!1;}try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(e){s=!1;}for(var u=new h.Buf8(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function l(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,h.shrinkBuf(e,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}u[254]=u[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new h.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return l(e,e.length)},r.binstring2buf=function(e){for(var t=new h.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=u[i]))o[n++]=65533,r+=s-1;else {for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i);}return l(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+u[e[r]]>t?r:t};},{"./common":41}],43:[function(e,t,r){t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521;}return i|s<<16|0};},{}],44:[function(e,t,r){t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};},{}],45:[function(e,t,r){var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e;}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return -1^e};},{}],46:[function(e,t,r){var h,c=e("../utils/common"),u=e("./trees"),d=e("./adler32"),p=e("./crc32"),n=e("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,i=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(e,t){return e.msg=n[t],t}function T(e){return (e<<1)-(4<e?9:0)}function D(e){for(var t=e.length;0<=--t;)e[t]=0;}function F(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(c.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0));}function N(e,t){u._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,F(e.strm);}function U(e,t){e.pending_buf[e.pending++]=t;}function P(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t;}function L(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,h=e.strstart>e.w_size-z?e.strstart-(e.w_size-z):0,u=e.window,l=e.w_mask,f=e.prev,c=e.strstart+S,d=u[s+a-1],p=u[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(u[(r=t)+a]===p&&u[r+a-1]===d&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<c);if(n=S-(c-s),s=c-S,a<n){if(e.match_start=t,o<=(a=n))break;d=u[s+a-1],p=u[s+a];}}}while((t=f[t&l])>h&&0!=--i);return a<=e.lookahead?a:e.lookahead}function j(e){var t,r,n,i,s,a,o,h,u,l,f=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=f+(f-z)){for(c.arraySet(e.window,e.window,f,f,0),e.match_start-=f,e.strstart-=f,e.block_start-=f,t=r=e.hash_size;n=e.head[--t],e.head[t]=f<=n?n-f:0,--r;);for(t=r=f;n=e.prev[--t],e.prev[t]=f<=n?n-f:0,--r;);i+=f;}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,h=e.strstart+e.lookahead,u=i,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,c.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=d(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),e.lookahead+=r,e.lookahead+e.insert>=x)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+x-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<x)););}while(e.lookahead<z&&0!==e.strm.avail_in)}function Z(e,t){for(var r,n;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r)),e.match_length>=x)if(n=u._tr_tally(e,e.strstart-e.match_start,e.match_length-x),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=x){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++;}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function W(e,t){for(var r,n,i;;){if(e.lookahead<z){if(j(e),e.lookahead<z&&t===l)return A;if(0===e.lookahead)break}if(r=0,e.lookahead>=x&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=x-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-z&&(e.match_length=L(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===x&&4096<e.strstart-e.match_start)&&(e.match_length=x-1)),e.prev_length>=x&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-x,n=u._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-x),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+x-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=x-1,e.strstart++,n&&(N(e,!1),0===e.strm.avail_out))return A}else if(e.match_available){if((n=u._tr_tally(e,0,e.window[e.strstart-1]))&&N(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return A}else e.match_available=1,e.strstart++,e.lookahead--;}return e.match_available&&(n=u._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<x-1?e.strstart:x-1,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}function M(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i;}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new c.Buf16(2*w),this.dyn_dtree=new c.Buf16(2*(2*a+1)),this.bl_tree=new c.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new c.Buf16(k+1),this.heap=new c.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new c.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}function G(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?C:E,e.adler=2===t.wrap?0:1,t.last_flush=l,u._tr_init(t),m):R(e,_)}function K(e){var t=G(e);return t===m&&function(e){e.window_size=2*e.w_size,D(e.head),e.max_lazy_match=h[e.level].max_lazy,e.good_match=h[e.level].good_length,e.nice_match=h[e.level].nice_length,e.max_chain_length=h[e.level].max_chain,e.strstart=0,e.block_start=0,e.lookahead=0,e.insert=0,e.match_length=e.prev_length=x-1,e.match_available=0,e.ins_h=0;}(e.state),t}function Y(e,t,r,n,i,s){if(!e)return _;var a=1;if(t===g&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||y<i||r!==v||n<8||15<n||t<0||9<t||s<0||b<s)return R(e,_);8===n&&(n=9);var o=new H;return (e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new c.Buf8(2*o.w_size),o.head=new c.Buf16(o.hash_size),o.prev=new c.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new c.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,K(e)}h=[new M(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(j(e),0===e.lookahead&&t===l)return A;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,N(e,!1),0===e.strm.avail_out))return A;if(e.strstart-e.block_start>=e.w_size-z&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):(e.strstart>e.block_start&&(N(e,!1),e.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(e,t){return Y(e,t,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?_:(e.state.gzhead=t,m):_},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?R(e,_):_;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&t!==f)return R(e,0===e.avail_out?-5:_);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===C)if(2===n.wrap)e.adler=0,U(n,31),U(n,139),U(n,8),n.gzhead?(U(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),U(n,255&n.gzhead.time),U(n,n.gzhead.time>>8&255),U(n,n.gzhead.time>>16&255),U(n,n.gzhead.time>>24&255),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(U(n,255&n.gzhead.extra.length),U(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(U(n,0),U(n,0),U(n,0),U(n,0),U(n,0),U(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),U(n,3),n.status=E);else {var a=v+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=E,P(n,a),0!==n.strstart&&(P(n,e.adler>>>16),P(n,65535&e.adler)),e.adler=1;}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending!==n.pending_buf_size));)U(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73);}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,U(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91);}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),F(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,U(n,s);}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103);}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&F(e),n.pending+2<=n.pending_buf_size&&(U(n,255&e.adler),U(n,e.adler>>8&255),e.adler=0,n.status=E)):n.status=E),0!==n.pending){if(F(e),0===e.avail_out)return n.last_flush=-1,m}else if(0===e.avail_in&&T(t)<=T(r)&&t!==f)return R(e,-5);if(666===n.status&&0!==e.avail_in)return R(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==l&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(j(e),0===e.lookahead)){if(t===l)return A;break}if(e.match_length=0,r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=S){if(j(e),e.lookahead<=S&&t===l)return A;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=x&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+S;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=S-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead);}if(e.match_length>=x?(r=u._tr_tally(e,1,e.match_length-x),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=u._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(N(e,!1),0===e.strm.avail_out))return A}return e.insert=0,t===f?(N(e,!0),0===e.strm.avail_out?O:B):e.last_lit&&(N(e,!1),0===e.strm.avail_out)?A:I}(n,t):h[n.level].func(n,t);if(o!==O&&o!==B||(n.status=666),o===A||o===O)return 0===e.avail_out&&(n.last_flush=-1),m;if(o===I&&(1===t?u._tr_align(n):5!==t&&(u._tr_stored_block(n,0,0,!1),3===t&&(D(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),F(e),0===e.avail_out))return n.last_flush=-1,m}return t!==f?m:n.wrap<=0?1:(2===n.wrap?(U(n,255&e.adler),U(n,e.adler>>8&255),U(n,e.adler>>16&255),U(n,e.adler>>24&255),U(n,255&e.total_in),U(n,e.total_in>>8&255),U(n,e.total_in>>16&255),U(n,e.total_in>>24&255)):(P(n,e.adler>>>16),P(n,65535&e.adler)),F(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?m:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==C&&69!==t&&73!==t&&91!==t&&103!==t&&t!==E&&666!==t?R(e,_):(e.state=null,t===E?R(e,-3):m):_},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,h,u,l=t.length;if(!e||!e.state)return _;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(e.adler=d(e.adler,t,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new c.Buf8(r.w_size),c.arraySet(u,t,l-r.w_size,r.w_size,0),t=u,l=r.w_size),a=e.avail_in,o=e.next_in,h=e.input,e.avail_in=l,e.next_in=0,e.input=t,j(r);r.lookahead>=x;){for(n=r.strstart,i=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+x-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=x-1,j(r);}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,e.next_in=o,e.input=h,e.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(e,t,r){t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;};},{}],48:[function(e,t,r){t.exports=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,C=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,c=r.window,d=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;e:do{p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=m[d&g];t:for(;;){if(d>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else {if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(d&(1<<y)-1)];continue t}if(32&y){r.mode=12;break e}e.msg="invalid literal/length code",r.mode=30;break e}w=65535&v,(y&=15)&&(p<y&&(d+=z[n++]<<p,p+=8),w+=d&(1<<y)-1,d>>>=y,p-=y),p<15&&(d+=z[n++]<<p,p+=8,d+=z[n++]<<p,p+=8),v=_[d&b];r:for(;;){if(d>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(d&(1<<y)-1)];continue r}e.msg="invalid distance code",r.mode=30;break e}if(k=65535&v,p<(y&=15)&&(d+=z[n++]<<p,(p+=8)<y&&(d+=z[n++]<<p,p+=8)),h<(k+=d&(1<<y)-1)){e.msg="invalid distance too far back",r.mode=30;break e}if(d>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){e.msg="invalid distance too far back",r.mode=30;break e}if(S=c,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C;}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=c[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=c[x++],--y;);x=s-k,S=C;}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=c[x++],--y;);x=s-k,S=C;}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]));}else {for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]));}break}}break}}while(n<i&&s<o);n-=w=p>>3,d&=(1<<(p-=w<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=d,r.bits=p;};},{}],49:[function(e,t,r){var I=e("../utils/common"),O=e("./adler32"),B=e("./crc32"),R=e("./inffast"),T=e("./inftrees"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return (e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function h(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function u(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=h(e,t))!==N&&(e.state=null),r):U}var l,f,c=!0;function j(e){if(c){var t;for(l=new I.Buf32(512),f=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(T(D,e.lens,0,288,l,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;T(F,e.lens,0,32,f,0,e.work,{bits:5}),c=!1;}e.lencode=l,e.lenbits=9,e.distcode=f,e.distbits=5;}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(e){return u(e,15)},r.inflateInit2=u,r.inflate=function(e,t){var r,n,i,s,a,o,h,u,l,f,c,d,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,f=o,c=h,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){e.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){e.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(r.flags=u,8!=(255&r.flags)){e.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0;}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(d=r.length)&&(d=o),d&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,d,k)),512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,r.length-=d),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(d=0;k=n[s+d++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&d<o;);if(512&r.flags&&(r.check=B(r.check,n,d,s)),o-=d,s+=d,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u!==(65535&r.check)){e.msg="header crc mismatch",r.mode=30;break}l=u=0;}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}e.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;u>>>=2,l-=2;break e;case 2:r.mode=17;break;case 3:e.msg="invalid block type",r.mode=30;}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if((65535&u)!=(u>>>16^65535)){e.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(d=r.length){if(o<d&&(d=o),h<d&&(d=h),0===d)break e;I.arraySet(i,n,s,d,a),o-=d,s+=d,h-=d,a+=d,r.length-=d;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){e.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3;}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else {if(16===b){for(z=_+2;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u>>>=_,l-=_,0===r.have){e.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],d=3+(3&u),u>>>=2,l-=2;}else if(17===b){for(z=_+3;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}l-=_,k=0,d=3+(7&(u>>>=_)),u>>>=3,l-=3;}else {for(z=_+7;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}l-=_,k=0,d=11+(127&(u>>>=_)),u>>>=7,l-=7;}if(r.have+d>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=30;break}for(;d--;)r.lens[r.have++]=k;}}if(30===r.mode)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=h){e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,R(e,c),a=e.next_out,i=e.output,h=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}u>>>=v,l-=v,r.back+=v;}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra;}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}u>>>=v,l-=v,r.back+=v;}if(u>>>=_,l-=_,r.back+=_,64&g){e.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra;}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break e;if(d=c-h,r.offset>d){if((d=r.offset-d)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=30;break}p=d>r.wnext?(d-=r.wnext,r.wsize-d):r.wnext-d,d>r.length&&(d=r.length),m=r.window;}else m=i,p=a-r.offset,d=r.length;for(h<d&&(d=h),h-=d,r.length-=d;i[a++]=m[p++],--d;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break e;i[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break e;o--,u|=n[s++]<<l,l+=8;}if(c-=h,e.total_out+=c,r.total+=c,c&&(e.adler=r.check=r.flags?B(r.check,i,c,a-c):O(r.check,i,c,a-c)),c=h,(r.flags?u:L(u))!==r.check){e.msg="incorrect data check",r.mode=30;break}l=u=0;}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break e;o--,u+=n[s++]<<l,l+=8;}if(u!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=30;break}l=u=0;}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return -4;case 32:default:return U}return e.next_out=a,e.avail_out=h,e.next_in=s,e.avail_in=o,r.hold=u,r.bits=l,(r.wsize||c!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,c-e.avail_out)?(r.mode=31,-4):(f-=e.avail_in,c-=e.avail_out,e.total_in+=f,e.total_out+=c,r.total+=c,r.wrap&&c&&(e.adler=r.check=r.flags?B(r.check,i,c,e.next_out-c):O(r.check,i,c,e.next_out-c)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===c||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)";},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(e,t,r){var D=e("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var h,u,l,f,c,d,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<n;v++)O[t[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return -1;if(0<z&&(0===e||1!==w))return -1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<n;v++)0!==t[r+v]&&(a[B[t[r+v]]++]=v);if(d=0===e?(A=R=a,19):1===e?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,c=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===e&&852<C||2===e&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<d?(m=0,a[v]):a[v]>d?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;i[c+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=t[r+a[v]];}if(k<b&&(E&f)!==l){for(0===S&&(S=k),c+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===e&&852<C||2===e&&592<C)return 1;i[l=E&f]=k<<24|x<<16|c-s|0;}}return 0!==E&&(i[c+E]=b-S<<24|64<<16|0),o.bits=k,0};},{"../utils/common":41}],51:[function(e,t,r){t.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};},{}],52:[function(e,t,r){var i=e("../utils/common"),o=0,h=1;function n(e){for(var t=e.length;0<=--t;)e[t]=0;}var s=0,a=29,u=256,l=u+1+a,f=30,c=19,_=2*l+1,g=15,d=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));n(z);var C=new Array(2*f);n(C);var E=new Array(512);n(E);var A=new Array(256);n(A);var I=new Array(a);n(I);var O,B,R,T=new Array(f);function D(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length;}function F(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t;}function N(e){return e<256?E[e]:E[256+(e>>>7)]}function U(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255;}function P(e,t,r){e.bi_valid>d-r?(e.bi_buf|=t<<e.bi_valid&65535,U(e,e.bi_buf),e.bi_buf=t>>d-e.bi_valid,e.bi_valid+=r-d):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r);}function L(e,t,r){P(e,r[2*t],r[2*t+1]);}function j(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function Z(e,t,r){var n,i,s=new Array(g+1),a=0;for(n=1;n<=g;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=j(s[o]++,o));}}function W(e){var t;for(t=0;t<l;t++)e.dyn_ltree[2*t]=0;for(t=0;t<f;t++)e.dyn_dtree[2*t]=0;for(t=0;t<c;t++)e.bl_tree[2*t]=0;e.dyn_ltree[2*m]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0;}function M(e){8<e.bi_valid?U(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0;}function H(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function G(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&H(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!H(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n;}function K(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?L(e,i,t):(L(e,(s=A[i])+u+1,t),0!==(a=w[s])&&P(e,i-=I[s],a),L(e,s=N(--n),r),0!==(a=k[s])&&P(e,n-=T[s],a)),o<e.last_lit;);L(e,m,t);}function Y(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,h=t.stat_desc.elems,u=-1;for(e.heap_len=0,e.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(e.heap[++e.heap_len]=u=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=u<2?++u:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=u,r=e.heap_len>>1;1<=r;r--)G(e,s,r);for(i=h;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],G(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,G(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,h=t.dyn_tree,u=t.max_code,l=t.stat_desc.static_tree,f=t.stat_desc.has_stree,c=t.stat_desc.extra_bits,d=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=g;s++)e.bl_count[s]=0;for(h[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<_;r++)p<(s=h[2*h[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),h[2*n+1]=s,u<n||(e.bl_count[s]++,a=0,d<=n&&(a=c[n-d]),o=h[2*n],e.opt_len+=o*(s+a),f&&(e.static_len+=o*(l[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2;}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)u<(i=e.heap[--r])||(h[2*i+1]!==s&&(e.opt_len+=(s-h[2*i+1])*h[2*i],h[2*i+1]=s),n--);}}(e,t),Z(s,u,e.bl_count);}function X(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<h&&i===a||(o<u?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[2*b]++):o<=10?e.bl_tree[2*v]++:e.bl_tree[2*y]++,s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4));}function V(e,t,r){var n,i,s=-1,a=t[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<h&&i===a)){if(o<u)for(;L(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(L(e,i,e.bl_tree),o--),L(e,b,e.bl_tree),P(e,o-3,2)):o<=10?(L(e,v,e.bl_tree),P(e,o-3,3)):(L(e,y,e.bl_tree),P(e,o-11,7));s=i,u=(o=0)===a?(h=138,3):i===a?(h=6,3):(h=7,4);}}n(T);var q=!1;function J(e,t,r,n){P(e,(s<<1)+(n?1:0),3),function(e,t,r,n){M(e),n&&(U(e,r),U(e,~r)),i.arraySet(e.pending_buf,e.window,t,r,e.pending),e.pending+=r;}(e,t,r,!0);}r._tr_init=function(e){q||(function(){var e,t,r,n,i,s=new Array(g+1);for(n=r=0;n<a-1;n++)for(I[n]=r,e=0;e<1<<w[n];e++)A[r++]=n;for(A[r-1]=n,n=i=0;n<16;n++)for(T[n]=i,e=0;e<1<<k[n];e++)E[i++]=n;for(i>>=7;n<f;n++)for(T[n]=i<<7,e=0;e<1<<k[n]-7;e++)E[256+i++]=n;for(t=0;t<=g;t++)s[t]=0;for(e=0;e<=143;)z[2*e+1]=8,e++,s[8]++;for(;e<=255;)z[2*e+1]=9,e++,s[9]++;for(;e<=279;)z[2*e+1]=7,e++,s[7]++;for(;e<=287;)z[2*e+1]=8,e++,s[8]++;for(Z(z,l+1,s),e=0;e<f;e++)C[2*e+1]=5,C[2*e]=j(e,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,c,p);}(),q=!0),e.l_desc=new F(e.dyn_ltree,O),e.d_desc=new F(e.dyn_dtree,B),e.bl_desc=new F(e.bl_tree,R),e.bi_buf=0,e.bi_valid=0,W(e);},r._tr_stored_block=J,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return o;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return h;for(t=32;t<u;t++)if(0!==e.dyn_ltree[2*t])return h;return o}(e)),Y(e,e.l_desc),Y(e,e.d_desc),a=function(e){var t;for(X(e,e.dyn_ltree,e.l_desc.max_code),X(e,e.dyn_dtree,e.d_desc.max_code),Y(e,e.bl_desc),t=c-1;3<=t&&0===e.bl_tree[2*S[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?J(e,t,r,n):4===e.strategy||s===i?(P(e,2+(n?1:0),3),K(e,z,C)):(P(e,4+(n?1:0),3),function(e,t,r,n){var i;for(P(e,t-257,5),P(e,r-1,5),P(e,n-4,4),i=0;i<n;i++)P(e,e.bl_tree[2*S[i]+1],3);V(e,e.dyn_ltree,t-1),V(e,e.dyn_dtree,r-1);}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),K(e,e.dyn_ltree,e.dyn_dtree)),W(e),n&&M(e);},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(A[r]+u+1)]++,e.dyn_dtree[2*N(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){P(e,2,3),L(e,m,z),function(e){16===e.bi_valid?(U(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):8<=e.bi_valid&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8);}(e);};},{"../utils/common":41}],53:[function(e,t,r){t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;};},{}],54:[function(e,t,r){(function(e){!function(r,n){if(!r.setImmediate){var i,s,t,a,o=1,h={},u=!1,l=r.document,e=Object.getPrototypeOf&&Object.getPrototypeOf(r);e=e&&e.setTimeout?e:r,i="[object process]"==={}.toString.call(r.process)?function(e){browser$1.nextTick(function(){c(e);});}:function(){if(r.postMessage&&!r.importScripts){var e=!0,t=r.onmessage;return r.onmessage=function(){e=!1;},r.postMessage("","*"),r.onmessage=t,e}}()?(a="setImmediate$"+Math.random()+"$",r.addEventListener?r.addEventListener("message",d,!1):r.attachEvent("onmessage",d),function(e){r.postMessage(a+e,"*");}):r.MessageChannel?((t=new MessageChannel).port1.onmessage=function(e){c(e.data);},function(e){t.port2.postMessage(e);}):l&&"onreadystatechange"in l.createElement("script")?(s=l.documentElement,function(e){var t=l.createElement("script");t.onreadystatechange=function(){c(e),t.onreadystatechange=null,s.removeChild(t),t=null;},s.appendChild(t);}):function(e){setTimeout(c,0,e);},e.setImmediate=function(e){"function"!=typeof e&&(e=new Function(""+e));for(var t=new Array(arguments.length-1),r=0;r<t.length;r++)t[r]=arguments[r+1];var n={callback:e,args:t};return h[o]=n,i(o),o++},e.clearImmediate=f;}function f(e){delete h[e];}function c(e){if(u)setTimeout(c,0,e);else {var t=h[e];if(t){u=!0;try{!function(e){var t=e.callback,r=e.args;switch(r.length){case 0:t();break;case 1:t(r[0]);break;case 2:t(r[0],r[1]);break;case 3:t(r[0],r[1],r[2]);break;default:t.apply(n,r);}}(t);}finally{f(e),u=!1;}}}}function d(e){e.source===r&&"string"==typeof e.data&&0===e.data.indexOf(a)&&c(+e.data.slice(a.length));}}("undefined"==typeof self?void 0===e?this:e:self);}).call(this,"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{});},{}]},{},[10])(10)}); 
  	} (jszip_min, jszip_min.exports));
  	return jszip_min.exports;
  }

  var jszip_minExports = requireJszip_min();
  var JSZip = /*@__PURE__*/getDefaultExportFromCjs(jszip_minExports);

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  }

  function __generator(thisArg, body) {
      var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
      function verb(n) { return function (v) { return step([n, v]); }; }
      function step(op) {
          if (f) throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _) try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
              if (y = 0, t) op = [op[0] & 2, t.value];
              switch (op[0]) {
                  case 0: case 1: t = op; break;
                  case 4: _.label++; return { value: op[1], done: false };
                  case 5: _.label++; y = op[1]; op = [0]; continue;
                  case 7: op = _.ops.pop(); _.trys.pop(); continue;
                  default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                      if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                      if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                      if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                      if (t[2]) _.ops.pop();
                      _.trys.pop(); continue;
              }
              op = body.call(thisArg, _);
          } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
          if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
      }
  }

  function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
              if (!ar) ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
  }

  /**
   * PptxGenJS Enums
   * NOTE: `enum` wont work for objects, so use `Object.freeze`
   */
  // CONST
  var EMU = 914400; // One (1) inch (OfficeXML measures in EMU (English Metric Units))
  var ONEPT = 12700; // One (1) point (pt)
  var CRLF = '\r\n'; // AKA: Chr(13) & Chr(10)
  var LAYOUT_IDX_SERIES_BASE = 2147483649;
  var REGEX_HEX_COLOR = /^[0-9a-fA-F]{6}$/;
  var LINEH_MODIFIER = 1.67; // AKA: Golden Ratio Typography
  var DEF_BULLET_MARGIN = 27;
  var DEF_CELL_BORDER = { type: 'solid', color: '666666', pt: 1 };
  var DEF_CELL_MARGIN_IN = [0.05, 0.1, 0.05, 0.1]; // "Normal" margins in PPT-2021 ("Narrow" is `0.05` for all 4)
  var DEF_CHART_BORDER = { type: 'solid', color: '363636', pt: 1 };
  var DEF_CHART_GRIDLINE = { color: '888888', style: 'solid', size: 1, cap: 'flat' };
  var DEF_FONT_COLOR = '000000';
  var DEF_FONT_SIZE = 12;
  var DEF_FONT_TITLE_SIZE = 18;
  var DEF_PRES_LAYOUT = 'LAYOUT_16x9';
  var DEF_PRES_LAYOUT_NAME = 'DEFAULT';
  var DEF_SHAPE_LINE_COLOR = '333333';
  var DEF_SHAPE_SHADOW = { type: 'outer', blur: 3, offset: 23000 / 12700, angle: 90, color: '000000', opacity: 0.35, rotateWithShape: true };
  var DEF_SLIDE_MARGIN_IN = [0.5, 0.5, 0.5, 0.5]; // TRBL-style
  var DEF_TEXT_SHADOW = { type: 'outer', blur: 8, offset: 4, angle: 270, color: '000000', opacity: 0.75 };
  var DEF_TEXT_GLOW = { size: 8, color: 'FFFFFF', opacity: 0.75 };
  var AXIS_ID_VALUE_PRIMARY = '2094734552';
  var AXIS_ID_VALUE_SECONDARY = '2094734553';
  var AXIS_ID_CATEGORY_PRIMARY = '2094734554';
  var AXIS_ID_CATEGORY_SECONDARY = '2094734555';
  var AXIS_ID_SERIES_PRIMARY = '2094734556';
  var LETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
  var BARCHART_COLORS = [
      'C0504D',
      '4F81BD',
      '9BBB59',
      '8064A2',
      '4BACC6',
      'F79646',
      '628FC6',
      'C86360',
      'C0504D',
      '4F81BD',
      '9BBB59',
      '8064A2',
      '4BACC6',
      'F79646',
      '628FC6',
      'C86360'
  ];
  var PIECHART_COLORS = [
      '5DA5DA',
      'FAA43A',
      '60BD68',
      'F17CB0',
      'B2912F',
      'B276B2',
      'DECF3F',
      'F15854',
      'A7A7A7',
      '5DA5DA',
      'FAA43A',
      '60BD68',
      'F17CB0',
      'B2912F',
      'B276B2',
      'DECF3F',
      'F15854',
      'A7A7A7',
  ];
  var TEXT_HALIGN;
  (function (TEXT_HALIGN) {
      TEXT_HALIGN["left"] = "left";
      TEXT_HALIGN["center"] = "center";
      TEXT_HALIGN["right"] = "right";
      TEXT_HALIGN["justify"] = "justify";
  })(TEXT_HALIGN || (TEXT_HALIGN = {}));
  var TEXT_VALIGN;
  (function (TEXT_VALIGN) {
      TEXT_VALIGN["b"] = "b";
      TEXT_VALIGN["ctr"] = "ctr";
      TEXT_VALIGN["t"] = "t";
  })(TEXT_VALIGN || (TEXT_VALIGN = {}));
  var SLDNUMFLDID = '{F7021451-1387-4CA6-816F-3879F97B5CBC}';
  // ENUM
  // TODO: 3.5 or v4.0: rationalize ts-def exported enum names/case!
  // NOTE: First tsdef enum named correctly (shapes -> 'Shape', colors -> 'Color'), etc.
  var OutputType;
  (function (OutputType) {
      OutputType["arraybuffer"] = "arraybuffer";
      OutputType["base64"] = "base64";
      OutputType["binarystring"] = "binarystring";
      OutputType["blob"] = "blob";
      OutputType["nodebuffer"] = "nodebuffer";
      OutputType["uint8array"] = "uint8array";
  })(OutputType || (OutputType = {}));
  var ChartType;
  (function (ChartType) {
      ChartType["area"] = "area";
      ChartType["bar"] = "bar";
      ChartType["bar3d"] = "bar3D";
      ChartType["bubble"] = "bubble";
      ChartType["bubble3d"] = "bubble3D";
      ChartType["doughnut"] = "doughnut";
      ChartType["line"] = "line";
      ChartType["pie"] = "pie";
      ChartType["radar"] = "radar";
      ChartType["scatter"] = "scatter";
  })(ChartType || (ChartType = {}));
  var ShapeType;
  (function (ShapeType) {
      ShapeType["accentBorderCallout1"] = "accentBorderCallout1";
      ShapeType["accentBorderCallout2"] = "accentBorderCallout2";
      ShapeType["accentBorderCallout3"] = "accentBorderCallout3";
      ShapeType["accentCallout1"] = "accentCallout1";
      ShapeType["accentCallout2"] = "accentCallout2";
      ShapeType["accentCallout3"] = "accentCallout3";
      ShapeType["actionButtonBackPrevious"] = "actionButtonBackPrevious";
      ShapeType["actionButtonBeginning"] = "actionButtonBeginning";
      ShapeType["actionButtonBlank"] = "actionButtonBlank";
      ShapeType["actionButtonDocument"] = "actionButtonDocument";
      ShapeType["actionButtonEnd"] = "actionButtonEnd";
      ShapeType["actionButtonForwardNext"] = "actionButtonForwardNext";
      ShapeType["actionButtonHelp"] = "actionButtonHelp";
      ShapeType["actionButtonHome"] = "actionButtonHome";
      ShapeType["actionButtonInformation"] = "actionButtonInformation";
      ShapeType["actionButtonMovie"] = "actionButtonMovie";
      ShapeType["actionButtonReturn"] = "actionButtonReturn";
      ShapeType["actionButtonSound"] = "actionButtonSound";
      ShapeType["arc"] = "arc";
      ShapeType["bentArrow"] = "bentArrow";
      ShapeType["bentUpArrow"] = "bentUpArrow";
      ShapeType["bevel"] = "bevel";
      ShapeType["blockArc"] = "blockArc";
      ShapeType["borderCallout1"] = "borderCallout1";
      ShapeType["borderCallout2"] = "borderCallout2";
      ShapeType["borderCallout3"] = "borderCallout3";
      ShapeType["bracePair"] = "bracePair";
      ShapeType["bracketPair"] = "bracketPair";
      ShapeType["callout1"] = "callout1";
      ShapeType["callout2"] = "callout2";
      ShapeType["callout3"] = "callout3";
      ShapeType["can"] = "can";
      ShapeType["chartPlus"] = "chartPlus";
      ShapeType["chartStar"] = "chartStar";
      ShapeType["chartX"] = "chartX";
      ShapeType["chevron"] = "chevron";
      ShapeType["chord"] = "chord";
      ShapeType["circularArrow"] = "circularArrow";
      ShapeType["cloud"] = "cloud";
      ShapeType["cloudCallout"] = "cloudCallout";
      ShapeType["corner"] = "corner";
      ShapeType["cornerTabs"] = "cornerTabs";
      ShapeType["cube"] = "cube";
      ShapeType["curvedDownArrow"] = "curvedDownArrow";
      ShapeType["curvedLeftArrow"] = "curvedLeftArrow";
      ShapeType["curvedRightArrow"] = "curvedRightArrow";
      ShapeType["curvedUpArrow"] = "curvedUpArrow";
      ShapeType["custGeom"] = "custGeom";
      ShapeType["decagon"] = "decagon";
      ShapeType["diagStripe"] = "diagStripe";
      ShapeType["diamond"] = "diamond";
      ShapeType["dodecagon"] = "dodecagon";
      ShapeType["donut"] = "donut";
      ShapeType["doubleWave"] = "doubleWave";
      ShapeType["downArrow"] = "downArrow";
      ShapeType["downArrowCallout"] = "downArrowCallout";
      ShapeType["ellipse"] = "ellipse";
      ShapeType["ellipseRibbon"] = "ellipseRibbon";
      ShapeType["ellipseRibbon2"] = "ellipseRibbon2";
      ShapeType["flowChartAlternateProcess"] = "flowChartAlternateProcess";
      ShapeType["flowChartCollate"] = "flowChartCollate";
      ShapeType["flowChartConnector"] = "flowChartConnector";
      ShapeType["flowChartDecision"] = "flowChartDecision";
      ShapeType["flowChartDelay"] = "flowChartDelay";
      ShapeType["flowChartDisplay"] = "flowChartDisplay";
      ShapeType["flowChartDocument"] = "flowChartDocument";
      ShapeType["flowChartExtract"] = "flowChartExtract";
      ShapeType["flowChartInputOutput"] = "flowChartInputOutput";
      ShapeType["flowChartInternalStorage"] = "flowChartInternalStorage";
      ShapeType["flowChartMagneticDisk"] = "flowChartMagneticDisk";
      ShapeType["flowChartMagneticDrum"] = "flowChartMagneticDrum";
      ShapeType["flowChartMagneticTape"] = "flowChartMagneticTape";
      ShapeType["flowChartManualInput"] = "flowChartManualInput";
      ShapeType["flowChartManualOperation"] = "flowChartManualOperation";
      ShapeType["flowChartMerge"] = "flowChartMerge";
      ShapeType["flowChartMultidocument"] = "flowChartMultidocument";
      ShapeType["flowChartOfflineStorage"] = "flowChartOfflineStorage";
      ShapeType["flowChartOffpageConnector"] = "flowChartOffpageConnector";
      ShapeType["flowChartOnlineStorage"] = "flowChartOnlineStorage";
      ShapeType["flowChartOr"] = "flowChartOr";
      ShapeType["flowChartPredefinedProcess"] = "flowChartPredefinedProcess";
      ShapeType["flowChartPreparation"] = "flowChartPreparation";
      ShapeType["flowChartProcess"] = "flowChartProcess";
      ShapeType["flowChartPunchedCard"] = "flowChartPunchedCard";
      ShapeType["flowChartPunchedTape"] = "flowChartPunchedTape";
      ShapeType["flowChartSort"] = "flowChartSort";
      ShapeType["flowChartSummingJunction"] = "flowChartSummingJunction";
      ShapeType["flowChartTerminator"] = "flowChartTerminator";
      ShapeType["folderCorner"] = "folderCorner";
      ShapeType["frame"] = "frame";
      ShapeType["funnel"] = "funnel";
      ShapeType["gear6"] = "gear6";
      ShapeType["gear9"] = "gear9";
      ShapeType["halfFrame"] = "halfFrame";
      ShapeType["heart"] = "heart";
      ShapeType["heptagon"] = "heptagon";
      ShapeType["hexagon"] = "hexagon";
      ShapeType["homePlate"] = "homePlate";
      ShapeType["horizontalScroll"] = "horizontalScroll";
      ShapeType["irregularSeal1"] = "irregularSeal1";
      ShapeType["irregularSeal2"] = "irregularSeal2";
      ShapeType["leftArrow"] = "leftArrow";
      ShapeType["leftArrowCallout"] = "leftArrowCallout";
      ShapeType["leftBrace"] = "leftBrace";
      ShapeType["leftBracket"] = "leftBracket";
      ShapeType["leftCircularArrow"] = "leftCircularArrow";
      ShapeType["leftRightArrow"] = "leftRightArrow";
      ShapeType["leftRightArrowCallout"] = "leftRightArrowCallout";
      ShapeType["leftRightCircularArrow"] = "leftRightCircularArrow";
      ShapeType["leftRightRibbon"] = "leftRightRibbon";
      ShapeType["leftRightUpArrow"] = "leftRightUpArrow";
      ShapeType["leftUpArrow"] = "leftUpArrow";
      ShapeType["lightningBolt"] = "lightningBolt";
      ShapeType["line"] = "line";
      ShapeType["lineInv"] = "lineInv";
      ShapeType["mathDivide"] = "mathDivide";
      ShapeType["mathEqual"] = "mathEqual";
      ShapeType["mathMinus"] = "mathMinus";
      ShapeType["mathMultiply"] = "mathMultiply";
      ShapeType["mathNotEqual"] = "mathNotEqual";
      ShapeType["mathPlus"] = "mathPlus";
      ShapeType["moon"] = "moon";
      ShapeType["noSmoking"] = "noSmoking";
      ShapeType["nonIsoscelesTrapezoid"] = "nonIsoscelesTrapezoid";
      ShapeType["notchedRightArrow"] = "notchedRightArrow";
      ShapeType["octagon"] = "octagon";
      ShapeType["parallelogram"] = "parallelogram";
      ShapeType["pentagon"] = "pentagon";
      ShapeType["pie"] = "pie";
      ShapeType["pieWedge"] = "pieWedge";
      ShapeType["plaque"] = "plaque";
      ShapeType["plaqueTabs"] = "plaqueTabs";
      ShapeType["plus"] = "plus";
      ShapeType["quadArrow"] = "quadArrow";
      ShapeType["quadArrowCallout"] = "quadArrowCallout";
      ShapeType["rect"] = "rect";
      ShapeType["ribbon"] = "ribbon";
      ShapeType["ribbon2"] = "ribbon2";
      ShapeType["rightArrow"] = "rightArrow";
      ShapeType["rightArrowCallout"] = "rightArrowCallout";
      ShapeType["rightBrace"] = "rightBrace";
      ShapeType["rightBracket"] = "rightBracket";
      ShapeType["round1Rect"] = "round1Rect";
      ShapeType["round2DiagRect"] = "round2DiagRect";
      ShapeType["round2SameRect"] = "round2SameRect";
      ShapeType["roundRect"] = "roundRect";
      ShapeType["rtTriangle"] = "rtTriangle";
      ShapeType["smileyFace"] = "smileyFace";
      ShapeType["snip1Rect"] = "snip1Rect";
      ShapeType["snip2DiagRect"] = "snip2DiagRect";
      ShapeType["snip2SameRect"] = "snip2SameRect";
      ShapeType["snipRoundRect"] = "snipRoundRect";
      ShapeType["squareTabs"] = "squareTabs";
      ShapeType["star10"] = "star10";
      ShapeType["star12"] = "star12";
      ShapeType["star16"] = "star16";
      ShapeType["star24"] = "star24";
      ShapeType["star32"] = "star32";
      ShapeType["star4"] = "star4";
      ShapeType["star5"] = "star5";
      ShapeType["star6"] = "star6";
      ShapeType["star7"] = "star7";
      ShapeType["star8"] = "star8";
      ShapeType["stripedRightArrow"] = "stripedRightArrow";
      ShapeType["sun"] = "sun";
      ShapeType["swooshArrow"] = "swooshArrow";
      ShapeType["teardrop"] = "teardrop";
      ShapeType["trapezoid"] = "trapezoid";
      ShapeType["triangle"] = "triangle";
      ShapeType["upArrow"] = "upArrow";
      ShapeType["upArrowCallout"] = "upArrowCallout";
      ShapeType["upDownArrow"] = "upDownArrow";
      ShapeType["upDownArrowCallout"] = "upDownArrowCallout";
      ShapeType["uturnArrow"] = "uturnArrow";
      ShapeType["verticalScroll"] = "verticalScroll";
      ShapeType["wave"] = "wave";
      ShapeType["wedgeEllipseCallout"] = "wedgeEllipseCallout";
      ShapeType["wedgeRectCallout"] = "wedgeRectCallout";
      ShapeType["wedgeRoundRectCallout"] = "wedgeRoundRectCallout";
  })(ShapeType || (ShapeType = {}));
  /**
   * TODO: FUTURE: v4.0: rename to `ThemeColor`
   */
  var SchemeColor;
  (function (SchemeColor) {
      SchemeColor["text1"] = "tx1";
      SchemeColor["text2"] = "tx2";
      SchemeColor["background1"] = "bg1";
      SchemeColor["background2"] = "bg2";
      SchemeColor["accent1"] = "accent1";
      SchemeColor["accent2"] = "accent2";
      SchemeColor["accent3"] = "accent3";
      SchemeColor["accent4"] = "accent4";
      SchemeColor["accent5"] = "accent5";
      SchemeColor["accent6"] = "accent6";
  })(SchemeColor || (SchemeColor = {}));
  var AlignH;
  (function (AlignH) {
      AlignH["left"] = "left";
      AlignH["center"] = "center";
      AlignH["right"] = "right";
      AlignH["justify"] = "justify";
  })(AlignH || (AlignH = {}));
  var AlignV;
  (function (AlignV) {
      AlignV["top"] = "top";
      AlignV["middle"] = "middle";
      AlignV["bottom"] = "bottom";
  })(AlignV || (AlignV = {}));
  var SHAPE_TYPE;
  (function (SHAPE_TYPE) {
      SHAPE_TYPE["ACTION_BUTTON_BACK_OR_PREVIOUS"] = "actionButtonBackPrevious";
      SHAPE_TYPE["ACTION_BUTTON_BEGINNING"] = "actionButtonBeginning";
      SHAPE_TYPE["ACTION_BUTTON_CUSTOM"] = "actionButtonBlank";
      SHAPE_TYPE["ACTION_BUTTON_DOCUMENT"] = "actionButtonDocument";
      SHAPE_TYPE["ACTION_BUTTON_END"] = "actionButtonEnd";
      SHAPE_TYPE["ACTION_BUTTON_FORWARD_OR_NEXT"] = "actionButtonForwardNext";
      SHAPE_TYPE["ACTION_BUTTON_HELP"] = "actionButtonHelp";
      SHAPE_TYPE["ACTION_BUTTON_HOME"] = "actionButtonHome";
      SHAPE_TYPE["ACTION_BUTTON_INFORMATION"] = "actionButtonInformation";
      SHAPE_TYPE["ACTION_BUTTON_MOVIE"] = "actionButtonMovie";
      SHAPE_TYPE["ACTION_BUTTON_RETURN"] = "actionButtonReturn";
      SHAPE_TYPE["ACTION_BUTTON_SOUND"] = "actionButtonSound";
      SHAPE_TYPE["ARC"] = "arc";
      SHAPE_TYPE["BALLOON"] = "wedgeRoundRectCallout";
      SHAPE_TYPE["BENT_ARROW"] = "bentArrow";
      SHAPE_TYPE["BENT_UP_ARROW"] = "bentUpArrow";
      SHAPE_TYPE["BEVEL"] = "bevel";
      SHAPE_TYPE["BLOCK_ARC"] = "blockArc";
      SHAPE_TYPE["CAN"] = "can";
      SHAPE_TYPE["CHART_PLUS"] = "chartPlus";
      SHAPE_TYPE["CHART_STAR"] = "chartStar";
      SHAPE_TYPE["CHART_X"] = "chartX";
      SHAPE_TYPE["CHEVRON"] = "chevron";
      SHAPE_TYPE["CHORD"] = "chord";
      SHAPE_TYPE["CIRCULAR_ARROW"] = "circularArrow";
      SHAPE_TYPE["CLOUD"] = "cloud";
      SHAPE_TYPE["CLOUD_CALLOUT"] = "cloudCallout";
      SHAPE_TYPE["CORNER"] = "corner";
      SHAPE_TYPE["CORNER_TABS"] = "cornerTabs";
      SHAPE_TYPE["CROSS"] = "plus";
      SHAPE_TYPE["CUBE"] = "cube";
      SHAPE_TYPE["CURVED_DOWN_ARROW"] = "curvedDownArrow";
      SHAPE_TYPE["CURVED_DOWN_RIBBON"] = "ellipseRibbon";
      SHAPE_TYPE["CURVED_LEFT_ARROW"] = "curvedLeftArrow";
      SHAPE_TYPE["CURVED_RIGHT_ARROW"] = "curvedRightArrow";
      SHAPE_TYPE["CURVED_UP_ARROW"] = "curvedUpArrow";
      SHAPE_TYPE["CURVED_UP_RIBBON"] = "ellipseRibbon2";
      SHAPE_TYPE["CUSTOM_GEOMETRY"] = "custGeom";
      SHAPE_TYPE["DECAGON"] = "decagon";
      SHAPE_TYPE["DIAGONAL_STRIPE"] = "diagStripe";
      SHAPE_TYPE["DIAMOND"] = "diamond";
      SHAPE_TYPE["DODECAGON"] = "dodecagon";
      SHAPE_TYPE["DONUT"] = "donut";
      SHAPE_TYPE["DOUBLE_BRACE"] = "bracePair";
      SHAPE_TYPE["DOUBLE_BRACKET"] = "bracketPair";
      SHAPE_TYPE["DOUBLE_WAVE"] = "doubleWave";
      SHAPE_TYPE["DOWN_ARROW"] = "downArrow";
      SHAPE_TYPE["DOWN_ARROW_CALLOUT"] = "downArrowCallout";
      SHAPE_TYPE["DOWN_RIBBON"] = "ribbon";
      SHAPE_TYPE["EXPLOSION1"] = "irregularSeal1";
      SHAPE_TYPE["EXPLOSION2"] = "irregularSeal2";
      SHAPE_TYPE["FLOWCHART_ALTERNATE_PROCESS"] = "flowChartAlternateProcess";
      SHAPE_TYPE["FLOWCHART_CARD"] = "flowChartPunchedCard";
      SHAPE_TYPE["FLOWCHART_COLLATE"] = "flowChartCollate";
      SHAPE_TYPE["FLOWCHART_CONNECTOR"] = "flowChartConnector";
      SHAPE_TYPE["FLOWCHART_DATA"] = "flowChartInputOutput";
      SHAPE_TYPE["FLOWCHART_DECISION"] = "flowChartDecision";
      SHAPE_TYPE["FLOWCHART_DELAY"] = "flowChartDelay";
      SHAPE_TYPE["FLOWCHART_DIRECT_ACCESS_STORAGE"] = "flowChartMagneticDrum";
      SHAPE_TYPE["FLOWCHART_DISPLAY"] = "flowChartDisplay";
      SHAPE_TYPE["FLOWCHART_DOCUMENT"] = "flowChartDocument";
      SHAPE_TYPE["FLOWCHART_EXTRACT"] = "flowChartExtract";
      SHAPE_TYPE["FLOWCHART_INTERNAL_STORAGE"] = "flowChartInternalStorage";
      SHAPE_TYPE["FLOWCHART_MAGNETIC_DISK"] = "flowChartMagneticDisk";
      SHAPE_TYPE["FLOWCHART_MANUAL_INPUT"] = "flowChartManualInput";
      SHAPE_TYPE["FLOWCHART_MANUAL_OPERATION"] = "flowChartManualOperation";
      SHAPE_TYPE["FLOWCHART_MERGE"] = "flowChartMerge";
      SHAPE_TYPE["FLOWCHART_MULTIDOCUMENT"] = "flowChartMultidocument";
      SHAPE_TYPE["FLOWCHART_OFFLINE_STORAGE"] = "flowChartOfflineStorage";
      SHAPE_TYPE["FLOWCHART_OFFPAGE_CONNECTOR"] = "flowChartOffpageConnector";
      SHAPE_TYPE["FLOWCHART_OR"] = "flowChartOr";
      SHAPE_TYPE["FLOWCHART_PREDEFINED_PROCESS"] = "flowChartPredefinedProcess";
      SHAPE_TYPE["FLOWCHART_PREPARATION"] = "flowChartPreparation";
      SHAPE_TYPE["FLOWCHART_PROCESS"] = "flowChartProcess";
      SHAPE_TYPE["FLOWCHART_PUNCHED_TAPE"] = "flowChartPunchedTape";
      SHAPE_TYPE["FLOWCHART_SEQUENTIAL_ACCESS_STORAGE"] = "flowChartMagneticTape";
      SHAPE_TYPE["FLOWCHART_SORT"] = "flowChartSort";
      SHAPE_TYPE["FLOWCHART_STORED_DATA"] = "flowChartOnlineStorage";
      SHAPE_TYPE["FLOWCHART_SUMMING_JUNCTION"] = "flowChartSummingJunction";
      SHAPE_TYPE["FLOWCHART_TERMINATOR"] = "flowChartTerminator";
      SHAPE_TYPE["FOLDED_CORNER"] = "folderCorner";
      SHAPE_TYPE["FRAME"] = "frame";
      SHAPE_TYPE["FUNNEL"] = "funnel";
      SHAPE_TYPE["GEAR_6"] = "gear6";
      SHAPE_TYPE["GEAR_9"] = "gear9";
      SHAPE_TYPE["HALF_FRAME"] = "halfFrame";
      SHAPE_TYPE["HEART"] = "heart";
      SHAPE_TYPE["HEPTAGON"] = "heptagon";
      SHAPE_TYPE["HEXAGON"] = "hexagon";
      SHAPE_TYPE["HORIZONTAL_SCROLL"] = "horizontalScroll";
      SHAPE_TYPE["ISOSCELES_TRIANGLE"] = "triangle";
      SHAPE_TYPE["LEFT_ARROW"] = "leftArrow";
      SHAPE_TYPE["LEFT_ARROW_CALLOUT"] = "leftArrowCallout";
      SHAPE_TYPE["LEFT_BRACE"] = "leftBrace";
      SHAPE_TYPE["LEFT_BRACKET"] = "leftBracket";
      SHAPE_TYPE["LEFT_CIRCULAR_ARROW"] = "leftCircularArrow";
      SHAPE_TYPE["LEFT_RIGHT_ARROW"] = "leftRightArrow";
      SHAPE_TYPE["LEFT_RIGHT_ARROW_CALLOUT"] = "leftRightArrowCallout";
      SHAPE_TYPE["LEFT_RIGHT_CIRCULAR_ARROW"] = "leftRightCircularArrow";
      SHAPE_TYPE["LEFT_RIGHT_RIBBON"] = "leftRightRibbon";
      SHAPE_TYPE["LEFT_RIGHT_UP_ARROW"] = "leftRightUpArrow";
      SHAPE_TYPE["LEFT_UP_ARROW"] = "leftUpArrow";
      SHAPE_TYPE["LIGHTNING_BOLT"] = "lightningBolt";
      SHAPE_TYPE["LINE_CALLOUT_1"] = "borderCallout1";
      SHAPE_TYPE["LINE_CALLOUT_1_ACCENT_BAR"] = "accentCallout1";
      SHAPE_TYPE["LINE_CALLOUT_1_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout1";
      SHAPE_TYPE["LINE_CALLOUT_1_NO_BORDER"] = "callout1";
      SHAPE_TYPE["LINE_CALLOUT_2"] = "borderCallout2";
      SHAPE_TYPE["LINE_CALLOUT_2_ACCENT_BAR"] = "accentCallout2";
      SHAPE_TYPE["LINE_CALLOUT_2_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout2";
      SHAPE_TYPE["LINE_CALLOUT_2_NO_BORDER"] = "callout2";
      SHAPE_TYPE["LINE_CALLOUT_3"] = "borderCallout3";
      SHAPE_TYPE["LINE_CALLOUT_3_ACCENT_BAR"] = "accentCallout3";
      SHAPE_TYPE["LINE_CALLOUT_3_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
      SHAPE_TYPE["LINE_CALLOUT_3_NO_BORDER"] = "callout3";
      SHAPE_TYPE["LINE_CALLOUT_4"] = "borderCallout3";
      SHAPE_TYPE["LINE_CALLOUT_4_ACCENT_BAR"] = "accentCallout3";
      SHAPE_TYPE["LINE_CALLOUT_4_BORDER_AND_ACCENT_BAR"] = "accentBorderCallout3";
      SHAPE_TYPE["LINE_CALLOUT_4_NO_BORDER"] = "callout3";
      SHAPE_TYPE["LINE"] = "line";
      SHAPE_TYPE["LINE_INVERSE"] = "lineInv";
      SHAPE_TYPE["MATH_DIVIDE"] = "mathDivide";
      SHAPE_TYPE["MATH_EQUAL"] = "mathEqual";
      SHAPE_TYPE["MATH_MINUS"] = "mathMinus";
      SHAPE_TYPE["MATH_MULTIPLY"] = "mathMultiply";
      SHAPE_TYPE["MATH_NOT_EQUAL"] = "mathNotEqual";
      SHAPE_TYPE["MATH_PLUS"] = "mathPlus";
      SHAPE_TYPE["MOON"] = "moon";
      SHAPE_TYPE["NON_ISOSCELES_TRAPEZOID"] = "nonIsoscelesTrapezoid";
      SHAPE_TYPE["NOTCHED_RIGHT_ARROW"] = "notchedRightArrow";
      SHAPE_TYPE["NO_SYMBOL"] = "noSmoking";
      SHAPE_TYPE["OCTAGON"] = "octagon";
      SHAPE_TYPE["OVAL"] = "ellipse";
      SHAPE_TYPE["OVAL_CALLOUT"] = "wedgeEllipseCallout";
      SHAPE_TYPE["PARALLELOGRAM"] = "parallelogram";
      SHAPE_TYPE["PENTAGON"] = "homePlate";
      SHAPE_TYPE["PIE"] = "pie";
      SHAPE_TYPE["PIE_WEDGE"] = "pieWedge";
      SHAPE_TYPE["PLAQUE"] = "plaque";
      SHAPE_TYPE["PLAQUE_TABS"] = "plaqueTabs";
      SHAPE_TYPE["QUAD_ARROW"] = "quadArrow";
      SHAPE_TYPE["QUAD_ARROW_CALLOUT"] = "quadArrowCallout";
      SHAPE_TYPE["RECTANGLE"] = "rect";
      SHAPE_TYPE["RECTANGULAR_CALLOUT"] = "wedgeRectCallout";
      SHAPE_TYPE["REGULAR_PENTAGON"] = "pentagon";
      SHAPE_TYPE["RIGHT_ARROW"] = "rightArrow";
      SHAPE_TYPE["RIGHT_ARROW_CALLOUT"] = "rightArrowCallout";
      SHAPE_TYPE["RIGHT_BRACE"] = "rightBrace";
      SHAPE_TYPE["RIGHT_BRACKET"] = "rightBracket";
      SHAPE_TYPE["RIGHT_TRIANGLE"] = "rtTriangle";
      SHAPE_TYPE["ROUNDED_RECTANGLE"] = "roundRect";
      SHAPE_TYPE["ROUNDED_RECTANGULAR_CALLOUT"] = "wedgeRoundRectCallout";
      SHAPE_TYPE["ROUND_1_RECTANGLE"] = "round1Rect";
      SHAPE_TYPE["ROUND_2_DIAG_RECTANGLE"] = "round2DiagRect";
      SHAPE_TYPE["ROUND_2_SAME_RECTANGLE"] = "round2SameRect";
      SHAPE_TYPE["SMILEY_FACE"] = "smileyFace";
      SHAPE_TYPE["SNIP_1_RECTANGLE"] = "snip1Rect";
      SHAPE_TYPE["SNIP_2_DIAG_RECTANGLE"] = "snip2DiagRect";
      SHAPE_TYPE["SNIP_2_SAME_RECTANGLE"] = "snip2SameRect";
      SHAPE_TYPE["SNIP_ROUND_RECTANGLE"] = "snipRoundRect";
      SHAPE_TYPE["SQUARE_TABS"] = "squareTabs";
      SHAPE_TYPE["STAR_10_POINT"] = "star10";
      SHAPE_TYPE["STAR_12_POINT"] = "star12";
      SHAPE_TYPE["STAR_16_POINT"] = "star16";
      SHAPE_TYPE["STAR_24_POINT"] = "star24";
      SHAPE_TYPE["STAR_32_POINT"] = "star32";
      SHAPE_TYPE["STAR_4_POINT"] = "star4";
      SHAPE_TYPE["STAR_5_POINT"] = "star5";
      SHAPE_TYPE["STAR_6_POINT"] = "star6";
      SHAPE_TYPE["STAR_7_POINT"] = "star7";
      SHAPE_TYPE["STAR_8_POINT"] = "star8";
      SHAPE_TYPE["STRIPED_RIGHT_ARROW"] = "stripedRightArrow";
      SHAPE_TYPE["SUN"] = "sun";
      SHAPE_TYPE["SWOOSH_ARROW"] = "swooshArrow";
      SHAPE_TYPE["TEAR"] = "teardrop";
      SHAPE_TYPE["TRAPEZOID"] = "trapezoid";
      SHAPE_TYPE["UP_ARROW"] = "upArrow";
      SHAPE_TYPE["UP_ARROW_CALLOUT"] = "upArrowCallout";
      SHAPE_TYPE["UP_DOWN_ARROW"] = "upDownArrow";
      SHAPE_TYPE["UP_DOWN_ARROW_CALLOUT"] = "upDownArrowCallout";
      SHAPE_TYPE["UP_RIBBON"] = "ribbon2";
      SHAPE_TYPE["U_TURN_ARROW"] = "uturnArrow";
      SHAPE_TYPE["VERTICAL_SCROLL"] = "verticalScroll";
      SHAPE_TYPE["WAVE"] = "wave";
  })(SHAPE_TYPE || (SHAPE_TYPE = {}));
  var CHART_TYPE;
  (function (CHART_TYPE) {
      CHART_TYPE["AREA"] = "area";
      CHART_TYPE["BAR"] = "bar";
      CHART_TYPE["BAR3D"] = "bar3D";
      CHART_TYPE["BUBBLE"] = "bubble";
      CHART_TYPE["BUBBLE3D"] = "bubble3D";
      CHART_TYPE["DOUGHNUT"] = "doughnut";
      CHART_TYPE["LINE"] = "line";
      CHART_TYPE["PIE"] = "pie";
      CHART_TYPE["RADAR"] = "radar";
      CHART_TYPE["SCATTER"] = "scatter";
  })(CHART_TYPE || (CHART_TYPE = {}));
  var SCHEME_COLOR_NAMES;
  (function (SCHEME_COLOR_NAMES) {
      SCHEME_COLOR_NAMES["TEXT1"] = "tx1";
      SCHEME_COLOR_NAMES["TEXT2"] = "tx2";
      SCHEME_COLOR_NAMES["BACKGROUND1"] = "bg1";
      SCHEME_COLOR_NAMES["BACKGROUND2"] = "bg2";
      SCHEME_COLOR_NAMES["ACCENT1"] = "accent1";
      SCHEME_COLOR_NAMES["ACCENT2"] = "accent2";
      SCHEME_COLOR_NAMES["ACCENT3"] = "accent3";
      SCHEME_COLOR_NAMES["ACCENT4"] = "accent4";
      SCHEME_COLOR_NAMES["ACCENT5"] = "accent5";
      SCHEME_COLOR_NAMES["ACCENT6"] = "accent6";
  })(SCHEME_COLOR_NAMES || (SCHEME_COLOR_NAMES = {}));
  var MASTER_OBJECTS;
  (function (MASTER_OBJECTS) {
      MASTER_OBJECTS["chart"] = "chart";
      MASTER_OBJECTS["image"] = "image";
      MASTER_OBJECTS["line"] = "line";
      MASTER_OBJECTS["rect"] = "rect";
      MASTER_OBJECTS["text"] = "text";
      MASTER_OBJECTS["placeholder"] = "placeholder";
  })(MASTER_OBJECTS || (MASTER_OBJECTS = {}));
  var SLIDE_OBJECT_TYPES;
  (function (SLIDE_OBJECT_TYPES) {
      SLIDE_OBJECT_TYPES["chart"] = "chart";
      SLIDE_OBJECT_TYPES["hyperlink"] = "hyperlink";
      SLIDE_OBJECT_TYPES["image"] = "image";
      SLIDE_OBJECT_TYPES["media"] = "media";
      SLIDE_OBJECT_TYPES["online"] = "online";
      SLIDE_OBJECT_TYPES["placeholder"] = "placeholder";
      SLIDE_OBJECT_TYPES["table"] = "table";
      SLIDE_OBJECT_TYPES["tablecell"] = "tablecell";
      SLIDE_OBJECT_TYPES["text"] = "text";
      SLIDE_OBJECT_TYPES["notes"] = "notes";
  })(SLIDE_OBJECT_TYPES || (SLIDE_OBJECT_TYPES = {}));
  var PLACEHOLDER_TYPES;
  (function (PLACEHOLDER_TYPES) {
      PLACEHOLDER_TYPES["title"] = "title";
      PLACEHOLDER_TYPES["body"] = "body";
      PLACEHOLDER_TYPES["image"] = "pic";
      PLACEHOLDER_TYPES["chart"] = "chart";
      PLACEHOLDER_TYPES["table"] = "tbl";
      PLACEHOLDER_TYPES["media"] = "media";
  })(PLACEHOLDER_TYPES || (PLACEHOLDER_TYPES = {}));
  /**
   * NOTE: 20170304: BULLET_TYPES: Only default is used so far. I'd like to combine the two pieces of code that use these before implementing these as options
   * Since we close <p> within the text object bullets, its slightly more difficult than combining into a func and calling to get the paraProp
   * and i'm not sure if anyone will even use these... so, skipping for now.
   */
  var BULLET_TYPES;
  (function (BULLET_TYPES) {
      BULLET_TYPES["DEFAULT"] = "&#x2022;";
      BULLET_TYPES["CHECK"] = "&#x2713;";
      BULLET_TYPES["STAR"] = "&#x2605;";
      BULLET_TYPES["TRIANGLE"] = "&#x25B6;";
  })(BULLET_TYPES || (BULLET_TYPES = {}));
  // IMAGES (base64)
  var IMG_BROKEN = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAB3CAYAAAD1oOVhAAAGAUlEQVR4Xu2dT0xcRRzHf7tAYSsc0EBSIq2xEg8mtTGebVzEqOVIolz0siRE4gGTStqKwdpWsXoyGhMuyAVJOHBgqyvLNgonDkabeCBYW/8kTUr0wsJC+Wfm0bfuvn37Znbem9mR9303mJnf/Pb7ed95M7PDI5JIJPYJV5EC7e3t1N/fT62trdqViQCIu+bVgpIHEo/Hqbe3V/sdYVKHyWSSZmZm8ilVA0oeyNjYmEnaVC2Xvr6+qg5fAOJAz4DU1dURGzFSqZRVqtMpAFIGyMjICC0vL9PExIRWKADiAYTNshYWFrRCARAOEFZcCKWtrY0GBgaUTYkBRACIE4rKZwqACALR5RQAqQCIDqcASIVAVDsFQCSAqHQKgEgCUeUUAPEBRIVTAMQnEBvK5OQkbW9vk991CoAEAMQJxc86BUACAhKUUwAkQCBBOAVAAgbi1ykAogCIH6cAiCIgsk4BEIVAZJwCIIqBVLqiBxANQFgXS0tLND4+zl08AogmIG5OSSQS1gGKwgtANAIRcQqAaAbCe6YASBWA2E6xDyeyDUl7+AKQMkDYYevm5mZHabA/Li4uUiaTsYLau8QA4gLE/hU7wajyYtv1hReDAiAOxQcHBymbzark4BkbQKom/X8dp9Npmpqasn4BIAYAYSnYp+4BBEAMUcCwNOCQsAKZnp62NtQOw8WmwT09PUo+ijaHsOMx7GppaaH6+nolH0Z10K2tLVpdXbW6UfV3mNqBdHd3U1NTk2rtlMRfW1uj2dlZAFGirkRQAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAFGprkRsAJEQTWUTAGHqrm8caPzQ0WC1logbeiC7X3xJm0PvUmRzh45cuki1588FAmVn9BO6P3yF9utrqGH0MtW82S8UN9RA9v/4k7InjhcJFTs/TLVXLwmJV67S7vD7tHF5pKi46fYdosdOcOOGG8j1OcqefbFEJD9Q3GCwDhqT31HklS4A8VRgfYM2Op6k3bt/BQJl58J7lPvwg5JYNccepaMry0LPqFA7hCm39+NNyp2J0172b19QysGINj5CsRtpij57musOViH0QPJQXn6J9u7dlYJSFkbrMYolrwvDAJAC+WWdEpQz7FTgECeUCpzi6YxvvqXoM6eEhqnCSgDikEzUKUE7Aw7xuHctKB5OYU3dZlNR9syQdAaAcAYTC0pXF+39c09o2Ik+3EqxVKqiB7hbYAxZkk4pbBaEM+AQofv+wTrFwylBOQNABIGwavdfe4O2pg5elO+86l99nY58/VUF0byrYsjiSFluNlXYrOHcBar7+EogUADEQ0YRGHbzoKAASBkg2+9cpM1rV0tK2QOcXW7bLEFAARAXIF4w2DrDWoeUWaf4hQIgDiA8GPZ2iNfi0Q8UACkAIgrDbrJ385eDxaPLLrEsFAB5oG6lMPJQPLZZZKAACBGVhcG2Q+bmuLu2nk55e4jqPv1IeEoceiBeX7s2zCa5MAqdstl91vfXwaEGsv/rb5TtOFk6tWXOuJGh6KmnhO9sayrMninPx103JBtXblHkice58cINZP4Hyr5wpkgkdiChEmc4FWazLzenNKa/p0jncwDiqcD6BuWePk07t1asatZGoYQzSqA4nFJ7soNiP/+EUyfc25GI2GG53dHPrKo1g/1Cw4pIXLrzO+1c+/wg7tBbFDle/EbQcjFCPWQJCau5EoBoFpzXHYDwFNJcDiCaBed1ByA8hTSXA4hmwXndAQhPIc3lAKJZcF53AMJTSHM5gGgWnNcdgPAU0lwOIJoF53UHIDyFNJcfSiCdnZ0Ui8U0SxlMd7lcjubn561gh+Y1scFIU/0o/3sgeLO12E2k7UXKYumgFoAYdg8ACIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6cAhAGKYAoalA4cAiGEKGJYOHAIghilgWDpwCIAYpoBh6ZQ4JB6PKzviYthnNy4d9h+1M5mMlVckkUjsG5dhiBMCEMPg/wuOfrZZ/RSywQAAAABJRU5ErkJggg==';
  var IMG_PLAYBTN = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVnCAYAAACzfHDVAAAAYHpUWHRSYXcgcHJvZmlsZSB0eXBlIGV4aWYAAHjaVcjJDYAwDEXBu6ughBfH+YnLQSwSHVA+Yrkwx7HtPHabHuEWrQ+lBBAZ6TMweBWoCwUH8quZH6VWFXVT696zxp12ARkVFEqn8wB8AAAACXBIWXMAAC4jAAAuIwF4pT92AADZLklEQVR42uzdd5hV9Z0/8M+dmcsUZmDovYOhKCiKYhR7JJuoSTCWGFI0WUxijBoTTXazVlyza4maYm9rTRSJigVsqCDNQhHBAogKCEgRMjMMU+7vj93sL8kqClLmnPt6PY+PeXZM9vP9vO8jZ+Y955xMfJLjorBrRMuSgmiViyjN1Ee2oSCyucbIBAAAAAAAAADbXaYgcoWNUZcrirpMbdRsysa69wbF+rggGrf439vSF7seF12aFUTnxvoosGIAAAAAAACAXacgoqEgF++/VRgr4r5o+Kh/pvD//F8uiII+LaPrum/EXzqui2b1ddHGKgEAAAAAAAB2rVxEQWMmWrQtjHZlA6N2w2tR84//zP8pgHu3ib6NBdG+zdqorK6KVUXZaB85j3sGAAAAAAAAaAoaG6OwIBdtyneP2PBabPzbr/1dAdx3VHRtyESHiIhcYzQrLo7WmVzkcjmPgAYAAAAAAABoSgpy0eIfS+D/LYD7fy3abC6Inn/7X2hsjELlLwAAAAAAAEDT9D8lcM1fHwddFBFxyAVR9M686PVp/gfqayKiJiLqLBMAAAAAAABgh8hGRGlEUekn/6PFEb3ikNgQk6O+KCJi6dzoksv83/cB/1X9xoiaJdmoWxlRV1dk2QAAAAAAAAA7QTZbH9muERX96v7n9t7/q6Exinq3i86LI94pjOOisHUu+uYykfmof7h+Y8Sa6aVRt74gGhs9DRoAAAAAAABgZ2lsLIi69QWxeUUmSjs0/vedwR8hk4uydSfE+wVd6qOyMfMx7/mtj9jwUtbjngEAAAAAAAB2obrqolg7IxtR/9Ffb4wo7P5GtCwobRaVH/c/UvNmNuqqPfIZAAAAAAAAYFerqy6KmjezH/v1ktpoVZBr/PgCeMN7yl8AAAAAAACApmJLHW5jUVQWNDSP+Q3ZeLco4i9/+8X6teHRzwAAAAAAAABNSd3/dLn/oLAoqqIuVhXFxhhSGB/xqGjlLwAAAAAAAECTU1eTjaK/KXSLIv7SWB+bc5ko9YxnAAAAAAAAgATJFv393bz1EeV//c8F1gMAAAAAAACQDgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKSEAhgAAAAAAAAgJRTAAAAAAAAAACmhAAYAAAAAAABICQUwAAAAAAAAQEoogAEAAAAAAABSQgEMAAAAAAAAkBIKYAAAAAAAAICUUAADAAAAAAAApIQCGAAAAAAAACAlFMAAAAAAAAAAKaEABgAAAAAAAEgJBTAAAAAAAABASiiAAQAAAAAAAFJCAQwAAAAAAACQEgpgAAAAAAAAgJRQAAMAAAAAAACkhAIYAAAAAAAAICUUwAAAAAAAAAApoQAGAAAAAAAASAkFMAAAAAAAAEBKKIABAAAAAAAAUkIBDAAAAAAAAJASCmAAAAAAAACAlFAAAwAAAAAAAKREkRUAAACwrUpLSwuGDRvWfMCAAS26du3avKysrLiioqKkZcuWzZs1a1bcvHnz0tLS0rJsNtusuLi4ebNmzUoLCgo+8/eijY2N9Zs3b66pra2tqqur21xTU1NdVVVVs2nTptqNGzdWbdiwoeYvf/nL5hUrVlQtWLBgw6xZs6pqamoaJQYAAEDaKYABAACIiIghQ4aUHnTQQW379u3bql27dq3at2/fpkWLFq2bN29eWVpa2qpZs2bNCwsLm2ez2fLCwsLyoqKi8sLCwtKknK+hoaG6vr6+qqGh4S91dXV/aWhoqNq8eXNVTU3NuqqqqvUbNmxYu2rVqjWrV69e99Zbb6177rnnPpgzZ06NTwYAAABJogAGAADIA8OGDWt+xBFHdBwwYECnLl26dGjdunXHFi1adCgtLe1YUlLSvlmzZq0KCgqK07yDwsLCssLCwrKIaPdp/zuNjY21mzdvXrdp06ZVNTU172/YsGHl2rVr31+2bNnKBQsWrHjyySffnzVrVpVPGAAAAE1Fpuexsd9HfaF+ZcSal0ptCAAAIAE6deqUPf744zvtueeeXbp3796lbdu2XSorKzuXlpZ2KS0t7VBYWFhhSztGQ0PDxpqampU1NTXL169fv+yDDz5Y9s477yybPXv2sj/96U8rVqxYUWdLAAAAbE9t9q6Jog4f/TUFMAAAQEJks9nMt7/97Y4jRozo1bdv397t2rXrXl5e3rWsrKxzcXFx+4gosKUmp7G2tnZVTU3Nso0bNy5btWrV0tdff/2tJ598cvG999672noAAADYFgpgAACAhPne977X6a9Fb/v27Xu1bNmyV1lZWa8kvXOXLauvr9/wl7/8ZdG6desWL1u2bNHChQsX/fGPf1w8derUjbYDAADAliiAAQAAmqhsNps59dRTuxx66KH9+/Tp87n27dv3Ly8v719UVOSRzXlq06ZNKzZu3Pj6+++//8abb775xqOPPvrG3XffvcpmAAAA+CsFMAAAQBNx6qmndvniF784qHfv3v3btWv3uYqKis8VFhaW2wxbUl9fv37Dhg1vfPDBB68vXrz4jccee2z+jTfeuNxmAAAA8pMCGAAAYBc45phjWn/rW9/aq3///kPatGnTv6Kiop9HOLO9NDQ0VG/cuPGtNWvWLFy4cOGcO+6445WHHnporc0AAACknwIYAABgJzjjjDO6f+lLX9qrV69eg1u3bj2orKysR0RkbIadJFddXb103bp18xcvXjz30UcffeXqq69+x1oAAADSRwEMAACwnZWWlhb86le/2u3QQw8d1r17931btmw5qLCwsMxmaEoaGhqqP/zww/nvvPPOzGeeeWbW2LFj36ipqWm0GQAAgGRTAAMAAGwHP/7xj7t+9atf3bdXr15D27Ztu1c2m21jKyRJXV3dmg8++OCVRYsWvfznP/95xh/+8IdltgIAAJA8CmAAAIBtcOKJJ7Y75ZRTDujXr9+w1q1bD81ms61shTSpq6tbt3bt2pfffPPNWbfccsvUe++9d7WtAAAANH0KYAAAgE+hoqKi4IILLhg0YsSI/bp27bpfy5YtB2YymUKbIR/kcrmGDz/8cP6777474/nnn59x4YUXvrZx40aPiwYAAGiCFMAAAAAf4/jjj2/7/e9//8D+/fsf2Lp1630KCgpKbAUiGhsbN61fv37eW2+9NeWGG2545u67715lKwAAAE2DAhgAAOB/ZLPZzAUXXPC5I4888sDu3bsfWFFRsVtEFNgMbFl1dfWSd999d8qsWbNmnnvuuS+vW7euwVYAAAB2DQUwAACQ10pLSwsuvfTSQYcccsjBXbt2HVFWVtbDVmDb1dbWrnr//fdfmDp16uRf/vKXL65evbreVgAAAHYeBTAAAJB3Bg0aVHrBBRd8fs899zywQ4cOBxQVFbWwFdj+Ghsba9euXTtrzpw5T59//vmTX3755WpbAQAA2LEUwAAAQF4YNmxY8/POO+/gIUOGHOZ9vrDz/W0ZfNFFFz07a9asKlsBAADY/hTAAABAarVq1arwyiuv3HfEiBEjO3TocFBhYWGZrcCu19DQUP3+++8/O2XKlIk/+clPZm7cuLHRVgAAALYPBTAAAJAqrVq1Kvztb3+7/3777Xd4x44dRxQWFpbbCjRdDQ0NG99///0pM2bMeOqHP/zhC8pgAACAz0YBDAAApMJZZ53V45vf/OaRvXr1GllaWtrVRiB5ampq3l28ePHEO++8c9LVV1/9jo0AAABsPQUwAACQWMOHDy+/6KKLvjB48OCjW7RoMdBGID0+/PDDV+fNmzfhvPPOe3L69Ol/sREAAIBPRwEMAAAkSqtWrQpvuOGGQ/bbb79/atOmzX6ZTCZrK5BeuVyubs2aNTNmzJjx2JgxYyavW7euwVYAAAA+ngIYAABIhB//+Mddv/e9732lZ8+e/1RcXNzWRiD/1NbWfvD2228/dssttzz029/+9l0bAQAA+L8UwAAAQJNVUVFRcO21137+4IMPPrZ169b7ZTKZAlsBIqJxzZo1M59//vnxp5122hR3BQMAAPx/CmAAAKDJOeWUUzqefvrpx/bu3ftL2Wy2jY0AH6e+vn7j0qVLH/vd7373x+uvv36ZjQAAAPlOAQwAADQJ2Ww2c+uttx5wyCGHnNC6deu9I8LdvsDWaFy7du1L06ZN+/OPfvSjZ1evXl1vJQAAQD5SAAMAALtU//79S6655pp/2nPPPY8tLy/vayPAZ1VTU7NswYIF488999wHp06dutFGAACAfKIABgAAdomf//znPU855ZQTu3btemRhYWGZjQDbW2NjY92KFSuevOWWW+689NJLF9kIAACQDxTAAADATuMxz8Cusn79+rlPP/30f5188slT6+rqcjYCAACklQIYAADY4fr27Vv8hz/84a+Pee5nI8CuUlNT8+68efPu/8EPfvDgwoULN9kIAACQNgpgAABghxkyZEjpNddc89XBgwefWFxc3MFGgKaitrZ21dy5c+/5yU9+8uc5c+bU2AgAAJAWWyqAPYoNAADYJqNHj+4wb968n06ZMuXRYcOGnaH8BZqa4uLi9sOGDTtjypQpj86bN++nJ510UntbAQAA0s4dwAAAwFY599xze33/+9//dufOnY/IZDJZGwGSIpfL1S1fvvzJG2644fbLLrvsbRsBAACSyiOgAQCAz+y8887r+53vfOfbHTt2PDyTyRTaCJBUuVyuYcWKFU/cdNNN//XrX/96sY0AAABJowAGAAC22WWXXTboG9/4xg9at249zDaAtFm7du2su++++9pzzjnnNdsAAACSQgEMAABsNcUvkE8UwQAAQJIogAEAgE9N8Qvks7Vr18665557rvv5z38+3zYAAICmaksFcGHlwOj6UV9orIqoWZG1PQAAyBO/+MUvet9xxx3nHHrooT8pLS3tYiNAPiotLe2y7777HvP973+/X1lZ2ZIpU6assxUAAKCpKetcHwXlH/01BTAAAOS5M844o/u99957zpe//OWflZeX94qIjK0AeS5TXl7e8+CDDx71/e9/v3dEvDVjxowPrQUAAGgqFMAAAMD/ceKJJ7a77777fjJq1Kh/KS8v7xOKX4B/lCkvL+99+OGHj/rWt77VfvXq1Qvnz59fbS0AAMCutqUC2DuAAQAgzwwdOrTs+uuvP6l///4nFRYWltkI20NjY2Ns2rQpqquro6amJurr62PTpk2xefPmqK+vj+rq6qivr4/NmzfHpk2boqGhYZv/fxUWFkZJSUk0a9YsioqKoqysLIqKiqJZs2ZRUlISRUVFUVpa+r9/FRQUCIjtoqGhoeq11167a8yYMffMmTOnxkYAAIBdZUvvAFYAAwBAnujUqVP2nnvuGbXXXnudnM1mK22Ej9PQ0BAbN26MDRs2/J+/Nm7cGBs3boyamprYtGlTbNq0KWpqaqK2trbJnqe4uDhKSkqitLT0f/9eUVERFRUV0aJFi//zV0VFRRQWFvog8LHq6urWvvjii7eceOKJf169enW9jQAAADubAhgAAPLcXXfdddAXv/jF00tLS7vZRn7L5XKxYcOGWLt2baxbty7Wrl37d3+tW7cuNmzYkPd7atGiRbRu3TpatWoVrVu3jjZt2vzvf27dunW0aNHCh4morq5e+sgjj1zzne98Z6ptAAAAO5MCGAAA8tTVV189+MQTTzyzoqJioG3kj8bGxli5cmUsX748Pvjgg1i9evX//n3t2rXR2NhoSZ9RYWFhtGrVKtq1axdt27b937937tw5OnTo4LHTeWbDhg3z77333qvOPPPMebYBAADsDApgAADIM1/72tfaXHrppad27979qIjQRKVUQ0NDrFq1KlasWBHvv//+//595cqVTfqRzGlXXFwcHTp0iI4dO0bnzp2jY8eO0alTp2jXrp1HS6dYLpdrfOeddx76+c9/fv2ECRPW2QgAALAjKYABACBP9OrVq9ldd931jT322OM7hYWFZTaSHh9++GG88847sXTp0njvvfdixYoVsXr16mhoaLCchCgsLIz27dtHp06dolu3btG9e/fo3r27x0mnTENDQ9W8efNu++Y3v/nHJUuWbLYRAABgR1AAAwBAHrjrrrtG/NM//dOZJSUlXWwj2davXx9Lly6Nd955539L3w8//NBiUqqysvJ/y+C//tWqVSuLSbiamppljz322G9Gjx49xTYAAIDtTQEMAAAp9qtf/arPD3/4w5+1atVqL9tIno0bN8aSJUvirbfeikWLFsV7770XmzZtspg8V1JSEl27do0+ffpE3759o3fv3lFeXm4xCbRu3bqXr7322ivGjh27yDYAAIDtRQEMAAApNGjQoNI77rjju7vttttJBQUFWRtJhtWrV8ebb74ZixcvjiVLlsTy5cujsbHRYtiigoKC6Ny5c/Tu3Tt69+4d/fr1i7Zt21pMQjQ2Nta98cYbd33rW9+6ff78+TU2AgAAfFYKYAAASJHS0tKCBx988Jj99tvvn7PZbBsbaboaGhri7bffjrfeeisWLFgQS5YscXcv201FRUX06tUr+vbtG3379o2ePXtGYWGhxTRhdXV1a2bMmHHjV77ylYdqamr85gcAALDNFMAAAJASp59+erdf/vKX51ZWVu5jG03T6tWr47XXXouFCxfGm2++GRs3brQUdooWLVpE3759Y8CAATFw4EB3CDdh69evf/E//uM//vPqq69+xzYAAIBtoQAGAICEGzRoUOm99977w969ex+byWTc4teErF+/PubNmxcLFiyIN954Q+FLk9GiRYvo169fDBgwIPbYY4+orKy0lCYkl8s1LF68eNyJJ554rcdCAwAAW0sBDAAACXbNNdcMOemkk35RVlbWyzZ2vVwuF++++27MnTs3XnvttViyZIl3+NLkFRQURK9evWLQoEExePDg6Natm6U0EdXV1UvuvvvuX//kJz+ZYxsAAMCnpQAGAIAEOuqoo1r99re//VmHDh0Ot41da9OmTTF79uyYO3duLFy4MKqqqiyFRGvevHn0798/Bg8eHHvuuWeUlJRYyi62cuXKp04//fTLJ0yYsM42AACAT6IABgCAhBk3btwRRxxxxFnZbLaNbewaVVVVMXfu3Jg7d27Mnz8/amtrLYVUKi4ujoEDB8bgwYNj8ODBUV5ebim7SF1d3ZqnnnrqqlGjRj1hGwAAwJYogAEAICFOOeWUjhdddNEvW7duvZ9t7HwrV66MWbNmxdy5c+Odd96JXC5nKeSdzp07x9577x3Dhg2LDh06WMgusHbt2hnnnXfepbfccsv7tgEAAHwUBTAAADRxpaWlBU899dQ3Bw8e/L2CggLPYt2JVqxYES+99FK89NJLsXz5cguBv/HXMnjvvfeOTp06WchO1NjYuGnu3Lk3H3744XfV1NR40TgAAPB3FMAAANCEjR49usOll176yzZt2gy3jZ1j/fr18eKLL8bMmTNj6dKlFgKfQs+ePWPfffeNYcOGRYsWLSxkJ1mzZs0L55577q/vvvvuVbYBAAD8lQIYAACaoIqKioKJEyd+c/Dgwd8vKCgotpEda8OGDfHiiy/G9OnTlb7wGfXo0SOGDx8ew4YNi4qKCgvZwdwNDAAA/CMFMAAANDGnnHJKx7Fjx/5rZWXlMNvYcerr6+PVV1+NGTNmxLx586Kurs5SYDvKZrMxZMiQ2HfffWP33XePwsJCS9mB1q5dO+MXv/jFv995550rbQMAAPKbAhgAAJqIbDabeeKJJ47fZ599fuSu3x0jl8vFwoULY/r06TF79uzYtGmTpcBOUFpaGkOGDInhw4fHgAEDLGQHaWhoqJ42bdo1Rx555J9tAwAA8pcCGAAAmoDjjz++7ZVXXvmr1q1be9fvDrBmzZqYNm1azJw5M1audHMc7EodO3aMz3/+87H//vt7X/CO+3fetDPPPPOScePGfWAbAACQfxTAAACwi9100037HXvssf9WXFzc1ja2n1wuF6+99lo8//zzMW/evKivr7cUaEKKiopizz33jBEjRsTnPve5yGQylrId1dbWrvrjH/948Q9+8INZtgEAAPlFAQwAALvIkCFDSu+///5zunTp8k+2sf2sXbs2Jk+eHNOnT48PP/zQQiABKisrY8SIEXHIIYdEeXm5hWxHy5Yte+zrX//6f86ZM6fGNgAAID9sqQAurBwYXT/qC41VETUrsrYHAADb6IILLtjt97///VVt2rQZZhvbx+LFi2P8+PFx9913xxtvvBG1tbWWAgmxadOmeOONN+LZZ5+NtWvXRps2bTweejtp0aJFv5NOOumg0tLSuc8+++xaGwEAgPQr61wfBR/zu7XuAAYAgO0sm81mJk2a9PVhw4b9pKCgwG9VfkZ1dXUxY8aMeOaZZ+K9996zEEiRfv36xSGHHBJDhw6NgoICC/mMGhsbN8+YMeOaL37xi+Pq6upyNgIAAOnlEdAAALCTHH/88W2vuuqqCyorK/exjc9mzZo18dRTT8XUqVNj06ZNFgIpVlFREZ///OfjsMMOi8rKSgv5jNavXz/r9NNPv3DcuHEf2AYAAKSTAhgAAHaC22677fNf+9rXzstms5W2se0WLVoUjz/+eMybNy9yOTewQT4pKiqKIUOGxBFHHBG9e/e2kM+grq5u3QMPPHDRySefPM02AAAgfRTAAACwA1VUVBQ8/fTTpwwcOPCUTCbjGabbIJfLxauvvhpPPvlkLFy40EIgz2UymRgwYEAcccQRMWjQIAvZ9n+3Ns6fP/+Www8//JaNGzc22ggAAKTHlgrgwsqB0fWjvtBYFVGzwuvKAABgS0488cR2EyZMuLx79+5fzmQyGRvZOo2NjTFr1qy49dZb48knn4wPPvC0UuC/rV69OmbMmBFz5syJ0tLS6NSpU/jX7NbJZDKZ9u3bD/3+978/dPny5TNfffXValsBAIB0KOtcHwXlH/O9gDuAAQBg29x66637H3vssRcWFRW1sI2tU1NTE0899VQ8++yzsWHDBgsBPlGLFi3i4IMPjsMPPzxKS/28YmvV19d/OG7cuPNPPvnk6bYBAADJ5xHQAACwHWWz2cyzzz77rSFDhvzAI5+3zqZNm2Ly5Mnx1FNPKX6BbdKiRYs47LDD4pBDDlEEb6VcLtfwyiuvXHfooYfeWVdX5yXrAACQYApgAADYTo455pjW11133cWVlZV728ant2HDhnj88cdjypQpUVtbayHAZ1ZcXBwHHnhgfPGLX4wWLTyIYWusWbNm2re//e3zn3nmGb+JAwAACeUdwAAAsB1cfvnlu1900UW/LS8v72cbn05VVVVMmDAhbrnllnjzzTejoaHBUoDtoqGhIZYsWRLPPfdc1NTURI8ePSKb9XOMT6OsrKzb17/+9SPbtm0774knnlhtIwAAkMDreu8ABgCAz+bhhx/+8qGHHnpOQUFBsW18sk2bNsUzzzwTTzzxRFRVVVkIsMOVl5fHkUceGYccckgUF/tX9afR2Ni46emnn/71Mccc87htAABAsngENAAAbKN27doVTZ48+YxevXodZxufrK6uLp5++umYOHGi4hfYJSoqKuKLX/xiHHzwwe4I/pQWLVr0x4MOOuiadevWeUwDAAAkhEdAAwDANjj22GPbPvzww7/p2LHjobaxZXV1dfHkk0/GddddF3Pnzo26ujpLAXaJzZs3x2uvvRbPPfdcRET06NEjCgsLLWYLWrduvfv3vve9fd9+++1pCxYsqLYRAABo+rb0CGgFMAAAfITLL7989wsuuOB3zZs372UbH6+xsTGmTJkS119/fbzyyiuKX6DJ2Lx5cyxYsCCmT58excXF0a1bt8hkMhbzMUpKSjp8+ctfPrJt27ZzvBcYAACaPu8ABgCArTB+/Pgjv/CFL/xLQUFBiW18vAULFsT48eNj6dKllgE0eT169IivfOUrMWjQIMvYgsbGxpqJEydecuyxxz5pGwAA0HR5BzAAAHwK7dq1K3ruued+1qNHj6/axsdbtGhR3H///bF48WLLABKnV69ecdxxx0WfPn0sYwuWLl3654MOOujy1atX19sGAAA0Pd4BDAAAn2DYsGHNn3766V936tTpC7bx0TZs2BD33Xdf/PGPf4y1a9daCJBI69evj2nTpsW6deuiZ8+eUVLiYQ8fpbKysv+3v/3t/lOmTJmyfPlyz/cHAIAmxjuAAQBgC372s5/1uP76669t0aKF54J+hJqamhg/fnzcfPPN8fbbb0cul7MUINFyuVy888478cwzz0RVVVX07t07slk/A/lHZWVl3U488cTD6+rqZkyfPv1DGwEAgCZ0va4ABgCAj3bFFVfscdZZZ11dXFzcwTb+Xi6XixkzZsR1110XCxYsiMbGRksBUqWxsTGWLFkSM2bMiPLy8ujSpUtkMhmL+RvZbLbFQQcddHibNm1mP/HEE6ttBAAAmoYtFcDeAQwAQN6aNGnSqAMOOODsTCZTaBt/b9GiRXHPPffEu+++axlA3ujWrVucdNJJ0bt3b8v4B7lcrm7y5Mm//vKXv/yIbQAAwK63pXcAK4ABAMg7paWlBTNnzjyzT58+x9vG39uwYUOMGzcuZsyY4VHPQF7KZDKx3377xde//vWoqKiwkH+waNGiP+27775X1dTUeCwEAADsQgpgAAD4H926dctOnjz5V506dRppG/9fLpeLqVOnxp///OfYuHGjhQB5r6KiIkaNGhX777+/x0L/g+XLlz9+6KGHXvLuu+/W2QYAAOwaWyqAvQMYAIC8MXz48PInnnjiynbt2o2wjf/vnXfeiWuvvTaee+652Lx5s4UARMTmzZtjzpw58dprr0XPnj2jRYsWlvI/Kioq+n7rW98aMnXq1Ofee+89f3AAAMAusKV3ACuAAQDIC9/+9rc73n777X9o0aLFANv4b1VVVXHXXXfFvffeG+vXr7cQgI+wbt26eP7552P9+vWx2267RVFRkaVERElJSefjjjvuoA8++GDKK6+88hcbAQCAnUsBDABAXjv//PP7XXzxxX8oKSnpbBv/bfr06XHttdfGokWLLAPgU3jnnXdi2rRp0bp16+jc2R8nERHZbLbyC1/4whElJSUvTp48eY2NAADAzqMABgAgb/3ud7/b60c/+tFVRUVFrWwjYs2aNXHzzTfHpEmTora21kIAtkJtbW289NJL8c4770Tfvn2jtLQ073dSWFhYNnz48C/26dNn4UMPPbTMpwQAAHYOBTAAAHnp1ltv3f+b3/zmfxYWFjbP913kcrl4/vnn4/rrr4/ly5f7cAB8BitXroxp06ZFRUVFdOvWLTKZTF7vo6CgIDto0KBDBw0atOiBBx54xycEAAB2vC0VwJmex8Z+H/WF+pURa17ym6wAACTTww8//KXDDjvsXzKZTN6/rPGDDz6I22+/Pd544w0fDIDtbMCAAfGtb30r2rRpk/e7yOVyjVOmTPn1yJEjH/LJAACAHavN3jVR1OGjv6YABgAgdV555ZXTPve5z30r3/fQ0NAQjz32WDz++ONRV1fngwGwg2Sz2Tj66KPjC1/4QhQUFOT9Pl5//fU79tprr9/7ZAAAwI6jAAYAIC9ks9nMyy+/fFafPn2Oz/ddvPvuu3HbbbfFe++954MBsJN069YtvvOd70S3bt3yfhdLliy5f5999rmypqam0ScDAAC2PwUwAACpV1paWjBr1qyzevfufVw+7yGXy8WTTz4ZDz74oLt+AXaBbDYbxxxzTBxxxBF5fzfw0qVLHxg6dOjlSmAAANj+FMAAAKRar169mk2ePHlsu3btDsrnPaxcuTJuueWWePvtt30oAHaxnj17ximnnBIdOnTI6z2sXr16yiGHHPIvS5Ys2exTAQAA28+WCuDCyoHR9aO+0FgVUbMia3sAADRpQ4cOLXvqqacub9Omzf75uoNcLhfPPPNMXH/99bF27VofCoAmYP369TFlypQoKSmJnj17RiaTycs9NG/evPtJJ500ZPLkyc+sWLHCoykAAGA7KetcHwXlH/01BTAAAIk1ZMiQ0kceeeSKVq1a7Z2vO6iuro7bb789nnjiiWhs9IRNgKaksbEx5s+fH++//34MGDAgstn8/DlLaWlpp6997WuDn3rqqadXrlxZ75MBAACfnQIYAIDUOfTQQ1s8+OCDv2/ZsuUe+bqDOXPmxNVXX+2RzwBN3PLly+OFF16Ijh075u0joUtLSzudcMIJ+7/00ktPv/3227U+FQAA8NkogAEASJVhw4Y1v++++37TsmXLQfl4/vr6+hg/fnz88Y9/jNpaP0MHSILNmzfHiy++GJs3b47ddtstCgoK8m4HxcXFbY866qg9n3vuuaeXL1/ucdAAAPAZKIABAEiNI488snLcuHG/b9GixcB8PP97770XV111VcyZM8eHASCBFi1aFC+//HL069cvWrRokXfnLykp6XDcccftP2fOnGcWLVq0yScCAAC2jQIYAIBUOPLIIyvvvPPO35aXl++Wj+d/+umn48Ybb4wPP/zQhwEgwf7yl7/ECy+8ECUlJdGrV6+8O3+zZs3aHHXUUfspgQEAYNspgAEASLxjjz227W233faH5s2b98m3s1dVVcXNN98cTz31VDQ2NvowAKRAY2NjzJ8/P5YtWxYDBgyIZs2a5dX5mzVr1uaYY4458M0333xm4cKFNT4RAACwdRTAAAAk2qGHHtritttuuzofy9+33347rrnmmli8eLEPAkAKvf/++/HKK69Enz59orKyMq/Ons1mK4888sh9Zs6c+dTSpUs3+zQAAMCnpwAGACCxjjjiiJb33nvvteXl5f3y6dy5XC4mTZoUN998c1RVVfkgAKRYVVVVTJ06NbLZbPTp0ycymUzenL24uLjtV7/61c+/8sorTy1evLjWpwEAAD4dBTAAAIl06KGHtrj33nt/l2/lb3V1ddx0000xefLkyOVyPggAeSCXy8WCBQvi3Xffjd133z2y2fz5mUyzZs1aH3300fvNmDHjSXcCAwDAp6MABgAgcYYOHVo2fvz4qysqKgbk07mXLVsWV111lUc+A+SplStXxiuvvBKf+9znoqKiIm/O3axZszZHH3300GeeeebJFStW1PkkAADAlimAAQBIlCFDhpQ++uij17Rs2XL3fDr31KlT49prr42NGzf6EADksaqqqpg+fXq0bds2unTpkjfnLikpaT9q1KihTz755JMrV66s90kAAICPt6UCuMB6AABoSjp16pSdMGHCv1dWVu6RL2dubGyMcePGxR133BF1dW56AiCitrY2br755hg/fnw0NjbmzbkrKyv3mDBhwr9369bNXQkAALCNFMAAADQZrVq1Kpw+ffolbdq02T9fzlxdXR2/+93vYtKkSd73C8DfyeVy8fjjj8fvf//7qK6uzptzt2nTZv8pU6Zc0qpVq0KfAgAA2HoKYAAAmoSKioqC2bNnX9KuXbuD8uXMS5cujYsuuijmz5/vAwDAx3r11VfjoosuiqVLl+bNmdu1a3fQ7Nmz/72iosLPrgAAYCu5iAYAoEmYOXPmz9q1a3dIvpz35ZdfjiuuuCLWrVsnfAA+0bp16+KKK66Il19+OW/O3K5du4Nnzpz5M+kDAMDWUQADALDLvfjii2N69OgxKh/Omsvl4oEHHogbbrghamtrhQ/Ap1ZbWxs33HBDPPDAA3nz2oAePXqMevHFF8dIHwAAPj0FMAAAu9SkSZO+NnDgwFPy4ax1dXVx8803x8SJE73vF4BtksvlYuLEiXHLLbdEXV1dXpx54MCBJ0+aNOlr0gcAgE9HAQwAwC7z6KOPHnXggQeekw9nXbduXfz617+OWbNmCR6Az2zmzJnx61//Ol9eJZA58MADz3n00UePkjwAAHyywsqB0fWjvtBYFVGzImtDAADsEDfeeOO+Rx999EWZTKYw7Wddvnx5XHXVVbFy5UrBA7DdbNiwIWbPnh0DBw6MioqKtB8307179/179uz56sMPP7xc+gAA5LuyzvVRUP7RX1MAAwCw011xxRV7fPe7372qoKCgWdrPOmfOnPjtb38bGzduFDwA2111dXVMmzYtOnfuHB07dkz1WTOZTOHuu+9+eJs2bV6aNGnSKukDAJDPFMAAADQZZ5xxRvef/exnvy0sLCxP+1knTJgQd999d9TX1wsegB2moaEhXnrppchms9G3b99UnzWTyRTttddeB/3lL395dubMmRukDwBAvlIAAwDQJBx00EEVf/jDH64pLi7ulOZz5nK5eOCBB+Kxxx4TOgA77c+eBQsWRF1dXfTv3z8ymUxqz1pQUFBywAEHDJs+ffqkpUuXbpY+AAD5aEsFcIH1AACwMwwaNKj0vvvuu7qsrKxXms9ZV1cX1113XUyaNEnoAOx0EydOjOuvvz7q6upSfc6ysrJef/rTn67u379/idQBAODvKYABANjhKioqCh577LGLKyoqBqb5nNXV1XHNNdfE7NmzhQ7ALvPKK6/ElVdeGVVVVak+Z4sWLQZOnDhxbEVFhZ9vAQDA33CBDADADjdz5syftW3b9sA0n3HdunVx2WWXxRtvvCFwAHa5xYsXx2WXXRZr165N9TnbtWt34MyZM38mcQAA+P8UwAAA7FBPPvnkqB49eoxK8xlXrVoVV1xxRSxfvlzgADQZK1asiCuuuCJWrlyZ6nP26NFj1KRJk0ZJHAAA/lth5cDo+lFfaKyKqFmRtSEAALbZjTfeuO+XvvSlCzOZTGp/8fDdd9+NK6+8MtatWydwAJqc6urqmDVrVvTv3z8qKytTe85u3boN79mz57yHH37Yb2MBAJAXyjrXR0H5R39NAQwAwA5x3nnn9T311FOvLigoKE7rGV977bW45pprorq6WuAANFmbN2+OGTNmRI8ePaJ9+/apPGMmkykYNGjQIYWFhVOee+45v5UFAEDqKYABANipjjrqqFb/8R//8YdmzZq1SusZX3755bj++uujrq5O4AA0eQ0NDfHSSy9Fp06dolOnTqk8Y0FBQXbYsGGfnz9//qQ33nhjk9QBAEizLRXA3gEMAMB21a1bt+wNN9zwnyUlJR3TesYpU6bEjTfeGPX19QIHIDHq6+vjxhtvjKlTp6b2jCUlJZ1uuOGG/+jWrZu7GgAAyFsKYAAAtqunn376XyorK/dI6/kmTZoUd955ZzQ2NgobgMRpbGyMO+64I5588snUnrGysnLw008//UtpAwCQrxTAAABsN88///w3unTp8k9pPd/EiRNj3LhxkcvlhA1AYuVyubj//vtTXQJ36dLlS88+++yJ0gYAIB95BzAAANvFTTfdNPzII488L5PJZNJ4vsceeyzGjx8vaABS47XXXotmzZpF3759U3m+zp0779urV695Dz/88DJpAwCQNlt6B7ACGACAz+wXv/hF7x/+8IdXFxQUNEvj+R544IF45JFHBA1A6ixYsCDq6upiwIABqTtbJpPJDBo06ODGxsbnpk6dul7aAACkiQIYAIAd5oADDqj43e9+99tmzZq1TeP5xo0bF5MmTRI0AKm1aNGi2Lx5cwwcODB1ZysoKMjut99+w5577rnH33vvvc3SBgAgLbZUAHsHMAAA2yybzWbuvPPOfyktLe2exvNNmDBB+QtAXpg0aVI89NBDqTxbaWlpj3vuuedfstlsRtIAAOQDBTAAANvs+eef/06HDh0OTePZHn744Xj44YeFDEDeeOSRR+LPf/5zKs/WoUOHw5599tlvSxkAgHygAAYAYJvcd999hw8ePPjUNJ7t/vvvjwkTJggZgLzz2GOPxX333ZfKs+25554/+NOf/nSYlAEASDvvAAYAYKudccYZ3ceMGXN5QUFBcdrONnHixHjkkUeEDEDeWrx4cWSz2ejbt2/ajpbp06fPvn/5y18mz5w5c4OkAQBIsi29A1gBDADAVhk2bFjzG2+88Q/NmjVrl7azPfroo6l99CUAbI2FCxdGUVFR9OvXL1XnKigoKD7wwAP3e/LJJx9dsWJFnaQBAEiqLRXAHgENAMBWuffee39ZWlraPW3nevzxx+PBBx8UMAD8jz//+c8xceLE1J2rtLS0x3333fdLCQMAkFYKYAAAPrVJkyaN6tSp0xEpPFeMHz9ewADwD8aPHx+TJ09O3bk6der0hUmTJn1VwgAApJFHQAMA8Kmcd955fU888cR/z2QyRWk618yZM+Puu+8WMAB8jNdeey06duwYnTt3TtW5unbtuk9BQcHzzz333DopAwCQNN4BDADAZ3LEEUe0vOKKK67NZrOVaTrXyy+/HDfffHPkcjkhA8DHyOVyMXv27OjSpUt06tQpNefKZDJF++yzz/CpU6c+9u67726WNAAASeIdwAAAbLNsNpu55ZZb/q2kpKRjms61YMGCuPnmm6OxsVHIAPAJGhsb4+abb44333wzVecqLS3tcvfdd5+fzWYzUgYAIC0UwAAAbNGkSZO+3rZt2wPTdKZly5bFDTfcEPX19QIGgE+prq4urr322li+fHmqztWuXbsDH3/88VESBgAgLTwCGgCAj3XZZZcN+upXvzo2k8mk5hcH33///bjyyiujqqpKwACwlerq6uLll1+OIUOGRHl5eWrO1aVLl31LS0unPvPMM2ukDABAEngENAAAW61///4lJ5988q8ymUxRWs60YcOG+P3vfx8bN24UMABso40bN8bvfve7VP15WlBQkP3hD394ft++fYslDABA4q9vrQAAgI/y4IMPnl1WVtYrLeeprq6O3/zmN7Fq1SrhAsBntGrVqrjyyiujuro6NWcqKyvr8/DDD58lXQAAkk4BDADA/zF+/Pgju3XrdnRazlNfX5/KdxYCwK60fPnyuO6666K+vj41Z+rRo8dXx40bd4R0AQBIMgUwAAB/53vf+16nI4444py0nCeXy8Vtt90Wb7zxhnABYDt7/fXX47bbbotcLpeaMx155JHnfvvb3+4oXQAAkkoBDADA/6qoqCi4+OKLLywsLCxPy5nGjx8fs2bNEi4A7CCzZs2Khx56KDXnKSwsrPj1r399QUVFhZ+bAQCQSC5kAQD4XxMnThxdWVk5OC3nef7552PixImCBYAd7LHHHosXXnghNeeprKzc89FHHz1RsgAAJFFh5cDo+lFfaKyKqFmRtSEAgDxxwQUX7DZq1KgLM5lMYRrO8+qrr8Ytt9ySqkdSAkBT/7O3d+/e0a5du1Scp2PHjkNzudxzU6ZMWSddAACamrLO9VHwMc/wcwcwAADRt2/f4h//+McXZzKZVPwG4HvvvRc33HBDNDY2ChcAdpKGhoa47rrrYtmyZak4T0FBQfbss88e27dv32LpAgCQqGtZKwAAYPz48T8qKyvrkYazbNiwIX7/+99HbW2tYAFgJ9u0aVP8/ve/j40bN6biPGVlZb3GjRs3RrIAACSJAhgAIM/ddNNNw/v06XN8Gs5SX18f1157baxdu1awALCLrFmzJq699tqor69PxXn69ev3jd///vdDJQsAQFIogAEA8thBBx1Uceyxx/5rRGTScJ477rgjFi9eLFgA2MUWLVoUd955Z1qOU/CNb3zj34YNG9ZcsgAAJOIC1goAAPLXzTfffFZxcXG7NJxl4sSJMX36dKECQBMxbdq0mDRpUirOUlJS0unOO+88Q6oAACSBAhgAIE/913/914FdunT5UhrO8tprr8Wf//xnoQJAEzN+/PhYsGBBKs7SrVu3o2+66abhUgUAoKlTAAMA5KEvfelLlV/5yld+lYazrFixIq6//vpobGwULAA0MY2NjXHdddfFihUr0nCczHHHHfergw46qEKyAAA0ZQpgAIA8dPXVV5+ezWYrk36OmpqauPbaa2PTpk1CBYAmatOmTXHttddGTU1N4s+SzWbb3njjjT+RKgAATZkCGAAgz9x6663Du3Tp8uWknyOXy8Utt9wSK1euFCoANHErV66MW2+9NXK5XOLP4lHQAAA0dQpgAIA8MnTo0LKvfvWrv0jDWSZMmBBz584VKgAkxJw5c+Kxxx5LxVlGjRr1i6FDh5ZJFQCApkgBDACQR+64444fFRcXd0z6OV5++eV45JFHBAoACfPQQw+l4he4SkpKOt5xxx0/lCgAAE2RAhgAIE9cfvnlu/fs2XNU0s/xwQcfxB133JGKR0gCQL7J5XJx2223xZo1axJ/lp49ex57+eWX7y5VAACaGgUwAEAe6NatW/a73/3uv2YymURf/9XX18cNN9wQ1dXVQgWAhKqqqoobb7wx6uvrE32OTCZT8N3vfvdX3bp1y0oVAICmRAEMAJAHxo8ff0pZWVmvpJ/jnnvuiaVLlwoUABJuyZIlcd999yX+HGVlZT3Hjx9/ikQBAGhKFMAAACn385//vOeAAQNGJ/0c06dPjylTpggUAFJi8uTJMWPGjMSfY8CAAaN//vOf95QoAABNhQIYACDFstls5qyzzjo3k8kk+tGEK1asiLvvvlugAJAyd911V6xYsSLRZ8hkMtmzzjrr3Gw2m5EoAABNgQIYACDFxo0b98XKysq9knyG2trauOGGG6K2tlagAJAyf/1zfvPmzYk+R2Vl5V7jxo0bKVEAAJoCBTAAQEoNHz68/OCDDz4t6ee4//77Y/ny5QIFgJRavnx5jBs3LvHnGDFixI+HDRvWXKIAAOxqCmAAgJS69dZbT8tms22TfIYZM2bEc889J0wASLnJkyfHzJkzE32G4uLitrfffvtp0gQAYFdTAAMApNBVV121R48ePb6S5DOsXLky7rrrLmECQJ64++6744MPPkj0GXr27PnVK664Yg9pAgCwKymAAQBSprS0tOAb3/jGT5N8rdfY2Bi333679/4CQB6pqamJ2267LRobG5N8jIJvfvObZ5aWlvqZGwAAu+6i1AoAANJlwoQJX6uoqBiQ5DOMHz8+Fi1aJEwAyDNvvvlmPPjgg4k+Q4sWLQY9+OCDx0gTAIBdRQEMAJAiRx55ZOWwYcN+kOQzzJ07N5544glhAkCemjhxYixYsCDRZxg+fPiPjjjiiJbSBABgV1AAAwCkyBVXXHFyUVFRRVLnr6qqijvvvDNyuZwwASBP5XK5uP3226O6ujqxZygqKmrxm9/85mRpAgCwKyiAAQBS4vzzz+/Xu3fv45J8httvvz0+/PBDYQJAnlu3bl3cfvvtiT5D7969jz///PP7SRMAgJ1NAQwAkALZbDZz6qmn/jyTyST2+m769OkxZ84cYQIAERExe/bsmDFjRmLnz2QyBaeeeurPs9lsRpoAAOxMCmAAgBT44x//eERlZeXgpM6/du3auPfeewUJAPyde+65J9atW5fY+SsrKwf/6U9/+oIkAQDYmRTAAAAJ17dv3+JDDjnkR0k+w9133x01NTXCBAD+Tk1NTdx9992JPsPBBx/8o759+xZLEwCAnUUBDACQcHfdddc3S0pKOiV1/smTJ8e8efMECQB8pLlz58azzz6b2PlLSko63nPPPd+SJAAAO4sCGAAgwb70pS9VDhw48KSkzr9mzZoYP368IAGALXrggQdizZo1iZ2/f//+Jx111FGtJAkAwM6gAAYASLArrrji1MLCwvIkzp7L5eK2226LTZs2CRIA2KJNmzbFbbfdFrlcLpHzFxYWll1++eU/kCQAADuDAhgAIKF+8Ytf9O7evftXkjr/s88+G2+88YYgAYBP5Y033ojnn38+sfN369bt6F/96ld9JAkAwI6mAAYASKgf/vCHP8pkMom8nvvggw/igQceECIAsFXGjRsX69atS+TsmUym4NRTT/2xFAEA2NEUwAAACXTdddcNa9eu3YFJnD2Xy8Udd9wRtbW1ggQAtsqmTZvizjvvTOz8bdq02f+mm27aT5IAAOxICmAAgIQpLS0t+NrXvnZ6Uud/4YUXYuHChYIEALbJq6++GjNmzEjs/Mccc8zpFRUVfiYHAMAO42ITACBhbr/99oMrKip2S+LsGzZsiHHjxgkRAPhM7r///qiqqkrk7OXl5X3/67/+6wgpAgCwoyiAAQASpKKiouCwww47Nanz33vvvYn9YS0A0HRs2LAh7r///sTOf9BBB/1zq1atCiUJAMCOoAAGAEiQ+++//+iysrKeSZx9zpw58dJLLwkRANguXnjhhViwYEEiZy8tLe32xz/+8StSBABgR1AAAwAkRN++fYv33Xfff07i7LW1tXHvvfcKEQDYru6+++6oq6tL5Oz77bffKf379y+RIgAA25sCGAAgIW6++eZRxcXFbZM4+yOPPBJr164VIgCwXa1atSoee+yxRM6ezWbb3njjjV+TIgAA25sCGAAgAYYOHVq21157fSeJs7/33nvxxBNPCBEA2CEmTpwYK1asSOTsQ4YM+c7QoUPLpAgAwPakAAYASIBrr732xKKiosqkzZ3L5eKee+6JxsZGIQIAO0R9fX3cddddkcvlEjd7UVFR5bXXXnuCFAEA2J4UwAAATdwBBxxQMWDAgG8kcfYZM2bEW2+9JUQAYId6880348UXX0zk7AMGDPjG8OHDy6UIAMD2ogAGAGjirrrqqhOKiooqkjb3pk2b4oEHHhAgALBT3H///VFbW5u4uYuKilpcffXV7gIGAGC7UQADADRhBx10UEX//v0Teffvww8/HB9++KEQAYCdYv369TFhwoREzj5w4MBvHHDAARVSBABge1AAAwA0Yf/5n/95bGFhYfOkzb1q1aqYPHmyAAGAnerpp5+O1atXJ27uwsLC8ssuu2yUBAEA2B4UwAAATdQBBxxQMWjQoNFJnP3uu++O+vp6IQIAO1V9fX3cddddiZx99913/+bQoUPLpAgAwGelAAYAaKIuv/zyYwsLC8uTNvfcuXNjwYIFAgQAdokFCxbE3LlzEzd3UVFRi9/97ndflyAAAJ+VAhgAoAkaOnRo2aBBgxL37t+6urr405/+JEAAYJf605/+FHV1dYmbe/fdd//mkCFDSiUIAMBnoQAGAGiCfvOb33ylqKioZdLmfu655xL53j0AIF1Wr14dzz33XOLmLioqann11VcfLUEAAD4LBTAAQBPTq1evZoMHD/5m0uaurq6ORx55RIAAQJPwyCOPRHV1deLmHjJkyLe6deuWlSAAANtKAQwA0MTcdNNNxxQXF7dN2twTJkyIqqoqAQIATUJVVVUifzmtuLi43a233uouYAAAtpkCGACgCWnVqlXhXnvtdVLS5l61alU8++yzAgQAmpTJkyfHqlWrEjf30KFDR7dq1apQggAAbAsFMABAE3LLLbccXlJS0jlpcz/44INRX18vQACgSamvr48HH3wwcXOXlJR0vummmw6VIAAA20IBDADQRGSz2cwBBxzw7aTNvWjRonjppZcECAA0SS+99FIsXrw4cXOPGDHiO9lsNiNBAAC2lgIYAKCJuOaaa/YuLy/vm7S5H3roocjlcgIEAJqkXC6XyLuAy8vL+1111VV7SRAAgK2lAAYAaCK+8pWvfDdpM8+bNy8WLlwoPACgSVu4cGG8+uqrrg8BAMgLCmAAgCbgsssuG1RZWblPkmbO5XIxfvx44QEAifDAAw8k7qklrVu33veSSy7pLz0AALaGAhgAoAkYNWrUCUmbefbs2bFs2TLhAQCJsGzZsnjllVcSN/cJJ5xwovQAANgaCmAAgF3sn//5nzt37NjxiCTN3NjYGA888IDwAIBEGT9+fDQ0NCRq5k6dOn1h9OjRHaQHAMCnpQAGANjFfvSjH30tk8kk6rps2rRpsWrVKuEBAImyatWqeOGFFxI1cyaTKfzpT386SnoAAHxaCmAAgF1o0KBBpX369Plqkmaur6+PCRMmCA8ASKQJEyZEXV1dombu27fvV/r27VssPQAAPg0FMADALnTZZZcdXlRUVJGkmadOnRpr164VHgCQSOvXr48pU6YkauaioqLK3/zmN0dIDwCAT0MBDACwi2Sz2cy+++57UpJmrqurc/cvAJB4jz76aOLuAt5///1PymazGekBAPBJFMAAALvI1VdfPbSsrKx3kmaeMmVKbNiwQXgAQKJt2LAhnn/++UTNXFZW1ueqq67aS3oAAHwSBTAAwC7y5S9/+bgkzVtfXx8TJ04UHACQCo8//nji7gL+0pe+dLzkAAD4JApgAIBdYPTo0R3atm07IkkzT5s2LdatWyc8ACAVPvzww5g+fXqiZm7fvv2I0aNHd5AeAABbogAGANgFfvrTn47KZDKFSZm3vr4+HnnkEcEBAKnyyCOPRH19fWLmzWQyhT/96U+/JjkAALZEAQwAsJN16tQp26dPn6OTNLO7fwGANFq3bl1MmzYtUTP36dPnmE6dOmWlBwDAx1EAAwDsZFddddUB2Wy2dVLmbWxsjEmTJgmOVOvYsWN06OCJmgD5aNKkSdHY2JiYebPZbOurrrrqAMkBAPBxFMAAADvZiBEjvp6keV988cVYtWqV4Ei1Ll26xIUXXhinnXZadO3a1UIA8siqVavipZdecj0JAEBqKIABAHaiM844o3tlZeXeSZk3l8vFxIkTBUdeyGQyMXjw4PjVr34VY8aMcUcwQB55/PHHI5fLJWbeysrKvc8444zukgMA4KMogAEAdqJTTjnlqxGRScq8CxYsiPfee09w5JVMJhN77713XHjhhTFmzJho3769pQCk3HvvvRcLFy5M1B9X/3NdCQAA/4cCGABgJ+nVq1ezXr16fTlJM3v3L/nsr0XwBRdcECeffHK0bdvWUgBSLGnXPb169fpyr169mkkOAIB/pAAGANhJrrjiioOLiopaJmXeBN4JAztEYWFhDB8+PC688MIYPXp0VFZWWgpACi1YsCCWLVuWmHmLiopaXnnllYdIDgCAf6QABgDYSYYPH/6VJM2btHfhwY5WVFQUI0aMiEsuuSRGjx4dLVu2tBSAFMnlcvH4448naub99tvvK5IDAOAfKYABAHaC0aNHd6isrByalHnXrl0bL7/8suDgI/y1CL744ovjhBNOiBYtWlgKQEq89NJLsW7dusTMW1lZudfo0aM7SA4AgL+lAAYA2AlOP/30o5J07fXMM89EQ0OD4GALiouL47DDDouxY8fGqFGjoqyszFIAEq6hoSGeeeaZJI1c8D/XmQAA8P8vEq0AAGDHymazmX79+n05KfPW1tbGlClTBAefUnFxcYwcOTIuvfTSGDVqVJSWlloKQII9//zzUVtbm5h5+/Xr9+VsNpuRHAAAf6UABgDYwX7zm9/sWVJS0jkp886YMSOqq6sFB1uppKQkRo4cGZdcckkcffTRUVJSYikACVRdXR0zZ85M0p8/na+44orBkgMA4K8UwAAAO9gXvvCFLyVl1lwuF08//bTQ4DNo3rx5HHXUUXHJJZfEyJEjI5vNWgpAwjz11FORy+USM++RRx75ZakBAPBXCmAAgB1oyJAhpZ07dz4iKfO+/vrrsWLFCsHBdlBeXh6jRo2KSy+9VBEMkDArVqyI119/PTHzdunS5fD+/ft79AQAABGhAAYA2KHGjh17aGFhYWJeCOruX9j+KioqYtSoUXHxxRfH4YcfHkVFRZYC4LpouyosLGz+H//xHwdLDQCACAUwAMAOteeeex6ZlFnXrl0b8+bNExrsIK1atYrjjz8+LrroohgxYkQUFPh2DKApmzdvXqxZsyYx8+61115HSg0AgAgFMADADnPMMce0bt269b5Jmfe5556LxsZGwcEO1qZNmxg9enRcfPHFimCAJqyxsTGee+65JP35MvyYY45pLTkAAPykAQBgBznzzDMPz2Qyibjeqq+vj6lTpwoNdqK2bdvG6NGj47zzzovhw4crggGaoBdeeCHq6+sTMWsmkyk844wzDpUaAAB+wgAAsIP079//C0mZdc6cObFhwwahwS7QqVOnOPnkk+Pf/u3fYu+9945MJmMpAE3Ehg0bYvbs2YmZd8CAAR4DDQCAAhgAYEf43ve+16mysnKPpMybpMcbQlp17tw5xowZE7/61a8UwQBNyPPPP5+YWSsrKwd/73vf6yQ1AID8pgAGANgBTj755CMiIhHtzcqVK+P1118XGjQRXbt2jTFjxsQ555wTgwcPthCAXez111+PlStXJmXczMknn3y41AAA8psCGABgB+jXr19iHv88ZcqUyOVyQoMmpnfv3nHaaafFOeecE/3797cQgF0kl8vFlClTknQd6jHQAAB5TgEMALCdnX766d0qKip2S8Ks9fX1MW3aNKFBE9anT58466yz4pxzzonddtvNQgB2gWnTpkV9fX0iZq2oqNjt9NNP7yY1AID8pQAGANjORo8efURSZp03b15s3LhRaJAAffr0ibPPPjvOPPPM6Nmzp4UA7EQbN26MefPmuR4FACARFMAAANtZr169EvPetSQ9zhD4bwMGDIhf/vKXceaZZ0b37t0tBGAnmTp1apKuRw+TGABA/lIAAwBsR2eccUb38vLyvkmYdf369fHaa68JDRJqwIAB8S//8i9x2mmnRbdunvQJsKPNnz8/Pvzww0TMWl5e3u9HP/pRF6kBAOQnBTAAwHZ03HHHHZSUWWfMmBGNjY1CgwTLZDIxePDg+Nd//dcYM2ZMdOjQwVIAdpDGxsaYMWNGYub9xje+cYjUAADykwIYAGA76tOnz8FJmDOXyyXqMYbAlmUymdh7773jwgsvjDFjxkT79u0tBWAHeOGFF5J0XXqIxAAA8pMCGABgOznppJPat2zZcvckzLpkyZJYuXKl0CBl/loEX3DBBXHyySdH27ZtLQVgO1qxYkW8/fbbiZi1srJy0PHHH+8PAgCAPKQABgDYTr773e8eGBGZJMyapMcXAluvsLAwhg8fHhdeeGGMHj06KisrLQVgO5k+fXpSRi34/ve/f6DEAADyjwIYAGA72X333Q9Nwpz19fUxc+ZMgUEeKCoqihEjRsQll1wSo0ePjpYtW1oKwGc0c+bMqK+vT8SsAwcOPFRiAAD5RwEMALAdHHTQQRUtW7bcKwmzLly4MKqrq4UGeeSvRfDFF18cJ5xwQrRo0cJSALZRVVVVvP7664mYtVWrVkOHDx9eLjUAgPyiAAYA2A7OPvvsz2cymaIkzOrxz5C/iouL47DDDouxY8fGqFGjoqyszFIAtkFSnqaSyWSy55577uclBgCQXxTAAADbwe67735AEuasra2NOXPmCAzyXHFxcYwcOTIuvfRSRTDANpg9e3bU1dUlYtY99tjjAIkBAOQXBTAAwGfUqlWrwnbt2u2fhFnnzZsXtbW1QgMiIqKkpCRGjhwZY8eOjaOPPjpKSkosBeBT2LRpU8ybNy8Rs7Zv337/iooKPwMEAMgjLv4AAD6jCy+8cPeioqKKJMz64osvCgz4P5o3bx5HHXVUXHLJJTFy5MjIZrOWAvAJZs2alYg5i4qKWlx88cWDJAYAkD8UwAAAn9GBBx6YiMfqVVdXJ+ZOFWDXKC8vj1GjRsWll16qCAb4BPPmzYuamppEzHrQQQd5DDQAQB5RAAMAfEZdu3YdnoQ5582bF/X19QIDPlFFRUWMGjUqLr744jj88MOjqKjIUgD+QV1dXbz66quJmLVLly77SwwAIH8ogAEAPoNTTjmlY3l5+W5JmPXll18WGLBVWrVqFccff3xcdNFFMWLEiCgo8C0kwN966aWXEjFnRUXFbieddFJ7iQEA5AffvQMAfAYnnnji55MwZ21tbcyfP19gwDZp06ZNjB49OsaOHasIBvgb8+fPj9ra2iSMmvnud7/7eYkBAOQH37UDAHwGn/vc5/ZLwpwLFy6Muro6gQGfyV+L4PPOOy+GDx+uCAby3ubNm2PhwoWJmLVfv37DJQYAkB98tw4AsI1atWpV2Lp1672TMKvHPwPbU6dOneLkk0+Oc889NwYNGmQhQF6bPXt2IuZs06bN3hUVFX4WCACQB1z0AQBso/PPP39gYWFheVOfs76+PubMmSMwYLvr2bNn/OQnP4nzzjsv9t5778hkMpYC5J3Zs2dHfX19k5+zqKio4vzzzx8oMQCA9FMAAwBso/3333/fJMz5+uuvR01NjcCAHaZLly4xZsyYOOecc2Lw4MEWAuSV6urqeOONNxIx64EHHriPxAAA0k8BDACwjbp27ZqIxz/PnTtXWMBO0bt37zjttNPinHPOif79+1sIkDeScr3VvXv3vaUFAJB+CmAAgG0wZMiQ0srKyj2a+py5XM7jn4Gdrk+fPnHWWWfFOeecE7vttpuFAKk3e/bsyOVyTX7Oli1b7jlo0KBSiQEApJsCGABgG5x55pl7ZjKZbFOfc9myZbFu3TqBAbtEnz594uyzz44zzzwzevbsaSFAaq1bty6WL1/e5OfMZDLZs846a4jEAADSrcgKAAC23tChQ4clYc558+YJC9jlBgwYEAMGDIgFCxbE+PHjY+nSpZYCpM68efOiS5cuTX7OffbZZ5+ImC4xAID0cgcwAMA26Nix4z5JmHP+/PnCApqMAQMGxC9/+cs47bTTolu3bhYCpEpSrrs6deq0j7QAANJNAQwAsJWOOOKIlhUVFf2a+pxVVVWxaNEigQFNSiaTicGDB8e//uu/xpgxY6JDhw6WAqTCW2+9FVVVVU1+zoqKis8deuihLSQGAJBeCmAAgK108sknD46ITFOfc/78+dHY2CgwoEnKZDKx9957x4UXXhhjxoyJ9u3bWwqQaI2NjbFgwYJE/Cv4u9/97h4SAwBILwUwAMBW2n333fdMwpze/wskwV+L4AsuuCBOPvnkaNu2raUAiZWU66/BgwfvKS0AgPQqsgIAgK3Trl27wU19xlwul5Q7UAAiIqKwsDCGDx8e++yzT0ybNi0mTJgQ69evtxggURYsWBC5XC4ymab9sJgOHToMlhYAQHq5AxgAYCsMGjSotGXLlgOa+pzvvfdebNy4UWBA4hQVFcWIESPikksuidGjR0fLli0tBUiMDz/8MJYtW9bk52zZsuXA/v37l0gMACCdFMAAAFvhxz/+8aBMJtPkn6Li7l8g6f5aBI8dOzZOOOGEaNGihaUAibBw4cImP2Mmk8n+5Cc/GSAtAIB0UgADAGyFvffee88kzJmEHzwCfBrNmjWLww47LMaOHRujRo2KsrIySwGatKT8Il5SrmsBANh63gEMALAVunbtOqSpz1hfXx9vvvmmsIBUKS4ujpEjR8bBBx8czz77bDz++ONRXV1tMUCT8+abb0Z9fX0UFTXtH7t16dJlT2kBAKSTO4ABAD6lioqKgoqKikFNfc4lS5bE5s2bBQakUklJSYwcOTLGjh0bRx99dJSUeIUl0LTU1tbG0qVLm/ycLVu2HFRaWupngwAAKeQiDwDgUzr77LP7FhYWNvlnj7722mvCAlKvefPmcdRRR8Ull1wSI0eOjGbNmlkK4HpsKxQWFpafffbZvaQFAJA+CmAAgE9p//3375+EOV9//XVhAXmjvLw8Ro0aFf/+7/8eI0eOjGw2aymA67FP6fOf//xAaQEApI8CGADgU+rRo8fuTX3G2traePvtt4UF5J2KiooYNWpUXHzxxXH44Yc3+XdvAum2ePHiRLySo1evXoOkBQCQPgpgAIBPqXXr1k3+DoklS5ZEQ0ODsIC81apVqzj++OPj4osvjhEjRkRBgW97gZ2voaEhlixZ0uTnbNOmjQIYACCFfCcMAPApDBkypLR58+a9m/qcb775prAAIqJ169YxevToGDt2rCIYcF32MZo3b95n0KBBpdICAEgX3wEDAHwKp556av9MJtPkr53eeustYQH8jTZt2sTo0aPjvPPOi+HDhyuCAddlfyOTyRT84Ac/+Jy0AADSxXe+AACfwuDBg5v84/Hq6+tj0aJFwgL4CJ06dYqTTz45/u3f/i323nvvyGQylgLsUIsXL07Eqzn23HPPgdICAEgXBTAAwKfQpUuXAU19xnfeeSfq6uqEBbAFnTt3jjFjxiiCgR2utrY23n333SRc53oPMABAyiiAAQA+hZYtW/Zv6jN6/DPAp9elS5cYM2ZMnHvuuTF48GALAfL2+iwJ17kAAGwdBTAAwCcYPnx4eUlJSeemPqfHPwNsvV69esVpp50W55xzTvTvrwMB8u/6rLS0tPPw4cPLpQUAkB4KYACAT/Ctb31rt4ho8s8IXbx4sbAAtlGfPn3irLPOinPOOSd22203CwG2i4T8gl7m29/+dj9pAQCkhwIYAOAT7L777k2+CVi7dm1s2LBBWACfUZ8+feLss8+OM888M3r27GkhwGfy4Ycfxrp165r8nAMHDlQAAwCkSJEVAABsWadOnZr8D8TefvttQQFsRwMGDIgBAwbEggULYvz48bF06VJLAbb5Oq1Vq1audwEA2GkUwAAAn6CyslIBDJCnBgwYEP3794958+bFQw89FO+++66lAFtlyZIlsddeezX1613PvgcASBEFMADAFnTq1CnbvHnzXk19ziVLlggLYAfJZDIxePDg2GOPPeLll1+OBx98MFauXGkxQGqu05o3b967Xbt2RatXr66XGABA8nkHMADAFowZM6ZnJpPJNuUZGxsbPZoUYCfIZDKx9957x4UXXhhjxoyJ9u3bWwrwiZYuXRqNjY1NesaCgoLsqaee2kNaAADp4A5gAIAt2Hvvvfs29RlXrlwZtbW1wgLYSf5aBO+5554xa9asmDBhQqxevdpigI9UW1sb77//fnTu3LlJzzls2LC+EbFIYgAAyecOYACALejRo0eTL4DfeecdQQHsAoWFhTF8+PC48MILY/To0VFZWWkpQGKv15Jw3QsAwKejAAYA2ILWrVs3+ff/vvvuu4IC2IUKCwtjxIgRcckll8To0aOjZcuWlgIk7notCde9AAB8Oh4BDQCwBc2bN+/Z1GdUAAM0kW+wi4pixIgRsd9++8WUKVPiscceiw0bNlgMEO+9914SrnsVwAAAKeEOYACAj9G/f/+SkpKSjk19TgUwQNPSrFmzOOyww2Ls2LExatSoKCsrsxTIc0m4XistLe3Ut2/fYmkBACSfAhgA4GOccMIJ3Zr69dK6deuiqqpKWABNUHFxcYwcOTJ+/etfK4Ihz1VVVcX69eub+pgF3/zmN7tLCwAg+RTAAAAfY8iQIT2b+oxJeJwgQL77axE8duzYOProo6OkpMRSIA8l4botCde/AAB8MgUwAMDH6N69e8+mPqPHPwMkR/PmzeOoo46KSy65JEaOHBnNmjWzFMgjSbhuS8L1LwAAn0wBDADwMVq1atWjqc+4bNkyQQEkTHl5eYwaNSr+/d//PUaOHBnZbNZSIA8k4botCde/AAB8MgUwAMDHqKio6NXUZ1y+fLmgAJL750yMGjUqLr744jj88MOjqKjIUiDFknDd1rJly16SAgBIPgUwAMBHyGazmbKysq5NecbGxsZYtWqVsAASrlWrVnH88cfHxRdfHCNGjIiCAt+qQxqtWrUqGhsbm/SMJSUlXbPZbEZaAADJ5rtKAICPcNxxx7UrKCgobsozrl69Ourr64UFkBKtW7eO0aNHx9ixYxXBkEJ1dXXxwQcfNOkZCwoKio877rh20gIASDbfTQIAfITPf/7zXZr6jO+//76gAFKoTZs2MXr06Dj//PNj+PDhimBIkRUrVrgOBgBgh/NdJP+PvTuPr7I888d/nSwEkhD2HUQEUVRAoIiouCtq64Jabd1arVorbqO2tlXbaavTOu38Rqffdmpbu9rWpYogsqgFRXCttAIKArJDgAAJBLKQ5JzfH8WO4+DOcp6T9/v18jWvTv657ut6hNvnk/t+AICd2G+//bL+xVcSXiAC8PF17do1Lr300rj99ttj2LBhkUq5lRWSLgn7tyTsgwEAeH8FWgAA8H917txZAAxAVujevXtceeWVsXr16njiiSdi9uzZkclkNAYSKAn7tyTsgwEAeH8CYACAnWjXrp0roAHIKj169Igrr7wyli5dGpMmTYo5c+ZoCiRMEvZvSdgHAwDw/gTAAAA7UVxc3D3baxQAAzRPffr0ibFjx8aSJUti/PjxsWDBAk2BhEjC/i0J+2AAAN6fbwADAOxESUlJz2yur7q6Ourq6gwKoBnbb7/94l/+5V/ia1/7WhxwwAEaAglQV1cX1dXV9sEAAOxWAmAAgHc5/PDDSwsKCtpmc40VFRUGBUBERPTt2zduvPHGuOGGG2LffffVEMhy2b6PKygoaDt8+PASkwIASC4BMADAu5x44oldsr3GDRs2GBQA/8uAAQPiG9/4Rtxwww3Ru3dvDQH7uE+yH+5qUgAAyeUbwAAA79KvX7+sD4DXr19vUADs1IABA+LAAw+MuXPnxoQJE2LlypWaAlkkCTe5HHDAAV0i4i3TAgBIJgEwAMC7dO/evXO21+gEMADvJ5VKxaBBg2LgwIExe/bsGD9+fKxbt05jwD4uZ/bDAAC8NwEwAMC7tG/fvlO21ygABuDDSKVSMWzYsBg6dGjMnj07HnvsMbdIwF6WhBPASdgPAwDw3gTAAADv0rp166w/8ZCEF4cAZI+3g+BDDz00XnnllZg4caK/S8A+LtH7YQAA3psAGADgXUpKSrL6xENjY2Ns3rzZoAD4yPLz8+Pwww+P4cOHx/PPPx8TJ06MqqoqjYE9aPPmzdHY2BgFBdn7Wi7b98MAALw/ATAAwLu0bNmySzbXV1lZGZlMxqAA+Njy8/Nj1KhRMXLkyHjhhRcEwbAHZTKZqKqqio4dO9oPAwCwWwiAAQDepaioKKuvvKusrDQkAHaJgoKCGDVqVIwYMSJmzpwZkydPji1btmgM7IH9XDYHwNm+HwYA4P3laQEAwP8YPnx4SX5+fkk21ygABmBXa9GiRRx//PFxxx13xNlnnx0lJSWaAs14P5efn18yfPhwfxAAACSUABgA4B2OOOKIDtleo+//ArC7FBUVxejRo+P73/9+nH322VFcXKwpsBsk4cr1JOyLAQDYOQEwAMA79O3bt1221+gEMAC729tB8B133BGnn356tGrVSlOgme3n9ttvv7YmBQCQTAJgAIB36NSpkwAYAHYoKSmJz3zmM3HnnXfG6NGjo0WLFpoCzWQ/l4R9MQAAOycABgB4hw4dOrTN9hqTcGUgALmlpKQkzj777PjOd74To0aNivz8fE2BHN/PJWFfDADAzgmAAQDeoaysrG221ygABmBvad++fVx00UVx5513xgknnBCFhYWaAjm6nysrK3MCGAAgoQTAAADvUFJS0j6b68tkMlFdXW1QAOxV7dq1i/POOy+++93vxqhRoyIvz+sF+CiSsJ8rLS0VAAMAJJT/QgMAeIfi4uK22VxfXV1dNDY2GhQAWeHtE8F33HGHIBg+gsbGxqirq7MvBgBgt/BfZgAA79CqVausPung9C8A2ahDhw5x0UUXxbe//e04/PDDBcGQA/u6oqIiJ4ABABLKf5EBALxDQUGBABgAPqauXbvGpZdeGt/61rdi2LBhkUqlNAUSuq9r0aJFW1MCAEimAi0AAPgfhYWFZdlc39atWw0JgKzXrVu3uPLKK2P16tXxxBNPxOzZsyOTyWgMJGhfl+37YgAA3psAGADgnZujgoLW2VyfE8AAJEmPHj3iyiuvjKVLl8akSZNizpw5mgIJ2ddl+74YAID35gpoAIAdWrdunZefn98ym2sUAAOQRH369ImxY8fGLbfcEgMGDNAQSMC+Lj8/v1WrVq28OwQASCCbOACAHQYNGlQSEVn9scJt27YZFACJtd9++8UNN9wQX/va1+KAAw7QEJq1BOzr8gYPHlxsUgAAySMABgDY4YADDijJ9hpramoMCoDE69u3b9x4441xww03xL777qshNEu1tbVZX2P//v1LTQoAIHl8AxgAYIeePXtm/QuuJLwoBIAPa8CAATFgwICYP39+jBs3LpYvX64pNBtJ2Nf16NGjxKQAAJJHAAwAsEOnTp0EwACwFwwYMCAOPPDAmDt3bkyYMCFWrlypKeS8JOzrunbtKgAGAEggATAAwA5lZWVZ/4Krrq7OoADISalUKgYNGhQDBw6M2bNnx4QJE2Lt2rUaQ85KQgDcpk0bV0ADACSQABgAYIeysjIngAFgL0ulUjFs2LAYOnRozJ49O8aPHx/r1q3TGHKOABgAgN1FAAwAsENJSUlxttfoBDAAzcXbQfCQIUPi5ZdfjokTJ0ZFRYXGkDOSEAAnYX8MAMD/JQAGANihqKioKNtrrKmpMSgAmpW8vLw4/PDDY/jw4fH888/HE088EZWVlRpD4iUhAG7RokWRSQEAJI8AGABgh8LCwhbZXF86nY7t27cbFADNUn5+fowaNSpGjhwZL7zwQkycODGqqqo0hsTavn17ZDKZSKVSWVtjixYtWpgUAEDyCIABAHbI9gC4oaHBkABo9goKCmLUqFExYsSImDlzZkyePDm2bNmiMSROJpOJhoaGyOaMtbCw0AlgAIAk/neTFgAA7NgYFRRk9QuuxsZGQwKAHVq0aBHHH398HHnkkfHMM8/E1KlTY9u2bRpDomR7AJzt+2MAAN5jH6cFAAA7NkZZ/oLL9c8A8H8VFRXF6NGj49hjj41nnnkmpkyZEjU1NRpDImT7DS8FBQWugAYASCABMADA2xujLH/B5QpoAHhvbwfBRx11VEyfPj2efvrpqK2t1RiymgAYAIDdIU8LAAD+QQAMAMlXUlISn/nMZ+LOO++M0aNHZ/X1uiAABgBgdxAAAwDskO1XQAuAAeDDKykpibPPPjv+7d/+LUaPHh2FhYWagv3dR5Sfn9/SlAAAkkcADADw9sYoL88JYADIMa1bt46zzz47vve978UJJ5wgCMb+7iPIz8/3LwwAQAIJgAEAdkilUlm9N2psbDQkAPiY2rVrF+edd15897vfjRNOOCEKCgo0Bfu7D94f55sSAEDyCIABAHbI9gA4nU4bEgB8Qu3bt/9nEDxq1KjIy/NqBPu799kfp0wJACB5/FcOAMAOXnABQPPRoUOHuOiii+J73/ueIJi9JpPJZHuJ/sUAAEggmzgAgP+R1QFwAl4QAkDidOzYMS666KL41re+FYcffnj4fTDs796xOc7yG3IAANg5mzgAgITsjQTAALD7dOvWLS699NL41re+FcOGDRMEs0dk+xXQeXl5/kUAAEigAi0AAPiHbH/BJQAGgN2ve/fuceWVV8ayZcviiSeeiDlz5mgKzXl/5/AIAEACCYABAHbIZDJOAAMAERGx7777xtixY2PJkiUxYcKEmD9/vqZgfwwAQCIIgAEA/ocr7gCA/2W//faLG264Id56660YP358vPnmm5rCLpPtV0Cn3IUOAJBIAmAAgB2y/QVXtr8gBIBc1rdv37jxxhvjrbfeinHjxsWiRYs0hU/MFdAAANjEAQDsXln9Bs4BDADY+/r27Rs333xz3HDDDdG7d28NIdf3d75BAgCQQE4AAwDskO0nMATAAJA9BgwYEAMGDIj58+fHI488EitXrtQUcnF/5woaAIAEcgIYAGCHVCqVzvL6DAkAssyAAQPi1ltvjbFjx0bPnj01hJza32UScEc1AAD/lxPAAAD/QwAMAHysv6MHDRoUBx98cDz//PMxadKk2LRpk8aQ+P1dtv+CJAAAO+cEMADADul0dr/fEgADQHarr6+PioqK2LZtm2aQE/u7dDrtBDAAQAI5AQwA8D+cAAYAPrK6urp4+umnY9q0acJfcm1/5wQwAEACCYABAP6HEw4AwIfW0NAQ06ZNiyeffDK2bt2qIXxkCfgGsAAYACCBBMAAADtkMpmsDoDz8ny9AwCywdvB71NPPRXV1dUaQs7u7wTAAADJJAAGANgh219wCYABYO9qbGyMGTNmxJNPPhmVlZUawieWn5+f9VtkUwIASB4BMADADplMpiGb6yssLDQkANgL0ul0zJo1KyZPnhwbN27UEHaZgoLsfjXX1NTUaEoAAAncZ2oBAMA/NDY2bs/m+gTAALBnpdPpePnll2Py5Mmxdu1aDWGXa9GiRbb/O1BvSgAAySMABgDYoampSQAMAEQmk4nZs2fH448/HuXl5RpCs93fNTY2CoABABJIAAwAsENDQ0NWv+ASAAPA7vV28PvEE0/E6tWrNYTdLtuvgM72G3IAAHiPfaYWAAD8gyugAaD5mjNnTkyaNCmWLl2qGewx2X4FtAAYACCZBMAAADs0NTU5AQwAzcyCBQtiwoQJ8dZbb2kG9nfv0tDQIAAGAEggATAAwA7Z/oJLAAwAu87ChQtj/PjxsXjxYs1gr8n2K6Cz/RckAQB4j32mFgAA/EO2B8AFBQWRl5cX6XTasADgY1q+fHmMGzcu5s+frxnsVXl5eVkfAG/fvt0JYACABBIAAwDs0NDQkPUnHFq1ahXbtm0zLAD4iFauXBmPPPKI4Jes2tclYH8sAAYASCABMADADrW1tXXZXqMAGAA+mnXr1sX48eNj9uzZkclkNISs2tdlu7q6ulqTAgBIHgEwAMAOW7du3ZrtNSbhRSEAZIP169fHY489JvjFvu4TqK6u3mpSAADJIwAGANihqqpKAAwACbdhw4Z4/PHH45VXXommpiYNwb7uE6isrHT1DABAAgmAAQB22LRpU9a/4GrZsqVBAcBOVFVVxcSJE+OFF16IxsZGDSHrJSEA3rRpkxPAAAAJJAAGANhh3bp1WR8AOwEMAP/bli1bYsKECYJfEicJ+7ry8nIBMABAAgmAAQB2WLZsmSugASAhqqurY/LkyTFz5syor6/XEBInCfu6pUuXCoABABJIAAwAsMP8+fOz/gRwcXGxQQHQrNXU1MSUKVPimWeeEfySaEnY173++uu+AQwAkEACYACAHRYsWFCXyWQaUqlUYbbW2Lp1a4MCoFmqq6uLp59+OqZNmxbbtsmkSL5s39el0+mGpUuXbjcpAIDkEQADALxDU1PTtoKCgrbZWp8AGIDmZvv27TF9+vR48sknY+tWt9GSO7J9X9fU1ORfOACAhBIAAwC8Q0NDw9ZsDoBLS0sNCYDm8ndyTJs2LZ566qmorq7WEHJOtu/rGhsb/YsHAJBQAmAAgHeor6+vbNWqVc9src8JYAByXWNjY8yYMSOefPLJqKys1BByVrbv6+rr66tMCQAgmQTAAADv0NDQkNVvmgXAAOSqdDods2bNismTJ8fGjRs1hJyX7fu6bN8XAwDw3gTAAADvUFdXV5XN9ZWWlkYqlYpMJmNYAOSETCYTr732Wjz++OOxatUqDaFZSKVSUVJSktU11tbWVpkUAEAyCYABAN5h27Ztm7K5vvz8/GjVqlXU1NQYFgCJlslkYvbs2fH4449HeXm5htCstGrVKvLz87O6xq1btzoBDACQUAJgAIB3qK6u3pztNZaVlQmAAUist4PfiRMnxpo1azSEZqmsrCzra9y2bVuVSQEAJJMAGADgHaqqqjZle43t2rWLtWvXGhYAiTNnzpyYNGlSLF26VDNo1tq1a5f1NW7atMkJYACALNbQWBgFjQ0REZFKRSavMJre/pkAGADgHSoqKqqyvcYkvDAEgHdasGBBTJgwId566y3NgITs5zZs2CAABgDIYoUFDf9MejMRqab0/+S+AmAAgHdYtWpV1r/oatu2rUEBkAgLFy6M8ePHx+LFizUD3iEJAfDq1aurTAoAIJkEwAAA77BgwYKsD4CdAAYg2y1fvjzGjRsX8+fP1wzYiST8Ql8S9sUAAOycABgA4B2eeOKJjZlMpimVSuVna41OAAOQrVauXBmPPPKI4Bc+QLb/Ql8mk2l64oknNpoUAEAyCYABAN6huro6vX379g1FRUVdsrVGJ4AByDZr166NCRMmxOzZsyOTyWgIJHw/t3379g3V1dVpkwIASCYBMADAu9TV1a0XAAPAB1u/fn089thjgl/Isf1cXV3delMCAEguATAAwLvU1dVVtGnTJmvrKykpiRYtWsT27dsNC4C9oqKiIiZOnBivvPJKNDU1aQh8BEVFRVFcXJz1+2GTAgBILgEwAMC7bN26dV2XLll7ADhSqVR07Ngx1qxZY1gA7FFVVVUxceLEeP755wW/8DF17NgxUqlU1u+HTQoAILkEwAAA71JVVZX1Jx46deokAAZgj9m8eXM8/vjj8cILL0RjY6OGwCfcx9kPAwCwOwmAAQDeZf369Vn/zbMkvDgEIPm2bNkSU6ZMiZkzZ0Z9fb2GwC7QsWNH+2EAAHYrATAAwLusXr066088JOHFIQDJVVNTE1OmTIlnnnlG8Au7WBJ+kW/VqlUCYACABBMAAwC8y9///ves/+aZABiA3aG2tjYmT54czz77bNTV1WkINNN93KuvvioABgBIMAEwAMC7PPzww+t//OMfN6RSqcJsrbFz584GBcAus3379pg+fXpMnTo1tm3bpiGwG2X7CeB0Ot3w8MMPC4ABABJMAAwA8C7V1dXpurq68latWu2TrTV26NAh8vLyIp1OGxgAH1tDQ0NMmzYtnnrqqaiurtYQ2M3y8vKiQ4cOWV1jfX39mtraWptMAIAEEwADAOxEbW3tmmwOgAsKCqJdu3axceNGwwLgI2tsbIwZM2bEk08+GZWVlRoCe0j79u2joCC7X8fV1NSUmxQAQLIJgAEAdmLz5s2r2rdvn9U1duvWTQAMwEeSTqdj1qxZMXnyZH+HwF7av2W7LVu2rDQpAIBkEwADAOzEpk2bVvfp0yera+zWrVvMmzfPsAD4QG8Hv1OmTIkNGzZoCOzF/Vu227BhwxqTAgBINgEwAMBOrFixYvWwYcOyusYkvEAEYO/KZDLx0ksvxZQpU6K83K2usLd17do162tctWrVKpMCAEg2ATAAwE7Mnz9/9ZgxY7K6xiS8QARg78hkMjF79uyYOHFirFnjMB9kiyT8At+8efP8oQEAkHACYACAnRg3btyab37zm5mISGVrjU4AA7Azc+bMiSeeeCKWLVumGZBlEvALfJlx48atNikAgGQTAAMA7MTrr79e29DQsKmwsLBDttZYXFwcZWVlsWXLFgMDIBYsWBDjx4+PJUuWaAZkobKysiguLs7qGhsaGjYuWLCgzrQAAJJNAAwA8B62bt26vF27dh2yucauXbsKgAGauYULF8b48eNj8eLFmgFZLAm3t2zbtm25SQEAJJ8AGADgPVRVVS1t167d0GyusWfPnrFw4ULDAmiGli1bFo899ljMnz9fMyABevbsmfU1VlZWLjUpAIDkEwADALyHdevWLevTp09W15iEF4kA7ForVqyIRx99VPALCZOEfdvatWuXmRQAQPIJgAEA3sPChQuXHX744VldY69evQwKoJlYtWpVjB8/PubOnRuZTEZDIGGSsG9buHDhMpMCAEg+ATAAwHuYNm3a0ksuuSSra+zevXvk5+dHU1OTgQHkqHXr1sX48eNj9uzZgl9IqIKCgkR8A/jpp59eZloAADmw/9QCAICde+ihhzbcd999W/Pz80uzdjNXUBBdunSJNWvWGBhAjqmoqIiJEyfGyy+/HOl0WkMgwbp27RoFBdn9Gq6xsbH6kUce2WBaAADJJwAGAHgf27ZtW15WVnZwNtfYq1cvATBADqmqqoqJEyfG888/74YHyBFJ+P7vtm3blpsUAEBuEAADALyPLVu2LMv2ALhnz57x0ksvGRZAwm3evDkef/zxeOGFF6KxsVFDIIck4fu/W7ZsWWpSAAC5QQAMAPA+1q9fvyzbT2z06NHDoAASbMuWLTFlypSYOXNm1NfXawjkoCTs19avX7/MpAAAcoMAGADgfSxYsGDh0KFDs7rGfffdN1KpVGQyGQMDSJCampqYMmVKPPPMM4JfyGGpVCr23XffrK9z/vz5C00LACA3CIABAN7Ho48++uYFF1yQ1TWWlJRE586dY926dQYGkAC1tbUxefLkePbZZ6Ourk5DIMd17do1WrVqlfV1/vnPf15kWgAAuUEADADwPiZNmlRVX1+/oaioqGM217nvvvsKgAGy3Pbt22P69OkxderU2LZtm4ZAM9GnT5+sr7G+vr7iySefrDItAIDcIAAGAPgAW7duXZTtAXCfPn3ipZdeMiyALNTQ0BDTpk2Lp556KqqrqzUEmpkkXP+8detWp38BAHKIABgA4ANUVFQs7NChw8hsrjEJLxYBmpvGxsaYMWNGPPnkk1FZWakh0EwlYZ9WUVHh+78AADlEAAwA8AGWLl266MADD8zqGnv16hUFBQXR2NhoYAB7WTqdjlmzZsWkSZNi06ZNGgLNWGFhYfTs2TMR+13TAgDIHQJgAIAPMHPmzEWnnnpqdm/qCgqiZ8+esWzZMgMD2EveDn4nT54cGzdu1BAg9tlnn8jPz0/CfnexaQEA5I48LQAAeH+//OUvV6bT6bpsr7NPnz6GBbAXZDKZePHFF+O73/1u3H///cJf4J+ScP1zOp2u++Uvf7nStAAAcocTwAAAH6C6ujpdXV29uE2bNodkc539+vWL6dOnGxjAHpLJZGL27NkxceLEWLNmjYYAO92fJWCvu7i6ujptWgAAuUMADADwIWzYsGFetgfA/fv3NyiAPeTVV1+NSZMmxapVqzQD2KlUKpWI/dmGDRvmmhYAQG4RAAMAfAiLFy9+o2/fvlldY1lZWXTu3DnWr19vYAC7yYIFC2L8+PGxZMkSzQDeV5cuXaK0tDQJ+9z5pgUAkFsEwAAAH8JTTz31+ujRo7O+zv33318ADLAbLFy4MMaPHx+LFy/WDOBD78uSYMqUKa+bFgBAbsnTAgCAD/aLX/xiTWNjY1W215mUF40ASbFs2bK4++674z/+4z+Ev8BHkoTv/zY0NFTee++9q00LACC3OAEMAPAhNDQ0ZDZv3jy/Q4cOI7O5TgEwwK6xYsWKePTRR2P+fDejArm7L9uyZYs/5AAAcpAAGADgQ1q3bl3WB8AdO3aMNm3axObNmw0M4GNYtWpVjB8/PubOnRuZTEZDgI+lbdu20aFDh0Tsb00LACD3CIABAD6kefPmzTvooIOyvs4DDzwwXnrpJQMD+AjWrVsX48ePj9mzZwt+gV2yH0uCuXPnzjMtAIDcIwAGAPiQ/vznP88/77zzsr7OAw44QAAM8CFVVFTEuHHjBL/ALt+PJcHDDz/sBDAAQA4SAAMAfEgTJ06srK2tXdGqVat9srnOgw8+2LAAPkBVVVVMnDgxnn/++WhqatIQYJdKwq0xNTU1yydNmlRlWgAAuUcADADwEWzYsOHvvXr1yuoAuG3bttG1a9dYu3atgQG8y+bNm+Pxxx+PF154IRobGzUE2OW6desWbdu2TcS+1rQAAHKTABgA4CNYuHDha7169Toj2+scMGCAABjgHbZs2RJTpkyJ5557LrZv364hwG6TlO//Lly48O+mBQCQmwTAAAAfwcSJE/9+wgknZH2dBx54YEyfPt3AgGavpqYmpkyZEs8880zU19drCLDbDRgwIBF1jh8//u+mBQCQmwTAAAAfwb333rv6Bz/4wfqioqLO2VznAQccEHl5eZFOpw0NaJZqa2tj8uTJ8eyzz0ZdXZ2GAHtEXl5e9O/fP+vrrK+vX3ffffeVmxgAQG4SAAMAfESVlZVzu3btmtXHgFu1ahX77LNPLFu2zMCAZqWuri6efvrpmDZtWmzbtk1DgD1qn332iVatWmV9nZs2bZpjWgAAuUsADADwES1dunR2tgfAERGDBg0SAAPNRkNDQ0ybNi2eeuqpqK6u1hBgr+2/kuCtt976m2kBAOQuATAAwEc0ffr0v48cOTLr6xw4cGBMmDDBwICc1tDQEM8991w8+eSTUVlZqSHAXt9/JcG0adP+bloAALlLAAwA8BH9x3/8x9JbbrmlOj8/v3U219mrV68oKyuLLVu2GBqQc9LpdMyaNSsmTZoUmzZt0hBgrysrK4tevXplfZ2NjY1b7rnnnmUmBgCQuwTAAAAfUW1tbXrDhg1/7dKly3HZXGcqlYqBAwfGrFmzDA3IGW8Hv5MnT46NGzdqCJA1Bg4cGKlUKuvr3Lhx4yu1tbVpEwMAyF0CYACAj+Gtt956JdsD4IgQAAM5I51Ox8svvxxTpkyJ8vJyDQGyct+VBIsWLXrFtAAAcpsAGADgYxg/fvwrRxxxRNbXedBBB0VBQUE0NjYaGpBImUwmZs+eHRMnTow1a9ZoCJCVCgoK4qCDDkpErY888ogAGAAgx+VpAQDAR/fjH/94ZX19/fpsr7OoqCj69etnYEAivfrqq3HHHXfEz3/+c+EvkNX69esXRUVFWV9nXV1d+b333rvaxAAAcpsTwAAAH9OGDRte6dGjx6ezvc5BgwbFggULDAxIjCVLlsSECRNi/vz5mgEkwuDBgxNR5/r1653+BQBoBgTAAAAf07x5815OQgA8bNiwePjhhyOTyRgakNXefPPNmDBhQixevFgzgMRIpVIxdOjQRNQ6d+7cl0wMACD3CYABAD6m++677+XRo0dnIiKVzXW2bds2evfuHcuWLTM0ICstW7YsHnvsMSd+gUTq06dPtG3bNgmlpu+9996/mhgAQO4TAAMAfEwTJ06s3Lp165LS0tK+2V7rkCFDBMBA1lmxYkU8+uijgl8g0YYMGZKIOqurqxc+/fTTm00MACD3CYABAD6B8vLyl/fff/+sD4AHDx4c48aNMzAgK6xcuTImTJgQc+fOdT09kHhJ+f7vmjVrfP8XAKCZEAADAHwCM2fOfG7//ff/fLbX2a1bt+jWrVuUl5cbGrDXrFu3LsaPHx+zZ88W/AI5oWfPntGlS5dE1DpjxoznTAwAoHkQAAMAfAK33Xbba5dcckl1fn5+62yvdciQIQJgYK9Yv359PPbYY4JfIOck5frnxsbGzbfddts8EwMAaB4EwAAAn0BlZWXThg0b/tqlS5fjsr3WQw89NCZNmmRowJ78MzKeeOKJeP7556OpqUlDgJxz6KGHJqLOioqKV6qrq9MmBgDQPAiAAQA+oXnz5s1MQgDcu3dv10ADe0RVVVVMnDgxXnjhhWhsbNQQICd17949evbsmZT9quufAQCakTwtAAD4ZP77v/97VkQk4kTFpz71KQMDdpstW7bEQw89FLfffns899xzwl8gpw0fPjwRdWYymfTdd9/9gokBADQfTgADAHxCkyZNqtqyZcuCsrKyg7K91uHDh8fjjz9uaMAuVVNTE1OmTIlnnnkm6uvrNQTIealUKg477LBE1Lply5bXp0+fvsXUAACaDwEwAMAusHz58lkDBw7M+gC4S5cu0atXr1i5cqWhAZ9YbW1tTJ48OZ599tmoq6vTEKDZ6N27d3Ts2DEx+1QTAwBoXgTAAAC7wLPPPvvCwIEDr0hCrcOGDRMAA59IXV1dPP300zFt2rTYtm2bhgDNzrBhwxJT61/+8pcXTQwAoHnxDWAAgF3g1ltvnV9fX782CbUefvjhkUqlDA34yBoaGmLq1Klx6623xuOPPy78BZqlJF3/XFdXt/rWW29dYGoAAM2LE8AAALtAQ0NDZs2aNc/16dPns9lea7t27aJPnz6xZMkSgwM+7J9xMW3atHjqqaeiurpaQ4Bmbb/99ou2bdsmotbVq1fPNDEAgOZHAAwAsIs8++yz05IQAEdEHHHEEQJg4AOl0+mYNWtWTJo0KTZt2qQhABFx5JFHJqbW6dOnTzMxAIDmxxXQAAC7yC233PJaQ0NDZRJqHT58eLRo0cLQgJ1Kp9Px3HPPxW233Rb333+/8Bdgh6KiovjUpz6ViFobGho23HLLLXNNDQCg+XECGABgF6murk6Xl5c/t88++5yR7bW2bNkyDj300Hj55ZcNDvindDodL7/8ckyZMiXKy8s1BOBdhgwZEkVFRYmodc2aNc/V1tamTQ0AoPkRAAMA7EIvvvjiM0kIgCMiRo4cKQAGIiIik8nE7NmzY+LEibFmzRoNAXif/VNSzJo161kTAwBongTAAAC70O233/7KOeecszU/P78022sdMGBAtG/f3tWu0My9+uqrMWnSpFi1apVmALyPjh07xgEHHJCIWhsbG6u/8Y1v/NXUAACaJwEwAMAutHLlyob169fP6tat2+hsrzWVSsXhhx8ekyZNMjhohubMmROTJ0+OJUuWaAbAh3D44YdHKpVKRK3r16+fVVFR0WhqAADNU54WAADsWq+++mpirts77LDDDAyamTfffDP+/d//PX7yk58IfwE+pFQqFSNGjEhMva+88sozpgYA0Hw5AQwAsIvddNNNz5166qnV+fn5rbO91m7dukX//v1j4cKFBgc5btmyZfHYY4/F/PnzNQPgIzrggAOic+fOiai1sbFxy4033jjL1AAAmi8BMADALrZy5cqG8vLyGT179vx0Euo9+uijBcCQw5YvXx7jxo0T/AJ8wv1SUpSXlz9TXl7eYGoAAM2XABgAYDeYMWPGUxdccEEiAuAhQ4ZE69ato7q62uAgh6xcuTImTJgQc+fOjUwmoyEAH1ObNm3i0EMPTUy9zz777FOmBgDQvPkGMADAbvDVr371lYaGhk1JqLWgoCCOOOIIQ4McsW7duvj5z38ed955Z8yZM0f4C/AJjRw5MvLz8xNRa0NDw8abbrrpVVMDAGjenAAGANgNKisrm1atWjW9T58+5ySh3qOPPjqefPJJQREk2Pr16+Oxxx6L2bNn+3cZYBdJpVIxatSoxNS7cuXKadXV1WmTAwBo3pwABgDYTaZNm5aY6/c6duwYAwYMMDRIoA0bNsSvf/3r+Nd//dd49dVXhb8Au9CAAQOiY8eOian36aefftLUAAAQAAMA7CZf+9rX5tTX11ckpd6jjjrK0CBBqqqq4v77749vf/vb8eKLL0ZTU5OmAOxiRx55ZGJqra+vX/eNb3zjdVMDAMAV0AAAu0ltbW16xYoVT++///6fT0K9hx56aLRt2zaqqqoMD7LYli1bYsqUKfHcc8/F9u3bNQRgN2nbtm0MGTIkMfUuX778qdraWtc/AwDgBDAAwO70xz/+cUJSas3Pz4/jjjvO0CBL1dTUxKOPPhq33XZb/OUvfxH+Auxmxx57bOTn5yel3Myvf/3rCaYGAECEABgAYLe66667llZXV89PSr1HH310tGjRwuAgi7wd/H7jG9+IqVOnRn19vaYA7GYtWrSIo48+OjH1btmy5Y177rlnhckBABDhCmgAgN3u9ddfn3T44YcPSEKtxcXFcdhhh8XMmTMNDvayurq6ePrpp2PatGmxbds2DQHYgw477LAoKSlJTL3z5s17wtQAAHibE8AAALvZ9773vanpdLohKfWecMIJkUqlDA72koaGhpg6dWrceuut8fjjjwt/AfawVCoVJ5xwQmLqTafT27/73e8+ZXIAALzNCWAAgN1s+vTpWyoqKmZ26dIlER/Y7d69e/Tv3z/efPNNw4M9qKGhIaZNmxZPPfVUVFdXawjAXnLAAQdE9+7dE1NvRUXFczNmzPAXBwAA/+QEMADAHjBr1qxEXcuXpFMvkHTpdDqee+65uP322+PRRx8V/gLsZccff3yi6p0xY8YkUwMA4J2cAAYA2AO++tWvvnT66adXFRYWtk1CvQMHDoyOHTvGhg0bDA92k3Q6HbNmzYrJkyfHxo0bNQQgC3Ts2DEGDhyYmHobGhoqb7755pdMDgCAd3ICGABgDygvL29YsWLF1MRsEvPy4sQTTzQ42A3S6XS8+OKL8Z3vfCfuv/9+4S9AFjnppJMiLy85r8tWrFgxpaKiotHkAAB4JwEwAMAe8qtf/erRiMgkpd6jjjoqysrKDA52kUwmE6+++mp873vfi1//+texdu1aTQHIImVlZXHUUUcl6q+W//7v//6zyQEA8G4CYACAPeQ///M/l1dWVv4tKfUWFhbGMcccY3CwC7wd/P785z+PNWvWaAhAFjruuOOioCA5X0urqqqa/dOf/nS1yQEA8G4CYACAPeill14al6R6jzvuuCgqKjI4+JjmzJkTd911V/z85z+P1au9owfIVkVFRYn7xbcXXnhhnMkBALAzBVoAALDnjB079pkFCxZUFhYWtktCvSUlJXHEEUfE9OnTDQ8+gjfffDPGjx8fb731lmYAJMCRRx4ZJSUliam3oaFh0zXXXPOsyQEAsDMCYACAPai8vLxh6dKlE/v3739xUmo+8cQT49lnn410Om2A8AEWLVoUjz32WCxevFgzABIiLy8vTjzxxETVvGTJkifKy8sbTA8AgJ3ucbUAAGDP+u1vfzsxIjJJqbdjx44xdOhQg4P3sXz58rj77rvjRz/6kfAXIGGGDRsWHTp0SFLJmd/85jePmxwAAO9FAAwAsIf953/+5/JNmza9kqSaTz/99EilUoYH77Jy5cr4yU9+Et///vdj/vz5GgKQMHl5eXHGGWckquZNmza9fM8996wwPQAA3osroAEA9oKXXnpp/KmnnnpYUurt2rVrDBkyJGbPnm14EBHr1q2L8ePHx+zZsyOTyWgIQEINHTo0OnfunKiaX3jhhQkmBwDA+xEAAwDsBZdffvkzS5YsWVdUVNQlKTWfccYZ8be//U3YRbO2fv36eOyxxwS/ADkglUrF6aefnqia6+rq1lx22WXTTQ8AgPcjAAYA2AsqKyub5s+f/8ihhx56dVJq7tatm1PANFsbNmyIxx9/PF555ZVoamrSEIAc8KlPfSq6du2aqJrfeOONcdXV1WnTAwDg/fgGMADAXvL1r399XDqdrktSzb4FTHNTVVUV999/f3z729+OF198UfgLkCNSqVR8+tOfTlTN6XS69pvf/OZjpgcAwAdxAhgAYC+ZMWNG9Zo1a/7Ss2fPxLx97N69ewwcODDmzJljgOS0LVu2xIQJE+KFF16IxsZGDQHIMYceemh069YtUTWvXr36qRkzZlSbHgAAH8QJYACAvejXv/71HyMiUR8SPeuss5wCJmdt27YtHn300bjtttviueeeE/4C5KC8vLwYM2ZM0srO/OpXv/qT6QEA8KH2vFoAALD3fP/733+rqqoqUR/V7dGjR3zqU58yPHJKfX19TJ06Nb71rW/F1KlTo76+XlMActSIESOiS5cuiap506ZNf73rrruWmh4AAB+GABgAYC975plnHkpazWeccUbk5dlKkjvmzZsXjz76aGzdulUzAHJYQUFBnH766Ymre9q0aQ+aHgAAH5a3dgAAe9nYsWNn1tfXr01SzZ07d47DDjvM8ACARBk5cmR06NAhUTXX1dWtHjt27POmBwDAhyUABgDYyyorK5tee+21Pyat7jPPPDMKCgoMEABIhBYtWiTy9O/s2bP/UF1dnTZBAAA+LAEwAEAWuOqqqyY0NjZWJanm9u3bx9FHH214AEAiHHfccdGmTZtE1dzQ0LDxiiuumGh6AAB8FAJgAIAssGDBgrqFCxc+lrS6R48eHYWFhQYIAGS1li1bxsknn5y4uhcuXDhu6dKl200QAICPQgAMAJAlvv71r/8pnU7XJqnmtm3bximnnGJ4AEBWO+2006K0tDRRNTc1NdV+7Wtfe8j0AAD4qATAAABZ4umnn968fPnyxF3xN3r06GjXrp0BAgBZqUOHDnH88ccnru5ly5ZNmD59+hYTBADgoxIAAwBkkbvvvvtPmUymKUk1FxYWxumnn254AEBWOvPMMxP3yYpMJtN41113/dH0AAD4OATAAABZ5Be/+MWatWvXTkta3UcccUT06tXLAAGArNK7d+847LDDEld3eXn5X+6///51JggAwMchAAYAyDIPP/zwn5JWcyqVijPPPNPwAICsMmbMmEilUomr+8EHH/yT6QEA8HEJgAEAsszXv/71NzZs2DAraXUPHDgwDj74YAMEALLCoEGDYsCAAYmru6KiYuatt966wAQBAPi4BMAAAFlo3Lhxv01i3WPGjIm8PFtMAGDvysvLizFjxiSy9j//+c+/NUEAAD7RflgLAACyz/XXXz+nqqrqr0mru1evXnHUUUcZIACwVx1zzDHRvXv3xNW9adOmV2666aa5JggAwCchAAYAyFJ/+tOf7k1i3WPGjInS0lIDBAD2ijZt2sRZZ52VyNofeOCBe00QAIBPSgAMAJClbrrpprlJPAVcXFwcZ555pgECAHvFWWedFS1btkxc3Zs2bXrl5ptvnmeCAAB8UgJgAIAsNm7cuF8lse5Ro0ZF7969DRAA2KP69OkTI0eOTGTtjz322K9MEACAXUEADACQxcaOHTu7qqrqb0mrO5VKxfnnnx+pVMoQAYA9tv/4/Oc/n8j9R2Vl5d+uueaav5kiAAC7ggAYACDLTZ069bdJrLtv374xZMgQAwQA9ojDDjsssTeQTJ48+TcmCADAriIABgDIcpdeeumLVVVVryax9s9//vNRXFxsiADAblVaWhrnn39+Imuvqqr66+WXX/6SKQIAsKsIgAEAEuChhx76WRLrLisri9NPP90AAYDd6qyzzoqSkpIklp753e9+91MTBABgVxIAAwAkwA033DB3w4YNs5JY+3HHHRd9+vQxRABgt+jbt28cddRRiay9oqJi1te//vU3TBEAgF1JAAwAkBA///nPfxoR6aTVnUql4vOf/3zk5dl6AgC7Vn5+flx00UWRSqWSWH76F7/4xX+bIgAAu5q3cAAACXHHHXe8tW7duulJrL13795xzDHHGCIAsEudcMIJ0b1790TWXl5e/pc77rjjLVMEAGBXEwADACTI3XfffW8mk2lKYu1nnXVWtG3b1hABgF2iQ4cOcfrppyey9kwm03T33Xf/3BQBANgdBMAAAAlyzz33rCgvL386ibW3bNkyzj33XEMEAHaJc889N1q0aJHI2tesWTP1xz/+8UpTBABgdxAAAwAkzA9/+MOfZzKZhiTWPnz48Bg0aJAhAgCfyKGHHhpDhw5NZO3pdLrhBz/4wS9MEQCA3UUADACQMPfee+/qRYsWPZDU+i+++OIoKSkxSADgY2ndunVcfPHFia1/4cKFf7jvvvvKTRIAgN1FAAwAkECXXXbZrxsaGjYlsfaysjJXQQMAH9u5554bpaWliay9oaFh4+WXX/47UwQAYHcSAAMAJNDs2bNrXn311V8ntf4jjjgiDj74YIMEAD6SwYMHx+GHH57Y+l955ZX7Zs+eXWOSAADsTgJgAICEOueccx6tqalZmtT6L7roomjZsqVBAgAfSsuWLeNzn/tcYuuvqalZMmbMmMdMEgCA3U0ADACQUJWVlU3Tpk37RVLrb9++fZx++ukGCQB8KGeccUa0b98+sfU/+eST91ZXV6dNEgCA3U0ADACQYOedd960qqqqV5Ja/wknnOAqaADgAx188MFx/PHHJ7b+TZs2vXzBBRc8a5IAAOwJAmAAgIT74x//eG9EZJJYeyqVigsuuMBV0ADAe2rZsmVccMEFkUqlkrqEzP333/8zkwQAYE8RAAMAJNzNN988b9WqVU8ktf6OHTsm+nt+AMDudcEFF0THjh0TW/+KFSse//rXv/6GSQIAsKcIgAEAcsCNN974k6ampq1JrX/kyJExdOhQgwQA/pdPfepTMWLEiMTW39TUVH3zzTf/t0kCALAnCYABAHLAxIkTK//+97//KslruPDCC6OsrMwwAYCIiGjTpk18/vOfT/QaZs+efd/EiRMrTRMAgD1JAAwAkCPOPvvsh2pqapYntf7S0tK46KKLDBIAiFQqFV/84hejtLQ0sWuoqal566yzznrYNAEA2NMEwAAAOaKioqJx0qRJP07yGgYPHhwjR440TABo5o444og46KCDEr2GJ5544qeVlZVNpgkAwJ4mAAYAyCGXXHLJzIqKihlJXsMFF1wQ3bp1M0wAaKZ69uyZ+KufKyoqZnzhC1+YZZoAAOwNAmAAgBzzb//2b/ek0+ntSa2/RYsWceWVV0ZhYaFhAkAzU1hYGF/60pcSvQ9Ip9Pb/+3f/u0e0wQAYG8RAAMA5Jh777139aJFix5M8hq6d+8eZ555pmECQDNzxhlnRPfu3RO9hsWLFz947733rjZNAAD2FgEwAEAO+uxnP/vL2traRL94PPHEE2Pw4MGGCQDNxKBBg+Kkk05K9Bpqa2tXn3vuub80TQAA9iYBMABADlq8eHH9uHHj/j3Ja0ilUnHJJZdE27ZtDRQAclybNm3ikksuiVQqleh1jBs37t8XL15cb6IAAOxNAmAAgBx1+eWXv1RRUTEjyWsoLS2NL3zhC4l/GQwAvLe3f+mrdevWiV5HRUXFM5dffvlLJgoAwN4mAAYAyGE33HDDXU1NTVuTvIaDDjrI94ABIId95jOfiUMOOSTRa2hqaqq+4YYbfmiaAABkAwEwAEAOGzdu3MbZs2cn/jt0p5xyiu8BA0AOOuSQQ+LTn/504tfx17/+9efjxo3baKIAAGQDATAAQI77zGc+81B1dfXCJK8hlUrFF7/4xejQoYOBAkCO6NixY3zpS19K/KceNm/ePO+00057xEQBAMgWAmAAgBxXXV2dfuCBB34UEekkr6O4uDguvfTSyMuzhQWApMvPz4/LLrssiouLk76U9P333/+ftbW1aVMFACBbeHsGANAMXH/99XMWLVr0YNLXsf/++8e5555roACQcOedd1707ds38etYuHDhH7/61a++bqIAAGQTATAAQDNxySWX/Lyurq486es4/vjjfQ8YABJs2LBhccwxxyR+HXV1dWsuvPDC+0wUAIBsIwAGAGgmXnvttdoHHnjguxGRSfI6UqlUfOlLX4oePXoYKgAkTO/evePSSy9N/Hd/IyLzwAMPfO/111+vNVUAALKNABgAoBm5+uqr/7Z06dJHk76OoqKiGDt2bJSWlhoqACRE69at46qrrorCwsLEr2X58uXjrr766r+ZKgAA2UgADADQzJx33nn/r66ubnXS19GhQ4e4/PLLIy/PlhYAsl1eXl5cfvnl0b59+8Svpb6+ft0ll1zyE1MFACBr999aAADQvLz++uu1Dz744Pcj4VdBR0QMGDAgzjrrLEMFgCw3ZsyYOPDAA3NiLY899tgPXnnllW2mCgBAthIAAwA0Q1/5ylf+umbNmqm5sJaTTz45Dj30UEMFgCw1ZMiQOOmkk3JiLWvXrv3LpZde+oKpAgCQzQTAAADN1GWXXfYf9fX1FUlfRyqViksvvTS6d+9uqACQZXr06BFf/OIXI5VKJX4tDQ0Nm6655pofmioAANlOAAwA0EzNmDGj+oEHHvhO5MBV0C1btozrr78+2rZta7AAkCXatWsX1113XbRs2TIXlpN56KGH/nXSpElVJgsAQLYTAAMANGNf+cpX/rpkyZI/58Ja2rZtG1dffXW0aNHCYAFgL2vRokVcffXVOfPLWUuXLn30iiuueNlkAQBIAgEwAEAzd+655/6ktrZ2eS6spXfv3jlzzSQAJNXbn2fYZ599cmI9tbW1y88555wfmywAAEkhAAYAaOYWLFhQ97Of/ezbmUymMRfWM2zYsDjllFMMFgD2kk9/+tMxdOjQnFhLJpNp/NnPfvbtBQsW1JksAABJIQAGACBuvfXWBfPnz78/V9Zz5plnxuDBgw0WAPaw4cOHx2c+85mcWc/8+fN/d+utty4wWQAAkkQADABARESMGTPmvpqamrdyYS2pVCouu+yy6Nmzp8ECwB7Su3fvuPjii3PmUwxbt25ddPrpp//aZAEASBoBMAAAERGxcuXKhh/+8Ie3pdPpnLjisGXLlvEv//Iv0aVLF8MFgN2sS5cucf3110dRUVFOrKepqanmu9/97jfKy8sbTBcAgKQRAAMA8E933XXX0ueff/6eXFlPaWlpXHvttVFWVma4ALCblJWVxXXXXRclJSU5s6aZM2fe/f/+3/9bZboAACSRABgAgP/l5JNPHldeXv50rqynU6dOMXbs2Jw5kQQA2aSoqCiuueaa6NixY86sqby8/MlTTz11gukCAJBUAmAAAP6PSy655K66urq1ubKefffdN6644orIy7P9BYBdJS8vL6688sro3bt3zqyprq6u/JJLLvmh6QIAkOi9uhYAAPBus2bNqn7ooYfujIh0rqxp4MCBcd555xkuAOwi559/fhxyyCG5tKT0gw8+eOesWbOqTRcAgCTLb3tQ9NzpjndbRG15oQ4BADRTEydOXDNmzJi8Tp06Dc2VNfXp0yfy8/PjzTffNGAA+ATOOuusOOmkk3JqTa+//vp9Z5555kTTBQAgCYq7N0Ze6c5/5gQwAADv6dRTT/31li1bXs+lNZ122mlx9NFHGy4AfEzHHntsnHrqqTm1pi1btrxx2mmn/cZ0AQDIBQJgAADeU0VFReONN974jcbGxqpcWtcFF1wQRx55pAEDwEd05JFHxuc+97mcWlNjY2PVzTff/I2KiopGEwYAIBcIgAEAeF9//OMf1z/yyCPfiRz6HnAqlYqLLroohgwZYsAA8CENHTo0LrrookilUrm0rPQjjzzynfvvv3+dCQMAkCsEwAAAfKBLL730hQULFvwupzbCeXnxpS99Kfbff38DBoAPcNBBB8WXvvSlyMvLrVdJCxYs+N2ll176ggkDAJBLBMAAAHwoo0eP/mVVVdXcXFpTYWFhfOUrX4kePXoYMAC8h169esUVV1wRBQUFObWuqqqqOaNHj/6lCQMAkGsEwAAAfCgVFRWNV1111S0NDQ0bcmldJSUlcfPNN8c+++xjyADwLr17946bbropiouLc2pdDQ0NG6666qqv++4vAAC5SAAMAMCHNmHChE3333//tzKZTDqX1lVcXBzXXXdddO/e3ZABYIfu3bvHtddeG61atcqpdWUymfT999//rQkTJmwyZQAAcpEAGACAj2Ts2LGz58+f/9tcW1fr1q3juuuuiw4dOhgyAM1ehw4d4rrrrovWrVvn3Nrmz5//m7Fjx842ZQAAcpUAGACAj+y44477xaZNm17MtXW1a9cubrzxxmjXrp0hA9BstW3bNmf/Pty4ceOLxx13nO/+AgCQ0wTAAAB8ZNXV1emLL774W3V1datzbW0dO3aMG2+8Mdq0aWPQADQ7ZWVlceONN0bHjh1zbm21tbWrL7zwwturq6vTJg0AQC7Lb3tQ9NzZD9LbImrLC3UIAICdWrZsWf327dtfOvbYY0/Ny8trkUtrKykpiaFDh8Zrr70WNTU1hg1As9ChQ4f42te+Fp06dcq5tTU1NW39zne+M/bBBx9cb9IAAOSC4u6NkVe6858JgAEA+NhefPHFzYcccsiyAQMGnBgRqZzaRBcXx5AhQ4TAADQLHTt2jJtuuik6dOiQi8tLjx8//ravfvWrc0waAIBc8X4BsCugAQD4RC688MIZb7zxxm9ycW3t27ePm266KSdPQgHA2zp16pTL4W+88cYbv77wwgufM2kAAJoLATAAAJ/YqFGjfrFhw4aZubi2t0Pgzp07GzQAOadz585x0003Rfv27XNyfRs2bJg5atSo+0waAIDmRAAMAMAnVltbm77sssu+V1dXtzoX19euXbu44YYbomPHjoYNQM7o0KFDXH/99dGuXbtc3Z+s/sIXvvDd2tratGkDANCc+AYwAAC7xJIlS+oj4pVRo0admpeX1yLX1ldcXBxDhw6NuXPnxrZt2wwcgETr0qVL3HjjjTl77XNTU1P1nXfeec0f/vCHdaYNAEAuer9vAAuAAQDYZWbNmlXVo0ePuYceeujoVCqVn2vra9WqVYwYMSIWLVoUlZWVBg5AIu23335x0003RVlZWU6uL51ON/z617++4fbbb3/TtAEAyFUCYAAA9phJkyatPeqoozbsu+++R+fi+goLC2P48OGxbNmy2LBhg4EDkCgDBgyIa6+9Nlq1apWza5w2bdq/XXLJJc+ZNgAAuez9AmDfAAYAYJc77bTTHn/rrbcezNX1FRUVxTXXXBNDhgwxbAASY8iQIXHNNddEUVFRzq5xwYIFvzv99NOfMG0AAJozATAAALvFEUcccc+GDRtm5ur6CgoK4sorr4wjjjjCsAFIwt/LceWVV0ZBQUHOrrG8vPypESNG/LdpAwDQ3AmAAQDYLaqrq9MXXXTRd2pra1fk7GY6Ly8uvvjiOPLIIw0cgKw1atSouPjiiyMvL3dfA23dunXxZz/72e83NDRkTBwAgObON4ABANhtli9fvr2mpuaFY4899uT8/PyWubjGVCoVgwYNikwmE4sWLTJ0ALLK6aefHueee26kUqmcXWN9fX3FDTfccM3UqVOrTBwAgObi/b4BLAAGAGC3evnll7cUFBS8cMQRR4zOy8trkYtrTKVSccABB0SnTp1i7ty5kck4fATA3lVYWBhXXHFFHHPMMTm9zsbGxuo777zzKz/72c9WmzoAAM2JABgAgL1qxowZlb169Xp98ODBJ6dSqfxcXWfPnj2jb9++8fe//z0aGxsNHoC9olWrVnH11VfHwIEDc3qd6XS64be//e2Nt9122wJTBwCguREAAwCw1z3xxBPlw4cPX9OvX79jIyJn76Hs2LFjDBw4MObMmRN1dXUGD8Ae1a5du7jxxhujT58+ub7U9JQpU779xS9+8XlTBwCgOXq/ADhPewAA2FPGjBkz9Y033vh1rq+zZ8+eceONN0bHjh0NHYA9pkuXLnHTTTdF9+7dc36tc+fO/eU555zzF1MHAID/SwAMAMAe9alPfernS5cufTjX19mlS5e49dZb48ADDzR0AHa7gQMHxje/+c3o1KlTzq/1rbfeemjEiBG/MnUAANg5ATAAAHvcsccee8/GjRtfyPV1FhcXx7XXXhsjRowwdAB2m8MPPzyuuuqqaNmyZc6vdePGjc8fffTR95g6AAC8NwEwAAB7XEVFReNxxx339crKyr/l+loLCgrisssui/PPPz9SqZThA7DLpFKpOP/88+PSSy+NgoKCnF/vpk2bXj7ssMNuqaysbDJ9AAB4bwJgAAD2isWLF9efddZZN1dXV7/ZHNZ7/PHHx5e//OUoKioyfAA+sRYtWsSXv/zlOP7445vFequrq98cM2bMN8rLyxtMHwAA3l9+24Oi585+kN4WUVteqEMAAOw2a9asaVi1atWs0aNHH1dQUNA619fbrVu3OOCAA2LevHlRX1/vAQDgYykrK4trrrkmDjrooGax3rq6uvKxY8de89RTT202fQAA+Ifi7o2RV7rznwmAAQDYq+bNm1ezevXqZ04++eTjCwoKSnN9ve3atYuRI0fG8uXLY+PGjR4AAD6S/v37x0033RRdu3ZtFuutr69fd9111335T3/6U4XpAwDA/xAAAwCQ1ebMmbMtlUq9fOSRR56Ul5eX83ckt2jRIkaMGBG1tbWxdOlSDwAAH8rxxx8fX/rSl5rN5wQaGxu33HXXXdf99Kc/XWn6AADwvwmAAQDIejNnzqzs2bPn64MHDz4plUrl5/p6U6lUHHLIIdGqVatYsGBBZDIZDwEAO5WXlxef/exn4/TTT49UKtUs1pxOp7f//ve//+o3vvGN1z0BAADwfwmAAQBIhEmTJpXvs88+8wYOHHhCKpUqaA5r3m+//WLAgAExd+5c3wUG4P8oKyuL6667LoYNG9Zs1pxOp7f/8Y9/vOmqq676qycAAAB2TgAMAEBiTJw4cc3BBx+85MADDzwulUrlNYc1t2/fPoYOHRqLFi2KLVu2eAgAiIiIffbZJ66//vro2bNns1lzJpNpnDBhwm1f/OIXn/cEAADAexMAAwCQKI8++ujy/fff/42DDjrohOZwHXRERHFxcRx11FHR2NgYb731locAoJkbPXp0XHHFFVFSUtJs1pxOpxsefvjhr15yySWzPAEAAPD+BMAAACTO+PHjVw0cOHDpAQcccGxzOQmcSqViwIAB0aVLl3jjjTeiqanJgwDQzBQVFcWll14aJ554YrP53m/EP07+Pv7447dffPHFMz0FAADwwQTAAAAk0iOPPLLs0EMPXbb//vs3mxA4IqJHjx4xZMiQePPNN2Pr1q0eBIBmonv37vEv//IvccABBzSrdWcymaYnnnji9s997nPPeAoAAODDEQADAJBYDz/88NJjjjlmY+/evY+KiGZzFKq0tDSGDx8eq1evjvXr13sQAHLcwIED45prrol27do1t6VnZsyY8YOzzjprqqcAAAA+PAEwAACJdv/99795zDHHVO6zzz5HRDMKgVu0aBGHHXZYtGzZMhYuXBjpdNrDAJBjCgoK4pxzzonzzz8/WrRo0dyWn37uuefuOuWUUyZ4EgAA4KMRAAMAkHi///3v5w8bNmxF3759j2lO10GnUqno27dvDB06NBYvXhxbtmzxMADkiJ49e8YNN9wQgwcPblbf+434x7XPU6ZM+fbpp58+2ZMAAAAfnQAYAICc8OCDDy4ZNmzYin79+jWrEDgionXr1nHEEUdEfX19LF261MMAkGCpVCpOOOGEuOKKK6JNmzbNbv07wt9vnXPOOX/xNAAAwMcjAAYAIGc89NBDS4YNG7a8X79+xza3EDg/Pz8OPvjg6NWrV8yfPz8aGho8EAAJU1JSEpdffnmccMIJkZ+f3+zWn8lkGp944olvffazn53maQAAgI9PAAwAQE556KGHlo4cOXJdnz59RqWa252ZEdG1a9cYNmxYLFu2LCorKz0QAAnRt2/fuO6662K//fZrluvPZDLpp59++rvnnHPO054GAAD4ZATAAADknD/96U+LDj300KX7779/s7sOOiKiuLg4jjzyyCgpKYk333wz0um0hwIgSxUUFMRnP/vZuPDCC6OkpKRZ9iCdTjc88sgjt5x//vnTPREAAPDJCYABAMhJDz/88NId3wQelUqlmt09mqlUKvr06RMHH3xwLFy4MLZt2+ahAMgynTt3jrFjx8bQoUOjGV5aERH/CH+feOKJ2y+88MLnPBEAALBrCIABAMhZDz300JIePXq8NmjQoGPz8vJaNMcetG3bNkaNGhVNTU2xZMkSDwVAFkilUjF69Oi48soro0OHDs22D01NTdt++9vf/stll132oqcCAAB2HQEwAAA5bdKkSeXdu3efM3jw4GYbAufn58eAAQOiV69esWDBgti+fbsHA2Avad26dVx66aVx/PHHR35+frPtQ2NjY/WvfvWrf7nuuute81QAAMCuJQAGACDnTZ48eW1jY+OMI4444uiCgoKS5tqHrl27xqhRo2Lbtm2xcuVKDwbAHpRKpWLUqFExduzY6NWrV7PuRX19/fo77rjjK9/61rcWejIAAGDXEwADANAsPP/881UbNmx45rjjjjuqsLCwrLn2obCwMAYNGhT77bdfLF68OGpraz0cALtZ+/bt44orrogTTzwxCgub9/uU2tralTfffPPVP/nJT1Z7MgAAYPcQAAMA0Gz87W9/27p27doZJ5xwwsjCwsK2zbkXnTp1ipEjR0Z1dbXTwAC70ciRI+Pqq6+OHj16NPte1NTULL/hhhuu/e1vf7vOkwEAALuPABgAgGbltdde2zpv3rynTznllKFFRUWdmnMvCgsL49BDD4399tsvFi1a5DQwwC709qnfk08+udmf+o2I2Lx587yLL774unHjxm30dAAAwO71fgFwat9zYsTOftC4LmLjq610DwCAxOrVq1fhs88++69du3Y9QTciGhoaYurUqTF58uRobGzUEICPqaCgIE499dQYPXq04HeH8vLyp4499tjvrly5skE3AABg9+swrDYKuuz8ZwJgAAByWuvWrfNeeumlm/fdd9+zdeMfVq9eHffff38sWbJEMwA+ov322y8uuugi1z2/w8KFC38/fPjwnzY0NGR0AwAA9gwBMAAAzd7zzz9/8aGHHnp1RKR0IyKTycTMmTPjz3/+c9TV1WkIwAcoKSmJ8847L0aMGBGplL9Kdki//PLL9xx77LEPagUAAOxZ7xcA+wYwAADNwn333Tfn+OOP39yrV6/DQwgcqVQqevfuHcOHD49169ZFRUWFhwTgPRxyyCExduzY6N+/v/B3h0wm0/jMM8/828knnzxONwAAYM97v28AC4ABAGg2fve7370xePDgJf369Ts6lUrl60hEcXFxjBgxInr06BFLly6N2tpaTQHYoUOHDvGFL3whzjzzzCguLtaQHZqammoeeOCBWz73uc9N1w0AANg7BMAAALDDww8/vKygoOC54cOHH1FQUFCqI//QrVu3OO6446K0tDQWL14cTU1NmgI0Wy1btoxzzjknLr300ujevbuGvENtbe2K22677arbbrvtDd0AAIC9RwAMAADv8Oyzz25avHjx0yeddNKQoqKiTjryD3l5edGnT58YOXJkbN26NVatWqUpQLNz+OGHx1e+8pUYMGBA5OXlacg7VFVV/e3CCy+8/oEHHvDdAAAA2MsEwAAA8C7z58+vefbZZ58+44wz+hcXF/fSkf/RsmXLGDJkSOyzzz6xdOnSqKmp0RQg53Xs2DG++MUvximnnBItW7bUkHdZt27dMyeffPI3Xn755W26AQAAe9/7BcCpfc+JETv7QeO6iI2vttI9AAByWmFhYer555//0sEHH3y5bvxfTU1N8fzzz8f48eOjurpaQ4Cc07p16zjzzDPjyCOPdOJ35zJ///vff3rMMcfc39DQkNEOAADIDh2G1UZBl53/TAAMAAARMWnSpM8cc8wxt6RSKdfg7ERNTU1MmTIlpk2bFg0NDRoCJF5hYWGccsopcdJJJ0VRUZGG7EQ6na6fOnXqd88555y/6AYAAGSX9wuAXQENAAAR8Yc//GHhfvvt98aAAQOOysvLkwS8S2FhYQwYMCCGDh0amzZtinXr1mkKkFiDBw+Oq666KoYOHRoFBQUashONjY1Vv//972/5whe+MEs3AAAg+/gGMAAAfAgTJkxYXV1dPf3II4/8VGFhYTsd+b9KS0vjsMMOi/79+8eaNWti8+bNmgIkRu/evePyyy+PU045JUpLSzXkPWzdunXxLbfccs33vve9hboBAADZyTeAAQDgI+jTp0+LJ5988us9evQ4TTfe3/z58+ORRx6JlStXagaQtXr16hXnnHNODBgwQDM+wKpVq5444YQTfrBy5Ur3/QMAQBbzDWAAAPgYnnnmmfOHDx9+fSqVytON95bJZGL27Nkxbty4qKio0BAga3Tu3DnOOuusGDp0aKRSKQ15/z/Lm2bNmvXDk08++THdAACA7OcbwAAA8DH85je/eX3//fd//cADDzzSd4HfWyqViu7du8cxxxwT7dq1i2XLlkV9fb3GAHtN27Zt49xzz42LL744evToIfz9AI2NjdUPPvjgLZ/97Gf/ohsAAJAMvgEMAAAf0/jx41dFxPOHHXbYiMLCwjIdeW95eXnRu3fvOOqoo6KgoCBWrlwZjY2NGgPsMcXFxXHKKafEl770pejbt2/k5bnA4YPU1tau+MEPfnD9LbfcMk83AAAgQf/94xvAAADwyQwePLjVo48++s1u3bqdpBsfTn19fTzzzDMxderU2LZtm4YAu01ZWVmceuqpceSRR0ZRkQsbPqyVK1c+/ulPf/pHixcvdm0DAAAkjG8AAwDALvLkk0+edeSRR96USqVcl/MhCYKB3eXtE7/HHnus4PcjyGQyDbNmzfoP3/sFAIDk8g1gAADYRX7/+98v6NGjx2uHHHLIyPz8fL8x+SEUFBREv3794qijjoq8vLxYtWqVq6GBT6Rly5ZxwgknxBVXXBEHHXRQFBQUaMqH1NDQsOG3v/3t1z7/+c8/oxsAAJBcroAGAIBd7Lzzzut4991339m2bdvBuvHR1NTUxLPPPhvTpk2LLVu2aAjwoZWVlcXxxx8fxxxzTBQXF2vIR1RVVfW3a6+99vZHHnlkg24AAECyuQIaAAB2g06dOhVMmzZtbN++fT8XESkd+WgaGhri+eefjyeffDI2bJBFAO/7522cdNJJccQRR0RhodvKPobMokWL/nTsscf+pLKyskk7AAAg+QTAAACwG/3hD38Ydfrpp99WUFDQRjc+unQ6Ha+++mpMnTo1Vq5cqSHAP/Xq1StOOeWUGDp0aOTl5WnIx9DY2Fg1YcKEOy666KKZugEAALlDAAwAALvZaaed1vbee+/9docOHUbqxse3fPnymDZtWrz88suRTqc1BJqhvLy8OOyww+L444+P3r17a8gnsHHjxue//OUvf3fSpElVugEAALlFAAwAAHtAYWFh6qmnnjpv+PDh16RSKXeUfgIbNmyIGTNmxHPPPRc1NTUaAs1AcXFxjBo1Ko4++ujo2LGjhnwCmUym4ZVXXvl/J5100kMNDQ0ZHQEAgNzzfgFwftuDoufOfpDeFlFb7p0VAAB8WOl0On7zm9+8Xlpa+uLgwYM/VVhYWKYrH09xcXEMGDAgjj322GjTpk2sXbs2amtrNQZyUIcOHeKMM86ISy+9NAYOHBjFxcWa8gnU1tau+slPfnLjxRdf/IybFAAAIHcVd2+MvNKd/8wJYAAA2A1OPPHENvfdd9+tnTp1Olo3PrnGxsb429/+Fs8++2wsWrRIQyAH9OvXL44++ugYNmxYFBQUaMguUFFR8cwXv/jFf5s+ffoW3QAAgNzmCmgAANhLHn744RNGjx799YKCgta6sWusX78+Zs6cGc8//3xUV1drCCRIaWlpHHnkkXHUUUdF586dNWQXaWxs3DJ16tS7PvvZz/5FNwAAoHkQAAMAwF50ySWXdP3+97//rXbt2g3VjV2nsbExXnvttXjuuedi/vz5GgJZbMCAATFq1KgYPHiw0767WFVV1atf//rXv/e73/1urW4AAEDzIQAGAIC9rF27dvlTp0699OCDD740lUrl68iutXz58nj++efj5ZdfjpqaGg2BLFBSUhLDhw+PI444Inr37q0hu1gmk2mcN2/efSeeeOJvq6urfewXAACaGQEwAABkia9//ev73Xjjjf9aWlraXzd2vXQ6HW+++WY899xz8dprr0VjY6OmwB5UUFAQgwcPjlGjRsUBBxwQeXl5mrIbVFdXL/zP//zPf/3BD36wRDcAAKB5EgADAEAWOfjgg1v9+c9/vrZ3795jIiKlI7tHZWVlvPjii/HCCy/EunXrNAR2o65du8bIkSPj8MMPj7Zt22rI7pNZunTpn88888z/t3jx4nrtAACA5ksADAAAWejuu+8eePHFF9/WqlUrd6PuZuXl5fHqq6/GSy+9FOvXr9cQ2AU6d+4cI0aMiGHDhkW3bt00ZDerqalZ9tvf/vbOm266aa5uAAAAAmAAAMhS/fr1K3r44Ycv79+//4WpVMpdqXvA8uXL46WXXoqXX345qqurNQQ+grKyshg+fHiMGDHCd333kEwmk164cOEfzj777F8sXbp0u44AAAARAmAAAMh6P/3pT4d97nOf+2bLli176Mae0dDQEHPnzo2//vWvMXfu3Ni+Xa4CO9OyZcsYNGhQDBs2LA455JAoKCjQlD2ktrZ21R//+Mc7rr322r/rBgAA8E4CYAAASIA+ffq0ePTRR69wGnjPS6fTsXTp0nj11VedDIaIaNu2bQwbNiyGDRsWffr0ibw8fyTtSZlMpuG11177+ZlnnvmnioqKRh0BAADeTQAMAAAJ8uMf//jQCy644JutWrXaRzf2vLdPBs+ePTvmzp0bdXV1mkKzUFZWFoMHD45hw4ZF//79Iz8/X1P2gpqammX333//nTfccINv/QIAAO9JAAwAAAnTrl27/HHjxp37qU996qq8vDwb870kk8nEihUrYu7cuTFnzpxYsWJFZDIZjSEnpFKp6Nu3bwwbNiwGDRoUHTt21JS9qKmpqfbVV1/92ZgxY/5cWVnZpCMAAMD7EQADAEBCffnLX+5x++23f7V9+/aH68bet2XLlnjjjTdizpw5MW/evKivr9cUEqVly5Zx8MEHx6BBg+KQQw6J0tJSTckCGzdufPG73/3uv//iF79YoxsAAMCHIQAGAIAEKywsTE2cOPGMkSNHXlNQUNBaR7JDXV1dvPnmm/HGG2/EG2+8EevXr9cUslKXLl3ioIMOioMOOigOOOCAKCoq0pQs0djYuGXmzJk/PvPMMyc2NDS4XgAAAPjQBMAAAJADjjzyyNY/+9nPrujbt++5EZGnI9mluro6Fi5cGPPnz4958+ZFZWWlprBXtGvXLg455JAYMGBA9O/fP1q39nsjWSj91ltv/fmqq676xaxZs6q1AwAA+KgEwAAAkEN++ctfjhgzZsyNrVq16q0b2SmdTsfKlStj0aJFsXDhwli8eHFs27ZNY9gtSkpKol+/ftG/f//Yf//9o1evXpGX53dEslVNTc3yRx999EdXXnnlK7oBAAB8XAJgAADIMd26dSt8+OGHPzd48ODL8vPzbdyzXCaTiTVr1sTChQtj0aJFsWjRotiyZYvG8LGUlZVF//79/xn6du/ePVKplMZkuaampprXXnvtV2PGjHmgoqKiUUcAAIBPQgAMAAA56rjjjiv7r//6r8tdC508mzdvjuXLl8eKFSti+fLlsXjx4qipqdEY/pfi4uLo169f9O7dO/bZZ5/Yd999o6ysTGMSJJPJpJcsWfLn66677pfTp0/3mx8AAMAuIQAGAIAc99Of/nTIueeee3NpaWlf3UimxsbGWLlyZSxdujSWLVsWy5cvj3Xr1kUmk9GcZiKVSkWXLl1in332iT59+kSfPn2iV69eUVBQoDkJtXXr1sUPPvjgj6699tq/6wYAALArCYABAKAZaNeuXf64cePOGTp06BUFBQWtdST56uvrY+XKlf88KbxixYpYu3ZtpNNpzUm4vLy86Nq1a+yzzz7//KdXr17RsmVLzckBjY2NW/7617/+4pxzznm0srKySUcAAIBdTQAMAADNyIknntjmnnvuuXzfffcdk0qlHB3MMdu3b481a9bEmjVrYu3atbF27dooLy+PDRs2CIazUF5eXnTs2DG6desWXbt2jW7dukW3bt2iR48eUVhYqEE5JpPJNC5ZsuRR1z0DAAC7mwAYAACaoa9+9av7Xnfdddd16NDhCN3IfY2Njf8MhNetWxfr1q2LioqKWLduXWzbtk2DdrPS0tLo3LnzP//p0qVLdO3aNbp27eoK52Ziw4YNM//rv/7rxz/60Y+W6wYAALC7CYABAKAZ++UvfznirLPOuq64uNj3gZupmpqaWL9+/T//qaioiMrKyqisrIxNmzZFY2OjJn2AgoKCaN++fbRr1y7at28fHTt2jC5dukSnTp2ic+fOUVxcrEnN1NatW98aP378PVdcccXLugEAAOwpAmAAAGjm2rVrl//ggw+eOWLEiCsLCwvb6gjvtHnz5n+GwZs2bYrKysqorq6OLVu2xJYtW6K6ujqqq6sjk8nk3NpTqVS0bt06WrduHWVlZdGmTZsoLS39X2Fvu3btok2bNh4U/peGhobKl1566efnnHPO+OrqavevAwAAe5QAGAAAiIiIoUOHFt97770XHHjggRfk5+c7ssiHlk6n/xkEV1dXR01Nzfv+k8lkora2NtLpdNTX10dTU1PU1dXt0u8U5+XlRcuWLSM/Pz+KiooiLy8vWrVqFalUKoqLi3f6T0lJSbRq1eqfgW9paWnk5eUZMB9aU1NTzYIFC/745S9/+Y+zZ8+u0REAAGBvEAADAAD/y2mnndb2rrvuurRPnz5n5+XlFeoIe9LbgfDbtm/f/r7XUBcUFESLFi3++b/fDnxhT8pkMg1LliwZd8stt/xq0qRJVToCAADsTQJgAABgp0477bS2d95554X777//5wTBAP9XJpNpWLhw4QO33nrrHwS/AABAtni/ADi/7UHRc2c/SG+LqC33/gcAAHLZokWL6u69995X0un0swcddFCnkpKS3roC8A8VFRUz/7//7/+77aKLLpq6aNGiOh0BAACyRXH3xsgr3fnPBMAAAEDMnDmz8u67736qqalpWr9+/Ypbt27dN5VKpXQGaG4ymUx6zZo1U+65555/Peeccx6cOXNmpa4AAADZRgAMAAB8KDNnzqz88Y9//Gw6nZ4uCAaak7eD37vvvvtfzz///McEvwAAQDYTAAMAAB+JIBhoLgS/AABAEgmAAQCAj+XtILisrOyFvn37diwuLu4VEYJgIBdkKioqnrv33nu/PWbMmEcEvwAAQJK8XwCc2vecGLGzHzSui9j4aivdAwAA/unqq6/u8ZWvfOX8Pn36nJWXl9dCR4CkSafT9UuXLh3/X//1Xw/84he/WKMjAABAEnUYVhsFXXb+MwEwAADwkZ1xxhntb7/99rMPPPDA8/Pz81vrCJDtmpqaqhcsWPDgd77znUcmTpzotC8AAJBoAmAAAGC3GD58eMkPf/jDzwwePPjioqKijjoCZJv6+voNr7322u9vvPHGx2fPnl2jIwAAQC4QAAMAALvV0KFDi++5556zDjnkkPOKioq66giwt9XV1a19/fXXH7z++uvHC34BAIBcIwAGAAD2iFatWuXdc889w0455ZTzO3bseJSOAHtYZsOGDbOmTJny4PXXX/9qbW1tWksAAIBcJAAGAAD2uH/913/tf/7555/dq1ev0/Ly8lroCLC7pNPp+pUrV05+4IEHHvnOd76zSEcAAIBcJwAGAAD2mjPOOKP97bfffvYBBxzw2YKCgjY6AuwqjY2NVW+++eafv/e97z06YcKETToCAAA0FwJgAABgrxs+fHjJ97///dGDBg0aU1paur+OAB9XdXX1wtdee+3Rr371q1Nfe+21Wh0BAACaGwEwAACQVb761a/ue8EFF3y6b9++ZxUUFLTWEeCDNDY2bnnrrbfG/+EPf5j4ox/9aLmOAAAAzZkAGAAAyEpDhw4t/sEPfnDy4MGDz27dunV/HQHerbq6+s2XX375weuuu+7ppUuXbtcRAAAAATAAAJDlCgsLU3ffffeQ0aNHn9G1a9fj8vLyinQFmq90Ol1XXl4+bcqUKROuvfbav+sIAADA/yYABgAAEqNPnz4t/v3f/33UyJEjz2rfvv2nIiKlK9AsZDZt2vTXF1544bGvfe1rzzntCwAA8N4EwAAAQCJddNFFXa6++uqTDzzwwLNbtmzZTUcg99TV1a1ZsGDBuJ/+9KdP3n///et0BAAA4IMJgAEAgETr1q1b4d13333k4YcffmqHDh2OyMvLK9QVSK50Ot2wcePGWbNmzZp8/fXXz6qoqGjUFQAAgA9PAAwAAOSMo48+uvWtt956/CGHHHJKu3btBkdEnq5AIqQrKytfmzdv3uQ777xz+owZM6q1BAAA4OMRAAMAADnpuOOOK/vGN75x/CGHHHJa27ZtB4bvBUO2yVRVVc2dN2/epO9///vTpk+fvkVLAAAAPjkBMAAAkPNuu+22vmedddZJffr0Oa5Vq1a9dQT2ntra2uXLly+f/uijjz51xx13vKUjAAAAu5YAGAAAaFa+9KUvdbv44ouP7t+//wlOBsMekamqqpq7cOHCv/z+97+fcd9995VrCQAAwO4jAAYAAJqtSy65pOtll112jDAYdrl0VVXVvIULF/7lV7/61bO/+93v1moJAADAniEABgAAiIirr766x/nnnz9q//33P7JNmzZDUqlUga7Ah5fJZBoqKyv/vnjx4uf+9Kc/zbr33ntX6woAAMCeJwAGAAB4l379+hV97WtfGzRy5MhRPXv2PLaoqKizrsD/VV9fv37VqlXPvPDCC8/9+7//+5zFixfX6woAAMDeJQAGAAB4H61bt8678847Bx599NFHde/efURpaen+4apomq/M1q1bF69Zs+bF5557btY3v/nNOdXV1WltAQAAyB4CYAAAgI9g8ODBrcaOHXvI8OHDD+vevfvw1q1bHxACYXJXprq6+s01a9a88sorr7z8k5/8ZN5rr71Wqy0AAADZSwAMAADwCVx//fX7nHHGGYf169dvePv27Yfm5+e31hWSrLGxsXrjxo2vvvXWWy+PHz/+lR//+McrdQUAACA5BMAAAAC70Je//OUe55xzzvA+ffoM7tix45CioqKuukI2q6+vX7t27doXFy9ePGfixImv3Xvvvat1BQAAILkEwAAAALvRl7/85R6f+cxnBvfr129Qly5dDm/ZsqVAmL2qrq5u7bp16wS+AAAAOUoADAAAsIe0atUq75prrtnn2GOPPXi//fY7uH379oeUlpb2TaVS+brDbpKuqalZtnHjxnlvvfXW3GeffXbef/3Xfy2vra1Naw0AAEBuEgADAADsRQceeGDLq6+++oAhQ4Yc3LNnz4Pbtm17sGuj+biampqqq6qqXi8vL583Z86ceb/85S/nvfjii1t1BgAAoPkQAAMAAGSZoUOHFn/xi1/cf9CgQQf26NHjwHbt2h3YqlWr3qlUKk932CFdU1OzvLKycsHq1asXzJkzZ8Gf//znJTNmzKjWGgAAgOZNAAwAAJAAxx13XNkFF1xw4MEHH3xA165dDywtLd23pKRkn1QqVag7uS2TyTRs27ZtRXV19dJ169YtfOONNxZOmDBh4YQJEzbpDgAAAO8mAAYAAEiw8847r+OJJ57Yp3///vt16dKlT5s2bfZr3bp1v/z8/GLdSZampqaa6urqxZs3b16ybt26pQsXLlzy9NNPL33ooYc26A4AAAAflgAYAAAgx7Rr1y7/kksu6TFkyJCe++67b89OnTr1Kisr61VcXNyzZcuW3VKpVL4u7R2ZTKaprq6uvKamZtWWLVtWVlRUrFy6dOnK2bNnr7r//vvXVFZWNukSAAAAn4QAGAAAoBnp1KlTwec+97luQ4cO7bnPPvv0aNeuXafWrVt3Li4u7tqyZcvORUVFnfLy8lro1MeTTqe319fXr6+rq6uoqalZW11dvb6ysnL9ihUrVr/66qurHnzwwbUVFRWNOgUAAMDuIgAGAADgfznjjDPaH3bYYZ369OnTuUuXLp3Kysral5SUtC0uLu5YVFTUrqioqG2LFi065OfnlzaXnjQ1NW3dvn37xvr6+qr6+vrKmpqaDdu2bavasmXLpnXr1lUsXbp0/Ysvvrh+4sSJlZ4gAAAA9iYBMAAAAB9Lr169CkeNGtXuoIMOatexY8ey9u3bl7Zp06Z1SUlJWXFxcetWrVq1btGiRVlRUVHrwsLC1hGRX1hYWBoR+QUFBSV5eXkFeXl5u/0/LtPpdG06nW5sbGzcFhFNDQ0NW3f83+r6+vrq7du3b6mtra2uqamp3rZtW/XmzZurN23aVL1hw4YtCxYsqJo1a1bl0qVLt5s4AAAASSAABgAAYK/q169fUffu3Vvss88+xSUlJQVv//8LCwtT3bp1+8BTxuXl5VsbGhoyb//vbdu2Na5YsaJmzZo12xcvXlyvwwAAADQn7xcAF2gPAAAAu9vixYvrdwS11boBAAAAu0+eFgAAAAAAAADkBgEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4QAAMAAAAAAADkCAEwAAAAAAAAQI4o0AIAAAAAAACA5GhoLIyCxoaIiEilIpNXGE1v/0wADAAAAAAAAJAghQUN/0x6MxGppvT/5L6ugAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAAYAAAAAAADIEQJgAAAAAAAAgBwhAIb/v5272ZHiusM4/FZ1NUkz9sQwOF4EyZJtpJCwysa5jSy4n1xPEqRIuQFvvfGSgIwBOzGRQAQERnx0d1UW0cgWGvKxsMGvnmfVdc7/1OJsf+oCAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoIQADAAAAAAAAlBCAAQAAAAAAAEoIwAAAAAAAAAAlBGAAAAAAAACAEgIwAAAAAAAAQAkBGAAAAAAAAKCEAAwAAAAAAABQQgAGAAAAAAAAKCEAAwAAAAAAAJQQgAEAAAAAAABKCMAAAAAAAAAAJQRgAAAAAAAAgBICMAAAAAAAAEAJARgAAAAAAACghAAMAAAAAAAAUEIABgAAAAAAACghAAMAAAAAAACUEIABAAAAAAAASgjAAAAAAAAAACUEYAAAAAAAAIASAjAAAAAAAABACQEYAAAAAAAAoIQADAAAAAAAAFBCAAYAAAAAAAAoMY3JP//9K8My551lzpAk293a7QAAAAAAAAD8iIw3r+SL7TpPxuSt4/ibJJuz20QDBgAAAAAAAHhzrJPp6NvHYcyyjLl7dJTPbl/Jp6sPLufSsM+5ec7q5YOrF0OeP/SVaAAAAAAAAIA3weH7u6zfm79dWDIMSw6225w785vsx3XyzasOby5ssz69c4sAAAAAAAAAr9n69C6bC9sT93a7rKdnORin5Otxynzi1JQcfiwCAwAAAAAAALxO69O7HH68TaaT98cp85R8vbp3Nfszv8q0LHn7xMF1sjk/ZzUPmZ/MmWefhAYAAAAAAAD4oayPdjn7223Gn7x6ZrXPnetX8mBKkpv3cufDd/Pufn5FL56SzcVtNheT3dNt8tQlAwAAAAAAAHyv1sm0ySv/9XtsNWZ3I/lHkgzHi7/4XY7WYz5yiwAAAAAAAAA/Ivtcv/3nPEyS1fHa42t5+vNLyX7JoRsCAAAAAAAAePPt1/nbV3/KvePn1Xc371/NYxEYAAAAAAAA4M0yTHk2rvNo2WdzvHZqzN9v/SF3vju3evng/at5fPDLPDu1yuGyZHSVAAAAAAAAAK/XOGe4ueSvZ4e8M8xZbVe5ceuPufvy3Oqkw4+v5emDX+fuuTlLhhwsEYIBAAAAAAAAXpclGR8OuXP0TR4cPM/9z/+SRyfNDf/1TZezOp/87KdjzizJZkhO7edMy/w/nAUAAAAAAADg/zaMWcZkP8/ZLsmLacr2/MV8+cnvs/tP5/4FmLjAq1ifcioAAAAASUVORK5CYII=';

  /**
   * PptxGenJS: Utility Methods
   */
  /**
   * Translates any type of `x`/`y`/`w`/`h` prop to EMU
   * - guaranteed to return a result regardless of undefined, null, etc. (0)
   * - {number} - 12800 (EMU)
   * - {number} - 0.5 (inches)
   * - {string} - "75%"
   * @param {number|string} size - numeric ("5.5") or percentage ("90%")
   * @param {'X' | 'Y'} xyDir - direction
   * @param {PresLayout} layout - presentation layout
   * @returns {number} calculated size
   */
  function getSmartParseNumber(size, xyDir, layout) {
      // FIRST: Convert string numeric value if reqd
      if (typeof size === 'string' && !isNaN(Number(size)))
          size = Number(size);
      // CASE 1: Number in inches
      // Assume any number less than 100 is inches
      if (typeof size === 'number' && size < 100)
          return inch2Emu(size);
      // CASE 2: Number is already converted to something other than inches
      // Assume any number greater than 100 sure isnt inches! Just return it (assume value is EMU already).
      if (typeof size === 'number' && size >= 100)
          return size;
      // CASE 3: Percentage (ex: '50%')
      if (typeof size === 'string' && size.includes('%')) {
          if (xyDir && xyDir === 'X')
              return Math.round((parseFloat(size) / 100) * layout.width);
          if (xyDir && xyDir === 'Y')
              return Math.round((parseFloat(size) / 100) * layout.height);
          // Default: Assume width (x/cx)
          return Math.round((parseFloat(size) / 100) * layout.width);
      }
      // LAST: Default value
      return 0;
  }
  /**
   * Basic UUID Generator Adapted
   * @link https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript#answer-2117523
   * @param {string} uuidFormat - UUID format
   * @returns {string} UUID
   */
  function getUuid(uuidFormat) {
      return uuidFormat.replace(/[xy]/g, function (c) {
          var r = (Math.random() * 16) | 0;
          var v = c === 'x' ? r : (r & 0x3) | 0x8;
          return v.toString(16);
      });
  }
  /**
   * Replace special XML characters with HTML-encoded strings
   * @param {string} xml - XML string to encode
   * @returns {string} escaped XML
   */
  function encodeXmlEntities(xml) {
      // NOTE: Dont use short-circuit eval here as value c/b "0" (zero) etc.!
      if (typeof xml === 'undefined' || xml == null)
          return '';
      return xml.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
  }
  /**
   * Convert inches into EMU
   * @param {number|string} inches - as string or number
   * @returns {number} EMU value
   */
  function inch2Emu(inches) {
      // NOTE: Provide Caller Safety: Numbers may get conv<->conv during flight, so be kind and do some simple checks to ensure inches were passed
      // Any value over 100 damn sure isnt inches, so lets assume its in EMU already, therefore, just return the same value
      if (typeof inches === 'number' && inches > 100)
          return inches;
      if (typeof inches === 'string')
          inches = Number(inches.replace(/in*/gi, ''));
      return Math.round(EMU * inches);
  }
  /**
   * Convert `pt` into points (using `ONEPT`)
   * @param {number|string} pt
   * @returns {number} value in points (`ONEPT`)
   */
  function valToPts(pt) {
      var points = Number(pt) || 0;
      return isNaN(points) ? 0 : Math.round(points * ONEPT);
  }
  /**
   * Convert degrees (0..360) to PowerPoint `rot` value
   * @param {number} d degrees
   * @returns {number} calculated `rot` value
   */
  function convertRotationDegrees(d) {
      d = d || 0;
      return Math.round((d > 360 ? d - 360 : d) * 60000);
  }
  /**
   * Converts component value to hex value
   * @param {number} c - component color
   * @returns {string} hex string
   */
  function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
  }
  /**
   * Converts RGB colors from css selectors to Hex for Presentation colors
   * @param {number} r - red value
   * @param {number} g - green value
   * @param {number} b - blue value
   * @returns {string} XML string
   */
  function rgbToHex(r, g, b) {
      return (componentToHex(r) + componentToHex(g) + componentToHex(b)).toUpperCase();
  }
  /**  TODO: FUTURE: TODO-4.0:
   * @date 2022-04-10
   * @tldr this s/b a private method with all current calls switched to `genXmlColorSelection()`
   * @desc lots of code calls this method
   * @example [gen-charts.tx] `strXml += '<a:solidFill>' + createColorElement(seriesColor, `<a:alpha val="${Math.round(opts.chartColorsOpacity * 1000)}"/>`) + '</a:solidFill>'`
   * Thi sis wrong. We s/b calling `genXmlColorSelection()` instead as it returns `<a:solidfill>BLAH</a:solidFill>`!!
   */
  /**
   * Create either a `a:schemeClr` - (scheme color) or `a:srgbClr` (hexa representation).
   * @param {string|SCHEME_COLORS} colorStr - hexa representation (eg. "FFFF00") or a scheme color constant (eg. pptx.SchemeColor.ACCENT1)
   * @param {string} innerElements - additional elements that adjust the color and are enclosed by the color element
   * @returns {string} XML string
   */
  function createColorElement(colorStr, innerElements) {
      var colorVal = (colorStr || '').replace('#', '');
      if (!REGEX_HEX_COLOR.test(colorVal) &&
          colorVal !== SchemeColor.background1 &&
          colorVal !== SchemeColor.background2 &&
          colorVal !== SchemeColor.text1 &&
          colorVal !== SchemeColor.text2 &&
          colorVal !== SchemeColor.accent1 &&
          colorVal !== SchemeColor.accent2 &&
          colorVal !== SchemeColor.accent3 &&
          colorVal !== SchemeColor.accent4 &&
          colorVal !== SchemeColor.accent5 &&
          colorVal !== SchemeColor.accent6) {
          console.warn("\"".concat(colorVal, "\" is not a valid scheme color or hex RGB! \"").concat(DEF_FONT_COLOR, "\" used instead. Only provide 6-digit RGB or 'pptx.SchemeColor' values!"));
          colorVal = DEF_FONT_COLOR;
      }
      var tagName = REGEX_HEX_COLOR.test(colorVal) ? 'srgbClr' : 'schemeClr';
      var colorAttr = 'val="' + (REGEX_HEX_COLOR.test(colorVal) ? colorVal.toUpperCase() : colorVal) + '"';
      return innerElements ? "<a:".concat(tagName, " ").concat(colorAttr, ">").concat(innerElements, "</a:").concat(tagName, ">") : "<a:".concat(tagName, " ").concat(colorAttr, "/>");
  }
  /**
   * Creates `a:glow` element
   * @param {TextGlowProps} options glow properties
   * @param {TextGlowProps} defaults defaults for unspecified properties in `opts`
   * @see http://officeopenxml.com/drwSp-effects.php
   * { size: 8, color: 'FFFFFF', opacity: 0.75 };
   */
  function createGlowElement(options, defaults) {
      var strXml = '';
      var opts = __assign(__assign({}, defaults), options);
      var size = Math.round(opts.size * ONEPT);
      var color = opts.color;
      var opacity = Math.round(opts.opacity * 100000);
      strXml += "<a:glow rad=\"".concat(size, "\">");
      strXml += createColorElement(color, "<a:alpha val=\"".concat(opacity, "\"/>"));
      strXml += '</a:glow>';
      return strXml;
  }
  /**
   * Create color selection
   * @param {Color | ShapeFillProps | ShapeLineProps} props fill props
   * @returns XML string
   */
  function genXmlColorSelection(props) {
      var fillType = 'solid';
      var colorVal = '';
      var internalElements = '';
      var outText = '';
      if (props) {
          if (typeof props === 'string')
              colorVal = props;
          else {
              if (props.type)
                  fillType = props.type;
              if (props.color)
                  colorVal = props.color;
              if (props.alpha)
                  internalElements += "<a:alpha val=\"".concat(Math.round((100 - props.alpha) * 1000), "\"/>"); // DEPRECATED: @deprecated v3.3.0
              if (props.transparency)
                  internalElements += "<a:alpha val=\"".concat(Math.round((100 - props.transparency) * 1000), "\"/>");
          }
          switch (fillType) {
              case 'solid':
                  outText += "<a:solidFill>".concat(createColorElement(colorVal, internalElements), "</a:solidFill>");
                  break;
              default: // @note need a statement as having only "break" is removed by rollup, then tiggers "no-default" js-linter
                  outText += '';
                  break;
          }
      }
      return outText;
  }
  /**
   * Get a new rel ID (rId) for charts, media, etc.
   * @param {PresSlide} target - the slide to use
   * @returns {number} count of all current rels plus 1 for the caller to use as its "rId"
   */
  function getNewRelId(target) {
      return target._rels.length + target._relsChart.length + target._relsMedia.length + 1;
  }
  /**
   * Checks shadow options passed by user and performs corrections if needed.
   * @param {ShadowProps} ShadowProps - shadow options
   */
  function correctShadowOptions(ShadowProps) {
      if (!ShadowProps || typeof ShadowProps !== 'object') {
          // console.warn("`shadow` options must be an object. Ex: `{shadow: {type:'none'}}`")
          return;
      }
      // OPT: `type`
      if (ShadowProps.type !== 'outer' && ShadowProps.type !== 'inner' && ShadowProps.type !== 'none') {
          console.warn('Warning: shadow.type options are `outer`, `inner` or `none`.');
          ShadowProps.type = 'outer';
      }
      // OPT: `angle`
      if (ShadowProps.angle) {
          // A: REALITY-CHECK
          if (isNaN(Number(ShadowProps.angle)) || ShadowProps.angle < 0 || ShadowProps.angle > 359) {
              console.warn('Warning: shadow.angle can only be 0-359');
              ShadowProps.angle = 270;
          }
          // B: ROBUST: Cast any type of valid arg to int: '12', 12.3, etc. -> 12
          ShadowProps.angle = Math.round(Number(ShadowProps.angle));
      }
      // OPT: `opacity`
      if (ShadowProps.opacity) {
          // A: REALITY-CHECK
          if (isNaN(Number(ShadowProps.opacity)) || ShadowProps.opacity < 0 || ShadowProps.opacity > 1) {
              console.warn('Warning: shadow.opacity can only be 0-1');
              ShadowProps.opacity = 0.75;
          }
          // B: ROBUST: Cast any type of valid arg to int: '12', 12.3, etc. -> 12
          ShadowProps.opacity = Number(ShadowProps.opacity);
      }
      // OPT: `color`
      if (ShadowProps.color) {
          // INCORRECT FORMAT
          if (ShadowProps.color.startsWith('#')) {
              console.warn('Warning: shadow.color should not include hash (#) character, , e.g. "FF0000"');
              ShadowProps.color = ShadowProps.color.replace('#', '');
          }
      }
      return ShadowProps;
  }

  /**
   * PptxGenJS: Table Generation
   */
  /**
   * Break cell text into lines based upon table column width (e.g.: Magic Happens Here(tm))
   * @param {TableCell} cell - table cell
   * @param {number} colWidth - table column width (inches)
   * @return {TableRow[]} - cell's text objects grouped into lines
   */
  function parseTextToLines(cell, colWidth, verbose) {
      var _a, _b;
      // FYI: CPL = Width / (font-size / font-constant)
      // FYI: CHAR:2.3, colWidth:10, fontSize:12 => CPL=138, (actual chars per line in PPT)=145 [14.5 CPI]
      // FYI: CHAR:2.3, colWidth:7 , fontSize:12 => CPL= 97, (actual chars per line in PPT)=100 [14.3 CPI]
      // FYI: CHAR:2.3, colWidth:9 , fontSize:16 => CPL= 96, (actual chars per line in PPT)=84  [ 9.3 CPI]
      var FOCO = 2.3 + (((_a = cell.options) === null || _a === void 0 ? void 0 : _a.autoPageCharWeight) ? cell.options.autoPageCharWeight : 0); // Character Constant
      var CPL = Math.floor((colWidth / ONEPT) * EMU) / ((((_b = cell.options) === null || _b === void 0 ? void 0 : _b.fontSize) ? cell.options.fontSize : DEF_FONT_SIZE) / FOCO); // Chars-Per-Line
      var parsedLines = [];
      var inputCells = [];
      var inputLines1 = [];
      var inputLines2 = [];
      /*
          if (cell.options && cell.options.autoPageCharWeight) {
              let CHR1 = 2.3 + (cell.options && cell.options.autoPageCharWeight ? cell.options.autoPageCharWeight : 0) // Character Constant
              let CPL1 = ((colWidth / ONEPT) * EMU) / ((cell.options && cell.options.fontSize ? cell.options.fontSize : DEF_FONT_SIZE) / CHR1) // Chars-Per-Line
              console.log(`cell.options.autoPageCharWeight: '${cell.options.autoPageCharWeight}' => CPL: ${CPL1}`)
              let CHR2 = 2.3 + 0
              let CPL2 = ((colWidth / ONEPT) * EMU) / ((cell.options && cell.options.fontSize ? cell.options.fontSize : DEF_FONT_SIZE) / CHR2) // Chars-Per-Line
              console.log(`cell.options.autoPageCharWeight: '0' => CPL: ${CPL2}`)
          }
      */
      /**
       * EX INPUTS: `cell.text`
       * - string....: "Account Name Column"
       * - object....: { text:"Account Name Column" }
       * - object[]..: [{ text:"Account Name", options:{ bold:true } }, { text:" Column" }]
       * - object[]..: [{ text:"Account Name", options:{ breakLine:true } }, { text:"Input" }]
       */
      /**
       * EX OUTPUTS:
       * - string....: [{ text:"Account Name Column" }]
       * - object....: [{ text:"Account Name Column" }]
       * - object[]..: [{ text:"Account Name", options:{ breakLine:true } }, { text:"Input" }]
       * - object[]..: [{ text:"Account Name", options:{ breakLine:true } }, { text:"Input" }]
       */
      // STEP 1: Ensure inputCells is an array of TableCells
      if (cell.text && cell.text.toString().trim().length === 0) {
          // Allow a single space/whitespace as cell text (user-requested feature)
          inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: ' ' });
      }
      else if (typeof cell.text === 'number' || typeof cell.text === 'string') {
          inputCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: (cell.text || '').toString().trim() });
      }
      else if (Array.isArray(cell.text)) {
          inputCells = cell.text;
      }
      if (verbose) {
          console.log('[1/4] inputCells');
          inputCells.forEach(function (cell, idx) { return console.log("[1/4] [".concat(idx + 1, "] cell: ").concat(JSON.stringify(cell))); });
          // console.log('...............................................\n\n')
      }
      // STEP 2: Group table cells into lines based on "\n" or `breakLine` prop
      /**
       * - EX: `[{ text:"Input Output" }, { text:"Extra" }]`                       == 1 line
       * - EX: `[{ text:"Input" }, { text:"Output", options:{ breakLine:true } }]` == 1 line
       * - EX: `[{ text:"Input\nOutput" }]`                                        == 2 lines
       * - EX: `[{ text:"Input", options:{ breakLine:true } }, { text:"Output" }]` == 2 lines
       */
      var newLine = [];
      inputCells.forEach(function (cell) {
          var _a;
          // (this is always true, we just constructed them above, but we need to tell typescript b/c type is still string||Cell[])
          if (typeof cell.text === 'string') {
              if (cell.text.split('\n').length > 1) {
                  cell.text.split('\n').forEach(function (textLine) {
                      newLine.push({
                          _type: SLIDE_OBJECT_TYPES.tablecell,
                          text: textLine,
                          options: __assign(__assign({}, cell.options), { breakLine: true }),
                      });
                  });
              }
              else {
                  newLine.push({
                      _type: SLIDE_OBJECT_TYPES.tablecell,
                      text: cell.text.trim(),
                      options: cell.options,
                  });
              }
              if ((_a = cell.options) === null || _a === void 0 ? void 0 : _a.breakLine) {
                  if (verbose)
                      console.log("inputCells: new line > ".concat(JSON.stringify(newLine)));
                  inputLines1.push(newLine);
                  newLine = [];
              }
          }
          // Flush buffer
          if (newLine.length > 0) {
              inputLines1.push(newLine);
              newLine = [];
          }
      });
      if (verbose) {
          console.log("[2/4] inputLines1 (".concat(inputLines1.length, ")"));
          inputLines1.forEach(function (line, idx) { return console.log("[2/4] [".concat(idx + 1, "] line: ").concat(JSON.stringify(line))); });
          // console.log('...............................................\n\n')
      }
      // STEP 3: Tokenize every text object into words (then it's really easy to assemble lines below without having to break text, add its `options`, etc.)
      inputLines1.forEach(function (line) {
          line.forEach(function (cell) {
              var lineCells = [];
              var cellTextStr = String(cell.text); // force convert to string (compiled JS is better with this than a cast)
              var lineWords = cellTextStr.split(' ');
              lineWords.forEach(function (word, idx) {
                  var cellProps = __assign({}, cell.options);
                  // IMPORTANT: Handle `breakLine` prop - we cannot apply to each word - only apply to very last word!
                  if (cellProps === null || cellProps === void 0 ? void 0 : cellProps.breakLine)
                      cellProps.breakLine = idx + 1 === lineWords.length;
                  lineCells.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: word + (idx + 1 < lineWords.length ? ' ' : ''), options: cellProps });
              });
              inputLines2.push(lineCells);
          });
      });
      if (verbose) {
          console.log("[3/4] inputLines2 (".concat(inputLines2.length, ")"));
          inputLines2.forEach(function (line) { return console.log("[3/4] line: ".concat(JSON.stringify(line))); });
          // console.log('...............................................\n\n')
      }
      // STEP 4: Group cells/words into lines based upon space consumed by word letters
      inputLines2.forEach(function (line) {
          var lineCells = [];
          var strCurrLine = '';
          line.forEach(function (word) {
              // A: create new line when horizontal space is exhausted
              if (strCurrLine.length + word.text.length > CPL) {
                  // if (verbose) console.log(`STEP 4: New line added: (${strCurrLine.length} + ${word.text.length} > ${CPL})`);
                  parsedLines.push(lineCells);
                  lineCells = [];
                  strCurrLine = '';
              }
              // B: add current word to line cells
              lineCells.push(word);
              // C: add current word to `strCurrLine` which we use to keep track of line's char length
              strCurrLine += word.text.toString();
          });
          // Flush buffer: Only create a line when there's text to avoid empty row
          if (lineCells.length > 0)
              parsedLines.push(lineCells);
      });
      if (verbose) {
          console.log("[4/4] parsedLines (".concat(parsedLines.length, ")"));
          parsedLines.forEach(function (line, idx) { return console.log("[4/4] [Line ".concat(idx + 1, "]:\n").concat(JSON.stringify(line))); });
          console.log('...............................................\n\n');
      }
      // Done:
      return parsedLines;
  }
  /**
   * Takes an array of table rows and breaks into an array of slides, which contain the calculated amount of table rows that fit on that slide
   * @param {TableCell[][]} tableRows - table rows
   * @param {TableToSlidesProps} tableProps - table2slides properties
   * @param {PresLayout} presLayout - presentation layout
   * @param {SlideLayout} masterSlide - master slide
   * @return {TableRowSlide[]} array of table rows
   */
  function getSlidesForTableRows(tableRows, tableProps, presLayout, masterSlide) {
      if (tableRows === void 0) { tableRows = []; }
      if (tableProps === void 0) { tableProps = {}; }
      var arrInchMargins = DEF_SLIDE_MARGIN_IN;
      var emuSlideTabW = EMU * 1;
      var emuSlideTabH = EMU * 1;
      var emuTabCurrH = 0;
      var numCols = 0;
      var tableRowSlides = [];
      var tablePropX = getSmartParseNumber(tableProps.x, 'X', presLayout);
      var tablePropY = getSmartParseNumber(tableProps.y, 'Y', presLayout);
      var tablePropW = getSmartParseNumber(tableProps.w, 'X', presLayout);
      var tablePropH = getSmartParseNumber(tableProps.h, 'Y', presLayout);
      var tableCalcW = tablePropW;
      function calcSlideTabH() {
          var emuStartY = 0;
          if (tableRowSlides.length === 0)
              emuStartY = tablePropY || inch2Emu(arrInchMargins[0]);
          if (tableRowSlides.length > 0)
              emuStartY = inch2Emu(tableProps.autoPageSlideStartY || tableProps.newSlideStartY || arrInchMargins[0]);
          emuSlideTabH = (tablePropH || presLayout.height) - emuStartY - inch2Emu(arrInchMargins[2]);
          // console.log(`| startY .......................................... = ${(emuStartY / EMU).toFixed(1)}`)
          // console.log(`| emuSlideTabH .................................... = ${(emuSlideTabH / EMU).toFixed(1)}`)
          if (tableRowSlides.length > 1) {
              // D: RULE: Use margins for starting point after the initial Slide, not `opt.y` (ISSUE #43, ISSUE #47, ISSUE #48)
              if (typeof tableProps.autoPageSlideStartY === 'number') {
                  emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.autoPageSlideStartY + arrInchMargins[2]);
              }
              else if (typeof tableProps.newSlideStartY === 'number') {
                  // @deprecated v3.3.0
                  emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu(tableProps.newSlideStartY + arrInchMargins[2]);
              }
              else if (tablePropY) {
                  emuSlideTabH = (tablePropH || presLayout.height) - inch2Emu((tablePropY / EMU < arrInchMargins[0] ? tablePropY / EMU : arrInchMargins[0]) + arrInchMargins[2]);
                  // Use whichever is greater: area between margins or the table H provided (dont shrink usable area - the whole point of over-riding Y on paging is to *increase* usable space)
                  if (emuSlideTabH < tablePropH)
                      emuSlideTabH = tablePropH;
              }
          }
      }
      if (tableProps.verbose) {
          console.log('[[VERBOSE MODE]]');
          console.log('|-- TABLE PROPS --------------------------------------------------------|');
          console.log("| presLayout.width ................................ = ".concat((presLayout.width / EMU).toFixed(1)));
          console.log("| presLayout.height ............................... = ".concat((presLayout.height / EMU).toFixed(1)));
          console.log("| tableProps.x .................................... = ".concat(typeof tableProps.x === 'number' ? (tableProps.x / EMU).toFixed(1) : tableProps.x));
          console.log("| tableProps.y .................................... = ".concat(typeof tableProps.y === 'number' ? (tableProps.y / EMU).toFixed(1) : tableProps.y));
          console.log("| tableProps.w .................................... = ".concat(typeof tableProps.w === 'number' ? (tableProps.w / EMU).toFixed(1) : tableProps.w));
          console.log("| tableProps.h .................................... = ".concat(typeof tableProps.h === 'number' ? (tableProps.h / EMU).toFixed(1) : tableProps.h));
          console.log("| tableProps.slideMargin .......................... = ".concat(tableProps.slideMargin ? String(tableProps.slideMargin) : ''));
          console.log("| tableProps.margin ............................... = ".concat(String(tableProps.margin)));
          console.log("| tableProps.colW ................................. = ".concat(String(tableProps.colW)));
          console.log("| tableProps.autoPageSlideStartY .................. = ".concat(tableProps.autoPageSlideStartY));
          console.log("| tableProps.autoPageCharWeight ................... = ".concat(tableProps.autoPageCharWeight));
          console.log('|-- CALCULATIONS -------------------------------------------------------|');
          console.log("| tablePropX ...................................... = ".concat(tablePropX / EMU));
          console.log("| tablePropY ...................................... = ".concat(tablePropY / EMU));
          console.log("| tablePropW ...................................... = ".concat(tablePropW / EMU));
          console.log("| tablePropH ...................................... = ".concat(tablePropH / EMU));
          console.log("| tableCalcW ...................................... = ".concat(tableCalcW / EMU));
      }
      // STEP 1: Calculate margins
      {
          // Important: Use default size as zero cell margin is causing our tables to be too large and touch bottom of slide!
          if (!tableProps.slideMargin && tableProps.slideMargin !== 0)
              tableProps.slideMargin = DEF_SLIDE_MARGIN_IN[0];
          if (masterSlide && typeof masterSlide._margin !== 'undefined') {
              if (Array.isArray(masterSlide._margin))
                  arrInchMargins = masterSlide._margin;
              else if (!isNaN(Number(masterSlide._margin))) {
                  arrInchMargins = [Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin), Number(masterSlide._margin)];
              }
          }
          else if (tableProps.slideMargin || tableProps.slideMargin === 0) {
              if (Array.isArray(tableProps.slideMargin))
                  arrInchMargins = tableProps.slideMargin;
              else if (!isNaN(tableProps.slideMargin))
                  arrInchMargins = [tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin, tableProps.slideMargin];
          }
          if (tableProps.verbose)
              console.log("| arrInchMargins .................................. = [".concat(arrInchMargins.join(', '), "]"));
      }
      // STEP 2: Calculate number of columns
      {
          // NOTE: Cells may have a colspan, so merely taking the length of the [0] (or any other) row is not
          // ....: sufficient to determine column count. Therefore, check each cell for a colspan and total cols as reqd
          var firstRow = tableRows[0] || [];
          firstRow.forEach(function (cell) {
              if (!cell)
                  cell = { _type: SLIDE_OBJECT_TYPES.tablecell };
              var cellOpts = cell.options || null;
              numCols += Number((cellOpts === null || cellOpts === void 0 ? void 0 : cellOpts.colspan) ? cellOpts.colspan : 1);
          });
          if (tableProps.verbose)
              console.log("| numCols ......................................... = ".concat(numCols));
      }
      // STEP 3: Calculate width using tableProps.colW if possible
      if (!tablePropW && tableProps.colW) {
          tableCalcW = Array.isArray(tableProps.colW) ? tableProps.colW.reduce(function (p, n) { return p + n; }) * EMU : tableProps.colW * numCols || 0;
          if (tableProps.verbose)
              console.log("| tableCalcW ...................................... = ".concat(tableCalcW / EMU));
      }
      // STEP 4: Calculate usable width now that total usable space is known (`emuSlideTabW`)
      {
          emuSlideTabW = tableCalcW || inch2Emu((tablePropX ? tablePropX / EMU : arrInchMargins[1]) + arrInchMargins[3]);
          if (tableProps.verbose)
              console.log("| emuSlideTabW .................................... = ".concat((emuSlideTabW / EMU).toFixed(1)));
      }
      // STEP 5: Calculate column widths if not provided (emuSlideTabW will be used below to determine lines-per-col)
      if (!tableProps.colW || !Array.isArray(tableProps.colW)) {
          if (tableProps.colW && !isNaN(Number(tableProps.colW))) {
              var arrColW_1 = [];
              var firstRow = tableRows[0] || [];
              firstRow.forEach(function () { return arrColW_1.push(tableProps.colW); });
              tableProps.colW = [];
              arrColW_1.forEach(function (val) {
                  if (Array.isArray(tableProps.colW))
                      tableProps.colW.push(val);
              });
          }
          else {
              // No column widths provided? Then distribute cols.
              tableProps.colW = [];
              for (var iCol = 0; iCol < numCols; iCol++) {
                  tableProps.colW.push(emuSlideTabW / EMU / numCols);
              }
          }
      }
      // STEP 6: **MAIN** Iterate over rows, add table content, create new slides as rows overflow
      var newTableRowSlide = { rows: [] };
      tableRows.forEach(function (row, iRow) {
          // A: Row variables
          var rowCellLines = [];
          var maxCellMarTopEmu = 0;
          var maxCellMarBtmEmu = 0;
          // B: Create new row in data model, calc `maxCellMar*`
          var currTableRow = [];
          row.forEach(function (cell) {
              var _a, _b, _c, _d;
              currTableRow.push({
                  _type: SLIDE_OBJECT_TYPES.tablecell,
                  text: [],
                  options: cell.options,
              });
              /** FUTURE: DEPRECATED:
               * - Backwards-Compat: Oops! Discovered we were still using points for cell margin before v3.8.0 (UGH!)
               * - We cant introduce a breaking change before v4.0, so...
               */
              if (cell.options.margin && cell.options.margin[0] >= 1) {
                  if (((_a = cell.options) === null || _a === void 0 ? void 0 : _a.margin) && cell.options.margin[0] && valToPts(cell.options.margin[0]) > maxCellMarTopEmu)
                      maxCellMarTopEmu = valToPts(cell.options.margin[0]);
                  else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[0] && valToPts(tableProps.margin[0]) > maxCellMarTopEmu)
                      maxCellMarTopEmu = valToPts(tableProps.margin[0]);
                  if (((_b = cell.options) === null || _b === void 0 ? void 0 : _b.margin) && cell.options.margin[2] && valToPts(cell.options.margin[2]) > maxCellMarBtmEmu)
                      maxCellMarBtmEmu = valToPts(cell.options.margin[2]);
                  else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[2] && valToPts(tableProps.margin[2]) > maxCellMarBtmEmu)
                      maxCellMarBtmEmu = valToPts(tableProps.margin[2]);
              }
              else {
                  if (((_c = cell.options) === null || _c === void 0 ? void 0 : _c.margin) && cell.options.margin[0] && inch2Emu(cell.options.margin[0]) > maxCellMarTopEmu)
                      maxCellMarTopEmu = inch2Emu(cell.options.margin[0]);
                  else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[0] && inch2Emu(tableProps.margin[0]) > maxCellMarTopEmu)
                      maxCellMarTopEmu = inch2Emu(tableProps.margin[0]);
                  if (((_d = cell.options) === null || _d === void 0 ? void 0 : _d.margin) && cell.options.margin[2] && inch2Emu(cell.options.margin[2]) > maxCellMarBtmEmu)
                      maxCellMarBtmEmu = inch2Emu(cell.options.margin[2]);
                  else if ((tableProps === null || tableProps === void 0 ? void 0 : tableProps.margin) && tableProps.margin[2] && inch2Emu(tableProps.margin[2]) > maxCellMarBtmEmu)
                      maxCellMarBtmEmu = inch2Emu(tableProps.margin[2]);
              }
          });
          // C: Calc usable vertical space/table height. Set default value first, adjust below when necessary.
          calcSlideTabH();
          emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu; // Start row height with margins
          if (tableProps.verbose && iRow === 0)
              console.log("| SLIDE [".concat(tableRowSlides.length, "]: emuSlideTabH ...... = ").concat((emuSlideTabH / EMU).toFixed(1), " "));
          // D: --==[[ BUILD DATA SET ]]==-- (iterate over cells: split text into lines[], set `lineHeight`)
          row.forEach(function (cell, iCell) {
              var _a;
              var newCell = {
                  _type: SLIDE_OBJECT_TYPES.tablecell,
                  _lines: null,
                  _lineHeight: inch2Emu(((((_a = cell.options) === null || _a === void 0 ? void 0 : _a.fontSize) ? cell.options.fontSize : tableProps.fontSize ? tableProps.fontSize : DEF_FONT_SIZE) *
                      (LINEH_MODIFIER + (tableProps.autoPageLineWeight ? tableProps.autoPageLineWeight : 0))) /
                      100),
                  text: [],
                  options: cell.options,
              };
              // E-1: Exempt cells with `rowspan` from increasing lineHeight (or we could create a new slide when unecessary!)
              if (newCell.options.rowspan)
                  newCell._lineHeight = 0;
              // E-2: The parseTextToLines method uses `autoPageCharWeight`, so inherit from table options
              newCell.options.autoPageCharWeight = tableProps.autoPageCharWeight ? tableProps.autoPageCharWeight : null;
              // E-3: **MAIN** Parse cell contents into lines based upon col width, font, etc
              var totalColW = tableProps.colW[iCell];
              if (cell.options.colspan && Array.isArray(tableProps.colW)) {
                  totalColW = tableProps.colW.filter(function (_cell, idx) { return idx >= iCell && idx < idx + cell.options.colspan; }).reduce(function (prev, curr) { return prev + curr; });
              }
              // E-4: Create lines based upon available column width
              newCell._lines = parseTextToLines(cell, totalColW, false);
              // E-5: Add cell to array
              rowCellLines.push(newCell);
          });
          /** E: --==[[ PAGE DATA SET ]]==--
           * Add text one-line-a-time to this row's cells until: lines are exhausted OR table height limit is hit
           *
           * Design:
           * - Building cells L-to-R/loop style wont work as one could be 100 lines and another 1 line
           * - Therefore, build the whole row, one-line-at-a-time, across each table columns
           * - Then, when the vertical size limit is hit is by any of the cells, make a new slide and continue adding any remaining lines
           *
           * Implementation:
           * - `rowCellLines` is an array of cells, one for each column in the table, with each cell containing an array of lines
           *
           * Sample Data:
           * - `rowCellLines` ..: [ TableCell, TableCell, TableCell ]
           * - `TableCell` .....: { _type: 'tablecell', _lines: TableCell[], _lineHeight: 10 }
           * - `_lines` ........: [ {_type: 'tablecell', text: 'cell-1,line-1', options: {}}, {_type: 'tablecell', text: 'cell-1,line-2', options: {}} }
           * - `_lines` is TableCell[] (the 1-N words in the line)
           * {
           *    _lines: [{ text:'cell-1,line-1' }, { text:'cell-1,line-2' }],                                                     // TOTAL-CELL-HEIGHT = 2
           *    _lines: [{ text:'cell-2,line-1' }, { text:'cell-2,line-2' }],                                                     // TOTAL-CELL-HEIGHT = 2
           *    _lines: [{ text:'cell-3,line-1' }, { text:'cell-3,line-2' }, { text:'cell-3,line-3' }, { text:'cell-3,line-4' }], // TOTAL-CELL-HEIGHT = 4
           * }
           *
           * Example: 2 rows, with the firstrow overflowing onto a new slide
           * SLIDE 1:
           *  |--------|--------|--------|--------|
           *  | line-1 | line-1 | line-1 | line-1 |
           *  |        |        | line-2 |        |
           *  |        |        | line-3 |        |
           *  |--------|--------|--------|--------|
           *
           * SLIDE 2:
           *  |--------|--------|--------|--------|
           *  |        |        | line-4 |        |
           *  |--------|--------|--------|--------|
           *  | line-1 | line-1 | line-1 | line-1 |
           *  |--------|--------|--------|--------|
           */
          if (tableProps.verbose)
              console.log("\n| SLIDE [".concat(tableRowSlides.length, "]: ROW [").concat(iRow, "]: START..."));
          var currCellIdx = 0;
          var emuLineMaxH = 0;
          var isDone = false;
          while (!isDone) {
              var srcCell = rowCellLines[currCellIdx];
              var tgtCell = currTableRow[currCellIdx]; // NOTE: may be redefined below (a new row may be created, thus changing this value)
              // 1: calc emuLineMaxH
              rowCellLines.forEach(function (cell) {
                  if (cell._lineHeight >= emuLineMaxH)
                      emuLineMaxH = cell._lineHeight;
              });
              // 2: create a new slide if there is insufficient room for the current row
              if (emuTabCurrH + emuLineMaxH > emuSlideTabH) {
                  if (tableProps.verbose) {
                      console.log('\n|-----------------------------------------------------------------------|');
                      // prettier-ignore
                      console.log("|-- NEW SLIDE CREATED (currTabH+currLineH > maxH) => ".concat((emuTabCurrH / EMU).toFixed(2), " + ").concat((srcCell._lineHeight / EMU).toFixed(2), " > ").concat(emuSlideTabH / EMU));
                      console.log('|-----------------------------------------------------------------------|\n\n');
                  }
                  // A: add current row slide or it will be lost (only if it has rows and text)
                  if (currTableRow.length > 0 && currTableRow.map(function (cell) { return cell.text.length; }).reduce(function (p, n) { return p + n; }) > 0)
                      newTableRowSlide.rows.push(currTableRow);
                  // B: add current slide to Slides array
                  tableRowSlides.push(newTableRowSlide);
                  // C: reset working/curr slide to hold rows as they're created
                  var newRows = [];
                  newTableRowSlide = { rows: newRows };
                  // D: reset working/curr row
                  currTableRow = [];
                  row.forEach(function (cell) { return currTableRow.push({ _type: SLIDE_OBJECT_TYPES.tablecell, text: [], options: cell.options }); });
                  // E: Calc usable vertical space/table height now as we may still be in the same row and code above ("C: Calc usable vertical space/table height.") calc may now be invalid
                  calcSlideTabH();
                  emuTabCurrH += maxCellMarTopEmu + maxCellMarBtmEmu; // Start row height with margins
                  if (tableProps.verbose)
                      console.log("| SLIDE [".concat(tableRowSlides.length, "]: emuSlideTabH ...... = ").concat((emuSlideTabH / EMU).toFixed(1), " "));
                  // F: reset current table height for this new Slide
                  emuTabCurrH = 0;
                  // G: handle repeat headers option /or/ Add new empty row to continue current lines into
                  if ((tableProps.addHeaderToEach || tableProps.autoPageRepeatHeader) && tableProps._arrObjTabHeadRows) {
                      tableProps._arrObjTabHeadRows.forEach(function (row) {
                          var newHeadRow = [];
                          var maxLineHeight = 0;
                          row.forEach(function (cell) {
                              newHeadRow.push(cell);
                              if (cell._lineHeight > maxLineHeight)
                                  maxLineHeight = cell._lineHeight;
                          });
                          newTableRowSlide.rows.push(newHeadRow);
                          emuTabCurrH += maxLineHeight; // TODO: what about margins? dont we need to include cell margin in line height?
                      });
                  }
                  // WIP: NEW: TEST THIS!!
                  tgtCell = currTableRow[currCellIdx];
              }
              // 3: set array of words that comprise this line
              var currLine = srcCell._lines.shift();
              // 4: create new line by adding all words from curr line (or add empty if there are no words to avoid "needs repair" issue triggered when cells have null content)
              if (Array.isArray(tgtCell.text)) {
                  if (currLine)
                      tgtCell.text = tgtCell.text.concat(currLine);
                  else if (tgtCell.text.length === 0)
                      tgtCell.text = tgtCell.text.concat({ _type: SLIDE_OBJECT_TYPES.tablecell, text: '' });
                  // IMPORTANT: ^^^ add empty if there are no words to avoid "needs repair" issue triggered when cells have null content
              }
              // 5: increase table height by the curr line height (if we're on the last column)
              if (currCellIdx === rowCellLines.length - 1)
                  emuTabCurrH += emuLineMaxH;
              // 6: advance column/cell index (or circle back to first one to continue adding lines)
              currCellIdx = currCellIdx < rowCellLines.length - 1 ? currCellIdx + 1 : 0;
              // 7: done?
              var brent = rowCellLines.map(function (cell) { return cell._lines.length; }).reduce(function (prev, next) { return prev + next; });
              if (brent === 0)
                  isDone = true;
          }
          // F: Flush/capture row buffer before it resets at the top of this loop
          if (currTableRow.length > 0)
              newTableRowSlide.rows.push(currTableRow);
          if (tableProps.verbose) {
              console.log("- SLIDE [".concat(tableRowSlides.length, "]: ROW [").concat(iRow, "]: ...COMPLETE ...... emuTabCurrH = ").concat((emuTabCurrH / EMU).toFixed(2), " ( emuSlideTabH = ").concat((emuSlideTabH / EMU).toFixed(2), " )"));
          }
      });
      // STEP 7: Flush buffer / add final slide
      tableRowSlides.push(newTableRowSlide);
      if (tableProps.verbose) {
          console.log('\n|================================================|');
          console.log("| FINAL: tableRowSlides.length = ".concat(tableRowSlides.length));
          tableRowSlides.forEach(function (slide) { return console.log(slide); });
          console.log('|================================================|\n\n');
      }
      // LAST:
      return tableRowSlides;
  }
  /**
   * Reproduces an HTML table as a PowerPoint table - including column widths, style, etc. - creates 1 or more slides as needed
   * @param {PptxGenJS} pptx - pptxgenjs instance
   * @param {string} tabEleId - HTMLElementID of the table
   * @param {ITableToSlidesOpts} options - array of options (e.g.: tabsize)
   * @param {SlideLayout} masterSlide - masterSlide
   */
  function genTableToSlides(pptx, tabEleId, options, masterSlide) {
      if (options === void 0) { options = {}; }
      var opts = options || {};
      opts.slideMargin = opts.slideMargin || opts.slideMargin === 0 ? opts.slideMargin : 0.5;
      var emuSlideTabW = opts.w || pptx.presLayout.width;
      var arrObjTabHeadRows = [];
      var arrObjTabBodyRows = [];
      var arrObjTabFootRows = [];
      var arrColW = [];
      var arrTabColW = [];
      var arrInchMargins = [0.5, 0.5, 0.5, 0.5]; // TRBL-style
      var intTabW = 0;
      // REALITY-CHECK:
      if (!document.getElementById(tabEleId))
          throw new Error('tableToSlides: Table ID "' + tabEleId + '" does not exist!');
      // STEP 1: Set margins
      if (masterSlide === null || masterSlide === void 0 ? void 0 : masterSlide._margin) {
          if (Array.isArray(masterSlide._margin))
              arrInchMargins = masterSlide._margin;
          else if (!isNaN(masterSlide._margin))
              arrInchMargins = [masterSlide._margin, masterSlide._margin, masterSlide._margin, masterSlide._margin];
          opts.slideMargin = arrInchMargins;
      }
      else if (opts === null || opts === void 0 ? void 0 : opts.slideMargin) {
          if (Array.isArray(opts.slideMargin))
              arrInchMargins = opts.slideMargin;
          else if (!isNaN(opts.slideMargin))
              arrInchMargins = [opts.slideMargin, opts.slideMargin, opts.slideMargin, opts.slideMargin];
      }
      emuSlideTabW = (opts.w ? inch2Emu(opts.w) : pptx.presLayout.width) - inch2Emu(arrInchMargins[1] + arrInchMargins[3]);
      if (opts.verbose) {
          console.log('[[VERBOSE MODE]]');
          console.log('|-- `tableToSlides` ----------------------------------------------------|');
          console.log("| tableProps.h .................................... = ".concat(opts.h));
          console.log("| tableProps.w .................................... = ".concat(opts.w));
          console.log("| pptx.presLayout.width ........................... = ".concat((pptx.presLayout.width / EMU).toFixed(1)));
          console.log("| pptx.presLayout.height .......................... = ".concat((pptx.presLayout.height / EMU).toFixed(1)));
          console.log("| emuSlideTabW .................................... = ".concat((emuSlideTabW / EMU).toFixed(1)));
      }
      // STEP 2: Grab table col widths - just find the first availble row, either thead/tbody/tfoot, others may have colspans, who cares, we only need col widths from 1
      var firstRowCells = document.querySelectorAll("#".concat(tabEleId, " tr:first-child th"));
      if (firstRowCells.length === 0)
          firstRowCells = document.querySelectorAll("#".concat(tabEleId, " tr:first-child td"));
      firstRowCells.forEach(function (cell) {
          if (cell.getAttribute('colspan')) {
              // Guesstimate (divide evenly) col widths
              // NOTE: both j$query and vanilla selectors return {0} when table is not visible)
              for (var idxc = 0; idxc < Number(cell.getAttribute('colspan')); idxc++) {
                  arrTabColW.push(Math.round(cell.offsetWidth / Number(cell.getAttribute('colspan'))));
              }
          }
          else {
              arrTabColW.push(cell.offsetWidth);
          }
      });
      arrTabColW.forEach(function (colW) {
          intTabW += colW;
      });
      // STEP 3: Calc/Set column widths by using same column width percent from HTML table
      arrTabColW.forEach(function (colW, idxW) {
          var intCalcWidth = Number(((Number(emuSlideTabW) * ((colW / intTabW) * 100)) / 100 / EMU).toFixed(2));
          var intMinWidth = 0;
          var colSelectorMin = document.querySelector("#".concat(tabEleId, " thead tr:first-child th:nth-child(").concat(idxW + 1, ")"));
          if (colSelectorMin)
              intMinWidth = Number(colSelectorMin.getAttribute('data-pptx-min-width'));
          var colSelectorSet = document.querySelector("#".concat(tabEleId, " thead tr:first-child th:nth-child(").concat(idxW + 1, ")"));
          if (colSelectorSet)
              intMinWidth = Number(colSelectorSet.getAttribute('data-pptx-width'));
          arrColW.push((intMinWidth > intCalcWidth ? intMinWidth : intCalcWidth));
      });
      if (opts.verbose) {
          console.log("| arrColW ......................................... = [".concat(arrColW.join(', '), "]"));
      }
      // STEP 4: Iterate over each table element and create data arrays (text and opts)
      // NOTE: We create 3 arrays instead of one so we can loop over body then show header/footer rows on first and last page
      var tableParts = ['thead', 'tbody', 'tfoot'];
      tableParts.forEach(function (part) {
          document.querySelectorAll("#".concat(tabEleId, " ").concat(part, " tr")).forEach(function (row) {
              var arrObjTabCells = [];
              Array.from(row.cells).forEach(function (cell) {
                  // A: Get RGB text/bkgd colors
                  var arrRGB1 = window.getComputedStyle(cell).getPropertyValue('color').replace(/\s+/gi, '').replace('rgba(', '').replace('rgb(', '').replace(')', '').split(',');
                  var arrRGB2 = window
                      .getComputedStyle(cell)
                      .getPropertyValue('background-color')
                      .replace(/\s+/gi, '')
                      .replace('rgba(', '')
                      .replace('rgb(', '')
                      .replace(')', '')
                      .split(',');
                  if (
                  // NOTE: (ISSUE#57): Default for unstyled tables is black bkgd, so use white instead
                  window.getComputedStyle(cell).getPropertyValue('background-color') === 'rgba(0, 0, 0, 0)' ||
                      window.getComputedStyle(cell).getPropertyValue('transparent')) {
                      arrRGB2 = ['255', '255', '255'];
                  }
                  // B: Create option object
                  var cellOpts = {
                      align: null,
                      bold: !!(window.getComputedStyle(cell).getPropertyValue('font-weight') === 'bold' ||
                          Number(window.getComputedStyle(cell).getPropertyValue('font-weight')) >= 500),
                      border: null,
                      color: rgbToHex(Number(arrRGB1[0]), Number(arrRGB1[1]), Number(arrRGB1[2])),
                      fill: { color: rgbToHex(Number(arrRGB2[0]), Number(arrRGB2[1]), Number(arrRGB2[2])) },
                      fontFace: (window.getComputedStyle(cell).getPropertyValue('font-family') || '').split(',')[0].replace(/"/g, '').replace('inherit', '').replace('initial', '') ||
                          null,
                      fontSize: Number(window.getComputedStyle(cell).getPropertyValue('font-size').replace(/[a-z]/gi, '')),
                      margin: null,
                      colspan: Number(cell.getAttribute('colspan')) || null,
                      rowspan: Number(cell.getAttribute('rowspan')) || null,
                      valign: null,
                  };
                  if (['left', 'center', 'right', 'start', 'end'].includes(window.getComputedStyle(cell).getPropertyValue('text-align'))) {
                      var align = window.getComputedStyle(cell).getPropertyValue('text-align').replace('start', 'left').replace('end', 'right');
                      cellOpts.align = align === 'center' ? 'center' : align === 'left' ? 'left' : align === 'right' ? 'right' : null;
                  }
                  if (['top', 'middle', 'bottom'].includes(window.getComputedStyle(cell).getPropertyValue('vertical-align'))) {
                      var valign = window.getComputedStyle(cell).getPropertyValue('vertical-align');
                      cellOpts.valign = valign === 'top' ? 'top' : valign === 'middle' ? 'middle' : valign === 'bottom' ? 'bottom' : null;
                  }
                  // C: Add padding [margin] (if any)
                  // NOTE: Margins translate: px->pt 1:1 (e.g.: a 20px padded cell looks the same in PPTX as 20pt Text Inset/Padding)
                  if (window.getComputedStyle(cell).getPropertyValue('padding-left')) {
                      cellOpts.margin = [0, 0, 0, 0];
                      var sidesPad = ['padding-top', 'padding-right', 'padding-bottom', 'padding-left'];
                      sidesPad.forEach(function (val, idxs) {
                          cellOpts.margin[idxs] = Math.round(Number(window.getComputedStyle(cell).getPropertyValue(val).replace(/\D/gi, '')));
                      });
                  }
                  // D: Add border (if any)
                  if (window.getComputedStyle(cell).getPropertyValue('border-top-width') ||
                      window.getComputedStyle(cell).getPropertyValue('border-right-width') ||
                      window.getComputedStyle(cell).getPropertyValue('border-bottom-width') ||
                      window.getComputedStyle(cell).getPropertyValue('border-left-width')) {
                      cellOpts.border = [null, null, null, null];
                      var sidesBor = ['top', 'right', 'bottom', 'left'];
                      sidesBor.forEach(function (val, idxb) {
                          var intBorderW = Math.round(Number(window
                              .getComputedStyle(cell)
                              .getPropertyValue('border-' + val + '-width')
                              .replace('px', '')));
                          var arrRGB = [];
                          arrRGB = window
                              .getComputedStyle(cell)
                              .getPropertyValue('border-' + val + '-color')
                              .replace(/\s+/gi, '')
                              .replace('rgba(', '')
                              .replace('rgb(', '')
                              .replace(')', '')
                              .split(',');
                          var strBorderC = rgbToHex(Number(arrRGB[0]), Number(arrRGB[1]), Number(arrRGB[2]));
                          cellOpts.border[idxb] = { pt: intBorderW, color: strBorderC };
                      });
                  }
                  // LAST: Add cell
                  arrObjTabCells.push({
                      _type: SLIDE_OBJECT_TYPES.tablecell,
                      text: cell.innerText,
                      options: cellOpts,
                  });
              });
              switch (part) {
                  case 'thead':
                      arrObjTabHeadRows.push(arrObjTabCells);
                      break;
                  case 'tbody':
                      arrObjTabBodyRows.push(arrObjTabCells);
                      break;
                  case 'tfoot':
                      arrObjTabFootRows.push(arrObjTabCells);
                      break;
                  default:
                      console.log("table parsing: unexpected table part: ".concat(part));
                      break;
              }
          });
      });
      // STEP 5: Break table into Slides as needed
      // Pass head-rows as there is an option to add to each table and the parse func needs this data to fulfill that option
      opts._arrObjTabHeadRows = arrObjTabHeadRows || null;
      opts.colW = arrColW;
      getSlidesForTableRows(__spreadArray(__spreadArray(__spreadArray([], arrObjTabHeadRows, true), arrObjTabBodyRows, true), arrObjTabFootRows, true), opts, pptx.presLayout, masterSlide).forEach(function (slide, idxTr) {
          // A: Create new Slide
          var newSlide = pptx.addSlide({ masterName: opts.masterSlideName || null });
          // B: DESIGN: Reset `y` to startY or margin after first Slide (ISSUE#43, ISSUE#47, ISSUE#48)
          if (idxTr === 0)
              opts.y = opts.y || arrInchMargins[0];
          if (idxTr > 0)
              opts.y = opts.autoPageSlideStartY || opts.newSlideStartY || arrInchMargins[0];
          if (opts.verbose)
              console.log("| opts.autoPageSlideStartY: ".concat(opts.autoPageSlideStartY, " / arrInchMargins[0]: ").concat(arrInchMargins[0], " => opts.y = ").concat(opts.y));
          // C: Add table to Slide
          newSlide.addTable(slide.rows, { x: opts.x || arrInchMargins[3], y: opts.y, w: Number(emuSlideTabW) / EMU, colW: arrColW, autoPage: false });
          // D: Add any additional objects
          if (opts.addImage) {
              opts.addImage.options = opts.addImage.options || {};
              if (!opts.addImage.image || (!opts.addImage.image.path && !opts.addImage.image.data)) {
                  console.warn('Warning: tableToSlides.addImage requires either `path` or `data`');
              }
              else {
                  newSlide.addImage({
                      path: opts.addImage.image.path,
                      data: opts.addImage.image.data,
                      x: opts.addImage.options.x,
                      y: opts.addImage.options.y,
                      w: opts.addImage.options.w,
                      h: opts.addImage.options.h,
                  });
              }
          }
          if (opts.addShape)
              newSlide.addShape(opts.addShape.shapeName, opts.addShape.options || {});
          if (opts.addTable)
              newSlide.addTable(opts.addTable.rows, opts.addTable.options || {});
          if (opts.addText)
              newSlide.addText(opts.addText.text, opts.addText.options || {});
      });
  }

  /**
   * PptxGenJS: Slide Object Generators
   */
  /** counter for included charts (used for index in their filenames) */
  var _chartCounter = 0;
  /**
   * Transforms a slide definition to a slide object that is then passed to the XML transformation process.
   * @param {SlideMasterProps} props - slide definition
   * @param {PresSlide|SlideLayout} target - empty slide object that should be updated by the passed definition
   */
  function createSlideMaster(props, target) {
      // STEP 1: Add background if either the slide or layout has background props
      // if (props.background || target.background) addBackgroundDefinition(props.background, target)
      if (props.bkgd)
          target.bkgd = props.bkgd; // DEPRECATED: (remove in v4.0.0)
      // STEP 2: Add all Slide Master objects in the order they were given
      if (props.objects && Array.isArray(props.objects) && props.objects.length > 0) {
          props.objects.forEach(function (object, idx) {
              var key = Object.keys(object)[0];
              var tgt = target;
              if (MASTER_OBJECTS[key] && key === 'chart')
                  addChartDefinition(tgt, object[key].type, object[key].data, object[key].opts);
              else if (MASTER_OBJECTS[key] && key === 'image')
                  addImageDefinition(tgt, object[key]);
              else if (MASTER_OBJECTS[key] && key === 'line')
                  addShapeDefinition(tgt, SHAPE_TYPE.LINE, object[key]);
              else if (MASTER_OBJECTS[key] && key === 'rect')
                  addShapeDefinition(tgt, SHAPE_TYPE.RECTANGLE, object[key]);
              else if (MASTER_OBJECTS[key] && key === 'text')
                  addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, false);
              else if (MASTER_OBJECTS[key] && key === 'placeholder') {
                  // TODO: 20180820: Check for existing `name`?
                  object[key].options.placeholder = object[key].options.name;
                  delete object[key].options.name; // remap name for earier handling internally
                  object[key].options._placeholderType = object[key].options.type;
                  delete object[key].options.type; // remap name for earier handling internally
                  object[key].options._placeholderIdx = 100 + idx;
                  addTextDefinition(tgt, [{ text: object[key].text }], object[key].options, true);
                  // TODO: ISSUE#599 - only text is suported now (add more below)
                  // else if (object[key].image) addImageDefinition(tgt, object[key].image)
                  /* 20200120: So... image placeholders go into the "slideLayoutN.xml" file and addImage doesnt do this yet...
                      <p:sp>
                    <p:nvSpPr>
                      <p:cNvPr id="7" name="Picture Placeholder 6">
                        <a:extLst>
                          <a:ext uri="{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}">
                            <a16:creationId xmlns:a16="http://schemas.microsoft.com/office/drawing/2014/main" id="{CE1AE45D-8641-0F4F-BDB5-080E69CCB034}"/>
                          </a:ext>
                        </a:extLst>
                      </p:cNvPr>
                      <p:cNvSpPr>
                  */
              }
          });
      }
      // STEP 3: Add Slide Numbers (NOTE: Do this last so numbers are not covered by objects!)
      if (props.slideNumber && typeof props.slideNumber === 'object')
          target._slideNumberProps = props.slideNumber;
  }
  /**
   * Generate the chart based on input data.
   * OOXML Chart Spec: ISO/IEC 29500-1:2016(E)
   *
   * @param {CHART_NAME | IChartMulti[]} `type` should belong to: 'column', 'pie'
   * @param {[]} `data` a JSON object with follow the following format
   * @param {IChartOptsLib} `opt` chart options
   * @param {PresSlide} `target` slide object that the chart will be added to
   * @return {object} chart object
   * {
   *    title: 'eSurvey chart',
   *    data: [
   *        {
   *            name: 'Income',
   *            labels: ['2005', '2006', '2007', '2008', '2009'],
   *            values: [23.5, 26.2, 30.1, 29.5, 24.6]
   *        },
   *        {
   *            name: 'Expense',
   *            labels: ['2005', '2006', '2007', '2008', '2009'],
   *            values: [18.1, 22.8, 23.9, 25.1, 25]
   *        }
   *    ]
   * }
   */
  function addChartDefinition(target, type, data, opt) {
      var _a;
      function correctGridLineOptions(glOpts) {
          if (!glOpts || glOpts.style === 'none')
              return;
          if (glOpts.size !== undefined && (isNaN(Number(glOpts.size)) || glOpts.size <= 0)) {
              console.warn('Warning: chart.gridLine.size must be greater than 0.');
              delete glOpts.size; // delete prop to used defaults
          }
          if (glOpts.style && !['solid', 'dash', 'dot'].includes(glOpts.style)) {
              console.warn('Warning: chart.gridLine.style options: `solid`, `dash`, `dot`.');
              delete glOpts.style;
          }
          if (glOpts.cap && !['flat', 'square', 'round'].includes(glOpts.cap)) {
              console.warn('Warning: chart.gridLine.cap options: `flat`, `square`, `round`.');
              delete glOpts.cap;
          }
      }
      var chartId = ++_chartCounter;
      var resultObject = {
          _type: null,
          text: null,
          options: null,
          chartRid: null,
      };
      // DESIGN: `type` can an object (ex: `pptx.charts.DOUGHNUT`) or an array of chart objects
      // EX: addChartDefinition([ { type:pptx.charts.BAR, data:{name:'', labels:[], values[]} }, {<etc>} ])
      // Multi-Type Charts
      var tmpOpt = null;
      var tmpData = [];
      if (Array.isArray(type)) {
          // For multi-type charts there needs to be data for each type,
          // as well as a single data source for non-series operations.
          // The data is indexed below to keep the data in order when segmented
          // into types.
          type.forEach(function (obj) {
              tmpData = tmpData.concat(obj.data);
          });
          tmpOpt = data || opt;
      }
      else {
          tmpData = data;
          tmpOpt = opt;
      }
      tmpData.forEach(function (item, i) {
          item._dataIndex = i;
          // Converts the 'labels' array from string[] to string[][] (or the respective primitive type), if needed
          if (item.labels !== undefined && !Array.isArray(item.labels[0])) {
              item.labels = [item.labels];
          }
      });
      var options = tmpOpt && typeof tmpOpt === 'object' ? tmpOpt : {};
      // STEP 1: TODO: check for reqd fields, correct type, etc
      // `type` exists in CHART_TYPE
      // Array.isArray(data)
      /*
          if ( Array.isArray(rel.data) && rel.data.length > 0 && typeof rel.data[0] === 'object'
              && rel.data[0].labels && Array.isArray(rel.data[0].labels)
              && rel.data[0].values && Array.isArray(rel.data[0].values) ) {
              obj = rel.data[0];
          }
          else {
              console.warn("USAGE: addChart( 'pie', [ {name:'Sales', labels:['Jan','Feb'], values:[10,20]} ], {x:1, y:1} )");
              return;
          }
          */
      // STEP 2: Set default options/decode user options
      // A: Core
      options._type = type;
      options.x = typeof options.x !== 'undefined' && options.x != null && !isNaN(Number(options.x)) ? options.x : 1;
      options.y = typeof options.y !== 'undefined' && options.y != null && !isNaN(Number(options.y)) ? options.y : 1;
      options.w = options.w || '50%';
      options.h = options.h || '50%';
      options.objectName = options.objectName
          ? encodeXmlEntities(options.objectName)
          : "Chart ".concat(target._slideObjects.filter(function (obj) { return obj._type === SLIDE_OBJECT_TYPES.chart; }).length);
      // B: Options: misc
      if (!['bar', 'col'].includes(options.barDir || ''))
          options.barDir = 'col';
      // barGrouping: "21.2.3.17 ST_Grouping (Grouping)"
      // barGrouping must be handled before data label validation as it can affect valid label positioning
      if (options._type === CHART_TYPE.AREA) {
          if (!['stacked', 'standard', 'percentStacked'].includes(options.barGrouping || ''))
              options.barGrouping = 'standard';
      }
      if (options._type === CHART_TYPE.BAR) {
          if (!['clustered', 'stacked', 'percentStacked'].includes(options.barGrouping || ''))
              options.barGrouping = 'clustered';
      }
      if (options._type === CHART_TYPE.BAR3D) {
          if (!['clustered', 'stacked', 'standard', 'percentStacked'].includes(options.barGrouping || ''))
              options.barGrouping = 'standard';
      }
      if ((_a = options.barGrouping) === null || _a === void 0 ? void 0 : _a.includes('tacked')) {
          if (!options.barGapWidthPct)
              options.barGapWidthPct = 50;
      }
      // Clean up and validate data label positions
      // REFERENCE: https://docs.microsoft.com/en-us/openspecs/office_standards/ms-oi29500/e2b1697c-7adc-463d-9081-3daef72f656f?redirectedfrom=MSDN
      if (options.dataLabelPosition) {
          if (options._type === CHART_TYPE.AREA || options._type === CHART_TYPE.BAR3D || options._type === CHART_TYPE.DOUGHNUT || options._type === CHART_TYPE.RADAR) {
              delete options.dataLabelPosition;
          }
          if (options._type === CHART_TYPE.PIE) {
              if (!['bestFit', 'ctr', 'inEnd', 'outEnd'].includes(options.dataLabelPosition))
                  delete options.dataLabelPosition;
          }
          if (options._type === CHART_TYPE.BUBBLE || options._type === CHART_TYPE.BUBBLE3D || options._type === CHART_TYPE.LINE || options._type === CHART_TYPE.SCATTER) {
              if (!['b', 'ctr', 'l', 'r', 't'].includes(options.dataLabelPosition))
                  delete options.dataLabelPosition;
          }
          if (options._type === CHART_TYPE.BAR) {
              if (!['stacked', 'percentStacked'].includes(options.barGrouping || '')) {
                  if (!['ctr', 'inBase', 'inEnd'].includes(options.dataLabelPosition))
                      delete options.dataLabelPosition;
              }
              if (!['clustered'].includes(options.barGrouping || '')) {
                  if (!['ctr', 'inBase', 'inEnd', 'outEnd'].includes(options.dataLabelPosition))
                      delete options.dataLabelPosition;
              }
          }
      }
      options.dataLabelBkgrdColors = options.dataLabelBkgrdColors || !options.dataLabelBkgrdColors ? options.dataLabelBkgrdColors : false;
      if (!['b', 'l', 'r', 't', 'tr'].includes(options.legendPos || ''))
          options.legendPos = 'r';
      // 3D bar: ST_Shape
      if (!['cone', 'coneToMax', 'box', 'cylinder', 'pyramid', 'pyramidToMax'].includes(options.bar3DShape || ''))
          options.bar3DShape = 'box';
      // lineDataSymbol: http://www.datypic.com/sc/ooxml/a-val-32.html
      // Spec has [plus,star,x] however neither PPT2013 nor PPT-Online support them
      if (!['circle', 'dash', 'diamond', 'dot', 'none', 'square', 'triangle'].includes(options.lineDataSymbol || ''))
          options.lineDataSymbol = 'circle';
      if (!['gap', 'span'].includes(options.displayBlanksAs || ''))
          options.displayBlanksAs = 'span';
      if (!['standard', 'marker', 'filled'].includes(options.radarStyle || ''))
          options.radarStyle = 'standard';
      options.lineDataSymbolSize = options.lineDataSymbolSize && !isNaN(options.lineDataSymbolSize) ? options.lineDataSymbolSize : 6;
      options.lineDataSymbolLineSize = options.lineDataSymbolLineSize && !isNaN(options.lineDataSymbolLineSize) ? valToPts(options.lineDataSymbolLineSize) : valToPts(0.75);
      // `layout` allows the override of PPT defaults to maximize space
      if (options.layout) {
          ['x', 'y', 'w', 'h'].forEach(function (key) {
              var val = options.layout[key];
              if (isNaN(Number(val)) || val < 0 || val > 1) {
                  console.warn('Warning: chart.layout.' + key + ' can only be 0-1');
                  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                  delete options.layout[key]; // remove invalid value so that default will be used
              }
          });
      }
      // Set gridline defaults
      options.catGridLine = options.catGridLine || (options._type === CHART_TYPE.SCATTER ? { color: 'D9D9D9', size: 1 } : { style: 'none' });
      options.valGridLine = options.valGridLine || (options._type === CHART_TYPE.SCATTER ? { color: 'D9D9D9', size: 1 } : {});
      options.serGridLine = options.serGridLine || (options._type === CHART_TYPE.SCATTER ? { color: 'D9D9D9', size: 1 } : { style: 'none' });
      correctGridLineOptions(options.catGridLine);
      correctGridLineOptions(options.valGridLine);
      correctGridLineOptions(options.serGridLine);
      correctShadowOptions(options.shadow);
      // C: Options: plotArea
      options.showDataTable = options.showDataTable || !options.showDataTable ? options.showDataTable : false;
      options.showDataTableHorzBorder = options.showDataTableHorzBorder || !options.showDataTableHorzBorder ? options.showDataTableHorzBorder : true;
      options.showDataTableVertBorder = options.showDataTableVertBorder || !options.showDataTableVertBorder ? options.showDataTableVertBorder : true;
      options.showDataTableOutline = options.showDataTableOutline || !options.showDataTableOutline ? options.showDataTableOutline : true;
      options.showDataTableKeys = options.showDataTableKeys || !options.showDataTableKeys ? options.showDataTableKeys : true;
      options.showLabel = options.showLabel || !options.showLabel ? options.showLabel : false;
      options.showLegend = options.showLegend || !options.showLegend ? options.showLegend : false;
      options.showPercent = options.showPercent || !options.showPercent ? options.showPercent : true;
      options.showTitle = options.showTitle || !options.showTitle ? options.showTitle : false;
      options.showValue = options.showValue || !options.showValue ? options.showValue : false;
      options.showLeaderLines = options.showLeaderLines || !options.showLeaderLines ? options.showLeaderLines : false;
      options.catAxisLineShow = typeof options.catAxisLineShow !== 'undefined' ? options.catAxisLineShow : true;
      options.valAxisLineShow = typeof options.valAxisLineShow !== 'undefined' ? options.valAxisLineShow : true;
      options.serAxisLineShow = typeof options.serAxisLineShow !== 'undefined' ? options.serAxisLineShow : true;
      options.v3DRotX = !isNaN(options.v3DRotX) && options.v3DRotX >= -90 && options.v3DRotX <= 90 ? options.v3DRotX : 30;
      options.v3DRotY = !isNaN(options.v3DRotY) && options.v3DRotY >= 0 && options.v3DRotY <= 360 ? options.v3DRotY : 30;
      options.v3DRAngAx = options.v3DRAngAx || !options.v3DRAngAx ? options.v3DRAngAx : true;
      options.v3DPerspective = !isNaN(options.v3DPerspective) && options.v3DPerspective >= 0 && options.v3DPerspective <= 240 ? options.v3DPerspective : 30;
      // D: Options: chart
      options.barGapWidthPct = !isNaN(options.barGapWidthPct) && options.barGapWidthPct >= 0 && options.barGapWidthPct <= 1000 ? options.barGapWidthPct : 150;
      options.barGapDepthPct = !isNaN(options.barGapDepthPct) && options.barGapDepthPct >= 0 && options.barGapDepthPct <= 1000 ? options.barGapDepthPct : 150;
      options.chartColors = Array.isArray(options.chartColors)
          ? options.chartColors
          : options._type === CHART_TYPE.PIE || options._type === CHART_TYPE.DOUGHNUT
              ? PIECHART_COLORS
              : BARCHART_COLORS;
      options.chartColorsOpacity = options.chartColorsOpacity && !isNaN(options.chartColorsOpacity) ? options.chartColorsOpacity : null;
      // DEPRECATED: v3.11.0 - use `plotArea.border` vvv
      options.border = options.border && typeof options.border === 'object' ? options.border : null;
      if (options.border && (!options.border.pt || isNaN(options.border.pt)))
          options.border.pt = DEF_CHART_BORDER.pt;
      if (options.border && (!options.border.color || typeof options.border.color !== 'string'))
          options.border.color = DEF_CHART_BORDER.color;
      // DEPRECATED: (remove above in v4.0) ^^^
      options.plotArea = options.plotArea || {};
      options.plotArea.border = options.plotArea.border && typeof options.plotArea.border === 'object' ? options.plotArea.border : null;
      if (options.plotArea.border && (!options.plotArea.border.pt || isNaN(options.plotArea.border.pt)))
          options.plotArea.border.pt = DEF_CHART_BORDER.pt;
      if (options.plotArea.border && (!options.plotArea.border.color || typeof options.plotArea.border.color !== 'string')) {
          options.plotArea.border.color = DEF_CHART_BORDER.color;
      }
      if (options.border)
          options.plotArea.border = options.border; // @deprecated [[remove in v4.0]]
      options.plotArea.fill = options.plotArea.fill || { color: null, transparency: null };
      if (options.fill)
          options.plotArea.fill.color = options.fill; // @deprecated [[remove in v4.0]]
      //
      options.chartArea = options.chartArea || {};
      options.chartArea.border = options.chartArea.border && typeof options.chartArea.border === 'object' ? options.chartArea.border : null;
      if (options.chartArea.border) {
          options.chartArea.border = {
              color: options.chartArea.border.color || DEF_CHART_BORDER.color,
              pt: options.chartArea.border.pt || DEF_CHART_BORDER.pt,
          };
      }
      options.chartArea.roundedCorners = typeof options.chartArea.roundedCorners === 'boolean' ? options.chartArea.roundedCorners : true;
      //
      options.dataBorder = options.dataBorder && typeof options.dataBorder === 'object' ? options.dataBorder : null;
      if (options.dataBorder && (!options.dataBorder.pt || isNaN(options.dataBorder.pt)))
          options.dataBorder.pt = 0.75;
      if (options.dataBorder && (!options.dataBorder.color || typeof options.dataBorder.color !== 'string' || options.dataBorder.color.length !== 6)) {
          options.dataBorder.color = 'F9F9F9';
      }
      //
      if (!options.dataLabelFormatCode && options._type === CHART_TYPE.SCATTER)
          options.dataLabelFormatCode = 'General';
      if (!options.dataLabelFormatCode && (options._type === CHART_TYPE.PIE || options._type === CHART_TYPE.DOUGHNUT)) {
          options.dataLabelFormatCode = options.showPercent ? '0%' : 'General';
      }
      options.dataLabelFormatCode = options.dataLabelFormatCode && typeof options.dataLabelFormatCode === 'string' ? options.dataLabelFormatCode : '#,##0';
      //
      // Set default format for Scatter chart labels to custom string if not defined
      if (!options.dataLabelFormatScatter && options._type === CHART_TYPE.SCATTER)
          options.dataLabelFormatScatter = 'custom';
      //
      options.lineSize = typeof options.lineSize === 'number' ? options.lineSize : 2;
      options.valAxisMajorUnit = typeof options.valAxisMajorUnit === 'number' ? options.valAxisMajorUnit : null;
      if (options._type === CHART_TYPE.AREA || options._type === CHART_TYPE.BAR || options._type === CHART_TYPE.BAR3D || options._type === CHART_TYPE.LINE) {
          options.catAxisMultiLevelLabels = !!options.catAxisMultiLevelLabels;
      }
      else {
          delete options.catAxisMultiLevelLabels;
      }
      // STEP 4: Set props
      resultObject._type = 'chart';
      resultObject.options = options;
      resultObject.chartRid = getNewRelId(target);
      // STEP 5: Add this chart to this Slide Rels (rId/rels count spans all slides! Count all images to get next rId)
      target._relsChart.push({
          rId: getNewRelId(target),
          data: tmpData,
          opts: options,
          type: options._type,
          globalId: chartId,
          fileName: "chart".concat(chartId, ".xml"),
          Target: "/ppt/charts/chart".concat(chartId, ".xml"),
      });
      target._slideObjects.push(resultObject);
      return resultObject;
  }
  /**
   * Adds an image object to a slide definition.
   * This method can be called with only two args (opt, target) - this is supposed to be the only way in future.
   * @param {ImageProps} `opt` - object containing `path`/`data`, `x`, `y`, etc.
   * @param {PresSlide} `target` - slide that the image should be added to (if not specified as the 2nd arg)
   * @note: Remote images (eg: "http://whatev.com/blah"/from web and/or remote server arent supported yet - we'd need to create an <img>, load it, then send to canvas
   * @see: https://stackoverflow.com/questions/164181/how-to-fetch-a-remote-image-to-display-in-a-canvas)
   */
  function addImageDefinition(target, opt) {
      var newObject = {
          _type: null,
          text: null,
          options: null,
          image: null,
          imageRid: null,
          hyperlink: null,
      };
      // FIRST: Set vars for this image (object param replaces positional args in 1.1.0)
      var intPosX = opt.x || 0;
      var intPosY = opt.y || 0;
      var intWidth = opt.w || 0;
      var intHeight = opt.h || 0;
      var sizing = opt.sizing || null;
      var objHyperlink = opt.hyperlink || '';
      var strImageData = opt.data || '';
      var strImagePath = opt.path || '';
      var imageRelId = getNewRelId(target);
      var objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Image ".concat(target._slideObjects.filter(function (obj) { return obj._type === SLIDE_OBJECT_TYPES.image; }).length);
      // REALITY-CHECK:
      if (!strImagePath && !strImageData) {
          console.error('ERROR: addImage() requires either \'data\' or \'path\' parameter!');
          return null;
      }
      else if (strImagePath && typeof strImagePath !== 'string') {
          console.error("ERROR: addImage() 'path' should be a string, ex: {path:'/img/sample.png'} - you sent ".concat(String(strImagePath)));
          return null;
      }
      else if (strImageData && typeof strImageData !== 'string') {
          console.error("ERROR: addImage() 'data' should be a string, ex: {data:'image/png;base64,NMP[...]'} - you sent ".concat(String(strImageData)));
          return null;
      }
      else if (strImageData && typeof strImageData === 'string' && !strImageData.toLowerCase().includes('base64,')) {
          console.error('ERROR: Image `data` value lacks a base64 header! Ex: \'image/png;base64,NMP[...]\')');
          return null;
      }
      // STEP 1: Set extension
      // NOTE: Split to address URLs with params (eg: `path/brent.jpg?someParam=true`)
      var strImgExtn = (strImagePath
          .substring(strImagePath.lastIndexOf('/') + 1)
          .split('?')[0]
          .split('.')
          .pop()
          .split('#')[0] || 'png').toLowerCase();
      // However, pre-encoded images can be whatever mime-type they want (and good for them!)
      if (strImageData && /image\/(\w+);/.exec(strImageData) && /image\/(\w+);/.exec(strImageData).length > 0) {
          strImgExtn = /image\/(\w+);/.exec(strImageData)[1];
      }
      else if (strImageData === null || strImageData === void 0 ? void 0 : strImageData.toLowerCase().includes('image/svg+xml')) {
          strImgExtn = 'svg';
      }
      // STEP 2: Set type/path
      newObject._type = SLIDE_OBJECT_TYPES.image;
      newObject.image = strImagePath || 'preencoded.png';
      // STEP 3: Set image properties & options
      // FIXME: Measure actual image when no intWidth/intHeight params passed
      // ....: This is an async process: we need to make getSizeFromImage use callback, then set H/W...
      // if ( !intWidth || !intHeight ) { var imgObj = getSizeFromImage(strImagePath);
      newObject.options = {
          x: intPosX || 0,
          y: intPosY || 0,
          w: intWidth || 1,
          h: intHeight || 1,
          altText: opt.altText || '',
          rounding: typeof opt.rounding === 'boolean' ? opt.rounding : false,
          sizing: sizing,
          placeholder: opt.placeholder,
          rotate: opt.rotate || 0,
          flipV: opt.flipV || false,
          flipH: opt.flipH || false,
          transparency: opt.transparency || 0,
          objectName: objectName,
          shadow: correctShadowOptions(opt.shadow),
      };
      // STEP 4: Add this image to this Slide Rels (rId/rels count spans all slides! Count all images to get next rId)
      if (strImgExtn === 'svg') {
          // SVG files consume *TWO* rId's: (a png version and the svg image)
          // <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="../media/image1.png"/>
          // <Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="../media/image2.svg"/>
          target._relsMedia.push({
              path: strImagePath || strImageData + 'png',
              type: 'image/png',
              extn: 'png',
              data: strImageData || '',
              rId: imageRelId,
              Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png"),
              isSvgPng: true,
              svgSize: { w: getSmartParseNumber(newObject.options.w, 'X', target._presLayout), h: getSmartParseNumber(newObject.options.h, 'Y', target._presLayout) },
          });
          newObject.imageRid = imageRelId;
          target._relsMedia.push({
              path: strImagePath || strImageData,
              type: 'image/svg+xml',
              extn: strImgExtn,
              data: strImageData || '',
              rId: imageRelId + 1,
              Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn),
          });
          newObject.imageRid = imageRelId + 1;
      }
      else {
          // PERF: Duplicate media should reuse existing `Target` value and not create an additional copy
          var dupeItem = target._relsMedia.filter(function (item) { return item.path && item.path === strImagePath && item.type === 'image/' + strImgExtn && !item.isDuplicate; })[0];
          target._relsMedia.push({
              path: strImagePath || 'preencoded.' + strImgExtn,
              type: 'image/' + strImgExtn,
              extn: strImgExtn,
              data: strImageData || '',
              rId: imageRelId,
              isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),
              Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn),
          });
          newObject.imageRid = imageRelId;
      }
      // STEP 5: Hyperlink support
      if (typeof objHyperlink === 'object') {
          if (!objHyperlink.url && !objHyperlink.slide)
              throw new Error('ERROR: `hyperlink` option requires either: `url` or `slide`');
          else {
              imageRelId++;
              target._rels.push({
                  type: SLIDE_OBJECT_TYPES.hyperlink,
                  data: objHyperlink.slide ? 'slide' : 'dummy',
                  rId: imageRelId,
                  Target: objHyperlink.url || objHyperlink.slide.toString(),
              });
              objHyperlink._rId = imageRelId;
              newObject.hyperlink = objHyperlink;
          }
      }
      // STEP 6: Add object to slide
      target._slideObjects.push(newObject);
  }
  /**
   * Adds a media object to a slide definition.
   * @param {PresSlide} `target` - slide object that the media will be added to
   * @param {MediaProps} `opt` - media options
   */
  function addMediaDefinition(target, opt) {
      var intPosX = opt.x || 0;
      var intPosY = opt.y || 0;
      var intSizeX = opt.w || 2;
      var intSizeY = opt.h || 2;
      var strData = opt.data || '';
      var strLink = opt.link || '';
      var strPath = opt.path || '';
      var strType = opt.type || 'audio';
      var strExtn = '';
      var strCover = opt.cover || IMG_PLAYBTN;
      var objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Media ".concat(target._slideObjects.filter(function (obj) { return obj._type === SLIDE_OBJECT_TYPES.media; }).length);
      var slideData = { _type: SLIDE_OBJECT_TYPES.media };
      // STEP 1: REALITY-CHECK
      if (!strPath && !strData && strType !== 'online') {
          throw new Error('addMedia() error: either `data` or `path` are required!');
      }
      else if (strData && !strData.toLowerCase().includes('base64,')) {
          throw new Error('addMedia() error: `data` value lacks a base64 header! Ex: \'video/mpeg;base64,NMP[...]\')');
      }
      else if (strCover && !strCover.toLowerCase().includes('base64,')) {
          throw new Error('addMedia() error: `cover` value lacks a base64 header! Ex: \'data:image/png;base64,iV[...]\')');
      }
      // Online Video: requires `link`
      if (strType === 'online' && !strLink) {
          throw new Error('addMedia() error: online videos require `link` value');
      }
      // FIXME: 20190707
      // strType = strData ? strData.split(';')[0].split('/')[0] : strType
      strExtn = opt.extn || (strData ? strData.split(';')[0].split('/')[1] : strPath.split('.').pop()) || 'mp3';
      // STEP 2: Set type, media
      slideData.mtype = strType;
      slideData.media = strPath || 'preencoded.mov';
      slideData.options = {};
      // STEP 3: Set media properties & options
      slideData.options.x = intPosX;
      slideData.options.y = intPosY;
      slideData.options.w = intSizeX;
      slideData.options.h = intSizeY;
      slideData.options.objectName = objectName;
      // STEP 4: Add this media to this Slide Rels (rId/rels count spans all slides! Count all media to get next rId)
      /**
       * NOTE:
       * - rId starts at 2 (hence the intRels+1 below) as slideLayout.xml is rId=1!
       *
       * NOTE:
       * - Audio/Video files consume *TWO* rId's:
       * <Relationship Id="rId2" Target="../media/media1.mov" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video"/>
       * <Relationship Id="rId3" Target="../media/media1.mov" Type="http://schemas.microsoft.com/office/2007/relationships/media"/>
       */
      if (strType === 'online') {
          var relId1 = getNewRelId(target);
          // A: Add video
          target._relsMedia.push({
              path: strPath || 'preencoded' + strExtn,
              data: 'dummy',
              type: 'online',
              extn: strExtn,
              rId: relId1,
              Target: strLink,
          });
          slideData.mediaRid = relId1;
          // B: Add cover (preview/overlay) image
          target._relsMedia.push({
              path: 'preencoded.png',
              data: strCover,
              type: 'image/png',
              extn: 'png',
              rId: getNewRelId(target),
              Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png"),
          });
      }
      else {
          // PERF: Duplicate media should reuse existing `Target` value and not create an additional copy
          var dupeItem = target._relsMedia.filter(function (item) { return item.path && item.path === strPath && item.type === strType + '/' + strExtn && !item.isDuplicate; })[0];
          // A: "relationships/video"
          var relId1 = getNewRelId(target);
          target._relsMedia.push({
              path: strPath || 'preencoded' + strExtn,
              type: strType + '/' + strExtn,
              extn: strExtn,
              data: strData || '',
              rId: relId1,
              isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),
              Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : "../media/media-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".").concat(strExtn),
          });
          slideData.mediaRid = relId1;
          // B: "relationships/media"
          target._relsMedia.push({
              path: strPath || 'preencoded' + strExtn,
              type: strType + '/' + strExtn,
              extn: strExtn,
              data: strData || '',
              rId: getNewRelId(target),
              isDuplicate: !!(dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target),
              Target: (dupeItem === null || dupeItem === void 0 ? void 0 : dupeItem.Target) ? dupeItem.Target : "../media/media-".concat(target._slideNum, "-").concat(target._relsMedia.length + 0, ".").concat(strExtn),
          });
          // C: Add cover (preview/overlay) image
          target._relsMedia.push({
              path: 'preencoded.png',
              type: 'image/png',
              extn: 'png',
              data: strCover,
              rId: getNewRelId(target),
              Target: "../media/image-".concat(target._slideNum, "-").concat(target._relsMedia.length + 1, ".png"),
          });
      }
      // LAST
      target._slideObjects.push(slideData);
  }
  /**
   * Adds Notes to a slide.
   * @param {PresSlide} `target` slide object
   * @param {string} `notes`
   * @since 2.3.0
   */
  function addNotesDefinition(target, notes) {
      target._slideObjects.push({
          _type: SLIDE_OBJECT_TYPES.notes,
          text: [{ text: notes }],
      });
  }
  /**
   * Adds a shape object to a slide definition.
   * @param {PresSlide} target slide object that the shape should be added to
   * @param {SHAPE_NAME} shapeName shape name
   * @param {ShapeProps} opts shape options
   */
  function addShapeDefinition(target, shapeName, opts) {
      var options = typeof opts === 'object' ? opts : {};
      options.line = options.line || { type: 'none' };
      var newObject = {
          _type: SLIDE_OBJECT_TYPES.text,
          shape: shapeName || SHAPE_TYPE.RECTANGLE,
          options: options,
          text: null,
      };
      // Reality check
      if (!shapeName)
          throw new Error('Missing/Invalid shape parameter! Example: `addShape(pptxgen.shapes.LINE, {x:1, y:1, w:1, h:1});`');
      // 1: ShapeLineProps defaults
      var newLineOpts = {
          type: options.line.type || 'solid',
          color: options.line.color || DEF_SHAPE_LINE_COLOR,
          transparency: options.line.transparency || 0,
          width: options.line.width || 1,
          dashType: options.line.dashType || 'solid',
          beginArrowType: options.line.beginArrowType || null,
          endArrowType: options.line.endArrowType || null,
      };
      if (typeof options.line === 'object' && options.line.type !== 'none')
          options.line = newLineOpts;
      // 2: Set options defaults
      options.x = options.x || (options.x === 0 ? 0 : 1);
      options.y = options.y || (options.y === 0 ? 0 : 1);
      options.w = options.w || (options.w === 0 ? 0 : 1);
      options.h = options.h || (options.h === 0 ? 0 : 1);
      options.objectName = options.objectName
          ? encodeXmlEntities(options.objectName)
          : "Shape ".concat(target._slideObjects.filter(function (obj) { return obj._type === SLIDE_OBJECT_TYPES.text; }).length);
      // 3: Handle line (lots of deprecated opts)
      if (typeof options.line === 'string') {
          var tmpOpts = newLineOpts;
          tmpOpts.color = String(options.line); // @deprecated `options.line` string (was line color)
          options.line = tmpOpts;
      }
      if (typeof options.lineSize === 'number')
          options.line.width = options.lineSize; // @deprecated (part of `ShapeLineProps` now)
      if (typeof options.lineDash === 'string')
          options.line.dashType = options.lineDash; // @deprecated (part of `ShapeLineProps` now)
      if (typeof options.lineHead === 'string')
          options.line.beginArrowType = options.lineHead; // @deprecated (part of `ShapeLineProps` now)
      if (typeof options.lineTail === 'string')
          options.line.endArrowType = options.lineTail; // @deprecated (part of `ShapeLineProps` now)
      // 4: Create hyperlink rels
      createHyperlinkRels(target, newObject);
      // LAST: Add object to slide
      target._slideObjects.push(newObject);
  }
  /**
   * Adds a table object to a slide definition.
   * @param {PresSlide} target - slide object that the table should be added to
   * @param {TableRow[]} tableRows - table data
   * @param {TableProps} options - table options
   * @param {SlideLayout} slideLayout - Slide layout
   * @param {PresLayout} presLayout - Presentation layout
   * @param {Function} addSlide - method
   * @param {Function} getSlide - method
   */
  function addTableDefinition(target, tableRows, options, slideLayout, presLayout, addSlide, getSlide) {
      var slides = [target]; // Create array of Slides as more may be added by auto-paging
      var opt = options && typeof options === 'object' ? options : {};
      opt.objectName = opt.objectName ? encodeXmlEntities(opt.objectName) : "Table ".concat(target._slideObjects.filter(function (obj) { return obj._type === SLIDE_OBJECT_TYPES.table; }).length);
      // STEP 1: REALITY-CHECK
      {
          // A: check for empty
          if (tableRows === null || tableRows.length === 0 || !Array.isArray(tableRows)) {
              throw new Error('addTable: Array expected! EX: \'slide.addTable( [rows], {options} );\' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)');
          }
          // B: check for non-well-formatted array (ex: rows=['a','b'] instead of [['a','b']])
          if (!tableRows[0] || !Array.isArray(tableRows[0])) {
              throw new Error('addTable: \'rows\' should be an array of cells! EX: \'slide.addTable( [ [\'A\'], [\'B\'], {text:\'C\',options:{align:\'center\'}} ] );\' (https://gitbrent.github.io/PptxGenJS/docs/api-tables.html)');
          }
          // TODO: FUTURE: This is wacky and wont function right (shows .w value when there is none from demo.js?!) 20191219
          /*
          if (opt.w && opt.colW) {
              console.warn('addTable: please use either `colW` or `w` - not both (table will use `colW` and ignore `w`)')
              console.log(`${opt.w} ${opt.colW}`)
          }
          */
      }
      // STEP 2: Transform `tableRows` into well-formatted TableCell's
      // tableRows can be object or plain text array: `[{text:'cell 1'}, {text:'cell 2', options:{color:'ff0000'}}]` | `["cell 1", "cell 2"]`
      var arrRows = [];
      tableRows.forEach(function (row) {
          var newRow = [];
          if (Array.isArray(row)) {
              row.forEach(function (cell) {
                  // A:
                  var newCell = {
                      _type: SLIDE_OBJECT_TYPES.tablecell,
                      text: '',
                      options: typeof cell === 'object' && cell.options ? cell.options : {},
                  };
                  // B:
                  if (typeof cell === 'string' || typeof cell === 'number')
                      newCell.text = cell.toString();
                  else if (cell.text) {
                      // Cell can contain complex text type, or string, or number
                      if (typeof cell.text === 'string' || typeof cell.text === 'number')
                          newCell.text = cell.text.toString();
                      else if (cell.text)
                          newCell.text = cell.text;
                      // Capture options
                      if (cell.options && typeof cell.options === 'object')
                          newCell.options = cell.options;
                  }
                  // C: Set cell borders
                  newCell.options.border = newCell.options.border || opt.border || [{ type: 'none' }, { type: 'none' }, { type: 'none' }, { type: 'none' }];
                  var cellBorder = newCell.options.border;
                  // CASE 1: border interface is: BorderOptions | [BorderOptions, BorderOptions, BorderOptions, BorderOptions]
                  if (!Array.isArray(cellBorder) && typeof cellBorder === 'object')
                      newCell.options.border = [cellBorder, cellBorder, cellBorder, cellBorder];
                  // Handle: [null, null, {type:'solid'}, null]
                  if (!newCell.options.border[0])
                      newCell.options.border[0] = { type: 'none' };
                  if (!newCell.options.border[1])
                      newCell.options.border[1] = { type: 'none' };
                  if (!newCell.options.border[2])
                      newCell.options.border[2] = { type: 'none' };
                  if (!newCell.options.border[3])
                      newCell.options.border[3] = { type: 'none' };
                  // set complete BorderOptions for all sides
                  var arrSides = [0, 1, 2, 3];
                  arrSides.forEach(function (idx) {
                      newCell.options.border[idx] = {
                          type: newCell.options.border[idx].type || DEF_CELL_BORDER.type,
                          color: newCell.options.border[idx].color || DEF_CELL_BORDER.color,
                          pt: typeof newCell.options.border[idx].pt === 'number' ? newCell.options.border[idx].pt : DEF_CELL_BORDER.pt,
                      };
                  });
                  // LAST:
                  newRow.push(newCell);
              });
          }
          else {
              console.log('addTable: tableRows has a bad row. A row should be an array of cells. You provided:');
              console.log(row);
          }
          arrRows.push(newRow);
      });
      // STEP 3: Set options
      opt.x = getSmartParseNumber(opt.x || (opt.x === 0 ? 0 : EMU / 2), 'X', presLayout);
      opt.y = getSmartParseNumber(opt.y || (opt.y === 0 ? 0 : EMU / 2), 'Y', presLayout);
      if (opt.h)
          opt.h = getSmartParseNumber(opt.h, 'Y', presLayout); // NOTE: Dont set default `h` - leaving it null triggers auto-rowH in `makeXMLSlide()`
      opt.fontSize = opt.fontSize || DEF_FONT_SIZE;
      opt.margin = opt.margin === 0 || opt.margin ? opt.margin : DEF_CELL_MARGIN_IN;
      if (typeof opt.margin === 'number')
          opt.margin = [Number(opt.margin), Number(opt.margin), Number(opt.margin), Number(opt.margin)];
      if (!opt.color)
          opt.color = opt.color || DEF_FONT_COLOR; // Set default color if needed (table option > inherit from Slide > default to black)
      if (typeof opt.border === 'string') {
          console.warn('addTable `border` option must be an object. Ex: `{border: {type:\'none\'}}`');
          opt.border = null;
      }
      else if (Array.isArray(opt.border)) {
          [0, 1, 2, 3].forEach(function (idx) {
              opt.border[idx] = opt.border[idx]
                  ? { type: opt.border[idx].type || DEF_CELL_BORDER.type, color: opt.border[idx].color || DEF_CELL_BORDER.color, pt: opt.border[idx].pt || DEF_CELL_BORDER.pt }
                  : { type: 'none' };
          });
      }
      opt.autoPage = typeof opt.autoPage === 'boolean' ? opt.autoPage : false;
      opt.autoPageRepeatHeader = typeof opt.autoPageRepeatHeader === 'boolean' ? opt.autoPageRepeatHeader : false;
      opt.autoPageHeaderRows = typeof opt.autoPageHeaderRows !== 'undefined' && !isNaN(Number(opt.autoPageHeaderRows)) ? Number(opt.autoPageHeaderRows) : 1;
      opt.autoPageLineWeight = typeof opt.autoPageLineWeight !== 'undefined' && !isNaN(Number(opt.autoPageLineWeight)) ? Number(opt.autoPageLineWeight) : 0;
      if (opt.autoPageLineWeight) {
          if (opt.autoPageLineWeight > 1)
              opt.autoPageLineWeight = 1;
          else if (opt.autoPageLineWeight < -1)
              opt.autoPageLineWeight = -1;
      }
      // autoPage ^^^
      // Set/Calc table width
      // Get slide margins - start with default values, then adjust if master or slide margins exist
      var arrTableMargin = DEF_SLIDE_MARGIN_IN;
      // Case 1: Master margins
      if (slideLayout && typeof slideLayout._margin !== 'undefined') {
          if (Array.isArray(slideLayout._margin))
              arrTableMargin = slideLayout._margin;
          else if (!isNaN(Number(slideLayout._margin))) {
              arrTableMargin = [Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin), Number(slideLayout._margin)];
          }
      }
      // Case 2: Table margins
      /* FIXME: add `_margin` option to slide options
          else if ( addNewSlide._margin ) {
              if ( Array.isArray(addNewSlide._margin) ) arrTableMargin = addNewSlide._margin;
              else if ( !isNaN(Number(addNewSlide._margin)) ) arrTableMargin = [Number(addNewSlide._margin), Number(addNewSlide._margin), Number(addNewSlide._margin), Number(addNewSlide._margin)];
          }
      */
      /**
       * Calc table width depending upon what data we have - several scenarios exist (including bad data, eg: colW doesnt match col count)
       * The API does not require a `w` value, but XML generation does, hence, code to calc a width below using colW value(s)
       */
      if (opt.colW) {
          var firstRowColCnt = arrRows[0].reduce(function (totalLen, c) {
              var _a;
              if (((_a = c === null || c === void 0 ? void 0 : c.options) === null || _a === void 0 ? void 0 : _a.colspan) && typeof c.options.colspan === 'number') {
                  totalLen += c.options.colspan;
              }
              else {
                  totalLen += 1;
              }
              return totalLen;
          }, 0);
          if (typeof opt.colW === 'string' || typeof opt.colW === 'number') {
              // Ex: `colW = 3` or `colW = '3'`
              opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
              opt.colW = null; // IMPORTANT: Unset `colW` so table is created using `opt.w`, which will evenly divide cols
          }
          else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length === 1 && firstRowColCnt > 1) {
              // Ex: `colW=[3]` but with >1 cols (same as above, user is saying "use this width for all")
              opt.w = Math.floor(Number(opt.colW) * firstRowColCnt);
              opt.colW = null; // IMPORTANT: Unset `colW` so table is created using `opt.w`, which will evenly divide cols
          }
          else if (opt.colW && Array.isArray(opt.colW) && opt.colW.length !== firstRowColCnt) {
              // Err: Mismatched colW and cols count
              console.warn('addTable: mismatch: (colW.length != data.length) Therefore, defaulting to evenly distributed col widths.');
              opt.colW = null;
          }
      }
      else if (opt.w) {
          opt.w = getSmartParseNumber(opt.w, 'X', presLayout);
      }
      else {
          opt.w = Math.floor(presLayout._sizeW / EMU - arrTableMargin[1] - arrTableMargin[3]);
      }
      // STEP 4: Convert units to EMU now (we use different logic in makeSlide->table - smartCalc is not used)
      if (opt.x && opt.x < 20)
          opt.x = inch2Emu(opt.x);
      if (opt.y && opt.y < 20)
          opt.y = inch2Emu(opt.y);
      if (opt.w && opt.w < 20)
          opt.w = inch2Emu(opt.w);
      if (opt.h && opt.h < 20)
          opt.h = inch2Emu(opt.h);
      // STEP 5: Loop over cells: transform each to ITableCell; check to see whether to unset `autoPage` while here
      arrRows.forEach(function (row) {
          row.forEach(function (cell, idy) {
              // A: Transform cell data if needed
              /* Table rows can be an object or plain text - transform into object when needed
                  // EX:
                  var arrTabRows1 = [
                      [ { text:'A1\nA2', options:{rowspan:2, fill:'99FFCC'} } ]
                      ,[ 'B2', 'C2', 'D2', 'E2' ]
                  ]
              */
              if (typeof cell === 'number' || typeof cell === 'string') {
                  // Grab table formatting `opts` to use here so text style/format inherits as it should
                  row[idy] = { _type: SLIDE_OBJECT_TYPES.tablecell, text: String(row[idy]), options: opt };
              }
              else if (typeof cell === 'object') {
                  // ARG0: `text`
                  if (typeof cell.text === 'number')
                      row[idy].text = row[idy].text.toString();
                  else if (typeof cell.text === 'undefined' || cell.text === null)
                      row[idy].text = '';
                  // ARG1: `options`: ensure options exists
                  row[idy].options = cell.options || {};
                  // Set type to tabelcell
                  row[idy]._type = SLIDE_OBJECT_TYPES.tablecell;
              }
              // B: Check for fine-grained formatting, disable auto-page when found
              // Since genXmlTextBody already checks for text array ( text:[{},..{}] ) we're done!
              // Text in individual cells will be formatted as they are added by calls to genXmlTextBody within table builder
              // if (cell.text && Array.isArray(cell.text)) opt.autoPage = false
              // TODO: FIXME: WIP: 20210807: We cant do this anymore
          });
      });
      // If autoPage = true, we need to return references to newly created slides if any
      var newAutoPagedSlides = [];
      // STEP 6: Auto-Paging: (via {options} and used internally)
      // (used internally by `tableToSlides()` to not engage recursion - we've already paged the table data, just add this one)
      if (opt && !opt.autoPage) {
          // Create hyperlink rels (IMPORTANT: Wait until table has been shredded across Slides or all rels will end-up on Slide 1!)
          createHyperlinkRels(target, arrRows);
          // Add slideObjects (NOTE: Use `extend` to avoid mutation)
          target._slideObjects.push({
              _type: SLIDE_OBJECT_TYPES.table,
              arrTabRows: arrRows,
              options: Object.assign({}, opt),
          });
      }
      else {
          if (opt.autoPageRepeatHeader)
              opt._arrObjTabHeadRows = arrRows.filter(function (_row, idx) { return idx < opt.autoPageHeaderRows; });
          // Loop over rows and create 1-N tables as needed (ISSUE#21)
          getSlidesForTableRows(arrRows, opt, presLayout, slideLayout).forEach(function (slide, idx) {
              // A: Create new Slide when needed, otherwise, use existing (NOTE: More than 1 table can be on a Slide, so we will go up AND down the Slide chain)
              if (!getSlide(target._slideNum + idx))
                  slides.push(addSlide({ masterName: (slideLayout === null || slideLayout === void 0 ? void 0 : slideLayout._name) || null }));
              // B: Reset opt.y to `option`/`margin` after first Slide (ISSUE#43, ISSUE#47, ISSUE#48)
              if (idx > 0)
                  opt.y = inch2Emu(opt.autoPageSlideStartY || opt.newSlideStartY || arrTableMargin[0]);
              // C: Add this table to new Slide
              {
                  var newSlide = getSlide(target._slideNum + idx);
                  opt.autoPage = false;
                  // Create hyperlink rels (IMPORTANT: Wait until table has been shredded across Slides or all rels will end-up on Slide 1!)
                  createHyperlinkRels(newSlide, slide.rows);
                  // Add rows to new slide
                  newSlide.addTable(slide.rows, Object.assign({}, opt));
                  // Add reference to the new slide so it can be returned, but don't add the first one because the user already has a reference to that one.
                  if (idx > 0)
                      newAutoPagedSlides.push(newSlide);
              }
          });
      }
      return newAutoPagedSlides;
  }
  /**
   * Adds a text object to a slide definition.
   * @param {PresSlide} target - slide object that the text should be added to
   * @param {string|TextProps[]} text text string or object
   * @param {TextPropsOptions} opts text options
   * @param {boolean} isPlaceholder whether this a placeholder object
   * @since: 1.0.0
   */
  function addTextDefinition(target, text, opts, isPlaceholder) {
      var newObject = {
          _type: isPlaceholder ? SLIDE_OBJECT_TYPES.placeholder : SLIDE_OBJECT_TYPES.text,
          shape: (opts === null || opts === void 0 ? void 0 : opts.shape) || SHAPE_TYPE.RECTANGLE,
          text: !text || text.length === 0 ? [{ text: '', options: null }] : text,
          options: opts || {},
      };
      function cleanOpts(itemOpts) {
          // STEP 1: Set some options
          {
              // A.1: Color (placeholders should inherit their colors or override them, so don't default them)
              if (!itemOpts.placeholder) {
                  itemOpts.color = itemOpts.color || newObject.options.color || target.color || DEF_FONT_COLOR;
              }
              // A.2: Placeholder should inherit their bullets or override them, so don't default them
              if (itemOpts.placeholder || isPlaceholder) {
                  itemOpts.bullet = itemOpts.bullet || false;
              }
              // A.3: Text targeting a placeholder need to inherit the placeholders options (eg: margin, valign, etc.) (Issue #640)
              if (itemOpts.placeholder && target._slideLayout && target._slideLayout._slideObjects) {
                  var placeHold = target._slideLayout._slideObjects.filter(function (item) { return item._type === 'placeholder' && item.options && item.options.placeholder && item.options.placeholder === itemOpts.placeholder; })[0];
                  if (placeHold === null || placeHold === void 0 ? void 0 : placeHold.options)
                      itemOpts = __assign(__assign({}, itemOpts), placeHold.options);
              }
              // A.4: Other options
              itemOpts.objectName = itemOpts.objectName
                  ? encodeXmlEntities(itemOpts.objectName)
                  : "Text ".concat(target._slideObjects.filter(function (obj) { return obj._type === SLIDE_OBJECT_TYPES.text; }).length);
              // B:
              if (itemOpts.shape === SHAPE_TYPE.LINE) {
                  // ShapeLineProps defaults
                  var newLineOpts = {
                      type: itemOpts.line.type || 'solid',
                      color: itemOpts.line.color || DEF_SHAPE_LINE_COLOR,
                      transparency: itemOpts.line.transparency || 0,
                      width: itemOpts.line.width || 1,
                      dashType: itemOpts.line.dashType || 'solid',
                      beginArrowType: itemOpts.line.beginArrowType || null,
                      endArrowType: itemOpts.line.endArrowType || null,
                  };
                  if (typeof itemOpts.line === 'object')
                      itemOpts.line = newLineOpts;
                  // 3: Handle line (lots of deprecated opts)
                  if (typeof itemOpts.line === 'string') {
                      var tmpOpts = newLineOpts;
                      if (typeof itemOpts.line === 'string')
                          tmpOpts.color = itemOpts.line; // @deprecated [remove in v4.0]
                      // tmpOpts.color = itemOpts.line!.toString() // @deprecated `itemOpts.line`:[string] (was line color)
                      itemOpts.line = tmpOpts;
                  }
                  if (typeof itemOpts.lineSize === 'number')
                      itemOpts.line.width = itemOpts.lineSize; // @deprecated (part of `ShapeLineProps` now)
                  if (typeof itemOpts.lineDash === 'string')
                      itemOpts.line.dashType = itemOpts.lineDash; // @deprecated (part of `ShapeLineProps` now)
                  if (typeof itemOpts.lineHead === 'string')
                      itemOpts.line.beginArrowType = itemOpts.lineHead; // @deprecated (part of `ShapeLineProps` now)
                  if (typeof itemOpts.lineTail === 'string')
                      itemOpts.line.endArrowType = itemOpts.lineTail; // @deprecated (part of `ShapeLineProps` now)
              }
              // C: Line opts
              itemOpts.line = itemOpts.line || {};
              itemOpts.lineSpacing = itemOpts.lineSpacing && !isNaN(itemOpts.lineSpacing) ? itemOpts.lineSpacing : null;
              itemOpts.lineSpacingMultiple = itemOpts.lineSpacingMultiple && !isNaN(itemOpts.lineSpacingMultiple) ? itemOpts.lineSpacingMultiple : null;
              // D: Transform text options to bodyProperties as thats how we build XML
              itemOpts._bodyProp = itemOpts._bodyProp || {};
              itemOpts._bodyProp.autoFit = itemOpts.autoFit || false; // DEPRECATED: (3.3.0) If true, shape will collapse to text size (Fit To shape)
              itemOpts._bodyProp.anchor = !itemOpts.placeholder ? TEXT_VALIGN.ctr : null; // VALS: [t,ctr,b]
              itemOpts._bodyProp.vert = itemOpts.vert || null; // VALS: [eaVert,horz,mongolianVert,vert,vert270,wordArtVert,wordArtVertRtl]
              itemOpts._bodyProp.wrap = typeof itemOpts.wrap === 'boolean' ? itemOpts.wrap : true;
              // E: Inset
              // @deprecated 3.10.0 (`inset` - use `margin`)
              if ((itemOpts.inset && !isNaN(Number(itemOpts.inset))) || itemOpts.inset === 0) {
                  itemOpts._bodyProp.lIns = inch2Emu(itemOpts.inset);
                  itemOpts._bodyProp.rIns = inch2Emu(itemOpts.inset);
                  itemOpts._bodyProp.tIns = inch2Emu(itemOpts.inset);
                  itemOpts._bodyProp.bIns = inch2Emu(itemOpts.inset);
              }
              // F: Transform @deprecated props
              if (typeof itemOpts.underline === 'boolean' && itemOpts.underline === true)
                  itemOpts.underline = { style: 'sng' };
          }
          // STEP 2: Transform `align`/`valign` to XML values, store in _bodyProp for XML gen
          {
              if ((itemOpts.align || '').toLowerCase().indexOf('c') === 0)
                  itemOpts._bodyProp.align = TEXT_HALIGN.center;
              else if ((itemOpts.align || '').toLowerCase().indexOf('l') === 0)
                  itemOpts._bodyProp.align = TEXT_HALIGN.left;
              else if ((itemOpts.align || '').toLowerCase().indexOf('r') === 0)
                  itemOpts._bodyProp.align = TEXT_HALIGN.right;
              else if ((itemOpts.align || '').toLowerCase().indexOf('j') === 0)
                  itemOpts._bodyProp.align = TEXT_HALIGN.justify;
              if ((itemOpts.valign || '').toLowerCase().indexOf('b') === 0)
                  itemOpts._bodyProp.anchor = TEXT_VALIGN.b;
              else if ((itemOpts.valign || '').toLowerCase().indexOf('m') === 0)
                  itemOpts._bodyProp.anchor = TEXT_VALIGN.ctr;
              else if ((itemOpts.valign || '').toLowerCase().indexOf('t') === 0)
                  itemOpts._bodyProp.anchor = TEXT_VALIGN.t;
          }
          // STEP 3: ROBUST: Set rational values for some shadow props if needed
          correctShadowOptions(itemOpts.shadow);
          return itemOpts;
      }
      // STEP 1: Create/Clean object options
      newObject.options = cleanOpts(newObject.options);
      // STEP 2: Create/Clean text options
      newObject.text.forEach(function (item) { return (item.options = cleanOpts(item.options || {})); });
      // STEP 3: Create hyperlinks
      createHyperlinkRels(target, newObject.text || '');
      // LAST: Add object to Slide
      target._slideObjects.push(newObject);
  }
  /**
   * Adds placeholder objects to slide
   * @param {PresSlide} slide - slide object containing layouts
   */
  function addPlaceholdersToSlideLayouts(slide) {
      // Add all placeholders on this Slide that dont already exist
      (slide._slideLayout._slideObjects || []).forEach(function (slideLayoutObj) {
          if (slideLayoutObj._type === SLIDE_OBJECT_TYPES.placeholder) {
              // A: Search for this placeholder on Slide before we add
              // NOTE: Check to ensure a placeholder does not already exist on the Slide
              // They are created when they have been populated with text (ex: `slide.addText('Hi', { placeholder:'title' });`)
              if (slide._slideObjects.filter(function (slideObj) { return slideObj.options && slideObj.options.placeholder === slideLayoutObj.options.placeholder; }).length === 0) {
                  addTextDefinition(slide, [{ text: '' }], slideLayoutObj.options, false);
              }
          }
      });
  }
  /* -------------------------------------------------------------------------------- */
  /**
   * Adds a background image or color to a slide definition.
   * @param {BackgroundProps} props - color string or an object with image definition
   * @param {PresSlide} target - slide object that the background is set to
   */
  function addBackgroundDefinition(props, target) {
      var _a;
      // A: @deprecated
      if (target.bkgd) {
          if (!target.background)
              target.background = {};
          if (typeof target.bkgd === 'string')
              target.background.color = target.bkgd;
          else {
              if (target.bkgd.data)
                  target.background.data = target.bkgd.data;
              if (target.bkgd.path)
                  target.background.path = target.bkgd.path;
              if (target.bkgd.src)
                  target.background.path = target.bkgd.src; // @deprecated (drop in 4.x)
          }
      }
      if ((_a = target.background) === null || _a === void 0 ? void 0 : _a.fill)
          target.background.color = target.background.fill;
      // B: Handle media
      if (props && (props.path || props.data)) {
          // Allow the use of only the data key (`path` isnt reqd)
          props.path = props.path || 'preencoded.png';
          var strImgExtn = (props.path.split('.').pop() || 'png').split('?')[0]; // Handle "blah.jpg?width=540" etc.
          if (strImgExtn === 'jpg')
              strImgExtn = 'jpeg'; // base64-encoded jpg's come out as "data:image/jpeg;base64,/9j/[...]", so correct exttnesion to avoid content warnings at PPT startup
          target._relsMedia = target._relsMedia || [];
          var intRels = target._relsMedia.length + 1;
          // NOTE: `Target` cannot have spaces (eg:"Slide 1-image-1.jpg") or a "presentation is corrupt" warning comes up
          target._relsMedia.push({
              path: props.path,
              type: SLIDE_OBJECT_TYPES.image,
              extn: strImgExtn,
              data: props.data || null,
              rId: intRels,
              Target: "../media/".concat((target._name || '').replace(/\s+/gi, '-'), "-image-").concat(target._relsMedia.length + 1, ".").concat(strImgExtn),
          });
          target._bkgdImgRid = intRels;
      }
  }
  /**
   * Parses text/text-objects from `addText()` and `addTable()` methods; creates 'hyperlink'-type Slide Rels for each hyperlink found
   * @param {PresSlide} target - slide object that any hyperlinks will be be added to
   * @param {number | string | TextProps | TextProps[] | ITableCell[][]} text - text to parse
   */
  function createHyperlinkRels(target, text) {
      var textObjs = [];
      // Only text objects can have hyperlinks, bail when text param is plain text
      if (typeof text === 'string' || typeof text === 'number')
          return;
      // IMPORTANT: "else if" Array.isArray must come before typeof===object! Otherwise, code will exhaust recursion!
      else if (Array.isArray(text))
          textObjs = text;
      else if (typeof text === 'object')
          textObjs = [text];
      textObjs.forEach(function (text) {
          // `text` can be an array of other `text` objects (table cell word-level formatting), continue parsing using recursion
          if (Array.isArray(text)) {
              createHyperlinkRels(target, text);
          }
          else if (Array.isArray(text.text)) {
              // this handles TableCells with hyperlinks
              createHyperlinkRels(target, text.text);
          }
          else if (text && typeof text === 'object' && text.options && text.options.hyperlink && !text.options.hyperlink._rId) {
              if (typeof text.options.hyperlink !== 'object')
                  console.log('ERROR: text `hyperlink` option should be an object. Ex: `hyperlink: {url:\'https://github.com\'}` ');
              else if (!text.options.hyperlink.url && !text.options.hyperlink.slide)
                  console.log('ERROR: \'hyperlink requires either: `url` or `slide`\'');
              else {
                  var relId = getNewRelId(target);
                  target._rels.push({
                      type: SLIDE_OBJECT_TYPES.hyperlink,
                      data: text.options.hyperlink.slide ? 'slide' : 'dummy',
                      rId: relId,
                      Target: encodeXmlEntities(text.options.hyperlink.url) || text.options.hyperlink.slide.toString(),
                  });
                  text.options.hyperlink._rId = relId;
              }
          }
      });
  }

  /**
   * PptxGenJS: Slide Class
   */
  var Slide = /** @class */ (function () {
      function Slide(params) {
          var _a;
          this.addSlide = params.addSlide;
          this.getSlide = params.getSlide;
          this._name = "Slide ".concat(params.slideNumber);
          this._presLayout = params.presLayout;
          this._rId = params.slideRId;
          this._rels = [];
          this._relsChart = [];
          this._relsMedia = [];
          this._setSlideNum = params.setSlideNum;
          this._slideId = params.slideId;
          this._slideLayout = params.slideLayout || null;
          this._slideNum = params.slideNumber;
          this._slideObjects = [];
          /** NOTE: Slide Numbers: In order for Slide Numbers to function they need to be in all 3 files: master/layout/slide
           * `defineSlideMaster` and `addNewSlide.slideNumber` will add {slideNumber} to `this.masterSlide` and `this.slideLayouts`
           * so, lastly, add to the Slide now.
           */
          this._slideNumberProps = ((_a = this._slideLayout) === null || _a === void 0 ? void 0 : _a._slideNumberProps) ? this._slideLayout._slideNumberProps : null;
      }
      Object.defineProperty(Slide.prototype, "bkgd", {
          get: function () {
              return this._bkgd;
          },
          set: function (value) {
              this._bkgd = value;
              if (!this._background || !this._background.color) {
                  if (!this._background)
                      this._background = {};
                  if (typeof value === 'string')
                      this._background.color = value;
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Slide.prototype, "background", {
          get: function () {
              return this._background;
          },
          set: function (props) {
              this._background = props;
              // Add background (image data/path must be captured before `exportPresentation()` is called)
              if (props)
                  addBackgroundDefinition(props, this);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Slide.prototype, "color", {
          get: function () {
              return this._color;
          },
          set: function (value) {
              this._color = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Slide.prototype, "hidden", {
          get: function () {
              return this._hidden;
          },
          set: function (value) {
              this._hidden = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Slide.prototype, "slideNumber", {
          get: function () {
              return this._slideNumberProps;
          },
          /**
           * @type {SlideNumberProps}
           */
          set: function (value) {
              // NOTE: Slide Numbers: In order for Slide Numbers to function they need to be in all 3 files: master/layout/slide
              this._slideNumberProps = value;
              this._setSlideNum(value);
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(Slide.prototype, "newAutoPagedSlides", {
          get: function () {
              return this._newAutoPagedSlides;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Add chart to Slide
       * @param {CHART_NAME|IChartMulti[]} type - chart type
       * @param {object[]} data - data object
       * @param {IChartOpts} options - chart options
       * @return {Slide} this Slide
       */
      Slide.prototype.addChart = function (type, data, options) {
          // FUTURE: TODO-VERSION-4: Remove first arg - only take data and opts, with "type" required on opts
          // Set `_type` on IChartOptsLib as its what is used as object is passed around
          var optionsWithType = options || {};
          optionsWithType._type = type;
          addChartDefinition(this, type, data, options);
          return this;
      };
      /**
       * Add image to Slide
       * @param {ImageProps} options - image options
       * @return {Slide} this Slide
       */
      Slide.prototype.addImage = function (options) {
          addImageDefinition(this, options);
          return this;
      };
      /**
       * Add media (audio/video) to Slide
       * @param {MediaProps} options - media options
       * @return {Slide} this Slide
       */
      Slide.prototype.addMedia = function (options) {
          addMediaDefinition(this, options);
          return this;
      };
      /**
       * Add speaker notes to Slide
       * @docs https://gitbrent.github.io/PptxGenJS/docs/speaker-notes.html
       * @param {string} notes - notes to add to slide
       * @return {Slide} this Slide
       */
      Slide.prototype.addNotes = function (notes) {
          addNotesDefinition(this, notes);
          return this;
      };
      /**
       * Add shape to Slide
       * @param {SHAPE_NAME} shapeName - shape name
       * @param {ShapeProps} options - shape options
       * @return {Slide} this Slide
       */
      Slide.prototype.addShape = function (shapeName, options) {
          // NOTE: As of v3.1.0, <script> users are passing the old shape object from the shapes file (orig to the project)
          // But React/TypeScript users are passing the shapeName from an enum, which is a simple string, so lets cast
          // <script./> => `pptx.shapes.RECTANGLE` [string] "rect" ... shapeName['name'] = 'rect'
          // TypeScript => `pptxgen.shapes.RECTANGLE` [string] "rect" ... shapeName = 'rect'
          // let shapeNameDecode = typeof shapeName === 'object' && shapeName['name'] ? shapeName['name'] : shapeName
          addShapeDefinition(this, shapeName, options);
          return this;
      };
      /**
       * Add table to Slide
       * @param {TableRow[]} tableRows - table rows
       * @param {TableProps} options - table options
       * @return {Slide} this Slide
       */
      Slide.prototype.addTable = function (tableRows, options) {
          // FUTURE: we pass `this` - we dont need to pass layouts - they can be read from this!
          this._newAutoPagedSlides = addTableDefinition(this, tableRows, options, this._slideLayout, this._presLayout, this.addSlide, this.getSlide);
          return this;
      };
      /**
       * Add text to Slide
       * @param {string|TextProps[]} text - text string or complex object
       * @param {TextPropsOptions} options - text options
       * @return {Slide} this Slide
       */
      Slide.prototype.addText = function (text, options) {
          var textParam = typeof text === 'string' || typeof text === 'number' ? [{ text: text, options: options }] : text;
          addTextDefinition(this, textParam, options, false);
          return this;
      };
      return Slide;
  }());

  /**
   * PptxGenJS: Chart Generation
   */
  /**
   * Based on passed data, creates Excel Worksheet that is used as a data source for a chart.
   * @param {ISlideRelChart} chartObject - chart object
   * @param {JSZip} zip - file that the resulting XLSX should be added to
   * @return {Promise} promise of generating the XLSX file
   */
  function createExcelWorksheet(chartObject, zip) {
      return __awaiter(this, void 0, void 0, function () {
          var data;
          return __generator(this, function (_a) {
              switch (_a.label) {
                  case 0:
                      data = chartObject.data;
                      return [4 /*yield*/, new Promise(function (resolve, reject) {
                              var _a, _b;
                              var zipExcel = new JSZip();
                              var intBubbleCols = (data.length - 1) * 2 + 1; // 1 for "X-Values", then 2 for every Y-Axis
                              var IS_MULTI_CAT_AXES = ((_b = (_a = data[0]) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.length) > 1;
                              // A: Add folders
                              zipExcel.folder('_rels');
                              zipExcel.folder('docProps');
                              zipExcel.folder('xl/_rels');
                              zipExcel.folder('xl/tables');
                              zipExcel.folder('xl/theme');
                              zipExcel.folder('xl/worksheets');
                              zipExcel.folder('xl/worksheets/_rels');
                              // B: Add core contents
                              {
                                  zipExcel.file('[Content_Types].xml', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">' +
                                      '  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>' +
                                      '  <Default Extension="xml" ContentType="application/xml"/>' +
                                      '  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>' +
                                      '  <Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>' +
                                      '  <Override PartName="/xl/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>' +
                                      '  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>' +
                                      '  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>' +
                                      '  <Override PartName="/xl/tables/table1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"/>' +
                                      '  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>' +
                                      '  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>' +
                                      '</Types>\n');
                                  zipExcel.file('_rels/.rels', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
                                      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>' +
                                      '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>' +
                                      '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>' +
                                      '</Relationships>\n');
                                  zipExcel.file('docProps/app.xml', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">' +
                                      '<Application>Microsoft Macintosh Excel</Application>' +
                                      '<DocSecurity>0</DocSecurity>' +
                                      '<ScaleCrop>false</ScaleCrop>' +
                                      '<HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs>' +
                                      '<TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts>' +
                                      '<Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion>' +
                                      '</Properties>\n');
                                  zipExcel.file('docProps/core.xml', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
                                      '<dc:creator>PptxGenJS</dc:creator>' +
                                      '<cp:lastModifiedBy>PptxGenJS</cp:lastModifiedBy>' +
                                      '<dcterms:created xsi:type="dcterms:W3CDTF">' +
                                      new Date().toISOString() +
                                      '</dcterms:created>' +
                                      '<dcterms:modified xsi:type="dcterms:W3CDTF">' +
                                      new Date().toISOString() +
                                      '</dcterms:modified>' +
                                      '</cp:coreProperties>');
                                  zipExcel.file('xl/_rels/workbook.xml.rels', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
                                      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
                                      '<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>' +
                                      '<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/>' +
                                      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>' +
                                      '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/>' +
                                      '</Relationships>');
                                  zipExcel.file('xl/styles.xml', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><numFmts count="1"><numFmt numFmtId="0" formatCode="General"/></numFmts><fonts count="4"><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="9"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="10"/><color indexed="8"/><name val="Geneva"/></font><font><sz val="18"/><color indexed="8"/>' +
                                      '<name val="Arial"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><dxfs count="0"/><tableStyles count="0"/><colors><indexedColors><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ffff0000"/><rgbColor rgb="ff00ff00"/><rgbColor rgb="ff0000ff"/>' +
                                      '<rgbColor rgb="ffffff00"/><rgbColor rgb="ffff00ff"/><rgbColor rgb="ff00ffff"/><rgbColor rgb="ff000000"/><rgbColor rgb="ffffffff"/><rgbColor rgb="ff878787"/><rgbColor rgb="fff9f9f9"/></indexedColors></colors></styleSheet>\n');
                                  zipExcel.file('xl/theme/theme1.xml', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="4472C4"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="5B9BD5"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic Light"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface="DengXian Light"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="Yu Gothic"/><a:font script="Hang" typeface=" "/><a:font script="Hans" typeface="DengXian"/><a:font script="Hant" typeface=""/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>');
                                  zipExcel.file('xl/workbook.xml', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
                                      '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main">' +
                                      '<fileVersion appName="xl" lastEdited="7" lowestEdited="6" rupBuild="10507"/>' +
                                      '<workbookPr/>' +
                                      '<bookViews><workbookView xWindow="0" yWindow="500" windowWidth="20960" windowHeight="15960"/></bookViews>' +
                                      '<sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets>' +
                                      '<calcPr calcId="0" concurrentCalc="0"/>' +
                                      '</workbook>\n');
                                  zipExcel.file('xl/worksheets/_rels/sheet1.xml.rels', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
                                      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
                                      '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" Target="../tables/table1.xml"/>' +
                                      '</Relationships>\n');
                              }
                              // sharedStrings.xml
                              {
                                  // A: Start XML
                                  var strSharedStrings_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                                      strSharedStrings_1 += "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"".concat(intBubbleCols, "\" uniqueCount=\"").concat(intBubbleCols, "\">");
                                  }
                                  else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                                      strSharedStrings_1 += "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"".concat(data.length, "\" uniqueCount=\"").concat(data.length, "\">");
                                  }
                                  else if (IS_MULTI_CAT_AXES) {
                                      var totCount_1 = data.length;
                                      data[0].labels.forEach(function (arrLabel) { return (totCount_1 += arrLabel.filter(function (label) { return label && label !== ''; }).length); });
                                      strSharedStrings_1 += "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"".concat(totCount_1, "\" uniqueCount=\"").concat(totCount_1, "\">");
                                      strSharedStrings_1 += '<si><t/></si>';
                                  }
                                  else {
                                      // series names + all labels of one series + number of label groups (data.labels.length) of one series (i.e. how many times the blank string is used)
                                      var totCount = data.length + data[0].labels.length * data[0].labels[0].length + data[0].labels.length;
                                      // series names + labels of one series + blank string (same for all label groups)
                                      var unqCount = data.length + data[0].labels.length * data[0].labels[0].length + 1;
                                      // start `sst`
                                      strSharedStrings_1 += "<sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"".concat(totCount, "\" uniqueCount=\"").concat(unqCount, "\">");
                                      // B: Add 'blank' for A1, B1, ..., of every label group inside data[n].labels
                                      strSharedStrings_1 += '<si><t xml:space="preserve"></t></si>';
                                  }
                                  // C: Add `name`/Series
                                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                                      data.forEach(function (objData, idx) {
                                          if (idx === 0)
                                              strSharedStrings_1 += '<si><t>X-Axis</t></si>';
                                          else {
                                              strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities(objData.name || "Y-Axis".concat(idx)), "</t></si>");
                                              strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities("Size".concat(idx)), "</t></si>");
                                          }
                                      });
                                  }
                                  else {
                                      data.forEach(function (objData) {
                                          strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities((objData.name || ' ').replace('X-Axis', 'X-Values')), "</t></si>");
                                      });
                                  }
                                  // D: Add `labels`/Categories
                                  if (chartObject.opts._type !== CHART_TYPE.BUBBLE && chartObject.opts._type !== CHART_TYPE.BUBBLE3D && chartObject.opts._type !== CHART_TYPE.SCATTER) {
                                      // Use forEach backwards & check for '' to support multi-cat axes
                                      data[0].labels
                                          .slice()
                                          .reverse()
                                          .forEach(function (labelsGroup) {
                                          labelsGroup
                                              .filter(function (label) { return label && label !== ''; })
                                              .forEach(function (label) {
                                              strSharedStrings_1 += "<si><t>".concat(encodeXmlEntities(label), "</t></si>");
                                          });
                                      });
                                  }
                                  // DONE:
                                  strSharedStrings_1 += '</sst>\n';
                                  zipExcel.file('xl/sharedStrings.xml', strSharedStrings_1);
                              }
                              // tables/table1.xml
                              {
                                  var strTableXml_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                                      strTableXml_1 += "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"A1:".concat(getExcelColName(intBubbleCols)).concat(intBubbleCols, "\" totalsRowShown=\"0\">");
                                      strTableXml_1 += "<tableColumns count=\"".concat(intBubbleCols, "\">");
                                      var idxColLtr_1 = 1;
                                      data.forEach(function (obj, idx) {
                                          if (idx === 0) {
                                              strTableXml_1 += "<tableColumn id=\"".concat(idx + 1, "\" name=\"X-Values\"/>");
                                          }
                                          else {
                                              strTableXml_1 += "<tableColumn id=\"".concat(idx + idxColLtr_1, "\" name=\"").concat(obj.name, "\"/>");
                                              idxColLtr_1++;
                                              strTableXml_1 += "<tableColumn id=\"".concat(idx + idxColLtr_1, "\" name=\"Size").concat(idx, "\"/>");
                                          }
                                      });
                                  }
                                  else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                                      strTableXml_1 += "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"A1:".concat(getExcelColName(data.length)).concat(data[0].values.length + 1, "\" totalsRowShown=\"0\">");
                                      strTableXml_1 += "<tableColumns count=\"".concat(data.length, "\">");
                                      data.forEach(function (_obj, idx) {
                                          strTableXml_1 += "<tableColumn id=\"".concat(idx + 1, "\" name=\"").concat(idx === 0 ? 'X-Values' : 'Y-Value ').concat(idx, "\"/>");
                                      });
                                  }
                                  else {
                                      strTableXml_1 += "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"A1:".concat(getExcelColName(data.length + data[0].labels.length)).concat(data[0].labels[0].length + 1, "'\" totalsRowShown=\"0\">");
                                      strTableXml_1 += "<tableColumns count=\"".concat(data.length + data[0].labels.length, "\">");
                                      data[0].labels.forEach(function (_labelsGroup, idx) {
                                          strTableXml_1 += "<tableColumn id=\"".concat(idx + 1, "\" name=\"Column").concat(idx + 1, "\"/>");
                                      });
                                      data.forEach(function (obj, idx) {
                                          strTableXml_1 += "<tableColumn id=\"".concat(idx + data[0].labels.length + 1, "\" name=\"").concat(encodeXmlEntities(obj.name), "\"/>");
                                      });
                                  }
                                  strTableXml_1 += '</tableColumns>';
                                  strTableXml_1 += '<tableStyleInfo showFirstColumn="0" showLastColumn="0" showRowStripes="1" showColumnStripes="0"/>';
                                  strTableXml_1 += '</table>';
                                  zipExcel.file('xl/tables/table1.xml', strTableXml_1);
                              }
                              // worksheets/sheet1.xml
                              {
                                  var strSheetXml_1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                                  strSheetXml_1 +=
                                      '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">';
                                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                                      strSheetXml_1 += "<dimension ref=\"A1:".concat(getExcelColName(intBubbleCols)).concat(data[0].values.length + 1, "\"/>");
                                  }
                                  else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                                      strSheetXml_1 += "<dimension ref=\"A1:".concat(getExcelColName(data.length)).concat(data[0].values.length + 1, "\"/>");
                                  }
                                  else {
                                      strSheetXml_1 += "<dimension ref=\"A1:".concat(getExcelColName(data.length + 1)).concat(data[0].values.length + 1, "\"/>");
                                  }
                                  strSheetXml_1 += '<sheetViews><sheetView tabSelected="1" workbookViewId="0"><selection activeCell="B1" sqref="B1"/></sheetView></sheetViews>';
                                  strSheetXml_1 += '<sheetFormatPr baseColWidth="10" defaultRowHeight="16"/>';
                                  if (chartObject.opts._type === CHART_TYPE.BUBBLE || chartObject.opts._type === CHART_TYPE.BUBBLE3D) {
                                      // UNUSED: strSheetXml += `<cols><col min="1" max="${data.length}" width="11" customWidth="1" /></cols>`
                                      /* EX: INPUT: `data`
                                      [
                                          { name:'X-Axis'  , values:[10,11,12,13,14,15,16,17,18,19,20] },
                                          { name:'Y-Axis 1', values:[ 1, 6, 7, 8, 9], sizes:[ 4, 5, 6, 7, 8] },
                                          { name:'Y-Axis 2', values:[33,32,42,53,63], sizes:[11,12,13,14,15] }
                                      ];
                                      */
                                      /* EX: OUTPUT: bubbleChart Worksheet:
                                          -|----A-----|------B-----|------C-----|------D-----|------E-----|
                                          1| X-Values | Y-Values 1 | Y-Sizes 1  | Y-Values 2 | Y-Sizes 2  |
                                          2|    11    |     22     |      4     |     33     |      8     |
                                          -|----------|------------|------------|------------|------------|
                                      */
                                      strSheetXml_1 += '<sheetData>';
                                      // A: Create header row first (NOTE: Start at index=1 as headers cols start with 'B')
                                      strSheetXml_1 += "<row r=\"1\" spans=\"1:".concat(intBubbleCols, "\">");
                                      strSheetXml_1 += '<c r="A1" t="s"><v>0</v></c>';
                                      for (var idx = 1; idx < intBubbleCols; idx++) {
                                          strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + 1), "1\" t=\"s\"><v>").concat(idx, "</v></c>"); // NOTE: add `t="s"` for label cols!
                                      }
                                      strSheetXml_1 += '</row>';
                                      // B: Add row for each X-Axis value (Y-Axis* value is optional)
                                      data[0].values.forEach(function (val, idx) {
                                          // Leading col is reserved for the 'X-Axis' value, so hard-code it, then loop over col values
                                          strSheetXml_1 += "<row r=\"".concat(idx + 2, "\" spans=\"1:").concat(intBubbleCols, "\">");
                                          strSheetXml_1 += "<c r=\"A".concat(idx + 2, "\"><v>").concat(val, "</v></c>");
                                          // Add Y-Axis 1->N (idy=0 = Xaxis)
                                          var idxColLtr = 2;
                                          for (var idy = 1; idy < data.length; idy++) {
                                              // y-value
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idxColLtr)).concat(idx + 2, "\"><v>").concat(data[idy].values[idx] || '', "</v></c>");
                                              idxColLtr++;
                                              // y-size
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idxColLtr)).concat(idx + 2, "\"><v>").concat(data[idy].sizes[idx] || '', "</v></c>");
                                              idxColLtr++;
                                          }
                                          strSheetXml_1 += '</row>';
                                      });
                                  }
                                  else if (chartObject.opts._type === CHART_TYPE.SCATTER) {
                                      /* UNUSED:
                                          strSheetXml += '<cols>'
                                          strSheetXml += '<col min="1" max="' + data.length + '" width="11" customWidth="1" />'
                                          //data.forEach((obj,idx)=>{ strSheetXml += '<col min="'+(idx+1)+'" max="'+(idx+1)+'" width="11" customWidth="1" />' });
                                          strSheetXml += '</cols>'
                                      */
                                      /* EX: INPUT: `data`
                                          [
                                              { name:'X-AxisA', values:[ 1, 2, 3, 4, 5] },
                                              { name:'Y-AxisB', values:[ 2,22,42,52,62] },
                                              { name:'Y-AxisC', values:[ 3,33,43,53,63] }
                                          ];
                                      */
                                      /* EX: OUTPUT: sheet1.xml:
                                          -|----A----|----B----|----C----|
                                          1| X-AxisA | Y-AxisB | Y-AxisC |
                                          2|    1    |    2    |    3    |
                                          -|---------|---------|---------|
                                      */
                                      strSheetXml_1 += '<sheetData>';
                                      // A: Create header row first (every `name` row provided)
                                      strSheetXml_1 += "<row r=\"1\" spans=\"1:".concat(data.length, "\">");
                                      for (var idx = 0; idx < data.length; idx++) {
                                          strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + 1), "1\" t=\"s\"><v>").concat(idx, "</v></c>"); // NOTE: add `t="s"` for label cols!
                                      }
                                      strSheetXml_1 += '</row>';
                                      // B: Add row for each X-Axis value (Y-Axis* value is optional)
                                      data[0].values.forEach(function (val, idx) {
                                          // Leading col is reserved for the 'X-Axis' value, so hard-code it, then loop over col values
                                          strSheetXml_1 += "<row r=\"".concat(idx + 2, "\" spans=\"1:").concat(data.length, "\">");
                                          strSheetXml_1 += "<c r=\"A".concat(idx + 2, "\"><v>").concat(val, "</v></c>");
                                          // Add Y-Axis 1->N
                                          for (var idy = 1; idy < data.length; idy++) {
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idy + 1)).concat(idx + 2, "\"><v>").concat(data[idy].values[idx] || data[idy].values[idx] === 0 ? data[idy].values[idx] : '', "</v></c>");
                                          }
                                          strSheetXml_1 += '</row>';
                                      });
                                  }
                                  else {
                                      // strSheetXml += '<cols><col min="1" max="1" width="11" customWidth="1" /></cols>'
                                      strSheetXml_1 += '<sheetData>';
                                      /* EX: INPUT: `data`
                                          [
                                              { name:'Red', labels:['Jan..May-17'], values:[11,13,14,15,16] },
                                              { name:'Amb', labels:['Jan..May-17'], values:[22, 6, 7, 8, 9] },
                                              { name:'Grn', labels:['Jan..May-17'], values:[33,32,42,53,63] }
                                          ];
                                      */
                                      /* EX: OUTPUT: lineChart Worksheet:
                                          -|---A---|--B--|--C--|--D--|
                                          1|       | Red | Amb | Grn |
                                          2|Jan-17 |   11|   22|   33|
                                          3|Feb-17 |   55|   43|   70|
                                          4|Mar-17 |   56|  143|   99|
                                          5|Apr-17 |   65|    3|  120|
                                          6|May-17 |   75|   93|  170|
                                          -|-------|-----|-----|-----|
                                      */
                                      if (!IS_MULTI_CAT_AXES) {
                                          // A: Create header row first
                                          strSheetXml_1 += "<row r=\"1\" spans=\"1:".concat(data.length + data[0].labels.length, "\">");
                                          data[0].labels.forEach(function (_labelsGroup, idx) {
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + 1), "1\" t=\"s\"><v>0</v></c>");
                                          });
                                          for (var idx = 0; idx < data.length; idx++) {
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + 1 + data[0].labels.length), "1\" t=\"s\"><v>").concat(idx + 1, "</v></c>"); // NOTE: use `t="s"` for label cols!
                                          }
                                          strSheetXml_1 += '</row>';
                                          // B: Add data row(s) for each category
                                          data[0].labels[0].forEach(function (_cat, idx) {
                                              strSheetXml_1 += "<row r=\"".concat(idx + 2, "\" spans=\"1:").concat(data.length + data[0].labels.length, "\">");
                                              // Leading cols are reserved for the label groups
                                              for (var idx2 = data[0].labels.length - 1; idx2 >= 0; idx2--) {
                                                  strSheetXml_1 += "<c r=\"".concat(getExcelColName(data[0].labels.length - idx2)).concat(idx + 2, "\" t=\"s\">");
                                                  strSheetXml_1 += "<v>".concat(data.length + idx + 1, "</v>");
                                                  strSheetXml_1 += '</c>';
                                              }
                                              for (var idy = 0; idy < data.length; idy++) {
                                                  strSheetXml_1 += "<c r=\"".concat(getExcelColName(data[0].labels.length + idy + 1)).concat(idx + 2, "\"><v>").concat(data[idy].values[idx] || '', "</v></c>");
                                              }
                                              strSheetXml_1 += '</row>';
                                          });
                                      }
                                      else {
                                          // A: create header row
                                          strSheetXml_1 += "<row r=\"1\" spans=\"1:".concat(data.length + data[0].labels.length, "\">");
                                          for (var idx = 0; idx < data[0].labels.length; idx++) {
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + 1), "1\" t=\"s\"><v>0</v></c>");
                                          }
                                          for (var idx = data[0].labels.length - 1; idx < data.length + data[0].labels.length - 1; idx++) {
                                              strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + data[0].labels.length), "1\" t=\"s\"><v>").concat(idx, "</v></c>"); // NOTE: use `t="s"` for label cols!
                                          }
                                          strSheetXml_1 += '</row>';
                                          // FIXME: 20220524 (v3.11.0)
                                          /**
                                           * @example INPUT
                                           * const LABELS = [
                                           *   ["Gear", "Berg", "Motr", "Swch", "Plug", "Cord", "Pump", "Leak", "Seal"],
                                           *   ["Mech", "", "", "Elec", "", "", "Hydr", "", ""],
                                           * ];
                                           * const arrDataRegions = [
                                           *   { name: "West", labels: LABELS, values: [11, 8, 3, 0, 11, 3, 0, 0, 0] },
                                           *   { name: "Ctrl", labels: LABELS, values: [0, 11, 6, 19, 12, 5, 0, 0, 0] },
                                           *   { name: "East", labels: LABELS, values: [0, 3, 2, 0, 0, 0, 4, 3, 1] },
                                           * ];
                                           */
                                          /**
                                           * @example OUTPUT EXCEL SHEET
                                           * |/|---A--|---B--|---C--|---D--|---E--|
                                           * |1|      |      | West | Ctrl | East |
                                           * |2| Mech | Gear |  ##  |  ##  |  ##  |
                                           * |3|      | Brng |  ##  |  ##  |  ##  |
                                           * |4|      | Motr |  ##  |  ##  |  ##  |
                                           * |5| Elec | Swch |  ##  |  ##  |  ##  |
                                           * |6|      | Plug |  ##  |  ##  |  ##  |
                                           * |7|      | Cord |  ##  |  ##  |  ##  |
                                           * |8| Hydr | Pump |  ##  |  ##  |  ##  |
                                           * |9|      | Leak |  ##  |  ##  |  ##  |
                                           *|10|      | Seal |  ##  |  ##  |  ##  |
                                           */
                                          /**
                                           * @example OUTPUT EXCEL SHEET XML
                                           * <row r="1" spans="1:5">
                                           *   <c r="A1" t="s"><v>0</v></c>
                                           *   <c r="B1" t="s"><v>0</v></c>
                                           *   <c r="C1" t="s"><v>1</v></c>
                                           *   <c r="D1" t="s"><v>2</v></c>
                                           *   <c r="E1" t="s"><v>3</v></c>
                                           * </row>
                                           * <row r="2" spans="1:5">
                                           *   <c r="A2" t="s"><v>4</v></c>
                                           *   <c r="B2" t="s"><v>7</v></c>
                                           *   <c r="C2"      ><v>###</v></c>
                                           * </row>
                                           * <row r="3" spans="1:5">
                                           *   <c r="A3" />
                                           *   <c r="B3" t="s"><v>8</v></c>
                                           *   <c r="C3"      ><v>###</v></c>
                                           * </row>
                                           */
                                          /**
                                           * @example SHARED-STRINGS
                                           * 1=West, 2=Ctrl, 3=East, 4=Mech, 5=Elec, 6=Mydr, 7=Gear, 8=Brng, [...], 15=Seal
                                           */
                                          // B: Add data row(s) for each category
                                          /**
                                           * const LABELS = [
                                           *   ["Gear", "Berg", "Motr", "Swch", "Plug", "Cord", "Pump", "Leak", "Seal"],
                                           *   ["Mech",     "",     "", "Elec",     "",     "", "Hydr",     "",     ""],
                                           *   ["2010",     "",     "",     "",     "",     "",     "",     "",     ""],
                                           * ];
                                           */
                                          var TOT_SER = data.length;
                                          var TOT_CAT = data[0].labels[0].length;
                                          var TOT_LVL = data[0].labels.length;
                                          var _loop_1 = function (idx) {
                                              // A: start row
                                              strSheetXml_1 += "<row r=\"".concat(idx + 2, "\" spans=\"1:").concat(TOT_SER + TOT_LVL, "\">");
                                              // WIP: FIXME:
                                              // B: add a col for each label/cat
                                              var totLabels = TOT_SER;
                                              var revLabelGroups = data[0].labels.slice().reverse();
                                              revLabelGroups.forEach(function (labelsGroup, idy) {
                                                  /**
                                                   * const LABELS_REVERSED = [
                                                   *   ["Mech",     "",     "", "Elec",     "",     "", "Hydr",     "",     ""],
                                                   *   ["Gear", "Berg", "Motr", "Swch", "Plug", "Cord", "Pump", "Leak", "Seal"],
                                                   * ];
                                                   */
                                                  var colLabel = labelsGroup[idx];
                                                  if (colLabel) {
                                                      var totGrpLbls = idy === 0 ? 1 : revLabelGroups[idy - 1].filter(function (label) { return label && label !== ''; }).length; // get unique label so we can add to get proper shared-string #
                                                      totLabels += totGrpLbls;
                                                      strSheetXml_1 += "<c r=\"".concat(getExcelColName(idx + 1 + idy)).concat(idx + 2, "\" t=\"s\"><v>").concat(totLabels, "</v></c>");
                                                  }
                                              });
                                              // WIP: FIXME:
                                              // C: add a col for each data value
                                              for (var idy = 0; idy < TOT_SER; idy++) {
                                                  strSheetXml_1 += "<c r=\"".concat(getExcelColName(TOT_LVL + idy + 1)).concat(idx + 2, "\"><v>").concat(data[idy].values[idx] || 0, "</v></c>");
                                              }
                                              // D: Done
                                              strSheetXml_1 += '</row>';
                                          };
                                          // Iterate across labels/cats as these are the <row>'s
                                          for (var idx = 0; idx < TOT_CAT; idx++) {
                                              _loop_1(idx);
                                          }
                                          // console.log(strSheetXml) // WIP: CHECK:
                                          // console.log(`---CHECK ABOVE---------------------`)
                                      }
                                  }
                                  strSheetXml_1 += '</sheetData>';
                                  /* FIXME: support multi-level
                                  if (IS_MULTI_CAT_AXES) {
                                      strSheetXml += '<mergeCells count="3">'
                                      strSheetXml += ' <mergeCell ref="A2:A4"/>'
                                      strSheetXml += ' <mergeCell ref="A10:A12"/>'
                                      strSheetXml += ' <mergeCell ref="A5:A9"/>'
                                      strSheetXml += '</mergeCells>'
                                  }
                                  */
                                  strSheetXml_1 += '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>';
                                  // Link the `table1.xml` file to define an actual Table in Excel
                                  // NOTE: This only works with scatter charts - all others give a "cannot find linked file" error
                                  // ....: Since we dont need the table anyway (chart data can be edited/range selected, etc.), just dont use this
                                  // ....: Leaving this so nobody foolishly attempts to add this in the future
                                  // strSheetXml += '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>'
                                  strSheetXml_1 += '</worksheet>\n';
                                  zipExcel.file('xl/worksheets/sheet1.xml', strSheetXml_1);
                              }
                              // C: Add XLSX to PPTX export
                              zipExcel
                                  .generateAsync({ type: 'base64' })
                                  .then(function (content) {
                                  // 1: Create the embedded Excel worksheet with labels and data
                                  zip.file("ppt/embeddings/Microsoft_Excel_Worksheet".concat(chartObject.globalId, ".xlsx"), content, { base64: true });
                                  // 2: Create the chart.xml and rel files
                                  zip.file('ppt/charts/_rels/' + chartObject.fileName + '.rels', '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' +
                                      '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">' +
                                      "<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/package\" Target=\"../embeddings/Microsoft_Excel_Worksheet".concat(chartObject.globalId, ".xlsx\"/>") +
                                      '</Relationships>');
                                  zip.file("ppt/charts/".concat(chartObject.fileName), makeXmlCharts(chartObject));
                                  // 3: Done
                                  resolve('');
                              })
                                  .catch(function (strErr) {
                                  reject(strErr);
                              });
                          })];
                  case 1: return [2 /*return*/, _a.sent()];
              }
          });
      });
  }
  /**
   * Main entry point method for create charts
   * @see: http://www.datypic.com/sc/ooxml/s-dml-chart.xsd.html
   * @param {ISlideRelChart} rel - chart object
   * @return {string} XML
   */
  function makeXmlCharts(rel) {
      var _a, _b, _c, _d;
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
      var usesSecondaryValAxis = false;
      // STEP 1: Create chart
      {
          // CHARTSPACE: BEGIN vvv
          strXml +=
              '<c:chartSpace xmlns:c="http://schemas.openxmlformats.org/drawingml/2006/chart" xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">';
          strXml += '<c:date1904 val="0"/>'; // ppt defaults to 1904 dates, excel to 1900
          strXml += "<c:roundedCorners val=\"".concat(rel.opts.chartArea.roundedCorners ? '1' : '0', "\"/>");
          strXml += '<c:chart>';
          // OPTION: Title
          if (rel.opts.showTitle) {
              strXml += genXmlTitle({
                  title: rel.opts.title || 'Chart Title',
                  color: rel.opts.titleColor,
                  fontFace: rel.opts.titleFontFace,
                  fontSize: rel.opts.titleFontSize || DEF_FONT_TITLE_SIZE,
                  titleAlign: rel.opts.titleAlign,
                  titleBold: rel.opts.titleBold,
                  titlePos: rel.opts.titlePos,
                  titleRotate: rel.opts.titleRotate,
              }, rel.opts.x, rel.opts.y);
              strXml += '<c:autoTitleDeleted val="0"/>';
          }
          else {
              // NOTE: Add autoTitleDeleted tag in else to prevent default creation of chart title even when showTitle is set to false
              strXml += '<c:autoTitleDeleted val="1"/>';
          }
          /** Add 3D view tag
           * @see: https://c-rex.net/projects/samples/ooxml/e1/Part4/OOXML_P4_DOCX_perspective_topic_ID0E6BUQB.html
           */
          if (rel.opts._type === CHART_TYPE.BAR3D) {
              strXml += "<c:view3D><c:rotX val=\"".concat(rel.opts.v3DRotX, "\"/><c:rotY val=\"").concat(rel.opts.v3DRotY, "\"/><c:rAngAx val=\"").concat(!rel.opts.v3DRAngAx ? 0 : 1, "\"/><c:perspective val=\"").concat(rel.opts.v3DPerspective, "\"/></c:view3D>");
          }
          strXml += '<c:plotArea>';
          // IMPORTANT: Dont specify layout to enable auto-fit: PPT does a great job maximizing space with all 4 TRBL locations
          if (rel.opts.layout) {
              strXml += '<c:layout>';
              strXml += ' <c:manualLayout>';
              strXml += '  <c:layoutTarget val="inner" />';
              strXml += '  <c:xMode val="edge" />';
              strXml += '  <c:yMode val="edge" />';
              strXml += '  <c:x val="' + (rel.opts.layout.x || 0) + '" />';
              strXml += '  <c:y val="' + (rel.opts.layout.y || 0) + '" />';
              strXml += '  <c:w val="' + (rel.opts.layout.w || 1) + '" />';
              strXml += '  <c:h val="' + (rel.opts.layout.h || 1) + '" />';
              strXml += ' </c:manualLayout>';
              strXml += '</c:layout>';
          }
          else {
              strXml += '<c:layout/>';
          }
      }
      // A: Create Chart XML -----------------------------------------------------------
      if (Array.isArray(rel.opts._type)) {
          rel.opts._type.forEach(function (type) {
              // TODO: FIXME: theres `options` on chart rels??
              var options = __assign(__assign({}, rel.opts), type.options);
              // let options: IChartOptsLib = { type: type.type, }
              var valAxisId = options.secondaryValAxis ? AXIS_ID_VALUE_SECONDARY : AXIS_ID_VALUE_PRIMARY;
              var catAxisId = options.secondaryCatAxis ? AXIS_ID_CATEGORY_SECONDARY : AXIS_ID_CATEGORY_PRIMARY;
              usesSecondaryValAxis = usesSecondaryValAxis || options.secondaryValAxis;
              strXml += makeChartType(type.type, type.data, options, valAxisId, catAxisId);
          });
      }
      else {
          strXml += makeChartType(rel.opts._type, rel.data, rel.opts, AXIS_ID_VALUE_PRIMARY, AXIS_ID_CATEGORY_PRIMARY);
      }
      // B: Axes -----------------------------------------------------------
      if (rel.opts._type !== CHART_TYPE.PIE && rel.opts._type !== CHART_TYPE.DOUGHNUT) {
          // Param check
          if (rel.opts.valAxes && rel.opts.valAxes.length > 1 && !usesSecondaryValAxis) {
              throw new Error('Secondary axis must be used by one of the multiple charts');
          }
          if (rel.opts.catAxes) {
              if (!rel.opts.valAxes || rel.opts.valAxes.length !== rel.opts.catAxes.length) {
                  throw new Error('There must be the same number of value and category axes.');
              }
              strXml += makeCatAxis(__assign(__assign({}, rel.opts), rel.opts.catAxes[0]), AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
          }
          else {
              strXml += makeCatAxis(rel.opts, AXIS_ID_CATEGORY_PRIMARY, AXIS_ID_VALUE_PRIMARY);
          }
          if (rel.opts.valAxes) {
              strXml += makeValAxis(__assign(__assign({}, rel.opts), rel.opts.valAxes[0]), AXIS_ID_VALUE_PRIMARY);
              if (rel.opts.valAxes[1]) {
                  strXml += makeValAxis(__assign(__assign({}, rel.opts), rel.opts.valAxes[1]), AXIS_ID_VALUE_SECONDARY);
              }
          }
          else {
              strXml += makeValAxis(rel.opts, AXIS_ID_VALUE_PRIMARY);
              // Add series axis for 3D bar
              if (rel.opts._type === CHART_TYPE.BAR3D) {
                  strXml += makeSerAxis(rel.opts, AXIS_ID_SERIES_PRIMARY, AXIS_ID_VALUE_PRIMARY);
              }
          }
          // Combo Charts: Add secondary axes after all vals
          if (((_a = rel.opts) === null || _a === void 0 ? void 0 : _a.catAxes) && ((_b = rel.opts) === null || _b === void 0 ? void 0 : _b.catAxes[1])) {
              strXml += makeCatAxis(__assign(__assign({}, rel.opts), rel.opts.catAxes[1]), AXIS_ID_CATEGORY_SECONDARY, AXIS_ID_VALUE_SECONDARY);
          }
      }
      // C: Chart Properties and plotArea Options: Border, Data Table, Fill, Legend
      {
          // NOTE: DataTable goes between '</c:valAx>' and '<c:spPr>'
          if (rel.opts.showDataTable) {
              strXml += '<c:dTable>';
              strXml += "  <c:showHorzBorder val=\"".concat(!rel.opts.showDataTableHorzBorder ? 0 : 1, "\"/>");
              strXml += "  <c:showVertBorder val=\"".concat(!rel.opts.showDataTableVertBorder ? 0 : 1, "\"/>");
              strXml += "  <c:showOutline    val=\"".concat(!rel.opts.showDataTableOutline ? 0 : 1, "\"/>");
              strXml += "  <c:showKeys       val=\"".concat(!rel.opts.showDataTableKeys ? 0 : 1, "\"/>");
              strXml += '  <c:spPr>';
              strXml += '    <a:noFill/>';
              strXml += '    <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="tx1"><a:lumMod val="15000"/><a:lumOff val="85000"/></a:schemeClr></a:solidFill><a:round/></a:ln>';
              strXml += '    <a:effectLst/>';
              strXml += '  </c:spPr>';
              strXml += '  <c:txPr>';
              strXml += '   <a:bodyPr rot="0" spcFirstLastPara="1" vertOverflow="ellipsis" vert="horz" wrap="square" anchor="ctr" anchorCtr="1"/>';
              strXml += '   <a:lstStyle/>';
              strXml += '   <a:p>';
              strXml += '     <a:pPr rtl="0">';
              strXml += "       <a:defRPr sz=\"".concat(Math.round((rel.opts.dataTableFontSize || DEF_FONT_SIZE) * 100), "\" b=\"0\" i=\"0\" u=\"none\" strike=\"noStrike\" kern=\"1200\" baseline=\"0\">");
              strXml += '         <a:solidFill><a:schemeClr val="tx1"><a:lumMod val="65000"/><a:lumOff val="35000"/></a:schemeClr></a:solidFill>';
              strXml += '         <a:latin typeface="+mn-lt"/>';
              strXml += '         <a:ea typeface="+mn-ea"/>';
              strXml += '         <a:cs typeface="+mn-cs"/>';
              strXml += '       </a:defRPr>';
              strXml += '     </a:pPr>';
              strXml += '    <a:endParaRPr lang="en-US"/>';
              strXml += '   </a:p>';
              strXml += ' </c:txPr>';
              strXml += '</c:dTable>';
          }
          strXml += '  <c:spPr>';
          // OPTION: Fill
          strXml += ((_c = rel.opts.plotArea.fill) === null || _c === void 0 ? void 0 : _c.color) ? genXmlColorSelection(rel.opts.plotArea.fill) : '<a:noFill/>';
          // OPTION: Border
          strXml += rel.opts.plotArea.border
              ? "<a:ln w=\"".concat(valToPts(rel.opts.plotArea.border.pt), "\" cap=\"flat\">").concat(genXmlColorSelection(rel.opts.plotArea.border.color), "</a:ln>")
              : '<a:ln><a:noFill/></a:ln>';
          // Close shapeProp/plotArea before Legend
          strXml += '    <a:effectLst/>';
          strXml += '  </c:spPr>';
          strXml += '</c:plotArea>';
          // OPTION: Legend
          // IMPORTANT: Dont specify layout to enable auto-fit: PPT does a great job maximizing space with all 4 TRBL locations
          if (rel.opts.showLegend) {
              strXml += '<c:legend>';
              strXml += '<c:legendPos val="' + rel.opts.legendPos + '"/>';
              // strXml += '<c:layout/>'
              strXml += '<c:overlay val="0"/>';
              if (rel.opts.legendFontFace || rel.opts.legendFontSize || rel.opts.legendColor) {
                  strXml += '<c:txPr>';
                  strXml += '  <a:bodyPr/>';
                  strXml += '  <a:lstStyle/>';
                  strXml += '  <a:p>';
                  strXml += '    <a:pPr>';
                  strXml += rel.opts.legendFontSize ? "<a:defRPr sz=\"".concat(Math.round(Number(rel.opts.legendFontSize) * 100), "\">") : '<a:defRPr>';
                  if (rel.opts.legendColor)
                      strXml += genXmlColorSelection(rel.opts.legendColor);
                  if (rel.opts.legendFontFace)
                      strXml += '<a:latin typeface="' + rel.opts.legendFontFace + '"/>';
                  if (rel.opts.legendFontFace)
                      strXml += '<a:cs    typeface="' + rel.opts.legendFontFace + '"/>';
                  strXml += '      </a:defRPr>';
                  strXml += '    </a:pPr>';
                  strXml += '    <a:endParaRPr lang="en-US"/>';
                  strXml += '  </a:p>';
                  strXml += '</c:txPr>';
              }
              strXml += '</c:legend>';
          }
      }
      strXml += '  <c:plotVisOnly val="1"/>';
      strXml += '  <c:dispBlanksAs val="' + rel.opts.displayBlanksAs + '"/>';
      if (rel.opts._type === CHART_TYPE.SCATTER)
          strXml += '<c:showDLblsOverMax val="1"/>';
      strXml += '</c:chart>';
      // D: CHARTSPACE SHAPE PROPS
      strXml += '<c:spPr>';
      strXml += ((_d = rel.opts.chartArea.fill) === null || _d === void 0 ? void 0 : _d.color) ? genXmlColorSelection(rel.opts.chartArea.fill) : '<a:noFill/>';
      strXml += rel.opts.chartArea.border
          ? "<a:ln w=\"".concat(valToPts(rel.opts.chartArea.border.pt), "\" cap=\"flat\">").concat(genXmlColorSelection(rel.opts.chartArea.border.color), "</a:ln>")
          : '<a:ln><a:noFill/></a:ln>';
      strXml += '  <a:effectLst/>';
      strXml += '</c:spPr>';
      // E: DATA (Add relID)
      strXml += '<c:externalData r:id="rId1"><c:autoUpdate val="0"/></c:externalData>';
      // LAST: chartSpace end
      strXml += '</c:chartSpace>';
      return strXml;
  }
  /**
   * Create XML string for any given chart type
   * @param {CHART_NAME} chartType chart type name
   * @param {IOptsChartData[]} data chart data
   * @param {IChartOptsLib} opts chart options
   * @param {string} valAxisId chart val axis id
   * @param {string} catAxisId chart cat axis id
   * @param {boolean} isMultiTypeChart is this a mutli-type chart?
   * @example 'bubble' returns <c:bubbleChart></c>
   * @example '<c:lineChart>'
   * @return {string} XML chart
   */
  function makeChartType(chartType, data, opts, valAxisId, catAxisId, isMultiTypeChart) {
      // NOTE: "Chart Range" (as shown in "select Chart Area dialog") is calculated.
      // ....: Ensure each X/Y Axis/Col has same row height (esp. applicable to XY Scatter where X can often be larger than Y's)
      var colorIndex = -1; // Maintain the color index by region
      var idxColLtr = 1;
      var optsChartData = null;
      var strXml = '';
      switch (chartType) {
          case CHART_TYPE.AREA:
          case CHART_TYPE.BAR:
          case CHART_TYPE.BAR3D:
          case CHART_TYPE.LINE:
          case CHART_TYPE.RADAR:
              // 1: Start Chart
              strXml += "<c:".concat(chartType, "Chart>");
              if (chartType === CHART_TYPE.AREA && opts.barGrouping === 'stacked') {
                  strXml += '<c:grouping val="' + opts.barGrouping + '"/>';
              }
              if (chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) {
                  strXml += '<c:barDir val="' + opts.barDir + '"/>';
                  strXml += '<c:grouping val="' + (opts.barGrouping || 'clustered') + '"/>';
              }
              if (chartType === CHART_TYPE.RADAR) {
                  strXml += '<c:radarStyle val="' + opts.radarStyle + '"/>';
              }
              strXml += '<c:varyColors val="0"/>';
              // 2: "Series" block for every data row
              /* EX1:
                  data: [
                   {
                     name: 'Region 1',
                     labels: [['April', 'May', 'June', 'July']],
                     values: [17, 26, 53, 96]
                   },
                   {
                     name: 'Region 2',
                     labels: [['April', 'May', 'June', 'July']],
                     values: [55, 43, 70, 58]
                   }
                  ]
              */
              /* EX2:
                  data: [
                   {
                     name: 'Region 1',
                     labels: [
                         ['April', 'May', 'June', 'April', 'May', 'June'],
                         ['2020',     '',     '', '2021',     '',     '']
                     ],
                     values: [17, 26, 53, 96, 40, 33]
                   },
                   {
                     name: 'Region 2',
                     labels: [
                         ['April', 'May', 'June', 'April', 'May', 'June'],
                         ['2020',     '',     '', '2021',     '',     '']
                     ],
                     values: [55, 43, 70, 58, 78, 63]
                   }
                  ]
               */
              data.forEach(function (obj) {
                  var _a;
                  colorIndex++;
                  strXml += '<c:ser>';
                  strXml += "  <c:idx val=\"".concat(obj._dataIndex, "\"/><c:order val=\"").concat(obj._dataIndex, "\"/>");
                  strXml += '  <c:tx>';
                  strXml += '    <c:strRef>';
                  strXml += '      <c:f>Sheet1!$' + getExcelColName(obj._dataIndex + obj.labels.length + 1) + '$1</c:f>';
                  strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + '</c:v></c:pt></c:strCache>';
                  strXml += '    </c:strRef>';
                  strXml += '  </c:tx>';
                  // Fill and Border
                  // TODO: CURRENT: Pull#727
                  // TODO: let seriesColor = obj.color ? obj.color : opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null
                  var seriesColor = opts.chartColors ? opts.chartColors[colorIndex % opts.chartColors.length] : null;
                  strXml += '  <c:spPr>';
                  if (seriesColor === 'transparent') {
                      strXml += '<a:noFill/>';
                  }
                  else if (opts.chartColorsOpacity) {
                      strXml += '<a:solidFill>' + createColorElement(seriesColor, "<a:alpha val=\"".concat(Math.round(opts.chartColorsOpacity * 1000), "\"/>")) + '</a:solidFill>';
                  }
                  else {
                      strXml += '<a:solidFill>' + createColorElement(seriesColor) + '</a:solidFill>';
                  }
                  if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {
                      if (opts.lineSize === 0) {
                          strXml += '<a:ln><a:noFill/></a:ln>';
                      }
                      else {
                          strXml += "<a:ln w=\"".concat(valToPts(opts.lineSize), "\" cap=\"").concat(createLineCap(opts.lineCap), "\"><a:solidFill>").concat(createColorElement(seriesColor), "</a:solidFill>");
                          strXml += '<a:prstDash val="' + (opts.lineDash || 'solid') + '"/><a:round/></a:ln>';
                      }
                  }
                  else if (opts.dataBorder) {
                      strXml += "<a:ln w=\"".concat(valToPts(opts.dataBorder.pt), "\" cap=\"").concat(createLineCap(opts.lineCap), "\"><a:solidFill>").concat(createColorElement(opts.dataBorder.color), "</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>");
                  }
                  strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                  strXml += '  </c:spPr>';
                  strXml += '  <c:invertIfNegative val="0"/>';
                  // Data Labels per series
                  // NOTE: [20190117] Adding these to RADAR chart causes unrecoverable corruption!
                  if (chartType !== CHART_TYPE.RADAR) {
                      strXml += '<c:dLbls>';
                      strXml += "<c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.dataLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
                      if (opts.dataLabelBkgrdColors)
                          strXml += "<c:spPr><a:solidFill>".concat(createColorElement(seriesColor), "</a:solidFill></c:spPr>");
                      strXml += '<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>';
                      strXml += "<a:defRPr b=\"".concat(opts.dataLabelFontBold ? 1 : 0, "\" i=\"").concat(opts.dataLabelFontItalic ? 1 : 0, "\" strike=\"noStrike\" sz=\"").concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), "\" u=\"none\">");
                      strXml += "<a:solidFill>".concat(createColorElement(opts.dataLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
                      strXml += "<a:latin typeface=\"".concat(opts.dataLabelFontFace || 'Arial', "\"/>");
                      strXml += '</a:defRPr></a:pPr></a:p></c:txPr>';
                      if (opts.dataLabelPosition)
                          strXml += "<c:dLblPos val=\"".concat(opts.dataLabelPosition, "\"/>");
                      strXml += '<c:showLegendKey val="0"/>';
                      strXml += "<c:showVal val=\"".concat(opts.showValue ? '1' : '0', "\"/>");
                      strXml += "<c:showCatName val=\"0\"/><c:showSerName val=\"".concat(opts.showSerName ? '1' : '0', "\"/><c:showPercent val=\"0\"/><c:showBubbleSize val=\"0\"/>");
                      strXml += "<c:showLeaderLines val=\"".concat(opts.showLeaderLines ? '1' : '0', "\"/>");
                      strXml += '</c:dLbls>';
                  }
                  // 'c:marker' tag: `lineDataSymbol`
                  if (chartType === CHART_TYPE.LINE || chartType === CHART_TYPE.RADAR) {
                      strXml += '<c:marker>';
                      strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
                      if (opts.lineDataSymbolSize)
                          strXml += "<c:size val=\"".concat(opts.lineDataSymbolSize, "\"/>"); // Defaults to "auto" otherwise (but this is usually too small, so there is a default)
                      strXml += '  <c:spPr>';
                      strXml += "    <a:solidFill>".concat(createColorElement(opts.chartColors[obj._dataIndex + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : obj._dataIndex]), "</a:solidFill>");
                      strXml += "    <a:ln w=\"".concat(opts.lineDataSymbolLineSize, "\" cap=\"flat\"><a:solidFill>").concat(createColorElement(opts.lineDataSymbolLineColor || seriesColor), "</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>");
                      strXml += '    <a:effectLst/>';
                      strXml += '  </c:spPr>';
                      strXml += '</c:marker>';
                  }
                  // Allow users with a single data set to pass their own array of colors (check for this using != ours)
                  // Color chart bars various colors when >1 color
                  // NOTE: `<c:dPt>` created with various colors will change PPT legend by design so each dataPt/color is an legend item!
                  if ((chartType === CHART_TYPE.BAR || chartType === CHART_TYPE.BAR3D) &&
                      data.length === 1 &&
                      ((opts.chartColors && opts.chartColors !== BARCHART_COLORS && opts.chartColors.length > 1) || ((_a = opts.invertedColors) === null || _a === void 0 ? void 0 : _a.length))) {
                      // Series Data Point colors
                      obj.values.forEach(function (value, index) {
                          var arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
                          strXml += '  <c:dPt>';
                          strXml += "    <c:idx val=\"".concat(index, "\"/>");
                          strXml += '      <c:invertIfNegative val="0"/>';
                          strXml += '    <c:bubble3D val="0"/>';
                          strXml += '    <c:spPr>';
                          if (opts.lineSize === 0) {
                              strXml += '<a:ln><a:noFill/></a:ln>';
                          }
                          else if (chartType === CHART_TYPE.BAR) {
                              strXml += '<a:solidFill>';
                              strXml += '  <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                              strXml += '</a:solidFill>';
                          }
                          else {
                              strXml += '<a:ln>';
                              strXml += '  <a:solidFill>';
                              strXml += '   <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                              strXml += '  </a:solidFill>';
                              strXml += '</a:ln>';
                          }
                          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                          strXml += '    </c:spPr>';
                          strXml += '  </c:dPt>';
                      });
                  }
                  // 2: "Categories"
                  {
                      strXml += '<c:cat>';
                      if (opts.catLabelFormatCode) {
                          // Use 'numRef' as catLabelFormatCode implies that we are expecting numbers here
                          strXml += '  <c:numRef>';
                          strXml += "    <c:f>Sheet1!$A$2:$A$".concat(obj.labels[0].length + 1, "</c:f>");
                          strXml += '    <c:numCache>';
                          strXml += '      <c:formatCode>' + (opts.catLabelFormatCode || 'General') + '</c:formatCode>';
                          strXml += "      <c:ptCount val=\"".concat(obj.labels[0].length, "\"/>");
                          obj.labels[0].forEach(function (label, idx) { return (strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(encodeXmlEntities(label), "</c:v></c:pt>")); });
                          strXml += '    </c:numCache>';
                          strXml += '  </c:numRef>';
                      }
                      else {
                          strXml += '  <c:multiLvlStrRef>';
                          strXml += "    <c:f>Sheet1!$A$2:$".concat(getExcelColName(obj.labels.length), "$").concat(obj.labels[0].length + 1, "</c:f>");
                          strXml += '    <c:multiLvlStrCache>';
                          strXml += "      <c:ptCount val=\"".concat(obj.labels[0].length, "\"/>");
                          obj.labels.forEach(function (labelsGroup) {
                              strXml += '<c:lvl>';
                              labelsGroup.forEach(function (label, idx) { return (strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(encodeXmlEntities(label), "</c:v></c:pt>")); });
                              strXml += '</c:lvl>';
                          });
                          strXml += '    </c:multiLvlStrCache>';
                          strXml += '  </c:multiLvlStrRef>';
                      }
                      strXml += '</c:cat>';
                  }
                  // 3: "Values"
                  {
                      strXml += '<c:val>';
                      strXml += '  <c:numRef>';
                      strXml += "<c:f>Sheet1!$".concat(getExcelColName(obj._dataIndex + obj.labels.length + 1), "$2:$").concat(getExcelColName(obj._dataIndex + obj.labels.length + 1), "$").concat(obj.labels[0].length + 1, "</c:f>");
                      strXml += '    <c:numCache>';
                      strXml += '      <c:formatCode>' + (opts.valLabelFormatCode || opts.dataTableFormatCode || 'General') + '</c:formatCode>';
                      strXml += "      <c:ptCount val=\"".concat(obj.labels[0].length, "\"/>");
                      obj.values.forEach(function (value, idx) { return (strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(value || value === 0 ? value : '', "</c:v></c:pt>")); });
                      strXml += '    </c:numCache>';
                      strXml += '  </c:numRef>';
                      strXml += '</c:val>';
                  }
                  // Option: `smooth`
                  if (chartType === CHART_TYPE.LINE)
                      strXml += '<c:smooth val="' + (opts.lineSmooth ? '1' : '0') + '"/>';
                  // 4: Close "SERIES"
                  strXml += '</c:ser>';
              });
              // 3: "Data Labels"
              {
                  strXml += '  <c:dLbls>';
                  strXml += "    <c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.dataLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
                  strXml += '    <c:txPr>';
                  strXml += '      <a:bodyPr/>';
                  strXml += '      <a:lstStyle/>';
                  strXml += '      <a:p><a:pPr>';
                  strXml += "        <a:defRPr b=\"".concat(opts.dataLabelFontBold ? 1 : 0, "\" i=\"").concat(opts.dataLabelFontItalic ? 1 : 0, "\" strike=\"noStrike\" sz=\"").concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), "\" u=\"none\">");
                  strXml += '          <a:solidFill>' + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';
                  strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || 'Arial') + '"/>';
                  strXml += '        </a:defRPr>';
                  strXml += '      </a:pPr></a:p>';
                  strXml += '    </c:txPr>';
                  if (opts.dataLabelPosition)
                      strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                  strXml += '    <c:showLegendKey val="0"/>';
                  strXml += '    <c:showVal val="' + (opts.showValue ? '1' : '0') + '"/>';
                  strXml += '    <c:showCatName val="0"/>';
                  strXml += '    <c:showSerName val="' + (opts.showSerName ? '1' : '0') + '"/>';
                  strXml += '    <c:showPercent val="0"/>';
                  strXml += '    <c:showBubbleSize val="0"/>';
                  strXml += "    <c:showLeaderLines val=\"".concat(opts.showLeaderLines ? '1' : '0', "\"/>");
                  strXml += '  </c:dLbls>';
              }
              // 4: Add more chart options (gapWidth, line Marker, etc.)
              if (chartType === CHART_TYPE.BAR) {
                  strXml += "  <c:gapWidth val=\"".concat(opts.barGapWidthPct, "\"/>");
                  strXml += "  <c:overlap val=\"".concat((opts.barGrouping || '').includes('tacked') ? 100 : opts.barOverlapPct ? opts.barOverlapPct : 0, "\"/>");
              }
              else if (chartType === CHART_TYPE.BAR3D) {
                  strXml += "  <c:gapWidth val=\"".concat(opts.barGapWidthPct, "\"/>");
                  strXml += "  <c:gapDepth val=\"".concat(opts.barGapDepthPct, "\"/>");
                  strXml += '  <c:shape val="' + opts.bar3DShape + '"/>';
              }
              else if (chartType === CHART_TYPE.LINE) {
                  strXml += '  <c:marker val="1"/>';
              }
              // 5: Add axisId (NOTE: order matters! (category comes first))
              strXml += "<c:axId val=\"".concat(catAxisId, "\"/><c:axId val=\"").concat(valAxisId, "\"/><c:axId val=\"").concat(AXIS_ID_SERIES_PRIMARY, "\"/>");
              // 6: Close Chart tag
              strXml += "</c:".concat(chartType, "Chart>");
              // end switch
              break;
          case CHART_TYPE.SCATTER:
              /*
                  `data` = [
                      { name:'X-Axis',    values:[1,2,3,4,5,6,7,8,9,10,11,12] },
                      { name:'Y-Value 1', values:[13, 20, 21, 25] },
                      { name:'Y-Value 2', values:[ 1,  2,  5,  9] }
                  ];
              */
              // 1: Start Chart
              strXml += '<c:' + chartType + 'Chart>';
              strXml += '<c:scatterStyle val="lineMarker"/>';
              strXml += '<c:varyColors val="0"/>';
              // 2: Series: (One for each Y-Axis)
              colorIndex = -1;
              data.filter(function (_obj, idx) { return idx > 0; }).forEach(function (obj, idx) {
                  colorIndex++;
                  strXml += '<c:ser>';
                  strXml += "  <c:idx val=\"".concat(idx, "\"/>");
                  strXml += "  <c:order val=\"".concat(idx, "\"/>");
                  strXml += '  <c:tx>';
                  strXml += '    <c:strRef>';
                  strXml += "      <c:f>Sheet1!$".concat(getExcelColName(idx + 2), "$1</c:f>");
                  strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + '</c:v></c:pt></c:strCache>';
                  strXml += '    </c:strRef>';
                  strXml += '  </c:tx>';
                  // 'c:spPr': Fill, Border, Line, LineStyle (dash, etc.), Shadow
                  strXml += '  <c:spPr>';
                  {
                      var tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
                      if (tmpSerColor === 'transparent') {
                          strXml += '<a:noFill/>';
                      }
                      else if (opts.chartColorsOpacity) {
                          strXml += '<a:solidFill>' + createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1000).toString() + '"/>') + '</a:solidFill>';
                      }
                      else {
                          strXml += '<a:solidFill>' + createColorElement(tmpSerColor) + '</a:solidFill>';
                      }
                      if (opts.lineSize === 0) {
                          strXml += '<a:ln><a:noFill/></a:ln>';
                      }
                      else {
                          strXml += "<a:ln w=\"".concat(valToPts(opts.lineSize), "\" cap=\"").concat(createLineCap(opts.lineCap), "\"><a:solidFill>").concat(createColorElement(tmpSerColor), "</a:solidFill>");
                          strXml += "<a:prstDash val=\"".concat(opts.lineDash || 'solid', "\"/><a:round/></a:ln>");
                      }
                      // Shadow
                      strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                  }
                  strXml += '  </c:spPr>';
                  // 'c:marker' tag: `lineDataSymbol`
                  {
                      strXml += '<c:marker>';
                      strXml += '  <c:symbol val="' + opts.lineDataSymbol + '"/>';
                      if (opts.lineDataSymbolSize) {
                          // Defaults to "auto" otherwise (but this is usually too small, so there is a default)
                          strXml += "<c:size val=\"".concat(opts.lineDataSymbolSize, "\"/>");
                      }
                      strXml += '<c:spPr>';
                      strXml += "<a:solidFill>".concat(createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]), "</a:solidFill>");
                      strXml += "<a:ln w=\"".concat(opts.lineDataSymbolLineSize, "\" cap=\"flat\"><a:solidFill>").concat(createColorElement(opts.lineDataSymbolLineColor || opts.chartColors[colorIndex % opts.chartColors.length]), "</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>");
                      strXml += '<a:effectLst/>';
                      strXml += '</c:spPr>';
                      strXml += '</c:marker>';
                  }
                  // Option: scatter data point labels
                  if (opts.showLabel) {
                      var chartUuid_1 = getUuid('-xxxx-xxxx-xxxx-xxxxxxxxxxxx');
                      if (obj.labels[0] && (opts.dataLabelFormatScatter === 'custom' || opts.dataLabelFormatScatter === 'customXY')) {
                          strXml += '<c:dLbls>';
                          obj.labels[0].forEach(function (label, idx) {
                              if (opts.dataLabelFormatScatter === 'custom' || opts.dataLabelFormatScatter === 'customXY') {
                                  strXml += '  <c:dLbl>';
                                  strXml += "    <c:idx val=\"".concat(idx, "\"/>");
                                  strXml += '    <c:tx>';
                                  strXml += '      <c:rich>';
                                  strXml += '            <a:bodyPr>';
                                  strXml += '                <a:spAutoFit/>';
                                  strXml += '            </a:bodyPr>';
                                  strXml += '            <a:lstStyle/>';
                                  strXml += '            <a:p>';
                                  strXml += '                <a:pPr>';
                                  strXml += '                    <a:defRPr/>';
                                  strXml += '                </a:pPr>';
                                  strXml += '              <a:r>';
                                  strXml += '                    <a:rPr lang="' + (opts.lang || 'en-US') + '" dirty="0"/>';
                                  strXml += '                    <a:t>' + encodeXmlEntities(label) + '</a:t>';
                                  strXml += '              </a:r>';
                                  // Apply XY values at end of custom label
                                  // Do not apply the values if the label was empty or just spaces
                                  // This allows for selective labelling where required
                                  if (opts.dataLabelFormatScatter === 'customXY' && !/^ *$/.test(label)) {
                                      strXml += '              <a:r>';
                                      strXml += '                  <a:rPr lang="' + (opts.lang || 'en-US') + '" baseline="0" dirty="0"/>';
                                      strXml += '                  <a:t> (</a:t>';
                                      strXml += '              </a:r>';
                                      strXml += '              <a:fld id="{' + getUuid('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx') + '}" type="XVALUE">';
                                      strXml += '                  <a:rPr lang="' + (opts.lang || 'en-US') + '" baseline="0"/>';
                                      strXml += '                  <a:pPr>';
                                      strXml += '                      <a:defRPr/>';
                                      strXml += '                  </a:pPr>';
                                      strXml += '                  <a:t>[' + encodeXmlEntities(obj.name) + '</a:t>';
                                      strXml += '              </a:fld>';
                                      strXml += '              <a:r>';
                                      strXml += '                  <a:rPr lang="' + (opts.lang || 'en-US') + '" baseline="0" dirty="0"/>';
                                      strXml += '                  <a:t>, </a:t>';
                                      strXml += '              </a:r>';
                                      strXml += '              <a:fld id="{' + getUuid('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx') + '}" type="YVALUE">';
                                      strXml += '                  <a:rPr lang="' + (opts.lang || 'en-US') + '" baseline="0"/>';
                                      strXml += '                  <a:pPr>';
                                      strXml += '                      <a:defRPr/>';
                                      strXml += '                  </a:pPr>';
                                      strXml += '                  <a:t>[' + encodeXmlEntities(obj.name) + ']</a:t>';
                                      strXml += '              </a:fld>';
                                      strXml += '              <a:r>';
                                      strXml += '                  <a:rPr lang="' + (opts.lang || 'en-US') + '" baseline="0" dirty="0"/>';
                                      strXml += '                  <a:t>)</a:t>';
                                      strXml += '              </a:r>';
                                      strXml += '              <a:endParaRPr lang="' + (opts.lang || 'en-US') + '" dirty="0"/>';
                                  }
                                  strXml += '            </a:p>';
                                  strXml += '      </c:rich>';
                                  strXml += '    </c:tx>';
                                  strXml += '    <c:spPr>';
                                  strXml += '        <a:noFill/>';
                                  strXml += '        <a:ln>';
                                  strXml += '            <a:noFill/>';
                                  strXml += '        </a:ln>';
                                  strXml += '        <a:effectLst/>';
                                  strXml += '    </c:spPr>';
                                  if (opts.dataLabelPosition)
                                      strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                                  strXml += '    <c:showLegendKey val="0"/>';
                                  strXml += '    <c:showVal val="0"/>';
                                  strXml += '    <c:showCatName val="0"/>';
                                  strXml += '    <c:showSerName val="0"/>';
                                  strXml += '    <c:showPercent val="0"/>';
                                  strXml += '    <c:showBubbleSize val="0"/>';
                                  strXml += '       <c:showLeaderLines val="1"/>';
                                  strXml += '    <c:extLst>';
                                  strXml += '      <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart"/>';
                                  strXml += '      <c:ext uri="{C3380CC4-5D6E-409C-BE32-E72D297353CC}" xmlns:c16="http://schemas.microsoft.com/office/drawing/2014/chart">';
                                  strXml += "            <c16:uniqueId val=\"{".concat('00000000'.substring(0, 8 - (idx + 1).toString().length).toString()).concat(idx + 1).concat(chartUuid_1, "}\"/>");
                                  strXml += '      </c:ext>';
                                  strXml += '        </c:extLst>';
                                  strXml += '</c:dLbl>';
                              }
                          });
                          strXml += '</c:dLbls>';
                      }
                      if (opts.dataLabelFormatScatter === 'XY') {
                          strXml += '<c:dLbls>';
                          strXml += '    <c:spPr>';
                          strXml += '        <a:noFill/>';
                          strXml += '        <a:ln>';
                          strXml += '            <a:noFill/>';
                          strXml += '        </a:ln>';
                          strXml += '          <a:effectLst/>';
                          strXml += '    </c:spPr>';
                          strXml += '    <c:txPr>';
                          strXml += '        <a:bodyPr>';
                          strXml += '            <a:spAutoFit/>';
                          strXml += '        </a:bodyPr>';
                          strXml += '        <a:lstStyle/>';
                          strXml += '        <a:p>';
                          strXml += '            <a:pPr>';
                          strXml += '                <a:defRPr/>';
                          strXml += '            </a:pPr>';
                          strXml += '            <a:endParaRPr lang="en-US"/>';
                          strXml += '        </a:p>';
                          strXml += '    </c:txPr>';
                          if (opts.dataLabelPosition)
                              strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                          strXml += '    <c:showLegendKey val="0"/>';
                          strXml += " <c:showVal val=\"".concat(opts.showLabel ? '1' : '0', "\"/>");
                          strXml += " <c:showCatName val=\"".concat(opts.showLabel ? '1' : '0', "\"/>");
                          strXml += " <c:showSerName val=\"".concat(opts.showSerName ? '1' : '0', "\"/>");
                          strXml += '    <c:showPercent val="0"/>';
                          strXml += '    <c:showBubbleSize val="0"/>';
                          strXml += '    <c:extLst>';
                          strXml += '        <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
                          strXml += '            <c15:showLeaderLines val="1"/>';
                          strXml += '        </c:ext>';
                          strXml += '    </c:extLst>';
                          strXml += '</c:dLbls>';
                      }
                  }
                  // Color bar chart bars various colors
                  // Allow users with a single data set to pass their own array of colors (check for this using != ours)
                  if (data.length === 1 && opts.chartColors !== BARCHART_COLORS) {
                      // Series Data Point colors
                      obj.values.forEach(function (value, index) {
                          var arrColors = value < 0 ? opts.invertedColors || opts.chartColors || BARCHART_COLORS : opts.chartColors || [];
                          strXml += '  <c:dPt>';
                          strXml += "    <c:idx val=\"".concat(index, "\"/>");
                          strXml += '      <c:invertIfNegative val="0"/>';
                          strXml += '    <c:bubble3D val="0"/>';
                          strXml += '    <c:spPr>';
                          if (opts.lineSize === 0) {
                              strXml += '<a:ln><a:noFill/></a:ln>';
                          }
                          else {
                              strXml += '<a:solidFill>';
                              strXml += ' <a:srgbClr val="' + arrColors[index % arrColors.length] + '"/>';
                              strXml += '</a:solidFill>';
                          }
                          strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                          strXml += '    </c:spPr>';
                          strXml += '  </c:dPt>';
                      });
                  }
                  // 3: "Values": Scatter Chart has 2: `xVal` and `yVal`
                  {
                      // X-Axis is always the same
                      strXml += '<c:xVal>';
                      strXml += '  <c:numRef>';
                      strXml += "    <c:f>Sheet1!$A$2:$A$".concat(data[0].values.length + 1, "</c:f>");
                      strXml += '    <c:numCache>';
                      strXml += '      <c:formatCode>General</c:formatCode>';
                      strXml += "      <c:ptCount val=\"".concat(data[0].values.length, "\"/>");
                      data[0].values.forEach(function (value, idx) {
                          strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(value || value === 0 ? value : '', "</c:v></c:pt>");
                      });
                      strXml += '    </c:numCache>';
                      strXml += '  </c:numRef>';
                      strXml += '</c:xVal>';
                      // Y-Axis vals are this object's `values`
                      strXml += '<c:yVal>';
                      strXml += '  <c:numRef>';
                      strXml += "    <c:f>Sheet1!$".concat(getExcelColName(idx + 2), "$2:$").concat(getExcelColName(idx + 2), "$").concat(data[0].values.length + 1, "</c:f>");
                      strXml += '    <c:numCache>';
                      strXml += '      <c:formatCode>General</c:formatCode>';
                      // NOTE: Use pt count and iterate over data[0] (X-Axis) as user can have more values than data (eg: timeline where only first few months are populated)
                      strXml += "      <c:ptCount val=\"".concat(data[0].values.length, "\"/>");
                      data[0].values.forEach(function (_value, idx) {
                          strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(obj.values[idx] || obj.values[idx] === 0 ? obj.values[idx] : '', "</c:v></c:pt>");
                      });
                      strXml += '    </c:numCache>';
                      strXml += '  </c:numRef>';
                      strXml += '</c:yVal>';
                  }
                  // Option: `smooth`
                  strXml += '<c:smooth val="' + (opts.lineSmooth ? '1' : '0') + '"/>';
                  // 4: Close "SERIES"
                  strXml += '</c:ser>';
              });
              // 3: Data Labels
              {
                  strXml += '  <c:dLbls>';
                  strXml += "    <c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.dataLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
                  strXml += '    <c:txPr>';
                  strXml += '      <a:bodyPr/>';
                  strXml += '      <a:lstStyle/>';
                  strXml += '      <a:p><a:pPr>';
                  strXml += "        <a:defRPr b=\"".concat(opts.dataLabelFontBold ? '1' : '0', "\" i=\"").concat(opts.dataLabelFontItalic ? '1' : '0', "\" strike=\"noStrike\" sz=\"").concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), "\" u=\"none\">");
                  strXml += '          <a:solidFill>' + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';
                  strXml += '          <a:latin typeface="' + (opts.dataLabelFontFace || 'Arial') + '"/>';
                  strXml += '        </a:defRPr>';
                  strXml += '      </a:pPr></a:p>';
                  strXml += '    </c:txPr>';
                  if (opts.dataLabelPosition)
                      strXml += ' <c:dLblPos val="' + opts.dataLabelPosition + '"/>';
                  strXml += '    <c:showLegendKey val="0"/>';
                  strXml += '    <c:showVal val="' + (opts.showValue ? '1' : '0') + '"/>';
                  strXml += '    <c:showCatName val="0"/>';
                  strXml += '    <c:showSerName val="' + (opts.showSerName ? '1' : '0') + '"/>';
                  strXml += '    <c:showPercent val="0"/>';
                  strXml += '    <c:showBubbleSize val="0"/>';
                  strXml += '  </c:dLbls>';
              }
              // 4: Add axis Id (NOTE: order matters! - category comes first)
              strXml += "<c:axId val=\"".concat(catAxisId, "\"/><c:axId val=\"").concat(valAxisId, "\"/>");
              // 5: Close Chart tag
              strXml += '</c:' + chartType + 'Chart>';
              // end switch
              break;
          case CHART_TYPE.BUBBLE:
          case CHART_TYPE.BUBBLE3D:
              /*
                  `data` = [
                      { name:'X-Axis',     values:[1,2,3,4,5,6,7,8,9,10,11,12] },
                      { name:'Y-Values 1', values:[13, 20, 21, 25], sizes:[10, 5, 20, 15] },
                      { name:'Y-Values 2', values:[ 1,  2,  5,  9], sizes:[ 5, 3,  9,  3] }
                  ];
              */
              // 1: Start Chart
              strXml += '<c:bubbleChart>';
              strXml += '<c:varyColors val="0"/>';
              // 2: Series: (One for each Y-Axis)
              colorIndex = -1;
              data.filter(function (_obj, idx) { return idx > 0; }).forEach(function (obj, idx) {
                  colorIndex++;
                  strXml += '<c:ser>';
                  strXml += "  <c:idx val=\"".concat(idx, "\"/>");
                  strXml += "  <c:order val=\"".concat(idx, "\"/>");
                  // A: `<c:tx>`
                  strXml += '  <c:tx>';
                  strXml += '    <c:strRef>';
                  strXml += '      <c:f>Sheet1!$' + getExcelColName(idxColLtr + 1) + '$1</c:f>';
                  strXml += '      <c:strCache><c:ptCount val="1"/><c:pt idx="0"><c:v>' + encodeXmlEntities(obj.name) + '</c:v></c:pt></c:strCache>';
                  strXml += '    </c:strRef>';
                  strXml += '  </c:tx>';
                  // B: '<c:spPr>': Fill, Border, Line, LineStyle (dash, etc.), Shadow
                  {
                      strXml += '<c:spPr>';
                      var tmpSerColor = opts.chartColors[colorIndex % opts.chartColors.length];
                      if (tmpSerColor === 'transparent') {
                          strXml += '<a:noFill/>';
                      }
                      else if (opts.chartColorsOpacity) {
                          strXml += "<a:solidFill>".concat(createColorElement(tmpSerColor, '<a:alpha val="' + Math.round(opts.chartColorsOpacity * 1000).toString() + '"/>'), "</a:solidFill>");
                      }
                      else {
                          strXml += '<a:solidFill>' + createColorElement(tmpSerColor) + '</a:solidFill>';
                      }
                      if (opts.lineSize === 0) {
                          strXml += '<a:ln><a:noFill/></a:ln>';
                      }
                      else if (opts.dataBorder) {
                          strXml += "<a:ln w=\"".concat(valToPts(opts.dataBorder.pt), "\" cap=\"flat\"><a:solidFill>").concat(createColorElement(opts.dataBorder.color), "</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>");
                      }
                      else {
                          strXml += "<a:ln w=\"".concat(valToPts(opts.lineSize), "\" cap=\"flat\"><a:solidFill>").concat(createColorElement(tmpSerColor), "</a:solidFill>");
                          strXml += "<a:prstDash val=\"".concat(opts.lineDash || 'solid', "\"/><a:round/></a:ln>");
                      }
                      // Shadow
                      strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                      strXml += '</c:spPr>';
                  }
                  // C: '<c:dLbls>' "Data Labels"
                  // Let it be defaulted for now
                  // D: '<c:xVal>'/'<c:yVal>' "Values": Scatter Chart has 2: `xVal` and `yVal`
                  {
                      // X-Axis is always the same
                      strXml += '<c:xVal>';
                      strXml += '  <c:numRef>';
                      strXml += "    <c:f>Sheet1!$A$2:$A$".concat(data[0].values.length + 1, "</c:f>");
                      strXml += '    <c:numCache>';
                      strXml += '      <c:formatCode>General</c:formatCode>';
                      strXml += "      <c:ptCount val=\"".concat(data[0].values.length, "\"/>");
                      data[0].values.forEach(function (value, idx) {
                          strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(value || value === 0 ? value : '', "</c:v></c:pt>");
                      });
                      strXml += '    </c:numCache>';
                      strXml += '  </c:numRef>';
                      strXml += '</c:xVal>';
                      // Y-Axis vals are this object's `values`
                      strXml += '<c:yVal>';
                      strXml += '  <c:numRef>';
                      strXml += "<c:f>Sheet1!$".concat(getExcelColName(idxColLtr + 1), "$2:$").concat(getExcelColName(idxColLtr + 1), "$").concat(data[0].values.length + 1, "</c:f>");
                      idxColLtr++;
                      strXml += '    <c:numCache>';
                      strXml += '      <c:formatCode>General</c:formatCode>';
                      // NOTE: Use pt count and iterate over data[0] (X-Axis) as user can have more values than data (eg: timeline where only first few months are populated)
                      strXml += "      <c:ptCount val=\"".concat(data[0].values.length, "\"/>");
                      data[0].values.forEach(function (_value, idx) {
                          strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(obj.values[idx] || obj.values[idx] === 0 ? obj.values[idx] : '', "</c:v></c:pt>");
                      });
                      strXml += '    </c:numCache>';
                      strXml += '  </c:numRef>';
                      strXml += '</c:yVal>';
                  }
                  // E: '<c:bubbleSize>'
                  strXml += '  <c:bubbleSize>';
                  strXml += '    <c:numRef>';
                  strXml += "<c:f>Sheet1!$".concat(getExcelColName(idxColLtr + 1), "$2:$").concat(getExcelColName(idxColLtr + 1), "$").concat(obj.sizes.length + 1, "</c:f>");
                  idxColLtr++;
                  strXml += '      <c:numCache>';
                  strXml += '        <c:formatCode>General</c:formatCode>';
                  strXml += "           <c:ptCount val=\"".concat(obj.sizes.length, "\"/>");
                  obj.sizes.forEach(function (value, idx) {
                      strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(value || '', "</c:v></c:pt>");
                  });
                  strXml += '      </c:numCache>';
                  strXml += '    </c:numRef>';
                  strXml += '  </c:bubbleSize>';
                  strXml += '  <c:bubble3D val="' + (chartType === CHART_TYPE.BUBBLE3D ? '1' : '0') + '"/>';
                  // F: Close "SERIES"
                  strXml += '</c:ser>';
              });
              // 3: Data Labels
              {
                  strXml += '<c:dLbls>';
                  strXml += "<c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.dataLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
                  strXml += '<c:txPr><a:bodyPr/><a:lstStyle/><a:p><a:pPr>';
                  strXml += "<a:defRPr b=\"".concat(opts.dataLabelFontBold ? 1 : 0, "\" i=\"").concat(opts.dataLabelFontItalic ? 1 : 0, "\" strike=\"noStrike\" sz=\"").concat(Math.round(Math.round(opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), "\" u=\"none\">");
                  strXml += "<a:solidFill>".concat(createColorElement(opts.dataLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
                  strXml += "<a:latin typeface=\"".concat(opts.dataLabelFontFace || 'Arial', "\"/>");
                  strXml += '</a:defRPr></a:pPr></a:p></c:txPr>';
                  if (opts.dataLabelPosition)
                      strXml += "<c:dLblPos val=\"".concat(opts.dataLabelPosition, "\"/>");
                  strXml += '<c:showLegendKey val="0"/>';
                  strXml += "<c:showVal val=\"".concat(opts.showValue ? '1' : '0', "\"/>");
                  strXml += "<c:showCatName val=\"0\"/><c:showSerName val=\"".concat(opts.showSerName ? '1' : '0', "\"/><c:showPercent val=\"0\"/><c:showBubbleSize val=\"0\"/>");
                  strXml += '<c:extLst>';
                  strXml += '  <c:ext uri="{CE6537A1-D6FC-4f65-9D91-7224C49458BB}" xmlns:c15="http://schemas.microsoft.com/office/drawing/2012/chart">';
                  strXml += '    <c15:showLeaderLines val="' + (opts.showLeaderLines ? '1' : '0') + '"/>';
                  strXml += '  </c:ext>';
                  strXml += '</c:extLst>';
                  strXml += '</c:dLbls>';
              }
              // 4: Bubble options
              // strXml += '  <c:bubbleScale val="100"/>';
              // strXml += '  <c:showNegBubbles val="0"/>';
              // Commented out to let it default to PPT until we create options
              // 5: AxisId (NOTE: order matters! (category comes first))
              strXml += "<c:axId val=\"".concat(catAxisId, "\"/><c:axId val=\"").concat(valAxisId, "\"/>");
              // 6: Close Chart tag
              strXml += '</c:bubbleChart>';
              // end switch
              break;
          case CHART_TYPE.DOUGHNUT:
          case CHART_TYPE.PIE:
              // Use the same let name so code blocks from barChart are interchangeable
              optsChartData = data[0];
              /* EX:
                  data: [
                   {
                     name: 'Project Status',
                     labels: ['Red', 'Amber', 'Green', 'Unknown'],
                     values: [10, 20, 38, 2]
                   }
                  ]
              */
              // 1: Start Chart
              strXml += '<c:' + chartType + 'Chart>';
              strXml += '  <c:varyColors val="1"/>';
              strXml += '<c:ser>';
              strXml += '  <c:idx val="0"/>';
              strXml += '  <c:order val="0"/>';
              strXml += '  <c:tx>';
              strXml += '    <c:strRef>';
              strXml += '      <c:f>Sheet1!$B$1</c:f>';
              strXml += '      <c:strCache>';
              strXml += '        <c:ptCount val="1"/>';
              strXml += '        <c:pt idx="0"><c:v>' + encodeXmlEntities(optsChartData.name) + '</c:v></c:pt>';
              strXml += '      </c:strCache>';
              strXml += '    </c:strRef>';
              strXml += '  </c:tx>';
              strXml += '  <c:spPr>';
              strXml += '    <a:solidFill><a:schemeClr val="accent1"/></a:solidFill>';
              strXml += '    <a:ln w="9525" cap="flat"><a:solidFill><a:srgbClr val="F9F9F9"/></a:solidFill><a:prstDash val="solid"/><a:round/></a:ln>';
              if (opts.dataNoEffects) {
                  strXml += '<a:effectLst/>';
              }
              else {
                  strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
              }
              strXml += '  </c:spPr>';
              // strXml += '<c:explosion val="0"/>'
              // 2: "Data Point" block for every data row
              optsChartData.labels[0].forEach(function (_label, idx) {
                  strXml += '<c:dPt>';
                  strXml += " <c:idx val=\"".concat(idx, "\"/>");
                  strXml += ' <c:bubble3D val="0"/>';
                  strXml += ' <c:spPr>';
                  strXml += "<a:solidFill>".concat(createColorElement(opts.chartColors[idx + 1 > opts.chartColors.length ? Math.floor(Math.random() * opts.chartColors.length) : idx]), "</a:solidFill>");
                  if (opts.dataBorder) {
                      strXml += "<a:ln w=\"".concat(valToPts(opts.dataBorder.pt), "\" cap=\"flat\"><a:solidFill>").concat(createColorElement(opts.dataBorder.color), "</a:solidFill><a:prstDash val=\"solid\"/><a:round/></a:ln>");
                  }
                  strXml += createShadowElement(opts.shadow, DEF_SHAPE_SHADOW);
                  strXml += '  </c:spPr>';
                  strXml += '</c:dPt>';
              });
              // 3: "Data Label" block for every data Label
              strXml += '<c:dLbls>';
              optsChartData.labels[0].forEach(function (_label, idx) {
                  strXml += '<c:dLbl>';
                  strXml += " <c:idx val=\"".concat(idx, "\"/>");
                  strXml += "  <c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.dataLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
                  strXml += '  <c:spPr/><c:txPr>';
                  strXml += '   <a:bodyPr/><a:lstStyle/>';
                  strXml += '   <a:p><a:pPr>';
                  strXml += "   <a:defRPr sz=\"".concat(Math.round((opts.dataLabelFontSize || DEF_FONT_SIZE) * 100), "\" b=\"").concat(opts.dataLabelFontBold ? 1 : 0, "\" i=\"").concat(opts.dataLabelFontItalic ? 1 : 0, "\" u=\"none\" strike=\"noStrike\">");
                  strXml += '    <a:solidFill>' + createColorElement(opts.dataLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';
                  strXml += "    <a:latin typeface=\"".concat(opts.dataLabelFontFace || 'Arial', "\"/>");
                  strXml += '   </a:defRPr>';
                  strXml += '      </a:pPr></a:p>';
                  strXml += '    </c:txPr>';
                  if (chartType === CHART_TYPE.PIE && opts.dataLabelPosition)
                      strXml += "<c:dLblPos val=\"".concat(opts.dataLabelPosition, "\"/>");
                  strXml += '    <c:showLegendKey val="0"/>';
                  strXml += '    <c:showVal val="' + (opts.showValue ? '1' : '0') + '"/>';
                  strXml += '    <c:showCatName val="' + (opts.showLabel ? '1' : '0') + '"/>';
                  strXml += '    <c:showSerName val="' + (opts.showSerName ? '1' : '0') + '"/>';
                  strXml += '    <c:showPercent val="' + (opts.showPercent ? '1' : '0') + '"/>';
                  strXml += '    <c:showBubbleSize val="0"/>';
                  strXml += '  </c:dLbl>';
              });
              strXml += " <c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.dataLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
              strXml += '    <c:txPr>';
              strXml += '      <a:bodyPr/>';
              strXml += '      <a:lstStyle/>';
              strXml += '      <a:p>';
              strXml += '        <a:pPr>';
              strXml += "          <a:defRPr sz=\"1800\" b=\"".concat(opts.dataLabelFontBold ? '1' : '0', "\" i=\"").concat(opts.dataLabelFontItalic ? '1' : '0', "\" u=\"none\" strike=\"noStrike\">");
              strXml += '            <a:solidFill><a:srgbClr val="000000"/></a:solidFill><a:latin typeface="Arial"/>';
              strXml += '          </a:defRPr>';
              strXml += '        </a:pPr>';
              strXml += '      </a:p>';
              strXml += '    </c:txPr>';
              strXml += chartType === CHART_TYPE.PIE ? '<c:dLblPos val="ctr"/>' : '';
              strXml += '    <c:showLegendKey val="0"/>';
              strXml += '    <c:showVal val="0"/>';
              strXml += '    <c:showCatName val="1"/>';
              strXml += '    <c:showSerName val="0"/>';
              strXml += '    <c:showPercent val="1"/>';
              strXml += '    <c:showBubbleSize val="0"/>';
              strXml += " <c:showLeaderLines val=\"".concat(opts.showLeaderLines ? '1' : '0', "\"/>");
              strXml += '</c:dLbls>';
              // 2: "Categories"
              strXml += '<c:cat>';
              strXml += '  <c:strRef>';
              strXml += "    <c:f>Sheet1!$A$2:$A$".concat(optsChartData.labels[0].length + 1, "</c:f>");
              strXml += '    <c:strCache>';
              strXml += "         <c:ptCount val=\"".concat(optsChartData.labels[0].length, "\"/>");
              optsChartData.labels[0].forEach(function (label, idx) {
                  strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(encodeXmlEntities(label), "</c:v></c:pt>");
              });
              strXml += '    </c:strCache>';
              strXml += '  </c:strRef>';
              strXml += '</c:cat>';
              // 3: Create vals
              strXml += '  <c:val>';
              strXml += '    <c:numRef>';
              strXml += "      <c:f>Sheet1!$B$2:$B$".concat(optsChartData.labels[0].length + 1, "</c:f>");
              strXml += '      <c:numCache>';
              strXml += "           <c:ptCount val=\"".concat(optsChartData.labels[0].length, "\"/>");
              optsChartData.values.forEach(function (value, idx) {
                  strXml += "<c:pt idx=\"".concat(idx, "\"><c:v>").concat(value || value === 0 ? value : '', "</c:v></c:pt>");
              });
              strXml += '      </c:numCache>';
              strXml += '    </c:numRef>';
              strXml += '  </c:val>';
              // 4: Close "SERIES"
              strXml += '  </c:ser>';
              strXml += "  <c:firstSliceAng val=\"".concat(opts.firstSliceAng ? Math.round(opts.firstSliceAng) : 0, "\"/>");
              if (chartType === CHART_TYPE.DOUGHNUT)
                  strXml += "<c:holeSize val=\"".concat(typeof opts.holeSize === 'number' ? opts.holeSize : '50', "\"/>");
              strXml += '</c:' + chartType + 'Chart>';
              // Done with Doughnut/Pie
              break;
          default:
              strXml += '';
              break;
      }
      return strXml;
  }
  /**
   * Create Category axis
   * @param {IChartOptsLib} opts - chart options
   * @param {string} axisId - value
   * @param {string} valAxisId - value
   * @return {string} XML
   */
  function makeCatAxis(opts, axisId, valAxisId) {
      var strXml = '';
      // Build cat axis tag
      // NOTE: Scatter and Bubble chart need two Val axises as they display numbers on x axis
      if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
          strXml += '<c:valAx>';
      }
      else {
          strXml += '<c:' + (opts.catLabelFormatCode ? 'dateAx' : 'catAx') + '>';
      }
      strXml += '  <c:axId val="' + axisId + '"/>';
      strXml += '  <c:scaling>';
      strXml += '<c:orientation val="' + (opts.catAxisOrientation || (opts.barDir === 'col' ? 'minMax' : 'minMax')) + '"/>';
      if (opts.catAxisMaxVal || opts.catAxisMaxVal === 0)
          strXml += "<c:max val=\"".concat(opts.catAxisMaxVal, "\"/>");
      if (opts.catAxisMinVal || opts.catAxisMinVal === 0)
          strXml += "<c:min val=\"".concat(opts.catAxisMinVal, "\"/>");
      strXml += '</c:scaling>';
      strXml += '  <c:delete val="' + (opts.catAxisHidden ? '1' : '0') + '"/>';
      strXml += '  <c:axPos val="' + (opts.barDir === 'col' ? 'b' : 'l') + '"/>';
      strXml += opts.catGridLine.style !== 'none' ? createGridLineElement(opts.catGridLine) : '';
      // '<c:title>' comes between '</c:majorGridlines>' and '<c:numFmt>'
      if (opts.showCatAxisTitle) {
          strXml += genXmlTitle({
              color: opts.catAxisTitleColor,
              fontFace: opts.catAxisTitleFontFace,
              fontSize: opts.catAxisTitleFontSize,
              titleRotate: opts.catAxisTitleRotate,
              title: opts.catAxisTitle || 'Axis Title',
          });
      }
      // NOTE: Adding Val Axis Formatting if scatter or bubble charts
      if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
          strXml += '  <c:numFmt formatCode="' + (opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : 'General') + '" sourceLinked="1"/>';
      }
      else {
          strXml += '  <c:numFmt formatCode="' + (encodeXmlEntities(opts.catLabelFormatCode) || 'General') + '" sourceLinked="1"/>';
      }
      if (opts._type === CHART_TYPE.SCATTER) {
          strXml += '  <c:majorTickMark val="none"/>';
          strXml += '  <c:minorTickMark val="none"/>';
          strXml += '  <c:tickLblPos val="nextTo"/>';
      }
      else {
          strXml += '  <c:majorTickMark val="' + (opts.catAxisMajorTickMark || 'out') + '"/>';
          strXml += '  <c:minorTickMark val="' + (opts.catAxisMinorTickMark || 'none') + '"/>';
          strXml += '  <c:tickLblPos val="' + (opts.catAxisLabelPos || (opts.barDir === 'col' ? 'low' : 'nextTo')) + '"/>';
      }
      strXml += '  <c:spPr>';
      strXml += "    <a:ln w=\"".concat(opts.catAxisLineSize ? valToPts(opts.catAxisLineSize) : ONEPT, "\" cap=\"flat\">");
      strXml += !opts.catAxisLineShow ? '<a:noFill/>' : '<a:solidFill>' + createColorElement(opts.catAxisLineColor || DEF_CHART_GRIDLINE.color) + '</a:solidFill>';
      strXml += '      <a:prstDash val="' + (opts.catAxisLineStyle || 'solid') + '"/>';
      strXml += '      <a:round/>';
      strXml += '    </a:ln>';
      strXml += '  </c:spPr>';
      strXml += '  <c:txPr>';
      if (opts.catAxisLabelRotate) {
          strXml += "<a:bodyPr rot=\"".concat(convertRotationDegrees(opts.catAxisLabelRotate), "\"/>");
      }
      else {
          // NOTE: don't specify "`rot=0" - that way the object will be auto behavior
          strXml += '<a:bodyPr/>';
      }
      strXml += '    <a:lstStyle/>';
      strXml += '    <a:p>';
      strXml += '    <a:pPr>';
      strXml += "      <a:defRPr sz=\"".concat(Math.round((opts.catAxisLabelFontSize || DEF_FONT_SIZE) * 100), "\" b=\"").concat(opts.catAxisLabelFontBold ? 1 : 0, "\" i=\"").concat(opts.catAxisLabelFontItalic ? 1 : 0, "\" u=\"none\" strike=\"noStrike\">");
      strXml += '      <a:solidFill>' + createColorElement(opts.catAxisLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';
      strXml += '      <a:latin typeface="' + (opts.catAxisLabelFontFace || 'Arial') + '"/>';
      strXml += '   </a:defRPr>';
      strXml += '  </a:pPr>';
      strXml += '  <a:endParaRPr lang="' + (opts.lang || 'en-US') + '"/>';
      strXml += '  </a:p>';
      strXml += ' </c:txPr>';
      strXml += ' <c:crossAx val="' + valAxisId + '"/>';
      strXml += " <c:".concat(typeof opts.valAxisCrossesAt === 'number' ? 'crossesAt' : 'crosses', " val=\"").concat(opts.valAxisCrossesAt || 'autoZero', "\"/>");
      strXml += ' <c:auto val="1"/>';
      strXml += ' <c:lblAlgn val="ctr"/>';
      strXml += " <c:noMultiLvlLbl val=\"".concat(opts.catAxisMultiLevelLabels ? 0 : 1, "\"/>");
      if (opts.catAxisLabelFrequency)
          strXml += ' <c:tickLblSkip val="' + opts.catAxisLabelFrequency + '"/>';
      // Issue#149: PPT will auto-adjust these as needed after calcing the date bounds, so we only include them when specified by user
      // Allow major and minor units to be set for double value axis charts
      if (opts.catLabelFormatCode || opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
          if (opts.catLabelFormatCode) {
              ['catAxisBaseTimeUnit', 'catAxisMajorTimeUnit', 'catAxisMinorTimeUnit'].forEach(function (opt) {
                  // Validate input as poorly chosen/garbage options will cause chart corruption and it wont render at all!
                  if (opts[opt] && (typeof opts[opt] !== 'string' || !['days', 'months', 'years'].includes(opts[opt].toLowerCase()))) {
                      console.warn("\"".concat(opt, "\" must be one of: 'days','months','years' !"));
                      opts[opt] = null;
                  }
              });
              if (opts.catAxisBaseTimeUnit)
                  strXml += '<c:baseTimeUnit val="' + opts.catAxisBaseTimeUnit.toLowerCase() + '"/>';
              if (opts.catAxisMajorTimeUnit)
                  strXml += '<c:majorTimeUnit val="' + opts.catAxisMajorTimeUnit.toLowerCase() + '"/>';
              if (opts.catAxisMinorTimeUnit)
                  strXml += '<c:minorTimeUnit val="' + opts.catAxisMinorTimeUnit.toLowerCase() + '"/>';
          }
          if (opts.catAxisMajorUnit)
              strXml += "<c:majorUnit val=\"".concat(opts.catAxisMajorUnit, "\"/>");
          if (opts.catAxisMinorUnit)
              strXml += "<c:minorUnit val=\"".concat(opts.catAxisMinorUnit, "\"/>");
      }
      // Close cat axis tag
      // NOTE: Added closing tag of val or cat axis based on chart type
      if (opts._type === CHART_TYPE.SCATTER || opts._type === CHART_TYPE.BUBBLE || opts._type === CHART_TYPE.BUBBLE3D) {
          strXml += '</c:valAx>';
      }
      else {
          strXml += '</c:' + (opts.catLabelFormatCode ? 'dateAx' : 'catAx') + '>';
      }
      return strXml;
  }
  /**
   * Create Value Axis (Used by `bar3D`)
   * @param {IChartOptsLib} opts - chart options
   * @param {string} valAxisId - value
   * @return {string} XML
   */
  function makeValAxis(opts, valAxisId) {
      var axisPos = valAxisId === AXIS_ID_VALUE_PRIMARY ? (opts.barDir === 'col' ? 'l' : 'b') : opts.barDir !== 'col' ? 'r' : 't';
      if (valAxisId === AXIS_ID_VALUE_SECONDARY)
          axisPos = 'r'; // default behavior for PPT is showing 2nd val axis on right (primary axis on left)
      var crossAxId = valAxisId === AXIS_ID_VALUE_PRIMARY ? AXIS_ID_CATEGORY_PRIMARY : AXIS_ID_CATEGORY_SECONDARY;
      var strXml = '';
      strXml += '<c:valAx>';
      strXml += '  <c:axId val="' + valAxisId + '"/>';
      strXml += '  <c:scaling>';
      if (opts.valAxisLogScaleBase)
          strXml += "<c:logBase val=\"".concat(opts.valAxisLogScaleBase, "\"/>");
      strXml += '<c:orientation val="' + (opts.valAxisOrientation || (opts.barDir === 'col' ? 'minMax' : 'minMax')) + '"/>';
      if (opts.valAxisMaxVal || opts.valAxisMaxVal === 0)
          strXml += "<c:max val=\"".concat(opts.valAxisMaxVal, "\"/>");
      if (opts.valAxisMinVal || opts.valAxisMinVal === 0)
          strXml += "<c:min val=\"".concat(opts.valAxisMinVal, "\"/>");
      strXml += '  </c:scaling>';
      strXml += "  <c:delete val=\"".concat(opts.valAxisHidden ? 1 : 0, "\"/>");
      strXml += '  <c:axPos val="' + axisPos + '"/>';
      if (opts.valGridLine.style !== 'none')
          strXml += createGridLineElement(opts.valGridLine);
      // '<c:title>' comes between '</c:majorGridlines>' and '<c:numFmt>'
      if (opts.showValAxisTitle) {
          strXml += genXmlTitle({
              color: opts.valAxisTitleColor,
              fontFace: opts.valAxisTitleFontFace,
              fontSize: opts.valAxisTitleFontSize,
              titleRotate: opts.valAxisTitleRotate,
              title: opts.valAxisTitle || 'Axis Title',
          });
      }
      strXml += "<c:numFmt formatCode=\"".concat(opts.valAxisLabelFormatCode ? encodeXmlEntities(opts.valAxisLabelFormatCode) : 'General', "\" sourceLinked=\"0\"/>");
      if (opts._type === CHART_TYPE.SCATTER) {
          strXml += '  <c:majorTickMark val="none"/>';
          strXml += '  <c:minorTickMark val="none"/>';
          strXml += '  <c:tickLblPos val="nextTo"/>';
      }
      else {
          strXml += ' <c:majorTickMark val="' + (opts.valAxisMajorTickMark || 'out') + '"/>';
          strXml += ' <c:minorTickMark val="' + (opts.valAxisMinorTickMark || 'none') + '"/>';
          strXml += ' <c:tickLblPos val="' + (opts.valAxisLabelPos || (opts.barDir === 'col' ? 'nextTo' : 'low')) + '"/>';
      }
      strXml += ' <c:spPr>';
      strXml += "   <a:ln w=\"".concat(opts.valAxisLineSize ? valToPts(opts.valAxisLineSize) : ONEPT, "\" cap=\"flat\">");
      strXml += !opts.valAxisLineShow ? '<a:noFill/>' : '<a:solidFill>' + createColorElement(opts.valAxisLineColor || DEF_CHART_GRIDLINE.color) + '</a:solidFill>';
      strXml += '     <a:prstDash val="' + (opts.valAxisLineStyle || 'solid') + '"/>';
      strXml += '     <a:round/>';
      strXml += '   </a:ln>';
      strXml += ' </c:spPr>';
      strXml += ' <c:txPr>';
      strXml += "  <a:bodyPr".concat(opts.valAxisLabelRotate ? (' rot="' + convertRotationDegrees(opts.valAxisLabelRotate).toString() + '"') : '', "/>"); // don't specify rot 0 so we get the auto behavior
      strXml += '  <a:lstStyle/>';
      strXml += '  <a:p>';
      strXml += '    <a:pPr>';
      strXml += "      <a:defRPr sz=\"".concat(Math.round((opts.valAxisLabelFontSize || DEF_FONT_SIZE) * 100), "\" b=\"").concat(opts.valAxisLabelFontBold ? 1 : 0, "\" i=\"").concat(opts.valAxisLabelFontItalic ? 1 : 0, "\" u=\"none\" strike=\"noStrike\">");
      strXml += '        <a:solidFill>' + createColorElement(opts.valAxisLabelColor || DEF_FONT_COLOR) + '</a:solidFill>';
      strXml += '        <a:latin typeface="' + (opts.valAxisLabelFontFace || 'Arial') + '"/>';
      strXml += '      </a:defRPr>';
      strXml += '    </a:pPr>';
      strXml += '  <a:endParaRPr lang="' + (opts.lang || 'en-US') + '"/>';
      strXml += '  </a:p>';
      strXml += ' </c:txPr>';
      strXml += ' <c:crossAx val="' + crossAxId + '"/>';
      if (typeof opts.catAxisCrossesAt === 'number') {
          strXml += " <c:crossesAt val=\"".concat(opts.catAxisCrossesAt, "\"/>");
      }
      else if (typeof opts.catAxisCrossesAt === 'string') {
          strXml += ' <c:crosses val="' + opts.catAxisCrossesAt + '"/>';
      }
      else {
          var isRight = axisPos === 'r' || axisPos === 't';
          var crosses = isRight ? 'max' : 'autoZero';
          strXml += ' <c:crosses val="' + crosses + '"/>';
      }
      strXml +=
          ' <c:crossBetween val="' +
              (opts._type === CHART_TYPE.SCATTER || (!!(Array.isArray(opts._type) && opts._type.filter(function (type) { return type.type === CHART_TYPE.AREA; }).length > 0)) ? 'midCat' : 'between') +
              '"/>';
      if (opts.valAxisMajorUnit)
          strXml += " <c:majorUnit val=\"".concat(opts.valAxisMajorUnit, "\"/>");
      if (opts.valAxisDisplayUnit) {
          strXml += "<c:dispUnits><c:builtInUnit val=\"".concat(opts.valAxisDisplayUnit, "\"/>").concat(opts.valAxisDisplayUnitLabel ? '<c:dispUnitsLbl/>' : '', "</c:dispUnits>");
      }
      strXml += '</c:valAx>';
      return strXml;
  }
  /**
   * Create Series Axis (Used by `bar3D`)
   * @param {IChartOptsLib} opts - chart options
   * @param {string} axisId - axis ID
   * @param {string} valAxisId - value
   * @return {string} XML
   */
  function makeSerAxis(opts, axisId, valAxisId) {
      var strXml = '';
      // Build ser axis tag
      strXml += '<c:serAx>';
      strXml += '  <c:axId val="' + axisId + '"/>';
      strXml += '  <c:scaling><c:orientation val="' + (opts.serAxisOrientation || (opts.barDir === 'col' ? 'minMax' : 'minMax')) + '"/></c:scaling>';
      strXml += '  <c:delete val="' + (opts.serAxisHidden ? '1' : '0') + '"/>';
      strXml += '  <c:axPos val="' + (opts.barDir === 'col' ? 'b' : 'l') + '"/>';
      strXml += opts.serGridLine.style !== 'none' ? createGridLineElement(opts.serGridLine) : '';
      // '<c:title>' comes between '</c:majorGridlines>' and '<c:numFmt>'
      if (opts.showSerAxisTitle) {
          strXml += genXmlTitle({
              color: opts.serAxisTitleColor,
              fontFace: opts.serAxisTitleFontFace,
              fontSize: opts.serAxisTitleFontSize,
              titleRotate: opts.serAxisTitleRotate,
              title: opts.serAxisTitle || 'Axis Title',
          });
      }
      strXml += "  <c:numFmt formatCode=\"".concat(encodeXmlEntities(opts.serLabelFormatCode) || 'General', "\" sourceLinked=\"0\"/>");
      strXml += '  <c:majorTickMark val="out"/>';
      strXml += '  <c:minorTickMark val="none"/>';
      strXml += "  <c:tickLblPos val=\"".concat(opts.serAxisLabelPos || opts.barDir === 'col' ? 'low' : 'nextTo', "\"/>");
      strXml += '  <c:spPr>';
      strXml += '    <a:ln w="12700" cap="flat">';
      strXml += !opts.serAxisLineShow ? '<a:noFill/>' : "<a:solidFill>".concat(createColorElement(opts.serAxisLineColor || DEF_CHART_GRIDLINE.color), "</a:solidFill>");
      strXml += '      <a:prstDash val="solid"/>';
      strXml += '      <a:round/>';
      strXml += '    </a:ln>';
      strXml += '  </c:spPr>';
      strXml += '  <c:txPr>';
      strXml += '    <a:bodyPr/>'; // don't specify rot 0 so we get the auto behavior
      strXml += '    <a:lstStyle/>';
      strXml += '    <a:p>';
      strXml += '    <a:pPr>';
      strXml += "    <a:defRPr sz=\"".concat(Math.round((opts.serAxisLabelFontSize || DEF_FONT_SIZE) * 100), "\" b=\"").concat(opts.serAxisLabelFontBold ? '1' : '0', "\" i=\"").concat(opts.serAxisLabelFontItalic ? '1' : '0', "\" u=\"none\" strike=\"noStrike\">");
      strXml += "      <a:solidFill>".concat(createColorElement(opts.serAxisLabelColor || DEF_FONT_COLOR), "</a:solidFill>");
      strXml += "      <a:latin typeface=\"".concat(opts.serAxisLabelFontFace || 'Arial', "\"/>");
      strXml += '   </a:defRPr>';
      strXml += '  </a:pPr>';
      strXml += '  <a:endParaRPr lang="' + (opts.lang || 'en-US') + '"/>';
      strXml += '  </a:p>';
      strXml += ' </c:txPr>';
      strXml += ' <c:crossAx val="' + valAxisId + '"/>';
      strXml += ' <c:crosses val="autoZero"/>';
      if (opts.serAxisLabelFrequency)
          strXml += ' <c:tickLblSkip val="' + opts.serAxisLabelFrequency + '"/>';
      // Issue#149: PPT will auto-adjust these as needed after calcing the date bounds, so we only include them when specified by user
      if (opts.serLabelFormatCode) {
          ['serAxisBaseTimeUnit', 'serAxisMajorTimeUnit', 'serAxisMinorTimeUnit'].forEach(function (opt) {
              // Validate input as poorly chosen/garbage options will cause chart corruption and it wont render at all!
              if (opts[opt] && (typeof opts[opt] !== 'string' || !['days', 'months', 'years'].includes(opt.toLowerCase()))) {
                  console.warn("\"".concat(opt, "\" must be one of: 'days','months','years' !"));
                  opts[opt] = null;
              }
          });
          if (opts.serAxisBaseTimeUnit)
              strXml += " <c:baseTimeUnit  val=\"".concat(opts.serAxisBaseTimeUnit.toLowerCase(), "\"/>");
          if (opts.serAxisMajorTimeUnit)
              strXml += " <c:majorTimeUnit val=\"".concat(opts.serAxisMajorTimeUnit.toLowerCase(), "\"/>");
          if (opts.serAxisMinorTimeUnit)
              strXml += " <c:minorTimeUnit val=\"".concat(opts.serAxisMinorTimeUnit.toLowerCase(), "\"/>");
          if (opts.serAxisMajorUnit)
              strXml += " <c:majorUnit val=\"".concat(opts.serAxisMajorUnit, "\"/>");
          if (opts.serAxisMinorUnit)
              strXml += " <c:minorUnit val=\"".concat(opts.serAxisMinorUnit, "\"/>");
      }
      // Close ser axis tag
      strXml += '</c:serAx>';
      return strXml;
  }
  /**
   * Create char title elements
   * @param {IChartPropsTitle} opts - options
   * @return {string} XML `<c:title>`
   */
  function genXmlTitle(opts, chartX, chartY) {
      var align = opts.titleAlign === 'left' || opts.titleAlign === 'right' ? "<a:pPr algn=\"".concat(opts.titleAlign.substring(0, 1), "\">") : '<a:pPr>';
      var rotate = opts.titleRotate ? "<a:bodyPr rot=\"".concat(convertRotationDegrees(opts.titleRotate), "\"/>") : '<a:bodyPr/>'; // don't specify rotation to get default (ex. vertical for cat axis)
      var sizeAttr = opts.fontSize ? "sz=\"".concat(Math.round(opts.fontSize * 100), "\"") : ''; // only set the font size if specified.  Powerpoint will handle the default size
      var titleBold = opts.titleBold ? 1 : 0;
      var layout = '<c:layout/>';
      if (opts.titlePos && typeof opts.titlePos.x === 'number' && typeof opts.titlePos.y === 'number') {
          // NOTE: manualLayout x/y vals are *relative to entire slide*
          var totalX = opts.titlePos.x + chartX;
          var totalY = opts.titlePos.y + chartY;
          var valX = totalX === 0 ? 0 : (totalX * (totalX / 5)) / 10;
          if (valX >= 1)
              valX = valX / 10;
          if (valX >= 0.1)
              valX = valX / 10;
          var valY = totalY === 0 ? 0 : (totalY * (totalY / 5)) / 10;
          if (valY >= 1)
              valY = valY / 10;
          if (valY >= 0.1)
              valY = valY / 10;
          layout = "<c:layout><c:manualLayout><c:xMode val=\"edge\"/><c:yMode val=\"edge\"/><c:x val=\"".concat(valX, "\"/><c:y val=\"").concat(valY, "\"/></c:manualLayout></c:layout>");
      }
      return "<c:title>\n      <c:tx>\n        <c:rich>\n          ".concat(rotate, "\n          <a:lstStyle/>\n          <a:p>\n            ").concat(align, "\n            <a:defRPr ").concat(sizeAttr, " b=\"").concat(titleBold, "\" i=\"0\" u=\"none\" strike=\"noStrike\">\n              <a:solidFill>").concat(createColorElement(opts.color || DEF_FONT_COLOR), "</a:solidFill>\n              <a:latin typeface=\"").concat(opts.fontFace || 'Arial', "\"/>\n            </a:defRPr>\n          </a:pPr>\n          <a:r>\n            <a:rPr ").concat(sizeAttr, " b=\"").concat(titleBold, "\" i=\"0\" u=\"none\" strike=\"noStrike\">\n              <a:solidFill>").concat(createColorElement(opts.color || DEF_FONT_COLOR), "</a:solidFill>\n              <a:latin typeface=\"").concat(opts.fontFace || 'Arial', "\"/>\n            </a:rPr>\n            <a:t>").concat(encodeXmlEntities(opts.title) || '', "</a:t>\n          </a:r>\n        </a:p>\n        </c:rich>\n      </c:tx>\n      ").concat(layout, "\n      <c:overlay val=\"0\"/>\n    </c:title>");
  }
  /**
   * Calc and return excel column name for a given column length
   * @param colIndex column index
   * @return column name
   * @example 1 returns 'A'
   * @example 27 returns 'AA'
   */
  function getExcelColName(colIndex) {
      var colStr = '';
      var colIdx = colIndex - 1; // Subtract 1 so `LETTERS[columnIndex]` returns "A" etc
      if (colIdx <= 25) {
          // A-Z
          colStr = LETTERS[colIdx];
      }
      else {
          // AA-ZZ (ZZ = index 702)
          colStr = "".concat(LETTERS[Math.floor(colIdx / LETTERS.length - 1)]).concat(LETTERS[colIdx % LETTERS.length]);
      }
      return colStr;
  }
  /**
   * Creates `a:innerShdw` or `a:outerShdw` depending on pass options `opts`.
   * @param {Object} opts optional shadow properties
   * @param {Object} defaults defaults for unspecified properties in `opts`
   * @see http://officeopenxml.com/drwSp-effects.php
   * @example { type: 'outer', blur: 3, offset: (23000 / 12700), angle: 90, color: '000000', opacity: 0.35, rotateWithShape: true };
   * @return {string} XML
   */
  function createShadowElement(options, defaults) {
      if (!options) {
          return '<a:effectLst/>';
      }
      else if (typeof options !== 'object') {
          console.warn('`shadow` options must be an object. Ex: `{shadow: {type:\'none\'}}`');
          return '<a:effectLst/>';
      }
      var strXml = '<a:effectLst>';
      var opts = __assign(__assign({}, defaults), options);
      var type = opts.type || 'outer';
      var blur = valToPts(opts.blur);
      var offset = valToPts(opts.offset);
      var angle = Math.round(opts.angle * 60000);
      var color = opts.color;
      var opacity = Math.round(opts.opacity * 100000);
      var rotShape = opts.rotateWithShape ? 1 : 0;
      strXml += "<a:".concat(type, "Shdw sx=\"100000\" sy=\"100000\" kx=\"0\" ky=\"0\"  algn=\"bl\" blurRad=\"").concat(blur, "\" rotWithShape=\"").concat(rotShape, "\" dist=\"").concat(offset, "\" dir=\"").concat(angle, "\">");
      strXml += "<a:srgbClr val=\"".concat(color, "\">");
      strXml += "<a:alpha val=\"".concat(opacity, "\"/></a:srgbClr>");
      strXml += "</a:".concat(type, "Shdw>");
      strXml += '</a:effectLst>';
      return strXml;
  }
  /**
   * Create Grid Line Element
   * @param {OptsChartGridLine} glOpts {size, color, style}
   * @return {string} XML
   */
  function createGridLineElement(glOpts) {
      var strXml = '<c:majorGridlines>';
      strXml += ' <c:spPr>';
      strXml += "  <a:ln w=\"".concat(valToPts(glOpts.size || DEF_CHART_GRIDLINE.size), "\" cap=\"").concat(createLineCap(glOpts.cap || DEF_CHART_GRIDLINE.cap), "\">");
      strXml += '  <a:solidFill><a:srgbClr val="' + (glOpts.color || DEF_CHART_GRIDLINE.color) + '"/></a:solidFill>'; // should accept scheme colors as implemented in [Pull #135]
      strXml += '   <a:prstDash val="' + (glOpts.style || DEF_CHART_GRIDLINE.style) + '"/><a:round/>';
      strXml += '  </a:ln>';
      strXml += ' </c:spPr>';
      strXml += '</c:majorGridlines>';
      return strXml;
  }
  function createLineCap(lineCap) {
      if (!lineCap || lineCap === 'flat') {
          return 'flat';
      }
      else if (lineCap === 'square') {
          return 'sq';
      }
      else if (lineCap === 'round') {
          return 'rnd';
      }
      else {
          var neverLineCap = lineCap;
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          throw new Error("Invalid chart line cap: ".concat(neverLineCap));
      }
  }

  /**
   * PptxGenJS: Media Methods
   */
  /**
   * Encode Image/Audio/Video into base64
   * @param {PresSlide | SlideLayout} layout - slide layout
   * @return {Promise} promise
   */
  function encodeSlideMediaRels(layout) {
      var fs = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined' ? require$$0 : null; // NodeJS
      var https = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined' ? require$$1 : null; // NodeJS
      var imageProms = [];
      // A: Capture all audio/image/video candidates for encoding (filtering online/pre-encoded)
      var candidateRels = layout._relsMedia.filter(function (rel) { return rel.type !== 'online' && !rel.data && (!rel.path || (rel.path && !rel.path.includes('preencoded'))); });
      // B: PERF: Mark dupes (same `path`) so that we dont load same media over-and-over
      var unqPaths = [];
      candidateRels.forEach(function (rel) {
          if (!unqPaths.includes(rel.path)) {
              rel.isDuplicate = false;
              unqPaths.push(rel.path);
          }
          else {
              rel.isDuplicate = true;
          }
      });
      // C: Read/Encode each unique audio/image/video path
      candidateRels
          .filter(function (rel) { return !rel.isDuplicate; })
          .forEach(function (rel) {
          imageProms.push(new Promise(function (resolve, reject) {
              if (fs && rel.path.indexOf('http') !== 0) {
                  // DESIGN: Node local-file encoding is syncronous, so we can load all images here, then call export with a callback (if any)
                  try {
                      var bitmap = fs.readFileSync(rel.path);
                      rel.data = Buffer.from(bitmap).toString('base64');
                      candidateRels.filter(function (dupe) { return dupe.isDuplicate && dupe.path === rel.path; }).forEach(function (dupe) { return (dupe.data = rel.data); });
                      resolve('done');
                  }
                  catch (ex) {
                      rel.data = IMG_BROKEN;
                      candidateRels.filter(function (dupe) { return dupe.isDuplicate && dupe.path === rel.path; }).forEach(function (dupe) { return (dupe.data = rel.data); });
                      reject(new Error("ERROR: Unable to read media: \"".concat(rel.path, "\"\n").concat(String(ex))));
                  }
              }
              else if (fs && https && rel.path.indexOf('http') === 0) {
                  https.get(rel.path, function (res) {
                      var rawData = '';
                      res.setEncoding('binary'); // IMPORTANT: Only binary encoding works
                      res.on('data', function (chunk) { return (rawData += chunk); });
                      res.on('end', function () {
                          rel.data = Buffer.from(rawData, 'binary').toString('base64');
                          candidateRels.filter(function (dupe) { return dupe.isDuplicate && dupe.path === rel.path; }).forEach(function (dupe) { return (dupe.data = rel.data); });
                          resolve('done');
                      });
                      res.on('error', function (_ex) {
                          rel.data = IMG_BROKEN;
                          candidateRels.filter(function (dupe) { return dupe.isDuplicate && dupe.path === rel.path; }).forEach(function (dupe) { return (dupe.data = rel.data); });
                          reject(new Error("ERROR! Unable to load image (https.get): ".concat(rel.path)));
                      });
                  });
              }
              else {
                  // A: Declare XHR and onload/onerror handlers
                  // DESIGN: `XMLHttpRequest()` plus `FileReader()` = Ablity to read any file into base64!
                  var xhr_1 = new XMLHttpRequest();
                  xhr_1.onload = function () {
                      var reader = new FileReader();
                      reader.onloadend = function () {
                          rel.data = reader.result;
                          candidateRels.filter(function (dupe) { return dupe.isDuplicate && dupe.path === rel.path; }).forEach(function (dupe) { return (dupe.data = rel.data); });
                          if (!rel.isSvgPng) {
                              resolve('done');
                          }
                          else {
                              createSvgPngPreview(rel)
                                  .then(function () {
                                  resolve('done');
                              })
                                  .catch(function (ex) {
                                  reject(ex);
                              });
                          }
                      };
                      reader.readAsDataURL(xhr_1.response);
                  };
                  xhr_1.onerror = function (ex) {
                      rel.data = IMG_BROKEN;
                      candidateRels.filter(function (dupe) { return dupe.isDuplicate && dupe.path === rel.path; }).forEach(function (dupe) { return (dupe.data = rel.data); });
                      reject(new Error("ERROR! Unable to load image (xhr.onerror): ".concat(rel.path)));
                  };
                  // B: Execute request
                  xhr_1.open('GET', rel.path);
                  xhr_1.responseType = 'blob';
                  xhr_1.send();
              }
          }));
      });
      // B: SVG: base64 data still requires a png to be generated (`isSvgPng` flag this as the preview image, not the SVG itself)
      layout._relsMedia
          .filter(function (rel) { return rel.isSvgPng && rel.data; })
          .forEach(function (rel) {
          if (fs) {
              // console.log('Sorry, SVG is not supported in Node (more info: https://github.com/gitbrent/PptxGenJS/issues/401)')
              rel.data = IMG_BROKEN;
              imageProms.push(Promise.resolve().then(function () { return 'done'; }));
          }
          else {
              imageProms.push(createSvgPngPreview(rel));
          }
      });
      return imageProms;
  }
  /**
   * Create SVG preview image
   * @param {ISlideRelMedia} rel - slide rel
   * @return {Promise} promise
   */
  function createSvgPngPreview(rel) {
      return __awaiter(this, void 0, void 0, function () {
          return __generator(this, function (_a) {
              switch (_a.label) {
                  case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                          // A: Create
                          var image = new Image();
                          // B: Set onload event
                          image.onload = function () {
                              // First: Check for any errors: This is the best method (try/catch wont work, etc.)
                              if (image.width + image.height === 0) {
                                  image.onerror('h/w=0');
                              }
                              var canvas = document.createElement('CANVAS');
                              var ctx = canvas.getContext('2d');
                              canvas.width = image.width;
                              canvas.height = image.height;
                              ctx.drawImage(image, 0, 0);
                              // Users running on local machine will get the following error:
                              // "SecurityError: Failed to execute 'toDataURL' on 'HTMLCanvasElement': Tainted canvases may not be exported."
                              // when the canvas.toDataURL call executes below.
                              try {
                                  rel.data = canvas.toDataURL(rel.type);
                                  resolve('done');
                              }
                              catch (ex) {
                                  image.onerror(ex);
                              }
                              canvas = null;
                          };
                          image.onerror = function (ex) {
                              rel.data = IMG_BROKEN;
                              reject(new Error("ERROR! Unable to load image (image.onerror): ".concat(rel.path)));
                          };
                          // C: Load image
                          image.src = typeof rel.data === 'string' ? rel.data : IMG_BROKEN;
                      })];
                  case 1: return [2 /*return*/, _a.sent()];
              }
          });
      });
  }

  /**
   * PptxGenJS: XML Generation
   */
  var ImageSizingXml = {
      cover: function (imgSize, boxDim) {
          var imgRatio = imgSize.h / imgSize.w;
          var boxRatio = boxDim.h / boxDim.w;
          var isBoxBased = boxRatio > imgRatio;
          var width = isBoxBased ? boxDim.h / imgRatio : boxDim.w;
          var height = isBoxBased ? boxDim.h : boxDim.w * imgRatio;
          var hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
          var vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
          return "<a:srcRect l=\"".concat(hzPerc, "\" r=\"").concat(hzPerc, "\" t=\"").concat(vzPerc, "\" b=\"").concat(vzPerc, "\"/><a:stretch/>");
      },
      contain: function (imgSize, boxDim) {
          var imgRatio = imgSize.h / imgSize.w;
          var boxRatio = boxDim.h / boxDim.w;
          var widthBased = boxRatio > imgRatio;
          var width = widthBased ? boxDim.w : boxDim.h / imgRatio;
          var height = widthBased ? boxDim.w * imgRatio : boxDim.h;
          var hzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.w / width));
          var vzPerc = Math.round(1e5 * 0.5 * (1 - boxDim.h / height));
          return "<a:srcRect l=\"".concat(hzPerc, "\" r=\"").concat(hzPerc, "\" t=\"").concat(vzPerc, "\" b=\"").concat(vzPerc, "\"/><a:stretch/>");
      },
      crop: function (imgSize, boxDim) {
          var l = boxDim.x;
          var r = imgSize.w - (boxDim.x + boxDim.w);
          var t = boxDim.y;
          var b = imgSize.h - (boxDim.y + boxDim.h);
          var lPerc = Math.round(1e5 * (l / imgSize.w));
          var rPerc = Math.round(1e5 * (r / imgSize.w));
          var tPerc = Math.round(1e5 * (t / imgSize.h));
          var bPerc = Math.round(1e5 * (b / imgSize.h));
          return "<a:srcRect l=\"".concat(lPerc, "\" r=\"").concat(rPerc, "\" t=\"").concat(tPerc, "\" b=\"").concat(bPerc, "\"/><a:stretch/>");
      },
  };
  /**
   * Transforms a slide or slideLayout to resulting XML string - Creates `ppt/slide*.xml`
   * @param {PresSlide|SlideLayout} slideObject - slide object created within createSlideObject
   * @return {string} XML string with <p:cSld> as the root
   */
  function slideObjectToXml(slide) {
      var _a;
      var strSlideXml = slide._name ? '<p:cSld name="' + slide._name + '">' : '<p:cSld>';
      var intTableNum = 1;
      // STEP 1: Add background color/image (ensure only a single `<p:bg>` tag is created, ex: when master-baskground has both `color` and `path`)
      if (slide._bkgdImgRid) {
          strSlideXml += "<p:bg><p:bgPr><a:blipFill dpi=\"0\" rotWithShape=\"1\"><a:blip r:embed=\"rId".concat(slide._bkgdImgRid, "\"><a:lum/></a:blip><a:srcRect/><a:stretch><a:fillRect/></a:stretch></a:blipFill><a:effectLst/></p:bgPr></p:bg>");
      }
      else if ((_a = slide.background) === null || _a === void 0 ? void 0 : _a.color) {
          strSlideXml += "<p:bg><p:bgPr>".concat(genXmlColorSelection(slide.background), "</p:bgPr></p:bg>");
      }
      else if (!slide.bkgd && slide._name && slide._name === DEF_PRES_LAYOUT_NAME) {
          // NOTE: Default [white] background is needed on slideMaster1.xml to avoid gray background in Keynote (and Finder previews)
          strSlideXml += '<p:bg><p:bgRef idx="1001"><a:schemeClr val="bg1"/></p:bgRef></p:bg>';
      }
      // STEP 2: Continue slide by starting spTree node
      strSlideXml += '<p:spTree>';
      strSlideXml += '<p:nvGrpSpPr><p:cNvPr id="1" name=""/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr>';
      strSlideXml += '<p:grpSpPr><a:xfrm><a:off x="0" y="0"/><a:ext cx="0" cy="0"/>';
      strSlideXml += '<a:chOff x="0" y="0"/><a:chExt cx="0" cy="0"/></a:xfrm></p:grpSpPr>';
      // STEP 3: Loop over all Slide.data objects and add them to this slide
      slide._slideObjects.forEach(function (slideItemObj, idx) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          var x = 0;
          var y = 0;
          var cx = getSmartParseNumber('75%', 'X', slide._presLayout);
          var cy = 0;
          var placeholderObj;
          var locationAttr = '';
          var arrTabRows = null;
          var objTabOpts = null;
          var intColCnt = 0;
          var intColW = 0;
          var cellOpts = null;
          var strXml = null;
          var sizing = (_a = slideItemObj.options) === null || _a === void 0 ? void 0 : _a.sizing;
          var rounding = (_b = slideItemObj.options) === null || _b === void 0 ? void 0 : _b.rounding;
          if (slide._slideLayout !== undefined &&
              slide._slideLayout._slideObjects !== undefined &&
              slideItemObj.options &&
              slideItemObj.options.placeholder) {
              placeholderObj = slide._slideLayout._slideObjects.filter(function (object) { return object.options.placeholder === slideItemObj.options.placeholder; })[0];
          }
          // A: Set option vars
          slideItemObj.options = slideItemObj.options || {};
          if (typeof slideItemObj.options.x !== 'undefined')
              x = getSmartParseNumber(slideItemObj.options.x, 'X', slide._presLayout);
          if (typeof slideItemObj.options.y !== 'undefined')
              y = getSmartParseNumber(slideItemObj.options.y, 'Y', slide._presLayout);
          if (typeof slideItemObj.options.w !== 'undefined')
              cx = getSmartParseNumber(slideItemObj.options.w, 'X', slide._presLayout);
          if (typeof slideItemObj.options.h !== 'undefined')
              cy = getSmartParseNumber(slideItemObj.options.h, 'Y', slide._presLayout);
          // Set w/h now that smart parse is done
          var imgWidth = cx;
          var imgHeight = cy;
          // If using a placeholder then inherit it's position
          if (placeholderObj) {
              if (placeholderObj.options.x || placeholderObj.options.x === 0)
                  x = getSmartParseNumber(placeholderObj.options.x, 'X', slide._presLayout);
              if (placeholderObj.options.y || placeholderObj.options.y === 0)
                  y = getSmartParseNumber(placeholderObj.options.y, 'Y', slide._presLayout);
              if (placeholderObj.options.w || placeholderObj.options.w === 0)
                  cx = getSmartParseNumber(placeholderObj.options.w, 'X', slide._presLayout);
              if (placeholderObj.options.h || placeholderObj.options.h === 0)
                  cy = getSmartParseNumber(placeholderObj.options.h, 'Y', slide._presLayout);
          }
          //
          if (slideItemObj.options.flipH)
              locationAttr += ' flipH="1"';
          if (slideItemObj.options.flipV)
              locationAttr += ' flipV="1"';
          if (slideItemObj.options.rotate)
              locationAttr += " rot=\"".concat(convertRotationDegrees(slideItemObj.options.rotate), "\"");
          // B: Add OBJECT to the current Slide
          switch (slideItemObj._type) {
              case SLIDE_OBJECT_TYPES.table:
                  arrTabRows = slideItemObj.arrTabRows;
                  objTabOpts = slideItemObj.options;
                  intColCnt = 0;
                  intColW = 0;
                  // Calc number of columns
                  // NOTE: Cells may have a colspan, so merely taking the length of the [0] (or any other) row is not
                  // ....: sufficient to determine column count. Therefore, check each cell for a colspan and total cols as reqd
                  arrTabRows[0].forEach(function (cell) {
                      cellOpts = cell.options || null;
                      intColCnt += (cellOpts === null || cellOpts === void 0 ? void 0 : cellOpts.colspan) ? Number(cellOpts.colspan) : 1;
                  });
                  // STEP 1: Start Table XML
                  // NOTE: Non-numeric cNvPr id values will trigger "presentation needs repair" type warning in MS-PPT-2013
                  strXml = "<p:graphicFrame><p:nvGraphicFramePr><p:cNvPr id=\"".concat(intTableNum * slide._slideNum + 1, "\" name=\"").concat(slideItemObj.options.objectName, "\"/>");
                  strXml +=
                      '<p:cNvGraphicFramePr><a:graphicFrameLocks noGrp="1"/></p:cNvGraphicFramePr>' +
                          '  <p:nvPr><p:extLst><p:ext uri="{D42A27DB-BD31-4B8C-83A1-F6EECF244321}"><p14:modId xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main" val="1579011935"/></p:ext></p:extLst></p:nvPr>' +
                          '</p:nvGraphicFramePr>';
                  strXml += "<p:xfrm><a:off x=\"".concat(x || (x === 0 ? 0 : EMU), "\" y=\"").concat(y || (y === 0 ? 0 : EMU), "\"/><a:ext cx=\"").concat(cx || (cx === 0 ? 0 : EMU), "\" cy=\"").concat(cy || EMU, "\"/></p:xfrm>");
                  strXml += '<a:graphic><a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/table"><a:tbl><a:tblPr/>';
                  // + '        <a:tblPr bandRow="1"/>';
                  // TODO: Support banded rows, first/last row, etc.
                  // NOTE: Banding, etc. only shows when using a table style! (or set alt row color if banding)
                  // <a:tblPr firstCol="0" firstRow="0" lastCol="0" lastRow="0" bandCol="0" bandRow="1">
                  // STEP 2: Set column widths
                  // Evenly distribute cols/rows across size provided when applicable (calc them if only overall dimensions were provided)
                  // A: Col widths provided?
                  // B: Table Width provided without colW? Then distribute cols
                  if (Array.isArray(objTabOpts.colW)) {
                      strXml += '<a:tblGrid>';
                      for (var col = 0; col < intColCnt; col++) {
                          var w = inch2Emu(objTabOpts.colW[col]);
                          if (w == null || isNaN(w)) {
                              w = (typeof slideItemObj.options.w === 'number' ? slideItemObj.options.w : 1) / intColCnt;
                          }
                          strXml += "<a:gridCol w=\"".concat(Math.round(w), "\"/>");
                      }
                      strXml += '</a:tblGrid>';
                  }
                  else {
                      intColW = objTabOpts.colW ? objTabOpts.colW : EMU;
                      if (slideItemObj.options.w && !objTabOpts.colW)
                          intColW = Math.round((typeof slideItemObj.options.w === 'number' ? slideItemObj.options.w : 1) / intColCnt);
                      strXml += '<a:tblGrid>';
                      for (var colw = 0; colw < intColCnt; colw++) {
                          strXml += "<a:gridCol w=\"".concat(intColW, "\"/>");
                      }
                      strXml += '</a:tblGrid>';
                  }
                  // STEP 3: Build our row arrays into an actual grid to match the XML we will be building next (ISSUE #36)
                  // Note row arrays can arrive "lopsided" as in row1:[1,2,3] row2:[3] when first two cols rowspan!,
                  // so a simple loop below in XML building wont suffice to build table correctly.
                  // We have to build an actual grid now
                  /*
                      EX: (A0:rowspan=3, B1:rowspan=2, C1:colspan=2)

                      /------|------|------|------\
                      |  A0  |  B0  |  C0  |  D0  |
                      |      |  B1  |  C1  |      |
                      |      |      |  C2  |  D2  |
                      \------|------|------|------/
                  */
                  // A: add _hmerge cell for colspan. should reserve rowspan
                  arrTabRows.forEach(function (cells) {
                      var _a, _b;
                      var _loop_1 = function (cIdx) {
                          var cell = cells[cIdx];
                          var colspan = (_a = cell.options) === null || _a === void 0 ? void 0 : _a.colspan;
                          var rowspan = (_b = cell.options) === null || _b === void 0 ? void 0 : _b.rowspan;
                          if (colspan && colspan > 1) {
                              var vMergeCells = new Array(colspan - 1).fill(undefined).map(function (_) {
                                  return { _type: SLIDE_OBJECT_TYPES.tablecell, options: { rowspan: rowspan }, _hmerge: true };
                              });
                              cells.splice.apply(cells, __spreadArray([cIdx + 1, 0], vMergeCells, false));
                              cIdx += colspan;
                          }
                          else {
                              cIdx += 1;
                          }
                          out_cIdx_1 = cIdx;
                      };
                      var out_cIdx_1;
                      for (var cIdx = 0; cIdx < cells.length;) {
                          _loop_1(cIdx);
                          cIdx = out_cIdx_1;
                      }
                  });
                  // B: add _vmerge cell for rowspan. should reserve colspan/_hmerge
                  arrTabRows.forEach(function (cells, rIdx) {
                      var nextRow = arrTabRows[rIdx + 1];
                      if (!nextRow)
                          return;
                      cells.forEach(function (cell, cIdx) {
                          var _a, _b;
                          var rowspan = cell._rowContinue || ((_a = cell.options) === null || _a === void 0 ? void 0 : _a.rowspan);
                          var colspan = (_b = cell.options) === null || _b === void 0 ? void 0 : _b.colspan;
                          var _hmerge = cell._hmerge;
                          if (rowspan && rowspan > 1) {
                              var hMergeCell = { _type: SLIDE_OBJECT_TYPES.tablecell, options: { colspan: colspan }, _rowContinue: rowspan - 1, _vmerge: true, _hmerge: _hmerge };
                              nextRow.splice(cIdx, 0, hMergeCell);
                          }
                      });
                  });
                  // STEP 4: Build table rows/cells
                  arrTabRows.forEach(function (cells, rIdx) {
                      // A: Table Height provided without rowH? Then distribute rows
                      var intRowH = 0; // IMPORTANT: Default must be zero for auto-sizing to work
                      if (Array.isArray(objTabOpts.rowH) && objTabOpts.rowH[rIdx])
                          intRowH = inch2Emu(Number(objTabOpts.rowH[rIdx]));
                      else if (objTabOpts.rowH && !isNaN(Number(objTabOpts.rowH)))
                          intRowH = inch2Emu(Number(objTabOpts.rowH));
                      else if (slideItemObj.options.cy || slideItemObj.options.h) {
                          intRowH = Math.round((slideItemObj.options.h ? inch2Emu(slideItemObj.options.h) : typeof slideItemObj.options.cy === 'number' ? slideItemObj.options.cy : 1) /
                              arrTabRows.length);
                      }
                      // B: Start row
                      strXml += "<a:tr h=\"".concat(intRowH, "\">");
                      // C: Loop over each CELL
                      cells.forEach(function (cellObj) {
                          var _a, _b, _c, _d, _e;
                          var cell = cellObj;
                          var cellSpanAttrs = {
                              rowSpan: ((_a = cell.options) === null || _a === void 0 ? void 0 : _a.rowspan) > 1 ? cell.options.rowspan : undefined,
                              gridSpan: ((_b = cell.options) === null || _b === void 0 ? void 0 : _b.colspan) > 1 ? cell.options.colspan : undefined,
                              vMerge: cell._vmerge ? 1 : undefined,
                              hMerge: cell._hmerge ? 1 : undefined,
                          };
                          var cellSpanAttrStr = Object.keys(cellSpanAttrs)
                              .map(function (k) { return [k, cellSpanAttrs[k]]; })
                              .filter(function (_a) {
                              _a[0]; var v = _a[1];
                              return !!v;
                          })
                              .map(function (_a) {
                              var k = _a[0], v = _a[1];
                              return "".concat(String(k), "=\"").concat(String(v), "\"");
                          })
                              .join(' ');
                          if (cellSpanAttrStr)
                              cellSpanAttrStr = ' ' + cellSpanAttrStr;
                          // 1: COLSPAN/ROWSPAN: Add dummy cells for any active colspan/rowspan
                          if (cell._hmerge || cell._vmerge) {
                              strXml += "<a:tc".concat(cellSpanAttrStr, "><a:tcPr/></a:tc>");
                              return;
                          }
                          // 2: OPTIONS: Build/set cell options
                          var cellOpts = cell.options || {};
                          cell.options = cellOpts;
                          ['align', 'bold', 'border', 'color', 'fill', 'fontFace', 'fontSize', 'margin', 'underline', 'valign'].forEach(function (name) {
                              if (objTabOpts[name] && !cellOpts[name] && cellOpts[name] !== 0)
                                  cellOpts[name] = objTabOpts[name];
                          });
                          var cellValign = cellOpts.valign
                              ? " anchor=\"".concat(cellOpts.valign.replace(/^c$/i, 'ctr').replace(/^m$/i, 'ctr').replace('center', 'ctr').replace('middle', 'ctr').replace('top', 't').replace('btm', 'b').replace('bottom', 'b'), "\"")
                              : '';
                          var fillColor = ((_d = (_c = cell._optImp) === null || _c === void 0 ? void 0 : _c.fill) === null || _d === void 0 ? void 0 : _d.color)
                              ? cell._optImp.fill.color
                              : ((_e = cell._optImp) === null || _e === void 0 ? void 0 : _e.fill) && typeof cell._optImp.fill === 'string'
                                  ? cell._optImp.fill
                                  : '';
                          fillColor = fillColor || cellOpts.fill ? cellOpts.fill : '';
                          var cellFill = fillColor ? genXmlColorSelection(fillColor) : '';
                          var cellMargin = cellOpts.margin === 0 || cellOpts.margin ? cellOpts.margin : DEF_CELL_MARGIN_IN;
                          if (!Array.isArray(cellMargin) && typeof cellMargin === 'number')
                              cellMargin = [cellMargin, cellMargin, cellMargin, cellMargin];
                          /** FUTURE: DEPRECATED:
                           * - Backwards-Compat: Oops! Discovered we were still using points for cell margin before v3.8.0 (UGH!)
                           * - We cant introduce a breaking change before v4.0, so...
                           */
                          var cellMarginXml = '';
                          if (cellMargin[0] >= 1) {
                              cellMarginXml = " marL=\"".concat(valToPts(cellMargin[3]), "\" marR=\"").concat(valToPts(cellMargin[1]), "\" marT=\"").concat(valToPts(cellMargin[0]), "\" marB=\"").concat(valToPts(cellMargin[2]), "\"");
                          }
                          else {
                              cellMarginXml = " marL=\"".concat(inch2Emu(cellMargin[3]), "\" marR=\"").concat(inch2Emu(cellMargin[1]), "\" marT=\"").concat(inch2Emu(cellMargin[0]), "\" marB=\"").concat(inch2Emu(cellMargin[2]), "\"");
                          }
                          // FUTURE: Cell NOWRAP property (textwrap: add to a:tcPr (horzOverflow="overflow" or whatever options exist)
                          // 4: Set CELL content and properties ==================================
                          strXml += "<a:tc".concat(cellSpanAttrStr, ">").concat(genXmlTextBody(cell), "<a:tcPr").concat(cellMarginXml).concat(cellValign, ">");
                          // strXml += `<a:tc${cellColspan}${cellRowspan}>${genXmlTextBody(cell)}<a:tcPr${cellMarginXml}${cellValign}${cellTextDir}>`
                          // FIXME: 20200525: ^^^
                          // <a:tcPr marL="38100" marR="38100" marT="38100" marB="38100" vert="vert270">
                          // 5: Borders: Add any borders
                          if (cellOpts.border && Array.isArray(cellOpts.border)) {
                              // NOTE: *** IMPORTANT! *** LRTB order matters! (Reorder a line below to watch the borders go wonky in MS-PPT-2013!!)
                              [
                                  { idx: 3, name: 'lnL' },
                                  { idx: 1, name: 'lnR' },
                                  { idx: 0, name: 'lnT' },
                                  { idx: 2, name: 'lnB' },
                              ].forEach(function (obj) {
                                  if (cellOpts.border[obj.idx].type !== 'none') {
                                      strXml += "<a:".concat(obj.name, " w=\"").concat(valToPts(cellOpts.border[obj.idx].pt), "\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\">");
                                      strXml += "<a:solidFill>".concat(createColorElement(cellOpts.border[obj.idx].color), "</a:solidFill>");
                                      strXml += "<a:prstDash val=\"".concat(cellOpts.border[obj.idx].type === 'dash' ? 'sysDash' : 'solid', "\"/><a:round/><a:headEnd type=\"none\" w=\"med\" len=\"med\"/><a:tailEnd type=\"none\" w=\"med\" len=\"med\"/>");
                                      strXml += "</a:".concat(obj.name, ">");
                                  }
                                  else {
                                      strXml += "<a:".concat(obj.name, " w=\"0\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:noFill/></a:").concat(obj.name, ">");
                                  }
                              });
                          }
                          // 6: Close cell Properties & Cell
                          strXml += cellFill;
                          strXml += '  </a:tcPr>';
                          strXml += ' </a:tc>';
                      });
                      // D: Complete row
                      strXml += '</a:tr>';
                  });
                  // STEP 5: Complete table
                  strXml += '      </a:tbl>';
                  strXml += '    </a:graphicData>';
                  strXml += '  </a:graphic>';
                  strXml += '</p:graphicFrame>';
                  // STEP 6: Set table XML
                  strSlideXml += strXml;
                  // LAST: Increment counter
                  intTableNum++;
                  break;
              case SLIDE_OBJECT_TYPES.text:
              case SLIDE_OBJECT_TYPES.placeholder:
                  // Lines can have zero cy, but text should not
                  if (!slideItemObj.options.line && cy === 0)
                      cy = EMU * 0.3;
                  // Margin/Padding/Inset for textboxes
                  if (!slideItemObj.options._bodyProp)
                      slideItemObj.options._bodyProp = {};
                  if (slideItemObj.options.margin && Array.isArray(slideItemObj.options.margin)) {
                      slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin[0] || 0);
                      slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin[1] || 0);
                      slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin[2] || 0);
                      slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin[3] || 0);
                  }
                  else if (typeof slideItemObj.options.margin === 'number') {
                      slideItemObj.options._bodyProp.lIns = valToPts(slideItemObj.options.margin);
                      slideItemObj.options._bodyProp.rIns = valToPts(slideItemObj.options.margin);
                      slideItemObj.options._bodyProp.bIns = valToPts(slideItemObj.options.margin);
                      slideItemObj.options._bodyProp.tIns = valToPts(slideItemObj.options.margin);
                  }
                  // A: Start SHAPE =======================================================
                  strSlideXml += '<p:sp>';
                  // B: The addition of the "txBox" attribute is the sole determiner of if an object is a shape or textbox
                  strSlideXml += "<p:nvSpPr><p:cNvPr id=\"".concat(idx + 2, "\" name=\"").concat(slideItemObj.options.objectName, "\">");
                  // <Hyperlink>
                  if ((_c = slideItemObj.options.hyperlink) === null || _c === void 0 ? void 0 : _c.url) {
                      strSlideXml += "<a:hlinkClick r:id=\"rId".concat(slideItemObj.options.hyperlink._rId, "\" tooltip=\"").concat(slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : '', "\"/>");
                  }
                  if ((_d = slideItemObj.options.hyperlink) === null || _d === void 0 ? void 0 : _d.slide) {
                      strSlideXml += "<a:hlinkClick r:id=\"rId".concat(slideItemObj.options.hyperlink._rId, "\" tooltip=\"").concat(slideItemObj.options.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.options.hyperlink.tooltip) : '', "\" action=\"ppaction://hlinksldjump\"/>");
                  }
                  // </Hyperlink>
                  strSlideXml += '</p:cNvPr>';
                  strSlideXml += '<p:cNvSpPr' + (((_e = slideItemObj.options) === null || _e === void 0 ? void 0 : _e.isTextBox) ? ' txBox="1"/>' : '/>');
                  strSlideXml += "<p:nvPr>".concat(slideItemObj._type === 'placeholder' ? genXmlPlaceholder(slideItemObj) : genXmlPlaceholder(placeholderObj), "</p:nvPr>");
                  strSlideXml += '</p:nvSpPr><p:spPr>';
                  strSlideXml += "<a:xfrm".concat(locationAttr, ">");
                  strSlideXml += "<a:off x=\"".concat(x, "\" y=\"").concat(y, "\"/>");
                  strSlideXml += "<a:ext cx=\"".concat(cx, "\" cy=\"").concat(cy, "\"/></a:xfrm>");
                  if (slideItemObj.shape === 'custGeom') {
                      strSlideXml += '<a:custGeom><a:avLst />';
                      strSlideXml += '<a:gdLst>';
                      strSlideXml += '</a:gdLst>';
                      strSlideXml += '<a:ahLst />';
                      strSlideXml += '<a:cxnLst>';
                      strSlideXml += '</a:cxnLst>';
                      strSlideXml += '<a:rect l="l" t="t" r="r" b="b" />';
                      strSlideXml += '<a:pathLst>';
                      strSlideXml += "<a:path w=\"".concat(cx, "\" h=\"").concat(cy, "\">");
                      (_f = slideItemObj.options.points) === null || _f === void 0 ? void 0 : _f.forEach(function (point, i) {
                          if ('curve' in point) {
                              switch (point.curve.type) {
                                  case 'arc':
                                      strSlideXml += "<a:arcTo hR=\"".concat(getSmartParseNumber(point.curve.hR, 'Y', slide._presLayout), "\" wR=\"").concat(getSmartParseNumber(point.curve.wR, 'X', slide._presLayout), "\" stAng=\"").concat(convertRotationDegrees(point.curve.stAng), "\" swAng=\"").concat(convertRotationDegrees(point.curve.swAng), "\" />");
                                      break;
                                  case 'cubic':
                                      strSlideXml += "<a:cubicBezTo>\n\t\t\t\t\t\t\t\t\t<a:pt x=\"".concat(getSmartParseNumber(point.curve.x1, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.curve.y1, 'Y', slide._presLayout), "\" />\n\t\t\t\t\t\t\t\t\t<a:pt x=\"").concat(getSmartParseNumber(point.curve.x2, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.curve.y2, 'Y', slide._presLayout), "\" />\n\t\t\t\t\t\t\t\t\t<a:pt x=\"").concat(getSmartParseNumber(point.x, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.y, 'Y', slide._presLayout), "\" />\n\t\t\t\t\t\t\t\t\t</a:cubicBezTo>");
                                      break;
                                  case 'quadratic':
                                      strSlideXml += "<a:quadBezTo>\n\t\t\t\t\t\t\t\t\t<a:pt x=\"".concat(getSmartParseNumber(point.curve.x1, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.curve.y1, 'Y', slide._presLayout), "\" />\n\t\t\t\t\t\t\t\t\t<a:pt x=\"").concat(getSmartParseNumber(point.x, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.y, 'Y', slide._presLayout), "\" />\n\t\t\t\t\t\t\t\t\t</a:quadBezTo>");
                                      break;
                              }
                          }
                          else if ('close' in point) {
                              strSlideXml += '<a:close />';
                          }
                          else if (point.moveTo || i === 0) {
                              strSlideXml += "<a:moveTo><a:pt x=\"".concat(getSmartParseNumber(point.x, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.y, 'Y', slide._presLayout), "\" /></a:moveTo>");
                          }
                          else {
                              strSlideXml += "<a:lnTo><a:pt x=\"".concat(getSmartParseNumber(point.x, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(point.y, 'Y', slide._presLayout), "\" /></a:lnTo>");
                          }
                      });
                      strSlideXml += '</a:path>';
                      strSlideXml += '</a:pathLst>';
                      strSlideXml += '</a:custGeom>';
                  }
                  else {
                      strSlideXml += '<a:prstGeom prst="' + slideItemObj.shape + '"><a:avLst>';
                      if (slideItemObj.options.rectRadius) {
                          strSlideXml += "<a:gd name=\"adj\" fmla=\"val ".concat(Math.round((slideItemObj.options.rectRadius * EMU * 100000) / Math.min(cx, cy)), "\"/>");
                      }
                      else if (slideItemObj.options.angleRange) {
                          for (var i = 0; i < 2; i++) {
                              var angle = slideItemObj.options.angleRange[i];
                              strSlideXml += "<a:gd name=\"adj".concat(i + 1, "\" fmla=\"val ").concat(convertRotationDegrees(angle), "\" />");
                          }
                          if (slideItemObj.options.arcThicknessRatio) {
                              strSlideXml += "<a:gd name=\"adj3\" fmla=\"val ".concat(Math.round(slideItemObj.options.arcThicknessRatio * 50000), "\" />");
                          }
                      }
                      strSlideXml += '</a:avLst></a:prstGeom>';
                  }
                  // Option: FILL
                  strSlideXml += slideItemObj.options.fill ? genXmlColorSelection(slideItemObj.options.fill) : '<a:noFill/>';
                  // shape Type: LINE: line color
                  if (slideItemObj.options.line) {
                      strSlideXml += slideItemObj.options.line.width ? "<a:ln w=\"".concat(valToPts(slideItemObj.options.line.width), "\">") : '<a:ln>';
                      if (slideItemObj.options.line.color)
                          strSlideXml += genXmlColorSelection(slideItemObj.options.line);
                      if (slideItemObj.options.line.dashType)
                          strSlideXml += "<a:prstDash val=\"".concat(slideItemObj.options.line.dashType, "\"/>");
                      if (slideItemObj.options.line.beginArrowType)
                          strSlideXml += "<a:headEnd type=\"".concat(slideItemObj.options.line.beginArrowType, "\"/>");
                      if (slideItemObj.options.line.endArrowType)
                          strSlideXml += "<a:tailEnd type=\"".concat(slideItemObj.options.line.endArrowType, "\"/>");
                      // FUTURE: `endArrowSize` < a: headEnd type = "arrow" w = "lg" len = "lg" /> 'sm' | 'med' | 'lg'(values are 1 - 9, making a 3x3 grid of w / len possibilities)
                      strSlideXml += '</a:ln>';
                  }
                  // EFFECTS > SHADOW: REF: @see http://officeopenxml.com/drwSp-effects.php
                  if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== 'none') {
                      slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || 'outer';
                      slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);
                      slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);
                      slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 60000);
                      slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 100000);
                      slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;
                      strSlideXml += '<a:effectLst>';
                      strSlideXml += " <a:".concat(slideItemObj.options.shadow.type, "Shdw ").concat(slideItemObj.options.shadow.type === 'outer' ? 'sx="100000" sy="100000" kx="0" ky="0" algn="bl" rotWithShape="0"' : '', " blurRad=\"").concat(slideItemObj.options.shadow.blur, "\" dist=\"").concat(slideItemObj.options.shadow.offset, "\" dir=\"").concat(slideItemObj.options.shadow.angle, "\">");
                      strSlideXml += " <a:srgbClr val=\"".concat(slideItemObj.options.shadow.color, "\">");
                      strSlideXml += " <a:alpha val=\"".concat(slideItemObj.options.shadow.opacity, "\"/></a:srgbClr>");
                      strSlideXml += ' </a:outerShdw>';
                      strSlideXml += '</a:effectLst>';
                  }
                  /* TODO: FUTURE: Text wrapping (copied from MS-PPTX export)
                      // Commented out b/c i'm not even sure this works - current code produces text that wraps in shapes and textboxes, so...
                      if ( slideItemObj.options.textWrap ) {
                          strSlideXml += '<a:extLst>'
                                      + '<a:ext uri="{C572A759-6A51-4108-AA02-DFA0A04FC94B}">'
                                      + '<ma14:wrappingTextBoxFlag xmlns:ma14="http://schemas.microsoft.com/office/mac/drawingml/2011/main" val="1"/>'
                                      + '</a:ext>'
                                      + '</a:extLst>';
                      }
                  */
                  // B: Close shape Properties
                  strSlideXml += '</p:spPr>';
                  // C: Add formatted text (text body "bodyPr")
                  strSlideXml += genXmlTextBody(slideItemObj);
                  // LAST: Close SHAPE =======================================================
                  strSlideXml += '</p:sp>';
                  break;
              case SLIDE_OBJECT_TYPES.image:
                  strSlideXml += '<p:pic>';
                  strSlideXml += '  <p:nvPicPr>';
                  strSlideXml += "<p:cNvPr id=\"".concat(idx + 2, "\" name=\"").concat(slideItemObj.options.objectName, "\" descr=\"").concat(encodeXmlEntities(slideItemObj.options.altText || slideItemObj.image), "\">");
                  if ((_g = slideItemObj.hyperlink) === null || _g === void 0 ? void 0 : _g.url) {
                      strSlideXml += "<a:hlinkClick r:id=\"rId".concat(slideItemObj.hyperlink._rId, "\" tooltip=\"").concat(slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : '', "\"/>");
                  }
                  if ((_h = slideItemObj.hyperlink) === null || _h === void 0 ? void 0 : _h.slide) {
                      strSlideXml += "<a:hlinkClick r:id=\"rId".concat(slideItemObj.hyperlink._rId, "\" tooltip=\"").concat(slideItemObj.hyperlink.tooltip ? encodeXmlEntities(slideItemObj.hyperlink.tooltip) : '', "\" action=\"ppaction://hlinksldjump\"/>");
                  }
                  strSlideXml += '    </p:cNvPr>';
                  strSlideXml += '    <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
                  strSlideXml += '    <p:nvPr>' + genXmlPlaceholder(placeholderObj) + '</p:nvPr>';
                  strSlideXml += '  </p:nvPicPr>';
                  strSlideXml += '<p:blipFill>';
                  // NOTE: This works for both cases: either `path` or `data` contains the SVG
                  if ((slide._relsMedia || []).filter(function (rel) { return rel.rId === slideItemObj.imageRid; })[0] &&
                      (slide._relsMedia || []).filter(function (rel) { return rel.rId === slideItemObj.imageRid; })[0].extn === 'svg') {
                      strSlideXml += "<a:blip r:embed=\"rId".concat(slideItemObj.imageRid - 1, "\">");
                      strSlideXml += slideItemObj.options.transparency ? " <a:alphaModFix amt=\"".concat(Math.round((100 - slideItemObj.options.transparency) * 1000), "\"/>") : '';
                      strSlideXml += ' <a:extLst>';
                      strSlideXml += '  <a:ext uri="{96DAC541-7B7A-43D3-8B79-37D633B846F1}">';
                      strSlideXml += "   <asvg:svgBlip xmlns:asvg=\"http://schemas.microsoft.com/office/drawing/2016/SVG/main\" r:embed=\"rId".concat(slideItemObj.imageRid, "\"/>");
                      strSlideXml += '  </a:ext>';
                      strSlideXml += ' </a:extLst>';
                      strSlideXml += '</a:blip>';
                  }
                  else {
                      strSlideXml += "<a:blip r:embed=\"rId".concat(slideItemObj.imageRid, "\">");
                      strSlideXml += slideItemObj.options.transparency ? "<a:alphaModFix amt=\"".concat(Math.round((100 - slideItemObj.options.transparency) * 1000), "\"/>") : '';
                      strSlideXml += '</a:blip>';
                  }
                  if (sizing === null || sizing === void 0 ? void 0 : sizing.type) {
                      var boxW = sizing.w ? getSmartParseNumber(sizing.w, 'X', slide._presLayout) : cx;
                      var boxH = sizing.h ? getSmartParseNumber(sizing.h, 'Y', slide._presLayout) : cy;
                      var boxX = getSmartParseNumber(sizing.x || 0, 'X', slide._presLayout);
                      var boxY = getSmartParseNumber(sizing.y || 0, 'Y', slide._presLayout);
                      strSlideXml += ImageSizingXml[sizing.type]({ w: imgWidth, h: imgHeight }, { w: boxW, h: boxH, x: boxX, y: boxY });
                      imgWidth = boxW;
                      imgHeight = boxH;
                  }
                  else {
                      strSlideXml += '  <a:stretch><a:fillRect/></a:stretch>';
                  }
                  strSlideXml += '</p:blipFill>';
                  strSlideXml += '<p:spPr>';
                  strSlideXml += ' <a:xfrm' + locationAttr + '>';
                  strSlideXml += "  <a:off x=\"".concat(x, "\" y=\"").concat(y, "\"/>");
                  strSlideXml += "  <a:ext cx=\"".concat(imgWidth, "\" cy=\"").concat(imgHeight, "\"/>");
                  strSlideXml += ' </a:xfrm>';
                  strSlideXml += " <a:prstGeom prst=\"".concat(rounding ? 'ellipse' : 'rect', "\"><a:avLst/></a:prstGeom>");
                  // EFFECTS > SHADOW: REF: @see http://officeopenxml.com/drwSp-effects.php
                  if (slideItemObj.options.shadow && slideItemObj.options.shadow.type !== 'none') {
                      slideItemObj.options.shadow.type = slideItemObj.options.shadow.type || 'outer';
                      slideItemObj.options.shadow.blur = valToPts(slideItemObj.options.shadow.blur || 8);
                      slideItemObj.options.shadow.offset = valToPts(slideItemObj.options.shadow.offset || 4);
                      slideItemObj.options.shadow.angle = Math.round((slideItemObj.options.shadow.angle || 270) * 60000);
                      slideItemObj.options.shadow.opacity = Math.round((slideItemObj.options.shadow.opacity || 0.75) * 100000);
                      slideItemObj.options.shadow.color = slideItemObj.options.shadow.color || DEF_TEXT_SHADOW.color;
                      strSlideXml += '<a:effectLst>';
                      strSlideXml += "<a:".concat(slideItemObj.options.shadow.type, "Shdw ").concat(slideItemObj.options.shadow.type === 'outer' ? 'sx="100000" sy="100000" kx="0" ky="0" algn="bl" rotWithShape="0"' : '', " blurRad=\"").concat(slideItemObj.options.shadow.blur, "\" dist=\"").concat(slideItemObj.options.shadow.offset, "\" dir=\"").concat(slideItemObj.options.shadow.angle, "\">");
                      strSlideXml += "<a:srgbClr val=\"".concat(slideItemObj.options.shadow.color, "\">");
                      strSlideXml += "<a:alpha val=\"".concat(slideItemObj.options.shadow.opacity, "\"/></a:srgbClr>");
                      strSlideXml += "</a:".concat(slideItemObj.options.shadow.type, "Shdw>");
                      strSlideXml += '</a:effectLst>';
                  }
                  strSlideXml += '</p:spPr>';
                  strSlideXml += '</p:pic>';
                  break;
              case SLIDE_OBJECT_TYPES.media:
                  if (slideItemObj.mtype === 'online') {
                      strSlideXml += '<p:pic>';
                      strSlideXml += ' <p:nvPicPr>';
                      // IMPORTANT: <p:cNvPr id="" value is critical - if its not the same number as preview image `rId`, PowerPoint throws error!
                      strSlideXml += "<p:cNvPr id=\"".concat(slideItemObj.mediaRid + 2, "\" name=\"").concat(slideItemObj.options.objectName, "\"/>");
                      strSlideXml += ' <p:cNvPicPr/>';
                      strSlideXml += ' <p:nvPr>';
                      strSlideXml += "  <a:videoFile r:link=\"rId".concat(slideItemObj.mediaRid, "\"/>");
                      strSlideXml += ' </p:nvPr>';
                      strSlideXml += ' </p:nvPicPr>';
                      // NOTE: `blip` is diferent than videos; also there's no preview "p:extLst" above but exists in videos
                      strSlideXml += " <p:blipFill><a:blip r:embed=\"rId".concat(slideItemObj.mediaRid + 1, "\"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>"); // NOTE: Preview image is required!
                      strSlideXml += ' <p:spPr>';
                      strSlideXml += "  <a:xfrm".concat(locationAttr, "><a:off x=\"").concat(x, "\" y=\"").concat(y, "\"/><a:ext cx=\"").concat(cx, "\" cy=\"").concat(cy, "\"/></a:xfrm>");
                      strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
                      strSlideXml += ' </p:spPr>';
                      strSlideXml += '</p:pic>';
                  }
                  else {
                      strSlideXml += '<p:pic>';
                      strSlideXml += ' <p:nvPicPr>';
                      // IMPORTANT: <p:cNvPr id="" value is critical - if not the same number as preiew image rId, PowerPoint throws error!
                      strSlideXml += "<p:cNvPr id=\"".concat(slideItemObj.mediaRid + 2, "\" name=\"").concat(slideItemObj.options.objectName, "\"><a:hlinkClick r:id=\"\" action=\"ppaction://media\"/></p:cNvPr>");
                      strSlideXml += ' <p:cNvPicPr><a:picLocks noChangeAspect="1"/></p:cNvPicPr>';
                      strSlideXml += ' <p:nvPr>';
                      strSlideXml += "  <a:videoFile r:link=\"rId".concat(slideItemObj.mediaRid, "\"/>");
                      strSlideXml += '  <p:extLst>';
                      strSlideXml += '   <p:ext uri="{DAA4B4D4-6D71-4841-9C94-3DE7FCFB9230}">';
                      strSlideXml += "    <p14:media xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" r:embed=\"rId".concat(slideItemObj.mediaRid + 1, "\"/>");
                      strSlideXml += '   </p:ext>';
                      strSlideXml += '  </p:extLst>';
                      strSlideXml += ' </p:nvPr>';
                      strSlideXml += ' </p:nvPicPr>';
                      strSlideXml += " <p:blipFill><a:blip r:embed=\"rId".concat(slideItemObj.mediaRid + 2, "\"/><a:stretch><a:fillRect/></a:stretch></p:blipFill>"); // NOTE: Preview image is required!
                      strSlideXml += ' <p:spPr>';
                      strSlideXml += "  <a:xfrm".concat(locationAttr, "><a:off x=\"").concat(x, "\" y=\"").concat(y, "\"/><a:ext cx=\"").concat(cx, "\" cy=\"").concat(cy, "\"/></a:xfrm>");
                      strSlideXml += '  <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>';
                      strSlideXml += ' </p:spPr>';
                      strSlideXml += '</p:pic>';
                  }
                  break;
              case SLIDE_OBJECT_TYPES.chart:
                  strSlideXml += '<p:graphicFrame>';
                  strSlideXml += ' <p:nvGraphicFramePr>';
                  strSlideXml += "   <p:cNvPr id=\"".concat(idx + 2, "\" name=\"").concat(slideItemObj.options.objectName, "\" descr=\"").concat(encodeXmlEntities(slideItemObj.options.altText || ''), "\"/>");
                  strSlideXml += '   <p:cNvGraphicFramePr/>';
                  strSlideXml += "   <p:nvPr>".concat(genXmlPlaceholder(placeholderObj), "</p:nvPr>");
                  strSlideXml += ' </p:nvGraphicFramePr>';
                  strSlideXml += " <p:xfrm><a:off x=\"".concat(x, "\" y=\"").concat(y, "\"/><a:ext cx=\"").concat(cx, "\" cy=\"").concat(cy, "\"/></p:xfrm>");
                  strSlideXml += ' <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">';
                  strSlideXml += '  <a:graphicData uri="http://schemas.openxmlformats.org/drawingml/2006/chart">';
                  strSlideXml += "   <c:chart r:id=\"rId".concat(slideItemObj.chartRid, "\" xmlns:c=\"http://schemas.openxmlformats.org/drawingml/2006/chart\"/>");
                  strSlideXml += '  </a:graphicData>';
                  strSlideXml += ' </a:graphic>';
                  strSlideXml += '</p:graphicFrame>';
                  break;
              default:
                  strSlideXml += '';
                  break;
          }
      });
      // STEP 4: Add slide numbers (if any) last
      if (slide._slideNumberProps) {
          // Set some defaults (done here b/c SlideNumber canbe added to masters or slides and has numerous entry points)
          if (!slide._slideNumberProps.align)
              slide._slideNumberProps.align = 'left';
          strSlideXml += '<p:sp>';
          strSlideXml += ' <p:nvSpPr>';
          strSlideXml += '  <p:cNvPr id="25" name="Slide Number Placeholder 0"/><p:cNvSpPr><a:spLocks noGrp="1"/></p:cNvSpPr>';
          strSlideXml += '  <p:nvPr><p:ph type="sldNum" sz="quarter" idx="4294967295"/></p:nvPr>';
          strSlideXml += ' </p:nvSpPr>';
          strSlideXml += ' <p:spPr>';
          strSlideXml += '<a:xfrm>' +
              "<a:off x=\"".concat(getSmartParseNumber(slide._slideNumberProps.x, 'X', slide._presLayout), "\" y=\"").concat(getSmartParseNumber(slide._slideNumberProps.y, 'Y', slide._presLayout), "\"/>") +
              "<a:ext cx=\"".concat(slide._slideNumberProps.w ? getSmartParseNumber(slide._slideNumberProps.w, 'X', slide._presLayout) : '800000', "\" cy=\"").concat(slide._slideNumberProps.h ? getSmartParseNumber(slide._slideNumberProps.h, 'Y', slide._presLayout) : '300000', "\"/>") +
              '</a:xfrm>' +
              ' <a:prstGeom prst="rect"><a:avLst/></a:prstGeom>' +
              ' <a:extLst><a:ext uri="{C572A759-6A51-4108-AA02-DFA0A04FC94B}"><ma14:wrappingTextBoxFlag val="0" xmlns:ma14="http://schemas.microsoft.com/office/mac/drawingml/2011/main"/></a:ext></a:extLst>' +
              '</p:spPr>';
          strSlideXml += '<p:txBody>';
          strSlideXml += '<a:bodyPr';
          if (slide._slideNumberProps.margin && Array.isArray(slide._slideNumberProps.margin)) {
              strSlideXml += " lIns=\"".concat(valToPts(slide._slideNumberProps.margin[3] || 0), "\"");
              strSlideXml += " tIns=\"".concat(valToPts(slide._slideNumberProps.margin[0] || 0), "\"");
              strSlideXml += " rIns=\"".concat(valToPts(slide._slideNumberProps.margin[1] || 0), "\"");
              strSlideXml += " bIns=\"".concat(valToPts(slide._slideNumberProps.margin[2] || 0), "\"");
          }
          else if (typeof slide._slideNumberProps.margin === 'number') {
              strSlideXml += " lIns=\"".concat(valToPts(slide._slideNumberProps.margin || 0), "\"");
              strSlideXml += " tIns=\"".concat(valToPts(slide._slideNumberProps.margin || 0), "\"");
              strSlideXml += " rIns=\"".concat(valToPts(slide._slideNumberProps.margin || 0), "\"");
              strSlideXml += " bIns=\"".concat(valToPts(slide._slideNumberProps.margin || 0), "\"");
          }
          if (slide._slideNumberProps.valign) {
              strSlideXml += " anchor=\"".concat(slide._slideNumberProps.valign.replace('top', 't').replace('middle', 'ctr').replace('bottom', 'b'), "\"");
          }
          strSlideXml += '/>';
          strSlideXml += '  <a:lstStyle><a:lvl1pPr>';
          if (slide._slideNumberProps.fontFace || slide._slideNumberProps.fontSize || slide._slideNumberProps.color) {
              strSlideXml += "<a:defRPr sz=\"".concat(Math.round((slide._slideNumberProps.fontSize || 12) * 100), "\">");
              if (slide._slideNumberProps.color)
                  strSlideXml += genXmlColorSelection(slide._slideNumberProps.color);
              if (slide._slideNumberProps.fontFace) {
                  strSlideXml += "<a:latin typeface=\"".concat(slide._slideNumberProps.fontFace, "\"/><a:ea typeface=\"").concat(slide._slideNumberProps.fontFace, "\"/><a:cs typeface=\"").concat(slide._slideNumberProps.fontFace, "\"/>");
              }
              strSlideXml += '</a:defRPr>';
          }
          strSlideXml += '</a:lvl1pPr></a:lstStyle>';
          strSlideXml += '<a:p>';
          if (slide._slideNumberProps.align.startsWith('l'))
              strSlideXml += '<a:pPr algn="l"/>';
          else if (slide._slideNumberProps.align.startsWith('c'))
              strSlideXml += '<a:pPr algn="ctr"/>';
          else if (slide._slideNumberProps.align.startsWith('r'))
              strSlideXml += '<a:pPr algn="r"/>';
          else
              strSlideXml += '<a:pPr algn="l"/>';
          strSlideXml += "<a:fld id=\"".concat(SLDNUMFLDID, "\" type=\"slidenum\"><a:rPr b=\"").concat(slide._slideNumberProps.bold ? 1 : 0, "\" lang=\"en-US\"/>");
          strSlideXml += "<a:t>".concat(slide._slideNum, "</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p>");
          strSlideXml += '</p:txBody></p:sp>';
      }
      // STEP 5: Close spTree and finalize slide XML
      strSlideXml += '</p:spTree>';
      strSlideXml += '</p:cSld>';
      // LAST: Return
      return strSlideXml;
  }
  /**
   * Transforms slide relations to XML string.
   * Extra relations that are not dynamic can be passed using the 2nd arg (e.g. theme relation in master file).
   * These relations use rId series that starts with 1-increased maximum of rIds used for dynamic relations.
   * @param {PresSlide | SlideLayout} slide - slide object whose relations are being transformed
   * @param {{ target: string; type: string }[]} defaultRels - array of default relations
   * @return {string} XML
   */
  function slideObjectRelationsToXml(slide, defaultRels) {
      var lastRid = 0; // stores maximum rId used for dynamic relations
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">';
      // STEP 1: Add all rels for this Slide
      slide._rels.forEach(function (rel) {
          lastRid = Math.max(lastRid, rel.rId);
          if (rel.type.toLowerCase().includes('hyperlink')) {
              if (rel.data === 'slide') {
                  strXml += "<Relationship Id=\"rId".concat(rel.rId, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide\" Target=\"slide").concat(rel.Target, ".xml\"/>");
              }
              else {
                  strXml += "<Relationship Id=\"rId".concat(rel.rId, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink\" Target=\"").concat(rel.Target, "\" TargetMode=\"External\"/>");
              }
          }
          else if (rel.type.toLowerCase().includes('notesSlide')) {
              strXml += "<Relationship Id=\"rId".concat(rel.rId, "\" Target=\"").concat(rel.Target, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide\"/>");
          }
      });
      (slide._relsChart || []).forEach(function (rel) {
          lastRid = Math.max(lastRid, rel.rId);
          strXml += "<Relationship Id=\"rId".concat(rel.rId, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart\" Target=\"").concat(rel.Target, "\"/>");
      });
      (slide._relsMedia || []).forEach(function (rel) {
          var relRid = rel.rId.toString();
          lastRid = Math.max(lastRid, rel.rId);
          if (rel.type.toLowerCase().includes('image')) {
              strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="' + rel.Target + '"/>';
          }
          else if (rel.type.toLowerCase().includes('audio')) {
              // As media has *TWO* rel entries per item, check for first one, if found add second rel with alt style
              if (strXml.includes(' Target="' + rel.Target + '"')) {
                  strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/media" Target="' + rel.Target + '"/>';
              }
              else {
                  strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/audio" Target="' + rel.Target + '"/>';
              }
          }
          else if (rel.type.toLowerCase().includes('video')) {
              // As media has *TWO* rel entries per item, check for first one, if found add second rel with alt style
              if (strXml.includes(' Target="' + rel.Target + '"')) {
                  strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/media" Target="' + rel.Target + '"/>';
              }
              else {
                  strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video" Target="' + rel.Target + '"/>';
              }
          }
          else if (rel.type.toLowerCase().includes('online')) {
              // As media has *TWO* rel entries per item, check for first one, if found add second rel with alt style
              if (strXml.includes(' Target="' + rel.Target + '"')) {
                  strXml += '<Relationship Id="rId' + relRid + '" Type="http://schemas.microsoft.com/office/2007/relationships/image" Target="' + rel.Target + '"/>';
              }
              else {
                  strXml += '<Relationship Id="rId' + relRid + '" Target="' + rel.Target + '" TargetMode="External" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/video"/>';
              }
          }
      });
      // STEP 2: Add default rels
      defaultRels.forEach(function (rel, idx) {
          strXml += "<Relationship Id=\"rId".concat(lastRid + idx + 1, "\" Type=\"").concat(rel.type, "\" Target=\"").concat(rel.target, "\"/>");
      });
      strXml += '</Relationships>';
      return strXml;
  }
  /**
   * Generate XML Paragraph Properties
   * @param {ISlideObject|TextProps} textObj - text object
   * @param {boolean} isDefault - array of default relations
   * @return {string} XML
   */
  function genXmlParagraphProperties(textObj, isDefault) {
      var _a, _b;
      var strXmlBullet = '';
      var strXmlLnSpc = '';
      var strXmlParaSpc = '';
      var strXmlTabStops = '';
      var tag = isDefault ? 'a:lvl1pPr' : 'a:pPr';
      var bulletMarL = valToPts(DEF_BULLET_MARGIN);
      var paragraphPropXml = "<".concat(tag).concat(textObj.options.rtlMode ? ' rtl="1" ' : '');
      // A: Build paragraphProperties
      {
          // OPTION: align
          if (textObj.options.align) {
              switch (textObj.options.align) {
                  case 'left':
                      paragraphPropXml += ' algn="l"';
                      break;
                  case 'right':
                      paragraphPropXml += ' algn="r"';
                      break;
                  case 'center':
                      paragraphPropXml += ' algn="ctr"';
                      break;
                  case 'justify':
                      paragraphPropXml += ' algn="just"';
                      break;
                  default:
                      paragraphPropXml += '';
                      break;
              }
          }
          if (textObj.options.lineSpacing) {
              strXmlLnSpc = "<a:lnSpc><a:spcPts val=\"".concat(Math.round(textObj.options.lineSpacing * 100), "\"/></a:lnSpc>");
          }
          else if (textObj.options.lineSpacingMultiple) {
              strXmlLnSpc = "<a:lnSpc><a:spcPct val=\"".concat(Math.round(textObj.options.lineSpacingMultiple * 100000), "\"/></a:lnSpc>");
          }
          // OPTION: indent
          if (textObj.options.indentLevel && !isNaN(Number(textObj.options.indentLevel)) && textObj.options.indentLevel > 0) {
              paragraphPropXml += " lvl=\"".concat(textObj.options.indentLevel, "\"");
          }
          // OPTION: Paragraph Spacing: Before/After
          if (textObj.options.paraSpaceBefore && !isNaN(Number(textObj.options.paraSpaceBefore)) && textObj.options.paraSpaceBefore > 0) {
              strXmlParaSpc += "<a:spcBef><a:spcPts val=\"".concat(Math.round(textObj.options.paraSpaceBefore * 100), "\"/></a:spcBef>");
          }
          if (textObj.options.paraSpaceAfter && !isNaN(Number(textObj.options.paraSpaceAfter)) && textObj.options.paraSpaceAfter > 0) {
              strXmlParaSpc += "<a:spcAft><a:spcPts val=\"".concat(Math.round(textObj.options.paraSpaceAfter * 100), "\"/></a:spcAft>");
          }
          // OPTION: bullet
          // NOTE: OOXML uses the unicode character set for Bullets
          // EX: Unicode Character 'BULLET' (U+2022) ==> '<a:buChar char="&#x2022;"/>'
          if (typeof textObj.options.bullet === 'object') {
              if ((_b = (_a = textObj === null || textObj === void 0 ? void 0 : textObj.options) === null || _a === void 0 ? void 0 : _a.bullet) === null || _b === void 0 ? void 0 : _b.indent)
                  bulletMarL = valToPts(textObj.options.bullet.indent);
              if (textObj.options.bullet.type) {
                  if (textObj.options.bullet.type.toString().toLowerCase() === 'number') {
                      paragraphPropXml += " marL=\"".concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, "\" indent=\"-").concat(bulletMarL, "\"");
                      strXmlBullet = "<a:buSzPct val=\"100000\"/><a:buFont typeface=\"+mj-lt\"/><a:buAutoNum type=\"".concat(textObj.options.bullet.style || 'arabicPeriod', "\" startAt=\"").concat(textObj.options.bullet.numberStartAt || textObj.options.bullet.startAt || '1', "\"/>");
                  }
              }
              else if (textObj.options.bullet.characterCode) {
                  var bulletCode = "&#x".concat(textObj.options.bullet.characterCode, ";");
                  // Check value for hex-ness (s/b 4 char hex)
                  if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.characterCode)) {
                      console.warn('Warning: `bullet.characterCode should be a 4-digit unicode charatcer (ex: 22AB)`!');
                      bulletCode = BULLET_TYPES.DEFAULT;
                  }
                  paragraphPropXml += " marL=\"".concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, "\" indent=\"-").concat(bulletMarL, "\"");
                  strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
              }
              else if (textObj.options.bullet.code) {
                  // @deprecated `bullet.code` v3.3.0
                  var bulletCode = "&#x".concat(textObj.options.bullet.code, ";");
                  // Check value for hex-ness (s/b 4 char hex)
                  if (!/^[0-9A-Fa-f]{4}$/.test(textObj.options.bullet.code)) {
                      console.warn('Warning: `bullet.code should be a 4-digit hex code (ex: 22AB)`!');
                      bulletCode = BULLET_TYPES.DEFAULT;
                  }
                  paragraphPropXml += " marL=\"".concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, "\" indent=\"-").concat(bulletMarL, "\"");
                  strXmlBullet = '<a:buSzPct val="100000"/><a:buChar char="' + bulletCode + '"/>';
              }
              else {
                  paragraphPropXml += " marL=\"".concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, "\" indent=\"-").concat(bulletMarL, "\"");
                  strXmlBullet = "<a:buSzPct val=\"100000\"/><a:buChar char=\"".concat(BULLET_TYPES.DEFAULT, "\"/>");
              }
          }
          else if (textObj.options.bullet) {
              paragraphPropXml += " marL=\"".concat(textObj.options.indentLevel && textObj.options.indentLevel > 0 ? bulletMarL + bulletMarL * textObj.options.indentLevel : bulletMarL, "\" indent=\"-").concat(bulletMarL, "\"");
              strXmlBullet = "<a:buSzPct val=\"100000\"/><a:buChar char=\"".concat(BULLET_TYPES.DEFAULT, "\"/>");
          }
          else if (!textObj.options.bullet) {
              // We only add this when the user explicitely asks for no bullet, otherwise, it can override the master defaults!
              paragraphPropXml += ' indent="0" marL="0"'; // FIX: ISSUE#589 - specify zero indent and marL or default will be hanging paragraph
              strXmlBullet = '<a:buNone/>';
          }
          // OPTION: tabStops
          if (textObj.options.tabStops && Array.isArray(textObj.options.tabStops)) {
              var tabStopsXml = textObj.options.tabStops.map(function (stop) { return "<a:tab pos=\"".concat(inch2Emu(stop.position || 1), "\" algn=\"").concat(stop.alignment || 'l', "\"/>"); }).join('');
              strXmlTabStops = "<a:tabLst>".concat(tabStopsXml, "</a:tabLst>");
          }
          // B: Close Paragraph-Properties
          // IMPORTANT: strXmlLnSpc, strXmlParaSpc, and strXmlBullet require strict ordering - anything out of order is ignored. (PPT-Online, PPT for Mac)
          paragraphPropXml += '>' + strXmlLnSpc + strXmlParaSpc + strXmlBullet + strXmlTabStops;
          if (isDefault)
              paragraphPropXml += genXmlTextRunProperties(textObj.options, true);
          paragraphPropXml += '</' + tag + '>';
      }
      return paragraphPropXml;
  }
  /**
   * Generate XML Text Run Properties (`a:rPr`)
   * @param {ObjectOptions|TextPropsOptions} opts - text options
   * @param {boolean} isDefault - whether these are the default text run properties
   * @return {string} XML
   */
  function genXmlTextRunProperties(opts, isDefault) {
      var _a;
      var runProps = '';
      var runPropsTag = isDefault ? 'a:defRPr' : 'a:rPr';
      // BEGIN runProperties (ex: `<a:rPr lang="en-US" sz="1600" b="1" dirty="0">`)
      runProps += '<' + runPropsTag + ' lang="' + (opts.lang ? opts.lang : 'en-US') + '"' + (opts.lang ? ' altLang="en-US"' : '');
      runProps += opts.fontSize ? " sz=\"".concat(Math.round(opts.fontSize * 100), "\"") : ''; // NOTE: Use round so sizes like '7.5' wont cause corrupt presentations
      runProps += (opts === null || opts === void 0 ? void 0 : opts.bold) ? " b=\"".concat(opts.bold ? '1' : '0', "\"") : '';
      runProps += (opts === null || opts === void 0 ? void 0 : opts.italic) ? " i=\"".concat(opts.italic ? '1' : '0', "\"") : '';
      runProps += (opts === null || opts === void 0 ? void 0 : opts.strike) ? " strike=\"".concat(typeof opts.strike === 'string' ? opts.strike : 'sngStrike', "\"") : '';
      if (typeof opts.underline === 'object' && ((_a = opts.underline) === null || _a === void 0 ? void 0 : _a.style)) {
          runProps += " u=\"".concat(opts.underline.style, "\"");
      }
      else if (typeof opts.underline === 'string') {
          // DEPRECATED: opts.underline is an object as of v3.5.0
          runProps += " u=\"".concat(String(opts.underline), "\"");
      }
      else if (opts.hyperlink) {
          runProps += ' u="sng"';
      }
      if (opts.baseline) {
          runProps += " baseline=\"".concat(Math.round(opts.baseline * 50), "\"");
      }
      else if (opts.subscript) {
          runProps += ' baseline="-40000"';
      }
      else if (opts.superscript) {
          runProps += ' baseline="30000"';
      }
      runProps += opts.charSpacing ? " spc=\"".concat(Math.round(opts.charSpacing * 100), "\" kern=\"0\"") : ''; // IMPORTANT: Also disable kerning; otherwise text won't actually expand
      runProps += ' dirty="0">';
      // Color / Font / Highlight / Outline are children of <a:rPr>, so add them now before closing the runProperties tag
      if (opts.color || opts.fontFace || opts.outline || (typeof opts.underline === 'object' && opts.underline.color)) {
          if (opts.outline && typeof opts.outline === 'object') {
              runProps += "<a:ln w=\"".concat(valToPts(opts.outline.size || 0.75), "\">").concat(genXmlColorSelection(opts.outline.color || 'FFFFFF'), "</a:ln>");
          }
          if (opts.color)
              runProps += genXmlColorSelection({ color: opts.color, transparency: opts.transparency });
          if (opts.highlight)
              runProps += "<a:highlight>".concat(createColorElement(opts.highlight), "</a:highlight>");
          if (typeof opts.underline === 'object' && opts.underline.color)
              runProps += "<a:uFill>".concat(genXmlColorSelection(opts.underline.color), "</a:uFill>");
          if (opts.glow)
              runProps += "<a:effectLst>".concat(createGlowElement(opts.glow, DEF_TEXT_GLOW), "</a:effectLst>");
          if (opts.fontFace) {
              // NOTE: 'cs' = Complex Script, 'ea' = East Asian (use "-120" instead of "0" - per Issue #174); ea must come first (Issue #174)
              runProps += "<a:latin typeface=\"".concat(opts.fontFace, "\" pitchFamily=\"34\" charset=\"0\"/><a:ea typeface=\"").concat(opts.fontFace, "\" pitchFamily=\"34\" charset=\"-122\"/><a:cs typeface=\"").concat(opts.fontFace, "\" pitchFamily=\"34\" charset=\"-120\"/>");
          }
      }
      // Hyperlink support
      if (opts.hyperlink) {
          if (typeof opts.hyperlink !== 'object')
              throw new Error('ERROR: text `hyperlink` option should be an object. Ex: `hyperlink:{url:\'https://github.com\'}` ');
          else if (!opts.hyperlink.url && !opts.hyperlink.slide)
              throw new Error('ERROR: \'hyperlink requires either `url` or `slide`\'');
          else if (opts.hyperlink.url) {
              // runProps += '<a:uFill>'+ genXmlColorSelection('0000FF') +'</a:uFill>'; // Breaks PPT2010! (Issue#74)
              runProps += "<a:hlinkClick r:id=\"rId".concat(opts.hyperlink._rId, "\" invalidUrl=\"\" action=\"\" tgtFrame=\"\" tooltip=\"").concat(opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : '', "\" history=\"1\" highlightClick=\"0\" endSnd=\"0\"").concat(opts.color ? '>' : '/>');
          }
          else if (opts.hyperlink.slide) {
              runProps += "<a:hlinkClick r:id=\"rId".concat(opts.hyperlink._rId, "\" action=\"ppaction://hlinksldjump\" tooltip=\"").concat(opts.hyperlink.tooltip ? encodeXmlEntities(opts.hyperlink.tooltip) : '', "\"").concat(opts.color ? '>' : '/>');
          }
          if (opts.color) {
              runProps += ' <a:extLst>';
              runProps += '  <a:ext uri="{A12FA001-AC4F-418D-AE19-62706E023703}">';
              runProps += '   <ahyp:hlinkClr xmlns:ahyp="http://schemas.microsoft.com/office/drawing/2018/hyperlinkcolor" val="tx"/>';
              runProps += '  </a:ext>';
              runProps += ' </a:extLst>';
              runProps += '</a:hlinkClick>';
          }
      }
      // END runProperties
      runProps += "</".concat(runPropsTag, ">");
      return runProps;
  }
  /**
   * Build textBody text runs [`<a:r></a:r>`] for paragraphs [`<a:p>`]
   * @param {TextProps} textObj - Text object
   * @return {string} XML string
   */
  function genXmlTextRun(textObj) {
      // NOTE: Dont create full rPr runProps for empty [lineBreak] runs
      // Why? The size of the lineBreak wont match (eg: below it will be 18px instead of the correct 36px)
      // Do this:
      /*
          <a:p>
              <a:pPr algn="r"/>
              <a:endParaRPr lang="en-US" sz="3600" dirty="0"/>
          </a:p>
      */
      // NOT this:
      /*
          <a:p>
              <a:pPr algn="r"/>
              <a:r>
                  <a:rPr lang="en-US" sz="3600" dirty="0">
                      <a:solidFill>
                          <a:schemeClr val="accent5"/>
                      </a:solidFill>
                      <a:latin typeface="Times" pitchFamily="34" charset="0"/>
                      <a:ea typeface="Times" pitchFamily="34" charset="-122"/>
                      <a:cs typeface="Times" pitchFamily="34" charset="-120"/>
                  </a:rPr>
                  <a:t></a:t>
              </a:r>
              <a:endParaRPr lang="en-US" dirty="0"/>
          </a:p>
      */
      // Return paragraph with text run
      return textObj.text ? "<a:r>".concat(genXmlTextRunProperties(textObj.options, false), "<a:t>").concat(encodeXmlEntities(textObj.text), "</a:t></a:r>") : '';
  }
  /**
   * Builds `<a:bodyPr></a:bodyPr>` tag for "genXmlTextBody()"
   * @param {ISlideObject | TableCell} slideObject - various options
   * @return {string} XML string
   */
  function genXmlBodyProperties(slideObject) {
      var bodyProperties = '<a:bodyPr';
      if (slideObject && slideObject._type === SLIDE_OBJECT_TYPES.text && slideObject.options._bodyProp) {
          // PPT-2019 EX: <a:bodyPr wrap="square" lIns="1270" tIns="1270" rIns="1270" bIns="1270" rtlCol="0" anchor="ctr"/>
          // A: Enable or disable textwrapping none or square
          bodyProperties += slideObject.options._bodyProp.wrap ? ' wrap="square"' : ' wrap="none"';
          // B: Textbox margins [padding]
          if (slideObject.options._bodyProp.lIns || slideObject.options._bodyProp.lIns === 0)
              bodyProperties += " lIns=\"".concat(slideObject.options._bodyProp.lIns, "\"");
          if (slideObject.options._bodyProp.tIns || slideObject.options._bodyProp.tIns === 0)
              bodyProperties += " tIns=\"".concat(slideObject.options._bodyProp.tIns, "\"");
          if (slideObject.options._bodyProp.rIns || slideObject.options._bodyProp.rIns === 0)
              bodyProperties += " rIns=\"".concat(slideObject.options._bodyProp.rIns, "\"");
          if (slideObject.options._bodyProp.bIns || slideObject.options._bodyProp.bIns === 0)
              bodyProperties += " bIns=\"".concat(slideObject.options._bodyProp.bIns, "\"");
          // C: Add rtl after margins
          bodyProperties += ' rtlCol="0"';
          // D: Add anchorPoints
          if (slideObject.options._bodyProp.anchor)
              bodyProperties += ' anchor="' + slideObject.options._bodyProp.anchor + '"'; // VALS: [t,ctr,b]
          if (slideObject.options._bodyProp.vert)
              bodyProperties += ' vert="' + slideObject.options._bodyProp.vert + '"'; // VALS: [eaVert,horz,mongolianVert,vert,vert270,wordArtVert,wordArtVertRtl]
          // E: Close <a:bodyPr element
          bodyProperties += '>';
          /**
           * F: Text Fit/AutoFit/Shrink option
           * @see: http://officeopenxml.com/drwSp-text-bodyPr-fit.php
           * @see: http://www.datypic.com/sc/ooxml/g-a_EG_TextAutofit.html
           */
          if (slideObject.options.fit) {
              // NOTE: Use of '<a:noAutofit/>' instead of '' causes issues in PPT-2013!
              if (slideObject.options.fit === 'none')
                  bodyProperties += '';
              // NOTE: Shrink does not work automatically - PowerPoint calculates the `fontScale` value dynamically upon resize
              // else if (slideObject.options.fit === 'shrink') bodyProperties += '<a:normAutofit fontScale="85000" lnSpcReduction="20000"/>' // MS-PPT > Format shape > Text Options: "Shrink text on overflow"
              else if (slideObject.options.fit === 'shrink')
                  bodyProperties += '<a:normAutofit/>';
              else if (slideObject.options.fit === 'resize')
                  bodyProperties += '<a:spAutoFit/>';
          }
          //
          // DEPRECATED: below (@deprecated v3.3.0)
          if (slideObject.options.shrinkText)
              bodyProperties += '<a:normAutofit/>'; // MS-PPT > Format shape > Text Options: "Shrink text on overflow"
          /* DEPRECATED: below (@deprecated v3.3.0)
           * MS-PPT > Format shape > Text Options: "Resize shape to fit text" [spAutoFit]
           * NOTE: Use of '<a:noAutofit/>' in lieu of '' below causes issues in PPT-2013
           */
          bodyProperties += slideObject.options._bodyProp.autoFit ? '<a:spAutoFit/>' : '';
          // LAST: Close _bodyProp
          bodyProperties += '</a:bodyPr>';
      }
      else {
          // DEFAULT:
          bodyProperties += ' wrap="square" rtlCol="0">';
          bodyProperties += '</a:bodyPr>';
      }
      // LAST: Return Close _bodyProp
      return slideObject._type === SLIDE_OBJECT_TYPES.tablecell ? '<a:bodyPr/>' : bodyProperties;
  }
  /**
   * Generate the XML for text and its options (bold, bullet, etc) including text runs (word-level formatting)
   * @param {ISlideObject|TableCell} slideObj - slideObj or tableCell
   * @note PPT text lines [lines followed by line-breaks] are created using <p>-aragraph's
   * @note Bullets are a paragragh-level formatting device
   * @template
   *    <p:txBody>
   *        <a:bodyPr wrap="square" rtlCol="0">
   *            <a:spAutoFit/>
   *        </a:bodyPr>
   *        <a:lstStyle/>
   *        <a:p>
   *            <a:pPr algn="ctr"/>
   *            <a:r>
   *                <a:rPr lang="en-US" dirty="0" err="1"/>
   *                <a:t>textbox text</a:t>
   *            </a:r>
   *            <a:endParaRPr lang="en-US" dirty="0"/>
   *        </a:p>
   *    </p:txBody>
   * @returns XML containing the param object's text and formatting
   */
  function genXmlTextBody(slideObj) {
      var opts = slideObj.options || {};
      var tmpTextObjects = [];
      var arrTextObjects = [];
      // FIRST: Shapes without text, etc. may be sent here during build, but have no text to render so return an empty string
      if (opts && slideObj._type !== SLIDE_OBJECT_TYPES.tablecell && (typeof slideObj.text === 'undefined' || slideObj.text === null))
          return '';
      // STEP 1: Start textBody
      var strSlideXml = slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? '<a:txBody>' : '<p:txBody>';
      // STEP 2: Add bodyProperties
      {
          // A: 'bodyPr'
          strSlideXml += genXmlBodyProperties(slideObj);
          // B: 'lstStyle'
          // NOTE: shape type 'LINE' has different text align needs (a lstStyle.lvl1pPr between bodyPr and p)
          // FIXME: LINE horiz-align doesnt work (text is always to the left inside line) (FYI: the PPT code diff is substantial!)
          if (opts.h === 0 && opts.line && opts.align)
              strSlideXml += '<a:lstStyle><a:lvl1pPr algn="l"/></a:lstStyle>';
          else if (slideObj._type === 'placeholder')
              strSlideXml += "<a:lstStyle>".concat(genXmlParagraphProperties(slideObj, true), "</a:lstStyle>");
          else
              strSlideXml += '<a:lstStyle/>';
      }
      /* STEP 3: Modify slideObj.text to array
          CASES:
          addText( 'string' ) // string
          addText( 'line1\n line2' ) // string with lineBreak
          addText( {text:'word1'} ) // TextProps object
          addText( ['barry','allen'] ) // array of strings
          addText( [{text:'word1'}, {text:'word2'}] ) // TextProps object array
          addText( [{text:'line1\n line2'}, {text:'end word'}] ) // TextProps object array with lineBreak
      */
      if (typeof slideObj.text === 'string' || typeof slideObj.text === 'number') {
          // Handle cases 1,2
          tmpTextObjects.push({ text: slideObj.text.toString(), options: opts || {} });
      }
      else if (slideObj.text && !Array.isArray(slideObj.text) && typeof slideObj.text === 'object' && Object.keys(slideObj.text).includes('text')) {
          // } else if (!Array.isArray(slideObj.text) && slideObj.text!.hasOwnProperty('text')) { // 20210706: replaced with below as ts compiler rejected it
          // Handle case 3
          tmpTextObjects.push({ text: slideObj.text || '', options: slideObj.options || {} });
      }
      else if (Array.isArray(slideObj.text)) {
          // Handle cases 4,5,6
          // NOTE: use cast as text is TextProps[]|TableCell[] and their `options` dont overlap (they share the same TextBaseProps though)
          tmpTextObjects = slideObj.text.map(function (item) { return ({ text: item.text, options: item.options }); });
      }
      // STEP 4: Iterate over text objects, set text/options, break into pieces if '\n'/breakLine found
      tmpTextObjects.forEach(function (itext, idx) {
          if (!itext.text)
              itext.text = '';
          // A: Set options
          itext.options = itext.options || opts || {};
          if (idx === 0 && itext.options && !itext.options.bullet && opts.bullet)
              itext.options.bullet = opts.bullet;
          // B: Cast to text-object and fix line-breaks (if needed)
          if (typeof itext.text === 'string' || typeof itext.text === 'number') {
              // 1: Convert "\n" or any variation into CRLF
              itext.text = itext.text.toString().replace(/\r*\n/g, CRLF);
          }
          // C: If text string has line-breaks, then create a separate text-object for each (much easier than dealing with split inside a loop below)
          // NOTE: Filter for trailing lineBreak prevents the creation of an empty textObj as the last item
          if (itext.text.includes(CRLF) && itext.text.match(/\n$/g) === null) {
              itext.text.split(CRLF).forEach(function (line) {
                  itext.options.breakLine = true;
                  arrTextObjects.push({ text: line, options: itext.options });
              });
          }
          else {
              arrTextObjects.push(itext);
          }
      });
      // STEP 5: Group textObj into lines by checking for lineBreak, bullets, alignment change, etc.
      var arrLines = [];
      var arrTexts = [];
      arrTextObjects.forEach(function (textObj, idx) {
          // A: Align or Bullet trigger new line
          if (arrTexts.length > 0 && (textObj.options.align || opts.align)) {
              // Only start a new paragraph when align *changes*
              if (textObj.options.align !== arrTextObjects[idx - 1].options.align) {
                  arrLines.push(arrTexts);
                  arrTexts = [];
              }
          }
          else if (arrTexts.length > 0 && textObj.options.bullet && arrTexts.length > 0) {
              arrLines.push(arrTexts);
              arrTexts = [];
              textObj.options.breakLine = false; // For cases with both `bullet` and `brekaLine` - prevent double lineBreak
          }
          // B: Add this text to current line
          arrTexts.push(textObj);
          // C: BreakLine begins new line **after** adding current text
          if (arrTexts.length > 0 && textObj.options.breakLine) {
              // Avoid starting a para right as loop is exhausted
              if (idx + 1 < arrTextObjects.length) {
                  arrLines.push(arrTexts);
                  arrTexts = [];
              }
          }
          // D: Flush buffer
          if (idx + 1 === arrTextObjects.length)
              arrLines.push(arrTexts);
      });
      // STEP 6: Loop over each line and create paragraph props, text run, etc.
      arrLines.forEach(function (line) {
          var _a;
          var reqsClosingFontSize = false;
          // A: Start paragraph, add paraProps
          strSlideXml += '<a:p>';
          // NOTE: `rtlMode` is like other opts, its propagated up to each text:options, so just check the 1st one
          var paragraphPropXml = "<a:pPr ".concat(((_a = line[0].options) === null || _a === void 0 ? void 0 : _a.rtlMode) ? ' rtl="1" ' : '');
          // B: Start paragraph, loop over lines and add text runs
          line.forEach(function (textObj, idx) {
              // A: Set line index
              textObj.options._lineIdx = idx;
              // A.1: Add soft break if not the first run of the line.
              if (idx > 0 && textObj.options.softBreakBefore) {
                  strSlideXml += '<a:br/>';
              }
              // B: Inherit pPr-type options from parent shape's `options`
              textObj.options.align = textObj.options.align || opts.align;
              textObj.options.lineSpacing = textObj.options.lineSpacing || opts.lineSpacing;
              textObj.options.lineSpacingMultiple = textObj.options.lineSpacingMultiple || opts.lineSpacingMultiple;
              textObj.options.indentLevel = textObj.options.indentLevel || opts.indentLevel;
              textObj.options.paraSpaceBefore = textObj.options.paraSpaceBefore || opts.paraSpaceBefore;
              textObj.options.paraSpaceAfter = textObj.options.paraSpaceAfter || opts.paraSpaceAfter;
              paragraphPropXml = genXmlParagraphProperties(textObj, false);
              strSlideXml += paragraphPropXml.replace('<a:pPr></a:pPr>', ''); // IMPORTANT: Empty "pPr" blocks will generate needs-repair/corrupt msg
              // C: Inherit any main options (color, fontSize, etc.)
              // NOTE: We only pass the text.options to genXmlTextRun (not the Slide.options),
              // so the run building function cant just fallback to Slide.color, therefore, we need to do that here before passing options below.
              // FILTER RULE: Hyperlinks should not inherit `color` from main options (let PPT default to local color, eg: blue on MacOS)
              Object.entries(opts).filter(function (_a) {
                  var key = _a[0]; _a[1];
                  return !(textObj.options.hyperlink && key === 'color');
              }).forEach(function (_a) {
                  var key = _a[0], val = _a[1];
                  // if (textObj.options.hyperlink && key === 'color') null
                  // NOTE: This loop will pick up unecessary keys (`x`, etc.), but it doesnt hurt anything
                  if (key !== 'bullet' && !textObj.options[key])
                      textObj.options[key] = val;
              });
              // D: Add formatted textrun
              strSlideXml += genXmlTextRun(textObj);
              // E: Flag close fontSize for empty [lineBreak] elements
              if ((!textObj.text && opts.fontSize) || textObj.options.fontSize) {
                  reqsClosingFontSize = true;
                  opts.fontSize = opts.fontSize || textObj.options.fontSize;
              }
          });
          /* C: Append 'endParaRPr' (when needed) and close current open paragraph
           * NOTE: (ISSUE#20, ISSUE#193): Add 'endParaRPr' with font/size props or PPT default (Arial/18pt en-us) is used making row "too tall"/not honoring options
           */
          if (slideObj._type === SLIDE_OBJECT_TYPES.tablecell && (opts.fontSize || opts.fontFace)) {
              if (opts.fontFace) {
                  strSlideXml += "<a:endParaRPr lang=\"".concat(opts.lang || 'en-US', "\"") + (opts.fontSize ? " sz=\"".concat(Math.round(opts.fontSize * 100), "\"") : '') + ' dirty="0">';
                  strSlideXml += "<a:latin typeface=\"".concat(opts.fontFace, "\" charset=\"0\"/>");
                  strSlideXml += "<a:ea typeface=\"".concat(opts.fontFace, "\" charset=\"0\"/>");
                  strSlideXml += "<a:cs typeface=\"".concat(opts.fontFace, "\" charset=\"0\"/>");
                  strSlideXml += '</a:endParaRPr>';
              }
              else {
                  strSlideXml += "<a:endParaRPr lang=\"".concat(opts.lang || 'en-US', "\"") + (opts.fontSize ? " sz=\"".concat(Math.round(opts.fontSize * 100), "\"") : '') + ' dirty="0"/>';
              }
          }
          else if (reqsClosingFontSize) {
              // Empty [lineBreak] lines should not contain runProp, however, they need to specify fontSize in `endParaRPr`
              strSlideXml += "<a:endParaRPr lang=\"".concat(opts.lang || 'en-US', "\"") + (opts.fontSize ? " sz=\"".concat(Math.round(opts.fontSize * 100), "\"") : '') + ' dirty="0"/>';
          }
          else {
              strSlideXml += "<a:endParaRPr lang=\"".concat(opts.lang || 'en-US', "\" dirty=\"0\"/>"); // Added 20180101 to address PPT-2007 issues
          }
          // D: End paragraph
          strSlideXml += '</a:p>';
      });
      // STEP 7: Close the textBody
      strSlideXml += slideObj._type === SLIDE_OBJECT_TYPES.tablecell ? '</a:txBody>' : '</p:txBody>';
      // LAST: Return XML
      return strSlideXml;
  }
  /**
   * Generate an XML Placeholder
   * @param {ISlideObject} placeholderObj
   * @returns XML
   */
  function genXmlPlaceholder(placeholderObj) {
      var _a, _b;
      if (!placeholderObj)
          return '';
      var placeholderIdx = ((_a = placeholderObj.options) === null || _a === void 0 ? void 0 : _a._placeholderIdx) ? placeholderObj.options._placeholderIdx : '';
      var placeholderTyp = ((_b = placeholderObj.options) === null || _b === void 0 ? void 0 : _b._placeholderType) ? placeholderObj.options._placeholderType : '';
      var placeholderType = placeholderTyp && PLACEHOLDER_TYPES[placeholderTyp] ? (PLACEHOLDER_TYPES[placeholderTyp]).toString() : '';
      return "<p:ph\n\t\t".concat(placeholderIdx ? ' idx="' + placeholderIdx.toString() + '"' : '', "\n\t\t").concat(placeholderType && PLACEHOLDER_TYPES[placeholderType] ? " type=\"".concat(placeholderType, "\"") : '', "\n\t\t").concat(placeholderObj.text && placeholderObj.text.length > 0 ? ' hasCustomPrompt="1"' : '', "\n\t\t/>");
  }
  // XML-GEN: First 6 functions create the base /ppt files
  /**
   * Generate XML ContentType
   * @param {PresSlide[]} slides - slides
   * @param {SlideLayout[]} slideLayouts - slide layouts
   * @param {PresSlide} masterSlide - master slide
   * @returns XML
   */
  function makeXmlContTypes(slides, slideLayouts, masterSlide) {
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
      strXml += '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
      strXml += '<Default Extension="xml" ContentType="application/xml"/>';
      strXml += '<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>';
      strXml += '<Default Extension="jpeg" ContentType="image/jpeg"/>';
      strXml += '<Default Extension="jpg" ContentType="image/jpg"/>';
      strXml += '<Default Extension="svg" ContentType="image/svg+xml"/>';
      // STEP 1: Add standard/any media types used in Presentation
      strXml += '<Default Extension="png" ContentType="image/png"/>';
      strXml += '<Default Extension="gif" ContentType="image/gif"/>';
      strXml += '<Default Extension="m4v" ContentType="video/mp4"/>'; // NOTE: Hard-Code this extension as it wont be created in loop below (as extn !== type)
      strXml += '<Default Extension="mp4" ContentType="video/mp4"/>'; // NOTE: Hard-Code this extension as it wont be created in loop below (as extn !== type)
      slides.forEach(function (slide) {
          (slide._relsMedia || []).forEach(function (rel) {
              if (rel.type !== 'image' && rel.type !== 'online' && rel.type !== 'chart' && rel.extn !== 'm4v' && !strXml.includes(rel.type)) {
                  strXml += '<Default Extension="' + rel.extn + '" ContentType="' + rel.type + '"/>';
              }
          });
      });
      strXml += '<Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>';
      strXml += '<Default Extension="xlsx" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"/>';
      // STEP 2: Add presentation and slide master(s)/slide(s)
      strXml += '<Override PartName="/ppt/presentation.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml"/>';
      strXml += '<Override PartName="/ppt/notesMasters/notesMaster1.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.notesMaster+xml"/>';
      slides.forEach(function (slide, idx) {
          strXml += "<Override PartName=\"/ppt/slideMasters/slideMaster".concat(idx + 1, ".xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\"/>");
          strXml += "<Override PartName=\"/ppt/slides/slide".concat(idx + 1, ".xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\"/>");
          // Add charts if any
          slide._relsChart.forEach(function (rel) {
              strXml += "<Override PartName=\"".concat(rel.Target, "\" ContentType=\"application/vnd.openxmlformats-officedocument.drawingml.chart+xml\"/>");
          });
      });
      // STEP 3: Core PPT
      strXml += '<Override PartName="/ppt/presProps.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.presProps+xml"/>';
      strXml += '<Override PartName="/ppt/viewProps.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.viewProps+xml"/>';
      strXml += '<Override PartName="/ppt/theme/theme1.xml" ContentType="application/vnd.openxmlformats-officedocument.theme+xml"/>';
      strXml += '<Override PartName="/ppt/tableStyles.xml" ContentType="application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml"/>';
      // STEP 4: Add Slide Layouts
      slideLayouts.forEach(function (layout, idx) {
          strXml += "<Override PartName=\"/ppt/slideLayouts/slideLayout".concat(idx + 1, ".xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\"/>");
          (layout._relsChart || []).forEach(function (rel) {
              strXml += ' <Override PartName="' + rel.Target + '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>';
          });
      });
      // STEP 5: Add notes slide(s)
      slides.forEach(function (_slide, idx) {
          strXml += "<Override PartName=\"/ppt/notesSlides/notesSlide".concat(idx + 1, ".xml\" ContentType=\"application/vnd.openxmlformats-officedocument.presentationml.notesSlide+xml\"/>");
      });
      // STEP 6: Add rels
      masterSlide._relsChart.forEach(function (rel) {
          strXml += ' <Override PartName="' + rel.Target + '" ContentType="application/vnd.openxmlformats-officedocument.drawingml.chart+xml"/>';
      });
      masterSlide._relsMedia.forEach(function (rel) {
          if (rel.type !== 'image' && rel.type !== 'online' && rel.type !== 'chart' && rel.extn !== 'm4v' && !strXml.includes(rel.type)) {
              strXml += ' <Default Extension="' + rel.extn + '" ContentType="' + rel.type + '"/>';
          }
      });
      // LAST: Finish XML (Resume core)
      strXml += ' <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>';
      strXml += ' <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>';
      strXml += '</Types>';
      return strXml;
  }
  /**
   * Creates `_rels/.rels`
   * @returns XML
   */
  function makeXmlRootRels() {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n\t\t<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" Target=\"docProps/app.xml\"/>\n\t\t<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" Target=\"docProps/core.xml\"/>\n\t\t<Relationship Id=\"rId3\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"ppt/presentation.xml\"/>\n\t\t</Relationships>");
  }
  /**
   * Creates `docProps/app.xml`
   * @param {PresSlide[]} slides - Presenation Slides
   * @param {string} company - "Company" metadata
   * @returns XML
   */
  function makeXmlApp(slides, company) {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\" xmlns:vt=\"http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes\">\n\t<TotalTime>0</TotalTime>\n\t<Words>0</Words>\n\t<Application>Microsoft Office PowerPoint</Application>\n\t<PresentationFormat>On-screen Show (16:9)</PresentationFormat>\n\t<Paragraphs>0</Paragraphs>\n\t<Slides>").concat(slides.length, "</Slides>\n\t<Notes>").concat(slides.length, "</Notes>\n\t<HiddenSlides>0</HiddenSlides>\n\t<MMClips>0</MMClips>\n\t<ScaleCrop>false</ScaleCrop>\n\t<HeadingPairs>\n\t\t<vt:vector size=\"6\" baseType=\"variant\">\n\t\t\t<vt:variant><vt:lpstr>Fonts Used</vt:lpstr></vt:variant>\n\t\t\t<vt:variant><vt:i4>2</vt:i4></vt:variant>\n\t\t\t<vt:variant><vt:lpstr>Theme</vt:lpstr></vt:variant>\n\t\t\t<vt:variant><vt:i4>1</vt:i4></vt:variant>\n\t\t\t<vt:variant><vt:lpstr>Slide Titles</vt:lpstr></vt:variant>\n\t\t\t<vt:variant><vt:i4>").concat(slides.length, "</vt:i4></vt:variant>\n\t\t</vt:vector>\n\t</HeadingPairs>\n\t<TitlesOfParts>\n\t\t<vt:vector size=\"").concat(slides.length + 1 + 2, "\" baseType=\"lpstr\">\n\t\t\t<vt:lpstr>Arial</vt:lpstr>\n\t\t\t<vt:lpstr>Calibri</vt:lpstr>\n\t\t\t<vt:lpstr>Office Theme</vt:lpstr>\n\t\t\t").concat(slides.map(function (_slideObj, idx) { return "<vt:lpstr>Slide ".concat(idx + 1, "</vt:lpstr>"); }).join(''), "\n\t\t</vt:vector>\n\t</TitlesOfParts>\n\t<Company>").concat(company, "</Company>\n\t<LinksUpToDate>false</LinksUpToDate>\n\t<SharedDoc>false</SharedDoc>\n\t<HyperlinksChanged>false</HyperlinksChanged>\n\t<AppVersion>16.0000</AppVersion>\n\t</Properties>");
  }
  /**
   * Creates `docProps/core.xml`
   * @param {string} title - metadata data
   * @param {string} subject - metadata data
   * @param {string} author - metadata value
   * @param {string} revision - metadata value
   * @returns XML
   */
  function makeXmlCore(title, subject, author, revision) {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:dcmitype=\"http://purl.org/dc/dcmitype/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n\t\t<dc:title>".concat(encodeXmlEntities(title), "</dc:title>\n\t\t<dc:subject>").concat(encodeXmlEntities(subject), "</dc:subject>\n\t\t<dc:creator>").concat(encodeXmlEntities(author), "</dc:creator>\n\t\t<cp:lastModifiedBy>").concat(encodeXmlEntities(author), "</cp:lastModifiedBy>\n\t\t<cp:revision>").concat(revision, "</cp:revision>\n\t\t<dcterms:created xsi:type=\"dcterms:W3CDTF\">").concat(new Date().toISOString().replace(/\.\d\d\dZ/, 'Z'), "</dcterms:created>\n\t\t<dcterms:modified xsi:type=\"dcterms:W3CDTF\">").concat(new Date().toISOString().replace(/\.\d\d\dZ/, 'Z'), "</dcterms:modified>\n\t</cp:coreProperties>");
  }
  /**
   * Creates `ppt/_rels/presentation.xml.rels`
   * @param {PresSlide[]} slides - Presenation Slides
   * @returns XML
   */
  function makeXmlPresentationRels(slides) {
      var intRelNum = 1;
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
      strXml += '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">';
      strXml += '<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster" Target="slideMasters/slideMaster1.xml"/>';
      for (var idx = 1; idx <= slides.length; idx++) {
          strXml += "<Relationship Id=\"rId".concat(++intRelNum, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide\" Target=\"slides/slide").concat(idx, ".xml\"/>");
      }
      intRelNum++;
      strXml +=
          "<Relationship Id=\"rId".concat(intRelNum + 0, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster\" Target=\"notesMasters/notesMaster1.xml\"/>") +
              "<Relationship Id=\"rId".concat(intRelNum + 1, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/presProps\" Target=\"presProps.xml\"/>") +
              "<Relationship Id=\"rId".concat(intRelNum + 2, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/viewProps\" Target=\"viewProps.xml\"/>") +
              "<Relationship Id=\"rId".concat(intRelNum + 3, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"theme/theme1.xml\"/>") +
              "<Relationship Id=\"rId".concat(intRelNum + 4, "\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles\" Target=\"tableStyles.xml\"/>") +
              '</Relationships>';
      return strXml;
  }
  // XML-GEN: Functions that run 1-N times (once for each Slide)
  /**
   * Generates XML for the slide file (`ppt/slides/slide1.xml`)
   * @param {PresSlide} slide - the slide object to transform into XML
   * @return {string} XML
   */
  function makeXmlSlide(slide) {
      return ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF) +
          '<p:sld xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ' +
          'xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main"' +
          "".concat((slide === null || slide === void 0 ? void 0 : slide.hidden) ? ' show="0"' : '', ">") +
          "".concat(slideObjectToXml(slide)) +
          '<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sld>');
  }
  /**
   * Get text content of Notes from Slide
   * @param {PresSlide} slide - the slide object to transform into XML
   * @return {string} notes text
   */
  function getNotesFromSlide(slide) {
      var notesText = '';
      slide._slideObjects.forEach(function (data) {
          if (data._type === SLIDE_OBJECT_TYPES.notes)
              notesText += (data === null || data === void 0 ? void 0 : data.text) && data.text[0] ? data.text[0].text : '';
      });
      return notesText.replace(/\r*\n/g, CRLF);
  }
  /**
   * Generate XML for Notes Master (notesMaster1.xml)
   * @returns {string} XML
   */
  function makeXmlNotesMaster() {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<p:notesMaster xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"><p:cSld><p:bg><p:bgRef idx=\"1001\"><a:schemeClr val=\"bg1\"/></p:bgRef></p:bg><p:spTree><p:nvGrpSpPr><p:cNvPr id=\"1\" name=\"\"/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"0\" cy=\"0\"/><a:chOff x=\"0\" y=\"0\"/><a:chExt cx=\"0\" cy=\"0\"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id=\"2\" name=\"Header Placeholder 1\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"hdr\" sz=\"quarter\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"2971800\" cy=\"458788\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\"/><a:lstStyle><a:lvl1pPr algn=\"l\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"3\" name=\"Date Placeholder 2\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"dt\" idx=\"1\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"3884613\" y=\"0\"/><a:ext cx=\"2971800\" cy=\"458788\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\"/><a:lstStyle><a:lvl1pPr algn=\"r\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id=\"{5282F153-3F37-0F45-9E97-73ACFA13230C}\" type=\"datetimeFigureOut\"><a:rPr lang=\"en-US\"/><a:t>7/23/19</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"4\" name=\"Slide Image Placeholder 3\"/><p:cNvSpPr><a:spLocks noGrp=\"1\" noRot=\"1\" noChangeAspect=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldImg\" idx=\"2\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"685800\" y=\"1143000\"/><a:ext cx=\"5486400\" cy=\"3086100\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom><a:noFill/><a:ln w=\"12700\"><a:solidFill><a:prstClr val=\"black\"/></a:solidFill></a:ln></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\" anchor=\"ctr\"/><a:lstStyle/><a:p><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"5\" name=\"Notes Placeholder 4\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"body\" sz=\"quarter\" idx=\"3\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"685800\" y=\"4400550\"/><a:ext cx=\"5486400\" cy=\"3600450\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\"/><a:lstStyle/><a:p><a:pPr lvl=\"0\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Click to edit Master text styles</a:t></a:r></a:p><a:p><a:pPr lvl=\"1\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Second level</a:t></a:r></a:p><a:p><a:pPr lvl=\"2\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Third level</a:t></a:r></a:p><a:p><a:pPr lvl=\"3\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Fourth level</a:t></a:r></a:p><a:p><a:pPr lvl=\"4\"/><a:r><a:rPr lang=\"en-US\"/><a:t>Fifth level</a:t></a:r></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"6\" name=\"Footer Placeholder 5\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"ftr\" sz=\"quarter\" idx=\"4\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"0\" y=\"8685213\"/><a:ext cx=\"2971800\" cy=\"458787\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\" anchor=\"b\"/><a:lstStyle><a:lvl1pPr algn=\"l\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"7\" name=\"Slide Number Placeholder 6\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldNum\" sz=\"quarter\" idx=\"5\"/></p:nvPr></p:nvSpPr><p:spPr><a:xfrm><a:off x=\"3884613\" y=\"8685213\"/><a:ext cx=\"2971800\" cy=\"458787\"/></a:xfrm><a:prstGeom prst=\"rect\"><a:avLst/></a:prstGeom></p:spPr><p:txBody><a:bodyPr vert=\"horz\" lIns=\"91440\" tIns=\"45720\" rIns=\"91440\" bIns=\"45720\" rtlCol=\"0\" anchor=\"b\"/><a:lstStyle><a:lvl1pPr algn=\"r\"><a:defRPr sz=\"1200\"/></a:lvl1pPr></a:lstStyle><a:p><a:fld id=\"{CE5E9CC1-C706-0F49-92D6-E571CC5EEA8F}\" type=\"slidenum\"><a:rPr lang=\"en-US\"/><a:t>\u2039#\u203A</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri=\"{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}\"><p14:creationId xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" val=\"1024086991\"/></p:ext></p:extLst></p:cSld><p:clrMap bg1=\"lt1\" tx1=\"dk1\" bg2=\"lt2\" tx2=\"dk2\" accent1=\"accent1\" accent2=\"accent2\" accent3=\"accent3\" accent4=\"accent4\" accent5=\"accent5\" accent6=\"accent6\" hlink=\"hlink\" folHlink=\"folHlink\"/><p:notesStyle><a:lvl1pPr marL=\"0\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl1pPr><a:lvl2pPr marL=\"457200\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl2pPr><a:lvl3pPr marL=\"914400\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl3pPr><a:lvl4pPr marL=\"1371600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl4pPr><a:lvl5pPr marL=\"1828800\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl5pPr><a:lvl6pPr marL=\"2286000\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl6pPr><a:lvl7pPr marL=\"2743200\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl7pPr><a:lvl8pPr marL=\"3200400\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl8pPr><a:lvl9pPr marL=\"3657600\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\"><a:defRPr sz=\"1200\" kern=\"1200\"><a:solidFill><a:schemeClr val=\"tx1\"/></a:solidFill><a:latin typeface=\"+mn-lt\"/><a:ea typeface=\"+mn-ea\"/><a:cs typeface=\"+mn-cs\"/></a:defRPr></a:lvl9pPr></p:notesStyle></p:notesMaster>");
  }
  /**
   * Creates Notes Slide (`ppt/notesSlides/notesSlide1.xml`)
   * @param {PresSlide} slide - the slide object to transform into XML
   * @return {string} XML
   */
  function makeXmlNotesSlide(slide) {
      return ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<p:notes xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"><p:cSld><p:spTree><p:nvGrpSpPr><p:cNvPr id=\"1\" name=\"\"/><p:cNvGrpSpPr/><p:nvPr/></p:nvGrpSpPr><p:grpSpPr><a:xfrm><a:off x=\"0\" y=\"0\"/><a:ext cx=\"0\" cy=\"0\"/><a:chOff x=\"0\" y=\"0\"/><a:chExt cx=\"0\" cy=\"0\"/></a:xfrm></p:grpSpPr><p:sp><p:nvSpPr><p:cNvPr id=\"2\" name=\"Slide Image Placeholder 1\"/><p:cNvSpPr><a:spLocks noGrp=\"1\" noRot=\"1\" noChangeAspect=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldImg\"/></p:nvPr></p:nvSpPr><p:spPr/></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"3\" name=\"Notes Placeholder 2\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"body\" idx=\"1\"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:r><a:rPr lang=\"en-US\" dirty=\"0\"/><a:t>").concat(encodeXmlEntities(getNotesFromSlide(slide)), "</a:t></a:r><a:endParaRPr lang=\"en-US\" dirty=\"0\"/></a:p></p:txBody></p:sp><p:sp><p:nvSpPr><p:cNvPr id=\"4\" name=\"Slide Number Placeholder 3\"/><p:cNvSpPr><a:spLocks noGrp=\"1\"/></p:cNvSpPr><p:nvPr><p:ph type=\"sldNum\" sz=\"quarter\" idx=\"10\"/></p:nvPr></p:nvSpPr><p:spPr/><p:txBody><a:bodyPr/><a:lstStyle/><a:p><a:fld id=\"").concat(SLDNUMFLDID, "\" type=\"slidenum\"><a:rPr lang=\"en-US\"/><a:t>").concat(slide._slideNum, "</a:t></a:fld><a:endParaRPr lang=\"en-US\"/></a:p></p:txBody></p:sp></p:spTree><p:extLst><p:ext uri=\"{BB962C8B-B14F-4D97-AF65-F5344CB8AC3E}\"><p14:creationId xmlns:p14=\"http://schemas.microsoft.com/office/powerpoint/2010/main\" val=\"1024086991\"/></p:ext></p:extLst></p:cSld><p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:notes>"));
  }
  /**
   * Generates the XML layout resource from a layout object
   * @param {SlideLayout} layout - slide layout (master)
   * @return {string} XML
   */
  function makeXmlLayout(layout) {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t\t<p:sldLayout xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\" preserve=\"1\">\n\t\t".concat(slideObjectToXml(layout), "\n\t\t<p:clrMapOvr><a:masterClrMapping/></p:clrMapOvr></p:sldLayout>");
  }
  /**
   * Creates Slide Master 1 (`ppt/slideMasters/slideMaster1.xml`)
   * @param {PresSlide} slide - slide object that represents master slide layout
   * @param {SlideLayout[]} layouts - slide layouts
   * @return {string} XML
   */
  function makeXmlMaster(slide, layouts) {
      // NOTE: Pass layouts as static rels because they are not referenced any time
      var layoutDefs = layouts.map(function (_layoutDef, idx) { return "<p:sldLayoutId id=\"".concat(LAYOUT_IDX_SERIES_BASE + idx, "\" r:id=\"rId").concat(slide._rels.length + idx + 1, "\"/>"); });
      var strXml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + CRLF;
      strXml +=
          '<p:sldMaster xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:p="http://schemas.openxmlformats.org/presentationml/2006/main">';
      strXml += slideObjectToXml(slide);
      strXml +=
          '<p:clrMap bg1="lt1" tx1="dk1" bg2="lt2" tx2="dk2" accent1="accent1" accent2="accent2" accent3="accent3" accent4="accent4" accent5="accent5" accent6="accent6" hlink="hlink" folHlink="folHlink"/>';
      strXml += '<p:sldLayoutIdLst>' + layoutDefs.join('') + '</p:sldLayoutIdLst>';
      strXml += '<p:hf sldNum="0" hdr="0" ftr="0" dt="0"/>';
      strXml +=
          '<p:txStyles>' +
              ' <p:titleStyle>' +
              '  <a:lvl1pPr algn="ctr" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="0"/></a:spcBef><a:buNone/><a:defRPr sz="4400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mj-lt"/><a:ea typeface="+mj-ea"/><a:cs typeface="+mj-cs"/></a:defRPr></a:lvl1pPr>' +
              ' </p:titleStyle>' +
              ' <p:bodyStyle>' +
              '  <a:lvl1pPr marL="342900" indent="-342900" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="3200" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>' +
              '  <a:lvl2pPr marL="742950" indent="-285750" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>' +
              '  <a:lvl3pPr marL="1143000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2400" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>' +
              '  <a:lvl4pPr marL="1600200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>' +
              '  <a:lvl5pPr marL="2057400" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>' +
              '  <a:lvl6pPr marL="2514600" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>' +
              '  <a:lvl7pPr marL="2971800" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>' +
              '  <a:lvl8pPr marL="3429000" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>' +
              '  <a:lvl9pPr marL="3886200" indent="-228600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:spcBef><a:spcPct val="20000"/></a:spcBef><a:buFont typeface="Arial" pitchFamily="34" charset="0"/><a:buChar char=""/><a:defRPr sz="2000" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr>' +
              ' </p:bodyStyle>' +
              ' <p:otherStyle>' +
              '  <a:defPPr><a:defRPr lang="en-US"/></a:defPPr>' +
              '  <a:lvl1pPr marL="0" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl1pPr>' +
              '  <a:lvl2pPr marL="457200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl2pPr>' +
              '  <a:lvl3pPr marL="914400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl3pPr>' +
              '  <a:lvl4pPr marL="1371600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl4pPr>' +
              '  <a:lvl5pPr marL="1828800" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl5pPr>' +
              '  <a:lvl6pPr marL="2286000" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl6pPr>' +
              '  <a:lvl7pPr marL="2743200" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl7pPr>' +
              '  <a:lvl8pPr marL="3200400" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl8pPr>' +
              '  <a:lvl9pPr marL="3657600" algn="l" defTabSz="914400" rtl="0" eaLnBrk="1" latinLnBrk="0" hangingPunct="1"><a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/></a:defRPr></a:lvl9pPr>' +
              ' </p:otherStyle>' +
              '</p:txStyles>';
      strXml += '</p:sldMaster>';
      return strXml;
  }
  /**
   * Generates XML string for a slide layout relation file
   * @param {number} layoutNumber - 1-indexed number of a layout that relations are generated for
   * @param {SlideLayout[]} slideLayouts - Slide Layouts
   * @return {string} XML
   */
  function makeXmlSlideLayoutRel(layoutNumber, slideLayouts) {
      return slideObjectRelationsToXml(slideLayouts[layoutNumber - 1], [
          {
              target: '../slideMasters/slideMaster1.xml',
              type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideMaster',
          },
      ]);
  }
  /**
   * Creates `ppt/_rels/slide*.xml.rels`
   * @param {PresSlide[]} slides
   * @param {SlideLayout[]} slideLayouts - Slide Layout(s)
   * @param {number} `slideNumber` 1-indexed number of a layout that relations are generated for
   * @return {string} XML
   */
  function makeXmlSlideRel(slides, slideLayouts, slideNumber) {
      return slideObjectRelationsToXml(slides[slideNumber - 1], [
          {
              target: "../slideLayouts/slideLayout".concat(getLayoutIdxForSlide(slides, slideLayouts, slideNumber), ".xml"),
              type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout',
          },
          {
              target: "../notesSlides/notesSlide".concat(slideNumber, ".xml"),
              type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesSlide',
          },
      ]);
  }
  /**
   * Generates XML string for a slide relation file.
   * @param {number} slideNumber - 1-indexed number of a layout that relations are generated for
   * @return {string} XML
   */
  function makeXmlNotesSlideRel(slideNumber) {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n\t\t<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n\t\t\t<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/notesMaster\" Target=\"../notesMasters/notesMaster1.xml\"/>\n\t\t\t<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/slide\" Target=\"../slides/slide".concat(slideNumber, ".xml\"/>\n\t\t</Relationships>");
  }
  /**
   * Creates `ppt/slideMasters/_rels/slideMaster1.xml.rels`
   * @param {PresSlide} masterSlide - Slide object
   * @param {SlideLayout[]} slideLayouts - Slide Layouts
   * @return {string} XML
   */
  function makeXmlMasterRel(masterSlide, slideLayouts) {
      var defaultRels = slideLayouts.map(function (_layoutDef, idx) { return ({
          target: "../slideLayouts/slideLayout".concat(idx + 1, ".xml"),
          type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/slideLayout',
      }); });
      defaultRels.push({ target: '../theme/theme1.xml', type: 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme' });
      return slideObjectRelationsToXml(masterSlide, defaultRels);
  }
  /**
   * Creates `ppt/notesMasters/_rels/notesMaster1.xml.rels`
   * @return {string} XML
   */
  function makeXmlNotesMasterRel() {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\n\t\t<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme\" Target=\"../theme/theme1.xml\"/>\n\t\t</Relationships>");
  }
  /**
   * For the passed slide number, resolves name of a layout that is used for.
   * @param {PresSlide[]} slides - srray of slides
   * @param {SlideLayout[]} slideLayouts - array of slideLayouts
   * @param {number} slideNumber
   * @return {number} slide number
   */
  function getLayoutIdxForSlide(slides, slideLayouts, slideNumber) {
      for (var i = 0; i < slideLayouts.length; i++) {
          if (slideLayouts[i]._name === slides[slideNumber - 1]._slideLayout._name) {
              return i + 1;
          }
      }
      // IMPORTANT: Return 1 (for `slideLayout1.xml`) when no def is found
      // So all objects are in Layout1 and every slide that references it uses this layout.
      return 1;
  }
  // XML-GEN: Last 5 functions create root /ppt files
  /**
   * Creates `ppt/theme/theme1.xml`
   * @return {string} XML
   */
  function makeXmlTheme(pres) {
      var _a, _b, _c, _d;
      var majorFont = ((_a = pres.theme) === null || _a === void 0 ? void 0 : _a.headFontFace) ? "<a:latin typeface=\"".concat((_b = pres.theme) === null || _b === void 0 ? void 0 : _b.headFontFace, "\"/>") : '<a:latin typeface="Calibri Light" panose="020F0302020204030204"/>';
      var minorFont = ((_c = pres.theme) === null || _c === void 0 ? void 0 : _c.bodyFontFace) ? "<a:latin typeface=\"".concat((_d = pres.theme) === null || _d === void 0 ? void 0 : _d.bodyFontFace, "\"/>") : '<a:latin typeface="Calibri" panose="020F0502020204030204"/>';
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"><a:themeElements><a:clrScheme name=\"Office\"><a:dk1><a:sysClr val=\"windowText\" lastClr=\"000000\"/></a:dk1><a:lt1><a:sysClr val=\"window\" lastClr=\"FFFFFF\"/></a:lt1><a:dk2><a:srgbClr val=\"44546A\"/></a:dk2><a:lt2><a:srgbClr val=\"E7E6E6\"/></a:lt2><a:accent1><a:srgbClr val=\"4472C4\"/></a:accent1><a:accent2><a:srgbClr val=\"ED7D31\"/></a:accent2><a:accent3><a:srgbClr val=\"A5A5A5\"/></a:accent3><a:accent4><a:srgbClr val=\"FFC000\"/></a:accent4><a:accent5><a:srgbClr val=\"5B9BD5\"/></a:accent5><a:accent6><a:srgbClr val=\"70AD47\"/></a:accent6><a:hlink><a:srgbClr val=\"0563C1\"/></a:hlink><a:folHlink><a:srgbClr val=\"954F72\"/></a:folHlink></a:clrScheme><a:fontScheme name=\"Office\"><a:majorFont>".concat(majorFont, "<a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"\u6E38\u30B4\u30B7\u30C3\u30AF Light\"/><a:font script=\"Hang\" typeface=\"\uB9D1\uC740 \uACE0\uB515\"/><a:font script=\"Hans\" typeface=\"\u7B49\u7EBF Light\"/><a:font script=\"Hant\" typeface=\"\u65B0\u7D30\u660E\u9AD4\"/><a:font script=\"Arab\" typeface=\"Times New Roman\"/><a:font script=\"Hebr\" typeface=\"Times New Roman\"/><a:font script=\"Thai\" typeface=\"Angsana New\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"MoolBoran\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Times New Roman\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/><a:font script=\"Armn\" typeface=\"Arial\"/><a:font script=\"Bugi\" typeface=\"Leelawadee UI\"/><a:font script=\"Bopo\" typeface=\"Microsoft JhengHei\"/><a:font script=\"Java\" typeface=\"Javanese Text\"/><a:font script=\"Lisu\" typeface=\"Segoe UI\"/><a:font script=\"Mymr\" typeface=\"Myanmar Text\"/><a:font script=\"Nkoo\" typeface=\"Ebrima\"/><a:font script=\"Olck\" typeface=\"Nirmala UI\"/><a:font script=\"Osma\" typeface=\"Ebrima\"/><a:font script=\"Phag\" typeface=\"Phagspa\"/><a:font script=\"Syrn\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syrj\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syre\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Sora\" typeface=\"Nirmala UI\"/><a:font script=\"Tale\" typeface=\"Microsoft Tai Le\"/><a:font script=\"Talu\" typeface=\"Microsoft New Tai Lue\"/><a:font script=\"Tfng\" typeface=\"Ebrima\"/></a:majorFont><a:minorFont>").concat(minorFont, "<a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"\u6E38\u30B4\u30B7\u30C3\u30AF\"/><a:font script=\"Hang\" typeface=\"\uB9D1\uC740 \uACE0\uB515\"/><a:font script=\"Hans\" typeface=\"\u7B49\u7EBF\"/><a:font script=\"Hant\" typeface=\"\u65B0\u7D30\u660E\u9AD4\"/><a:font script=\"Arab\" typeface=\"Arial\"/><a:font script=\"Hebr\" typeface=\"Arial\"/><a:font script=\"Thai\" typeface=\"Cordia New\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"DaunPenh\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Arial\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/><a:font script=\"Geor\" typeface=\"Sylfaen\"/><a:font script=\"Armn\" typeface=\"Arial\"/><a:font script=\"Bugi\" typeface=\"Leelawadee UI\"/><a:font script=\"Bopo\" typeface=\"Microsoft JhengHei\"/><a:font script=\"Java\" typeface=\"Javanese Text\"/><a:font script=\"Lisu\" typeface=\"Segoe UI\"/><a:font script=\"Mymr\" typeface=\"Myanmar Text\"/><a:font script=\"Nkoo\" typeface=\"Ebrima\"/><a:font script=\"Olck\" typeface=\"Nirmala UI\"/><a:font script=\"Osma\" typeface=\"Ebrima\"/><a:font script=\"Phag\" typeface=\"Phagspa\"/><a:font script=\"Syrn\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syrj\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Syre\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Sora\" typeface=\"Nirmala UI\"/><a:font script=\"Tale\" typeface=\"Microsoft Tai Le\"/><a:font script=\"Talu\" typeface=\"Microsoft New Tai Lue\"/><a:font script=\"Tfng\" typeface=\"Ebrima\"/></a:minorFont></a:fontScheme><a:fmtScheme name=\"Office\"><a:fillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"110000\"/><a:satMod val=\"105000\"/><a:tint val=\"67000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"103000\"/><a:tint val=\"73000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"105000\"/><a:satMod val=\"109000\"/><a:tint val=\"81000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:satMod val=\"103000\"/><a:lumMod val=\"102000\"/><a:tint val=\"94000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:satMod val=\"110000\"/><a:lumMod val=\"100000\"/><a:shade val=\"100000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:lumMod val=\"99000\"/><a:satMod val=\"120000\"/><a:shade val=\"78000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w=\"6350\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"12700\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln><a:ln w=\"19050\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/><a:miter lim=\"800000\"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"57150\" dist=\"19050\" dir=\"5400000\" algn=\"ctr\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"63000\"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:solidFill><a:schemeClr val=\"phClr\"><a:tint val=\"95000\"/><a:satMod val=\"170000\"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"93000\"/><a:satMod val=\"150000\"/><a:shade val=\"98000\"/><a:lumMod val=\"102000\"/></a:schemeClr></a:gs><a:gs pos=\"50000\"><a:schemeClr val=\"phClr\"><a:tint val=\"98000\"/><a:satMod val=\"130000\"/><a:shade val=\"90000\"/><a:lumMod val=\"103000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"63000\"/><a:satMod val=\"120000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"5400000\" scaled=\"0\"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri=\"{05A4C25C-085E-4340-85A3-A5531E510DB2}\"><thm15:themeFamily xmlns:thm15=\"http://schemas.microsoft.com/office/thememl/2012/main\" name=\"Office Theme\" id=\"{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}\" vid=\"{4A3C46E8-61CC-4603-A589-7422A47A8E4A}\"/></a:ext></a:extLst></a:theme>");
  }
  /**
   * Create presentation file (`ppt/presentation.xml`)
   * @see https://docs.microsoft.com/en-us/office/open-xml/structure-of-a-presentationml-document
   * @see http://www.datypic.com/sc/ooxml/t-p_CT_Presentation.html
   * @param {IPresentationProps} pres - presentation
   * @return {string} XML
   */
  function makeXmlPresentation(pres) {
      var strXml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF) +
          '<p:presentation xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" ' +
          "xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\" ".concat(pres.rtlMode ? 'rtl="1"' : '', " saveSubsetFonts=\"1\" autoCompressPictures=\"0\">");
      // STEP 1: Add slide master (SPEC: tag 1 under <presentation>)
      strXml += '<p:sldMasterIdLst><p:sldMasterId id="2147483648" r:id="rId1"/></p:sldMasterIdLst>';
      // STEP 2: Add all Slides (SPEC: tag 3 under <presentation>)
      strXml += '<p:sldIdLst>';
      pres.slides.forEach(function (slide) { return (strXml += "<p:sldId id=\"".concat(slide._slideId, "\" r:id=\"rId").concat(slide._rId, "\"/>")); });
      strXml += '</p:sldIdLst>';
      // STEP 3: Add Notes Master (SPEC: tag 2 under <presentation>)
      // (NOTE: length+2 is from `presentation.xml.rels` func (since we have to match this rId, we just use same logic))
      // IMPORTANT: In this order (matches PPT2019) PPT will give corruption message on open!
      // IMPORTANT: Placing this before `<p:sldIdLst>` causes warning in modern powerpoint!
      // IMPORTANT: Presentations open without warning Without this line, however, the pres isnt preview in Finder anymore or viewable in iOS!
      strXml += "<p:notesMasterIdLst><p:notesMasterId r:id=\"rId".concat(pres.slides.length + 2, "\"/></p:notesMasterIdLst>");
      // STEP 4: Add sizes
      strXml += "<p:sldSz cx=\"".concat(pres.presLayout.width, "\" cy=\"").concat(pres.presLayout.height, "\"/>");
      strXml += "<p:notesSz cx=\"".concat(pres.presLayout.height, "\" cy=\"").concat(pres.presLayout.width, "\"/>");
      // STEP 5: Add text styles
      strXml += '<p:defaultTextStyle>';
      for (var idy = 1; idy < 10; idy++) {
          strXml +=
              "<a:lvl".concat(idy, "pPr marL=\"").concat((idy - 1) * 457200, "\" algn=\"l\" defTabSz=\"914400\" rtl=\"0\" eaLnBrk=\"1\" latinLnBrk=\"0\" hangingPunct=\"1\">") +
                  '<a:defRPr sz="1800" kern="1200"><a:solidFill><a:schemeClr val="tx1"/></a:solidFill><a:latin typeface="+mn-lt"/><a:ea typeface="+mn-ea"/><a:cs typeface="+mn-cs"/>' +
                  "</a:defRPr></a:lvl".concat(idy, "pPr>");
      }
      strXml += '</p:defaultTextStyle>';
      // STEP 6: Add Sections (if any)
      if (pres.sections && pres.sections.length > 0) {
          strXml += '<p:extLst><p:ext uri="{521415D9-36F7-43E2-AB2F-B90AF26B5E84}">';
          strXml += '<p14:sectionLst xmlns:p14="http://schemas.microsoft.com/office/powerpoint/2010/main">';
          pres.sections.forEach(function (sect) {
              strXml += "<p14:section name=\"".concat(encodeXmlEntities(sect.title), "\" id=\"{").concat(getUuid('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'), "}\"><p14:sldIdLst>");
              sect._slides.forEach(function (slide) { return (strXml += "<p14:sldId id=\"".concat(slide._slideId, "\"/>")); });
              strXml += '</p14:sldIdLst></p14:section>';
          });
          strXml += '</p14:sectionLst></p:ext>';
          strXml += '<p:ext uri="{EFAFB233-063F-42B5-8137-9DF3F51BA10A}"><p15:sldGuideLst xmlns:p15="http://schemas.microsoft.com/office/powerpoint/2012/main"/></p:ext>';
          strXml += '</p:extLst>';
      }
      // Done
      strXml += '</p:presentation>';
      return strXml;
  }
  /**
   * Create `ppt/presProps.xml`
   * @return {string} XML
   */
  function makeXmlPresProps() {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<p:presentationPr xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"/>");
  }
  /**
   * Create `ppt/tableStyles.xml`
   * @see: http://openxmldeveloper.org/discussions/formats/f/13/p/2398/8107.aspx
   * @return {string} XML
   */
  function makeXmlTableStyles() {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<a:tblStyleLst xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" def=\"{5C22544A-7EE6-4342-B048-85BDC9FD1C3A}\"/>");
  }
  /**
   * Creates `ppt/viewProps.xml`
   * @return {string} XML
   */
  function makeXmlViewProps() {
      return "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>".concat(CRLF, "<p:viewPr xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:p=\"http://schemas.openxmlformats.org/presentationml/2006/main\"><p:normalViewPr horzBarState=\"maximized\"><p:restoredLeft sz=\"15611\"/><p:restoredTop sz=\"94610\"/></p:normalViewPr><p:slideViewPr><p:cSldViewPr snapToGrid=\"0\" snapToObjects=\"1\"><p:cViewPr varScale=\"1\"><p:scale><a:sx n=\"136\" d=\"100\"/><a:sy n=\"136\" d=\"100\"/></p:scale><p:origin x=\"216\" y=\"312\"/></p:cViewPr><p:guideLst/></p:cSldViewPr></p:slideViewPr><p:notesTextViewPr><p:cViewPr><p:scale><a:sx n=\"1\" d=\"1\"/><a:sy n=\"1\" d=\"1\"/></p:scale><p:origin x=\"0\" y=\"0\"/></p:cViewPr></p:notesTextViewPr><p:gridSpacing cx=\"76200\" cy=\"76200\"/></p:viewPr>");
  }

  /**
   *  :: pptxgen.ts ::
   *
   *  JavaScript framework that creates PowerPoint (pptx) presentations
   *  https://github.com/gitbrent/PptxGenJS
   *
   *  This framework is released under the MIT Public License (MIT)
   *
   *  PptxGenJS (C) 2015-present Brent Ely -- https://github.com/gitbrent
   *
   *  Some code derived from the OfficeGen project:
   *  github.com/Ziv-Barber/officegen/ (Copyright 2013 Ziv Barber)
   *
   *  Permission is hereby granted, free of charge, to any person obtaining a copy
   *  of this software and associated documentation files (the "Software"), to deal
   *  in the Software without restriction, including without limitation the rights
   *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   *  copies of the Software, and to permit persons to whom the Software is
   *  furnished to do so, subject to the following conditions:
   *
   *  The above copyright notice and this permission notice shall be included in all
   *  copies or substantial portions of the Software.
   *
   *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   *  SOFTWARE.
   */
  var VERSION = '3.12.0';
  var PptxGenJS$1 = /** @class */ (function () {
      function PptxGenJS() {
          var _this = this;
          /**
           * PptxGenJS Library Version
           */
          this._version = VERSION;
          // Exposed class props
          this._alignH = AlignH;
          this._alignV = AlignV;
          this._chartType = ChartType;
          this._outputType = OutputType;
          this._schemeColor = SchemeColor;
          this._shapeType = ShapeType;
          /**
           * @depricated use `ChartType`
           */
          this._charts = CHART_TYPE;
          /**
           * @depricated use `SchemeColor`
           */
          this._colors = SCHEME_COLOR_NAMES;
          /**
           * @depricated use `ShapeType`
           */
          this._shapes = SHAPE_TYPE;
          /**
           * Provides an API for `addTableDefinition` to create slides as needed for auto-paging
           * @param {AddSlideProps} options - slide masterName and/or sectionTitle
           * @return {PresSlide} new Slide
           */
          this.addNewSlide = function (options) {
              // Continue using sections if the first slide using auto-paging has a Section
              var sectAlreadyInUse = _this.sections.length > 0 &&
                  _this.sections[_this.sections.length - 1]._slides.filter(function (slide) { return slide._slideNum === _this.slides[_this.slides.length - 1]._slideNum; }).length > 0;
              options.sectionTitle = sectAlreadyInUse ? _this.sections[_this.sections.length - 1].title : null;
              return _this.addSlide(options);
          };
          /**
           * Provides an API for `addTableDefinition` to get slide reference by number
           * @param {number} slideNum - slide number
           * @return {PresSlide} Slide
           * @since 3.0.0
           */
          this.getSlide = function (slideNum) { return _this.slides.filter(function (slide) { return slide._slideNum === slideNum; })[0]; };
          /**
           * Enables the `Slide` class to set PptxGenJS [Presentation] master/layout slidenumbers
           * @param {SlideNumberProps} slideNum - slide number config
           */
          this.setSlideNumber = function (slideNum) {
              // 1: Add slideNumber to slideMaster1.xml
              _this.masterSlide._slideNumberProps = slideNum;
              // 2: Add slideNumber to DEF_PRES_LAYOUT_NAME layout
              _this.slideLayouts.filter(function (layout) { return layout._name === DEF_PRES_LAYOUT_NAME; })[0]._slideNumberProps = slideNum;
          };
          /**
           * Create all chart and media rels for this Presentation
           * @param {PresSlide | SlideLayout} slide - slide with rels
           * @param {JSZip} zip - JSZip instance
           * @param {Promise<string>[]} chartPromises - promise array
           */
          this.createChartMediaRels = function (slide, zip, chartPromises) {
              slide._relsChart.forEach(function (rel) { return chartPromises.push(createExcelWorksheet(rel, zip)); });
              slide._relsMedia.forEach(function (rel) {
                  if (rel.type !== 'online' && rel.type !== 'hyperlink') {
                      // A: Loop vars
                      var data = rel.data && typeof rel.data === 'string' ? rel.data : '';
                      // B: Users will undoubtedly pass various string formats, so correct prefixes as needed
                      if (!data.includes(',') && !data.includes(';'))
                          data = 'image/png;base64,' + data;
                      else if (!data.includes(','))
                          data = 'image/png;base64,' + data;
                      else if (!data.includes(';'))
                          data = 'image/png;' + data;
                      // C: Add media
                      zip.file(rel.Target.replace('..', 'ppt'), data.split(',').pop(), { base64: true });
                  }
              });
          };
          /**
           * Create and export the .pptx file
           * @param {string} exportName - output file type
           * @param {Blob} blobContent - Blob content
           * @return {Promise<string>} Promise with file name
           */
          this.writeFileToBrowser = function (exportName, blobContent) { return __awaiter(_this, void 0, void 0, function () {
              var eleLink, url_1;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          eleLink = document.createElement('a');
                          eleLink.setAttribute('style', 'display:none;');
                          eleLink.dataset.interception = 'off'; // @see https://docs.microsoft.com/en-us/sharepoint/dev/spfx/hyperlinking
                          document.body.appendChild(eleLink);
                          if (!window.URL.createObjectURL) return [3 /*break*/, 2];
                          url_1 = window.URL.createObjectURL(new Blob([blobContent], { type: 'application/vnd.openxmlformats-officedocument.presentationml.presentation' }));
                          eleLink.href = url_1;
                          eleLink.download = exportName;
                          eleLink.click();
                          // Clean-up (NOTE: Add a slight delay before removing to avoid 'blob:null' error in Firefox Issue#81)
                          setTimeout(function () {
                              window.URL.revokeObjectURL(url_1);
                              document.body.removeChild(eleLink);
                          }, 100);
                          return [4 /*yield*/, Promise.resolve(exportName)];
                      case 1: 
                      // Done
                      return [2 /*return*/, _a.sent()];
                      case 2: return [2 /*return*/];
                  }
              });
          }); };
          /**
           * Create and export the .pptx file
           * @param {WRITE_OUTPUT_TYPE} outputType - output file type
           * @return {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} Promise with data or stream (node) or filename (browser)
           */
          this.exportPresentation = function (props) { return __awaiter(_this, void 0, void 0, function () {
              var arrChartPromises, arrMediaPromises, zip;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          arrChartPromises = [];
                          arrMediaPromises = [];
                          zip = new JSZip();
                          // STEP 1: Read/Encode all Media before zip as base64 content, etc. is required
                          this.slides.forEach(function (slide) {
                              arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(slide));
                          });
                          this.slideLayouts.forEach(function (layout) {
                              arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(layout));
                          });
                          arrMediaPromises = arrMediaPromises.concat(encodeSlideMediaRels(this.masterSlide));
                          return [4 /*yield*/, Promise.all(arrMediaPromises).then(function () { return __awaiter(_this, void 0, void 0, function () {
                                  var _this = this;
                                  return __generator(this, function (_a) {
                                      switch (_a.label) {
                                          case 0:
                                              // A: Add empty placeholder objects to slides that don't already have them
                                              this.slides.forEach(function (slide) {
                                                  if (slide._slideLayout)
                                                      addPlaceholdersToSlideLayouts(slide);
                                              });
                                              // B: Add all required folders and files
                                              zip.folder('_rels');
                                              zip.folder('docProps');
                                              zip.folder('ppt').folder('_rels');
                                              zip.folder('ppt/charts').folder('_rels');
                                              zip.folder('ppt/embeddings');
                                              zip.folder('ppt/media');
                                              zip.folder('ppt/slideLayouts').folder('_rels');
                                              zip.folder('ppt/slideMasters').folder('_rels');
                                              zip.folder('ppt/slides').folder('_rels');
                                              zip.folder('ppt/theme');
                                              zip.folder('ppt/notesMasters').folder('_rels');
                                              zip.folder('ppt/notesSlides').folder('_rels');
                                              zip.file('[Content_Types].xml', makeXmlContTypes(this.slides, this.slideLayouts, this.masterSlide)); // TODO: pass only `this` like below! 20200206
                                              zip.file('_rels/.rels', makeXmlRootRels());
                                              zip.file('docProps/app.xml', makeXmlApp(this.slides, this.company)); // TODO: pass only `this` like below! 20200206
                                              zip.file('docProps/core.xml', makeXmlCore(this.title, this.subject, this.author, this.revision)); // TODO: pass only `this` like below! 20200206
                                              zip.file('ppt/_rels/presentation.xml.rels', makeXmlPresentationRels(this.slides));
                                              zip.file('ppt/theme/theme1.xml', makeXmlTheme(this));
                                              zip.file('ppt/presentation.xml', makeXmlPresentation(this));
                                              zip.file('ppt/presProps.xml', makeXmlPresProps());
                                              zip.file('ppt/tableStyles.xml', makeXmlTableStyles());
                                              zip.file('ppt/viewProps.xml', makeXmlViewProps());
                                              // C: Create a Layout/Master/Rel/Slide file for each SlideLayout and Slide
                                              this.slideLayouts.forEach(function (layout, idx) {
                                                  zip.file("ppt/slideLayouts/slideLayout".concat(idx + 1, ".xml"), makeXmlLayout(layout));
                                                  zip.file("ppt/slideLayouts/_rels/slideLayout".concat(idx + 1, ".xml.rels"), makeXmlSlideLayoutRel(idx + 1, _this.slideLayouts));
                                              });
                                              this.slides.forEach(function (slide, idx) {
                                                  zip.file("ppt/slides/slide".concat(idx + 1, ".xml"), makeXmlSlide(slide));
                                                  zip.file("ppt/slides/_rels/slide".concat(idx + 1, ".xml.rels"), makeXmlSlideRel(_this.slides, _this.slideLayouts, idx + 1));
                                                  // Create all slide notes related items. Notes of empty strings are created for slides which do not have notes specified, to keep track of _rels.
                                                  zip.file("ppt/notesSlides/notesSlide".concat(idx + 1, ".xml"), makeXmlNotesSlide(slide));
                                                  zip.file("ppt/notesSlides/_rels/notesSlide".concat(idx + 1, ".xml.rels"), makeXmlNotesSlideRel(idx + 1));
                                              });
                                              zip.file('ppt/slideMasters/slideMaster1.xml', makeXmlMaster(this.masterSlide, this.slideLayouts));
                                              zip.file('ppt/slideMasters/_rels/slideMaster1.xml.rels', makeXmlMasterRel(this.masterSlide, this.slideLayouts));
                                              zip.file('ppt/notesMasters/notesMaster1.xml', makeXmlNotesMaster());
                                              zip.file('ppt/notesMasters/_rels/notesMaster1.xml.rels', makeXmlNotesMasterRel());
                                              // D: Create all Rels (images, media, chart data)
                                              this.slideLayouts.forEach(function (layout) {
                                                  _this.createChartMediaRels(layout, zip, arrChartPromises);
                                              });
                                              this.slides.forEach(function (slide) {
                                                  _this.createChartMediaRels(slide, zip, arrChartPromises);
                                              });
                                              this.createChartMediaRels(this.masterSlide, zip, arrChartPromises);
                                              return [4 /*yield*/, Promise.all(arrChartPromises).then(function () { return __awaiter(_this, void 0, void 0, function () {
                                                      return __generator(this, function (_a) {
                                                          switch (_a.label) {
                                                              case 0:
                                                                  if (!(props.outputType === 'STREAM')) return [3 /*break*/, 2];
                                                                  return [4 /*yield*/, zip.generateAsync({ type: 'nodebuffer', compression: props.compression ? 'DEFLATE' : 'STORE' })];
                                                              case 1: 
                                                              // A: stream file
                                                              return [2 /*return*/, _a.sent()];
                                                              case 2:
                                                                  if (!props.outputType) return [3 /*break*/, 4];
                                                                  return [4 /*yield*/, zip.generateAsync({ type: props.outputType })];
                                                              case 3: 
                                                              // B: Node [fs]: Output type user option or default
                                                              return [2 /*return*/, _a.sent()];
                                                              case 4: return [4 /*yield*/, zip.generateAsync({ type: 'blob', compression: props.compression ? 'DEFLATE' : 'STORE' })];
                                                              case 5: 
                                                              // C: Browser: Output blob as app/ms-pptx
                                                              return [2 /*return*/, _a.sent()];
                                                          }
                                                      });
                                                  }); })];
                                          case 1: 
                                          // E: Wait for Promises (if any) then generate the PPTX file
                                          return [2 /*return*/, _a.sent()];
                                      }
                                  });
                              }); })];
                      case 1: 
                      // STEP 2: Wait for Promises (if any) then generate the PPTX file
                      return [2 /*return*/, _a.sent()];
                  }
              });
          }); };
          var layout4x3 = { name: 'screen4x3', width: 9144000, height: 6858000 };
          var layout16x9 = { name: 'screen16x9', width: 9144000, height: 5143500 };
          var layout16x10 = { name: 'screen16x10', width: 9144000, height: 5715000 };
          var layoutWide = { name: 'custom', width: 12192000, height: 6858000 };
          // Set available layouts
          this.LAYOUTS = {
              LAYOUT_4x3: layout4x3,
              LAYOUT_16x9: layout16x9,
              LAYOUT_16x10: layout16x10,
              LAYOUT_WIDE: layoutWide,
          };
          // Core
          this._author = 'PptxGenJS';
          this._company = 'PptxGenJS';
          this._revision = '1'; // Note: Must be a whole number
          this._subject = 'PptxGenJS Presentation';
          this._title = 'PptxGenJS Presentation';
          // PptxGenJS props
          this._presLayout = {
              name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
              _sizeW: this.LAYOUTS[DEF_PRES_LAYOUT].width,
              _sizeH: this.LAYOUTS[DEF_PRES_LAYOUT].height,
              width: this.LAYOUTS[DEF_PRES_LAYOUT].width,
              height: this.LAYOUTS[DEF_PRES_LAYOUT].height,
          };
          this._rtlMode = false;
          //
          this._slideLayouts = [
              {
                  _margin: DEF_SLIDE_MARGIN_IN,
                  _name: DEF_PRES_LAYOUT_NAME,
                  _presLayout: this._presLayout,
                  _rels: [],
                  _relsChart: [],
                  _relsMedia: [],
                  _slide: null,
                  _slideNum: 1000,
                  _slideNumberProps: null,
                  _slideObjects: [],
              },
          ];
          this._slides = [];
          this._sections = [];
          this._masterSlide = {
              addChart: null,
              addImage: null,
              addMedia: null,
              addNotes: null,
              addShape: null,
              addTable: null,
              addText: null,
              //
              _name: null,
              _presLayout: this._presLayout,
              _rId: null,
              _rels: [],
              _relsChart: [],
              _relsMedia: [],
              _slideId: null,
              _slideLayout: null,
              _slideNum: null,
              _slideNumberProps: null,
              _slideObjects: [],
          };
      }
      Object.defineProperty(PptxGenJS.prototype, "layout", {
          get: function () {
              return this._layout;
          },
          set: function (value) {
              var newLayout = this.LAYOUTS[value];
              if (newLayout) {
                  this._layout = value;
                  this._presLayout = newLayout;
              }
              else {
                  throw new Error('UNKNOWN-LAYOUT');
              }
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "version", {
          get: function () {
              return this._version;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "author", {
          get: function () {
              return this._author;
          },
          set: function (value) {
              this._author = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "company", {
          get: function () {
              return this._company;
          },
          set: function (value) {
              this._company = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "revision", {
          get: function () {
              return this._revision;
          },
          set: function (value) {
              this._revision = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "subject", {
          get: function () {
              return this._subject;
          },
          set: function (value) {
              this._subject = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "theme", {
          get: function () {
              return this._theme;
          },
          set: function (value) {
              this._theme = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "title", {
          get: function () {
              return this._title;
          },
          set: function (value) {
              this._title = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "rtlMode", {
          get: function () {
              return this._rtlMode;
          },
          set: function (value) {
              this._rtlMode = value;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "masterSlide", {
          get: function () {
              return this._masterSlide;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "slides", {
          get: function () {
              return this._slides;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "sections", {
          get: function () {
              return this._sections;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "slideLayouts", {
          get: function () {
              return this._slideLayouts;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "AlignH", {
          get: function () {
              return this._alignH;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "AlignV", {
          get: function () {
              return this._alignV;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "ChartType", {
          get: function () {
              return this._chartType;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "OutputType", {
          get: function () {
              return this._outputType;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "presLayout", {
          get: function () {
              return this._presLayout;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "SchemeColor", {
          get: function () {
              return this._schemeColor;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "ShapeType", {
          get: function () {
              return this._shapeType;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "charts", {
          get: function () {
              return this._charts;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "colors", {
          get: function () {
              return this._colors;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(PptxGenJS.prototype, "shapes", {
          get: function () {
              return this._shapes;
          },
          enumerable: false,
          configurable: true
      });
      // EXPORT METHODS
      /**
       * Export the current Presentation to stream
       * @param {WriteBaseProps} props - output properties
       * @returns {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} file stream
       */
      PptxGenJS.prototype.stream = function (props) {
          return __awaiter(this, void 0, void 0, function () {
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0: return [4 /*yield*/, this.exportPresentation({
                              compression: props === null || props === void 0 ? void 0 : props.compression,
                              outputType: 'STREAM',
                          })];
                      case 1: return [2 /*return*/, _a.sent()];
                  }
              });
          });
      };
      /**
       * Export the current Presentation as JSZip content with the selected type
       * @param {WriteProps} props output properties
       * @returns {Promise<string | ArrayBuffer | Blob | Buffer | Uint8Array>} file content in selected type
       */
      PptxGenJS.prototype.write = function (props) {
          return __awaiter(this, void 0, void 0, function () {
              var propsOutpType, propsCompress;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          propsOutpType = typeof props === 'object' && (props === null || props === void 0 ? void 0 : props.outputType) ? props.outputType : props ? props : null;
                          propsCompress = typeof props === 'object' && (props === null || props === void 0 ? void 0 : props.compression) ? props.compression : false;
                          return [4 /*yield*/, this.exportPresentation({
                                  compression: propsCompress,
                                  outputType: propsOutpType,
                              })];
                      case 1: return [2 /*return*/, _a.sent()];
                  }
              });
          });
      };
      /**
       * Export the current Presentation. Writes file to local file system if `fs` exists, otherwise, initiates download in browsers
       * @param {WriteFileProps} props - output file properties
       * @returns {Promise<string>} the presentation name
       */
      PptxGenJS.prototype.writeFile = function (props) {
          return __awaiter(this, void 0, void 0, function () {
              var fs, propsExpName, propsCompress, fileName;
              var _this = this;
              return __generator(this, function (_a) {
                  switch (_a.label) {
                      case 0:
                          fs = typeof commonjsRequire !== 'undefined' && typeof window === 'undefined' ? require$$0 : null // NodeJS
                          ;
                          // DEPRECATED: @deprecated v3.5.0 - fileName - [[remove in v4.0.0]]
                          if (typeof props === 'string')
                              console.log('Warning: `writeFile(filename)` is deprecated - please use `WriteFileProps` argument (v3.5.0)');
                          propsExpName = typeof props === 'object' && (props === null || props === void 0 ? void 0 : props.fileName) ? props.fileName : typeof props === 'string' ? props : '';
                          propsCompress = typeof props === 'object' && (props === null || props === void 0 ? void 0 : props.compression) ? props.compression : false;
                          fileName = propsExpName ? (propsExpName.toString().toLowerCase().endsWith('.pptx') ? propsExpName : propsExpName + '.pptx') : 'Presentation.pptx';
                          return [4 /*yield*/, this.exportPresentation({
                                  compression: propsCompress,
                                  outputType: fs ? 'nodebuffer' : null,
                              }).then(function (content) { return __awaiter(_this, void 0, void 0, function () {
                                  return __generator(this, function (_a) {
                                      switch (_a.label) {
                                          case 0:
                                              if (!fs) return [3 /*break*/, 2];
                                              return [4 /*yield*/, new Promise(function (resolve, reject) {
                                                      fs.writeFile(fileName, content, function (err) {
                                                          if (err) {
                                                              reject(err);
                                                          }
                                                          else {
                                                              resolve(fileName);
                                                          }
                                                      });
                                                  })];
                                          case 1: 
                                          // Node: Output
                                          return [2 /*return*/, _a.sent()];
                                          case 2: return [4 /*yield*/, this.writeFileToBrowser(fileName, content)];
                                          case 3: 
                                          // Browser: Output blob as app/ms-pptx
                                          return [2 /*return*/, _a.sent()];
                                      }
                                  });
                              }); })];
                      case 1: return [2 /*return*/, _a.sent()];
                  }
              });
          });
      };
      // PRESENTATION METHODS
      /**
       * Add a new Section to Presentation
       * @param {ISectionProps} section - section properties
       * @example pptx.addSection({ title:'Charts' });
       */
      PptxGenJS.prototype.addSection = function (section) {
          if (!section)
              console.warn('addSection requires an argument');
          else if (!section.title)
              console.warn('addSection requires a title');
          var newSection = {
              _type: 'user',
              _slides: [],
              title: section.title,
          };
          if (section.order)
              this.sections.splice(section.order, 0, newSection);
          else
              this._sections.push(newSection);
      };
      /**
       * Add a new Slide to Presentation
       * @param {AddSlideProps} options - slide options
       * @returns {PresSlide} the new Slide
       */
      PptxGenJS.prototype.addSlide = function (options) {
          // TODO: DEPRECATED: arg0 string "masterSlideName" dep as of 3.2.0
          var masterSlideName = typeof options === 'string' ? options : (options === null || options === void 0 ? void 0 : options.masterName) ? options.masterName : '';
          var slideLayout = {
              _name: this.LAYOUTS[DEF_PRES_LAYOUT].name,
              _presLayout: this.presLayout,
              _rels: [],
              _relsChart: [],
              _relsMedia: [],
              _slideNum: this.slides.length + 1,
          };
          if (masterSlideName) {
              var tmpLayout = this.slideLayouts.filter(function (layout) { return layout._name === masterSlideName; })[0];
              if (tmpLayout)
                  slideLayout = tmpLayout;
          }
          var newSlide = new Slide({
              addSlide: this.addNewSlide,
              getSlide: this.getSlide,
              presLayout: this.presLayout,
              setSlideNum: this.setSlideNumber,
              slideId: this.slides.length + 256,
              slideRId: this.slides.length + 2,
              slideNumber: this.slides.length + 1,
              slideLayout: slideLayout,
          });
          // A: Add slide to pres
          this._slides.push(newSlide);
          // B: Sections
          // B-1: Add slide to section (if any provided)
          // B-2: Handle slides without a section when sections are already is use ("loose" slides arent allowed, they all need a section)
          if (options === null || options === void 0 ? void 0 : options.sectionTitle) {
              var sect = this.sections.filter(function (section) { return section.title === options.sectionTitle; })[0];
              if (!sect)
                  console.warn("addSlide: unable to find section with title: \"".concat(options.sectionTitle, "\""));
              else
                  sect._slides.push(newSlide);
          }
          else if (this.sections && this.sections.length > 0 && (!(options === null || options === void 0 ? void 0 : options.sectionTitle))) {
              var lastSect = this._sections[this.sections.length - 1];
              // CASE 1: The latest section is a default type - just add this one
              if (lastSect._type === 'default')
                  lastSect._slides.push(newSlide);
              // CASE 2: There latest section is NOT a default type - create the defualt, add this slide
              else {
                  this._sections.push({
                      title: "Default-".concat(this.sections.filter(function (sect) { return sect._type === 'default'; }).length + 1),
                      _type: 'default',
                      _slides: [newSlide],
                  });
              }
          }
          return newSlide;
      };
      /**
       * Create a custom Slide Layout in any size
       * @param {PresLayout} layout - layout properties
       * @example pptx.defineLayout({ name:'A3', width:16.5, height:11.7 });
       */
      PptxGenJS.prototype.defineLayout = function (layout) {
          // @see https://support.office.com/en-us/article/Change-the-size-of-your-slides-040a811c-be43-40b9-8d04-0de5ed79987e
          if (!layout)
              console.warn('defineLayout requires `{name, width, height}`');
          else if (!layout.name)
              console.warn('defineLayout requires `name`');
          else if (!layout.width)
              console.warn('defineLayout requires `width`');
          else if (!layout.height)
              console.warn('defineLayout requires `height`');
          else if (typeof layout.height !== 'number')
              console.warn('defineLayout `height` should be a number (inches)');
          else if (typeof layout.width !== 'number')
              console.warn('defineLayout `width` should be a number (inches)');
          this.LAYOUTS[layout.name] = {
              name: layout.name,
              _sizeW: Math.round(Number(layout.width) * EMU),
              _sizeH: Math.round(Number(layout.height) * EMU),
              width: Math.round(Number(layout.width) * EMU),
              height: Math.round(Number(layout.height) * EMU),
          };
      };
      /**
       * Create a new slide master [layout] for the Presentation
       * @param {SlideMasterProps} props - layout properties
       */
      PptxGenJS.prototype.defineSlideMaster = function (props) {
          if (!props.title)
              throw new Error('defineSlideMaster() object argument requires a `title` value. (https://gitbrent.github.io/PptxGenJS/docs/masters.html)');
          var newLayout = {
              _margin: props.margin || DEF_SLIDE_MARGIN_IN,
              _name: props.title,
              _presLayout: this.presLayout,
              _rels: [],
              _relsChart: [],
              _relsMedia: [],
              _slide: null,
              _slideNum: 1000 + this.slideLayouts.length + 1,
              _slideNumberProps: props.slideNumber || null,
              _slideObjects: [],
              background: props.background || null,
              bkgd: props.bkgd || null,
          };
          // STEP 1: Create the Slide Master/Layout
          createSlideMaster(props, newLayout);
          // STEP 2: Add it to layout defs
          this.slideLayouts.push(newLayout);
          // STEP 3: Add background (image data/path must be captured before `exportPresentation()` is called)
          if (props.background || props.bkgd)
              addBackgroundDefinition(props.background, newLayout);
          // STEP 4: Add slideNumber to master slide (if any)
          if (newLayout._slideNumberProps && !this.masterSlide._slideNumberProps)
              this.masterSlide._slideNumberProps = newLayout._slideNumberProps;
      };
      // HTML-TO-SLIDES METHODS
      /**
       * Reproduces an HTML table as a PowerPoint table - including column widths, style, etc. - creates 1 or more slides as needed
       * @param {string} eleId - table HTML element ID
       * @param {TableToSlidesProps} options - generation options
       */
      PptxGenJS.prototype.tableToSlides = function (eleId, options) {
          if (options === void 0) { options = {}; }
          // @note `verbose` option is undocumented; used for verbose output of layout process
          genTableToSlides(this, eleId, options, (options === null || options === void 0 ? void 0 : options.masterSlideName) ? this.slideLayouts.filter(function (layout) { return layout._name === options.masterSlideName; })[0] : null);
      };
      return PptxGenJS;
  }());

  var PptxGenJSImport = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': PptxGenJS$1
  });

  var html2canvas$2 = {exports: {}};

  /*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  var html2canvas$1 = html2canvas$2.exports;

  var hasRequiredHtml2canvas;

  function requireHtml2canvas () {
  	if (hasRequiredHtml2canvas) return html2canvas$2.exports;
  	hasRequiredHtml2canvas = 1;
  	(function (module, exports) {
  		(function (global, factory) {
  		    module.exports = factory() ;
  		}(html2canvas$1, (function () {
  		    /*! *****************************************************************************
  		    Copyright (c) Microsoft Corporation.

  		    Permission to use, copy, modify, and/or distribute this software for any
  		    purpose with or without fee is hereby granted.

  		    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  		    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  		    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  		    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  		    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  		    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  		    PERFORMANCE OF THIS SOFTWARE.
  		    ***************************************************************************** */
  		    /* global Reflect, Promise */

  		    var extendStatics = function(d, b) {
  		        extendStatics = Object.setPrototypeOf ||
  		            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
  		            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  		        return extendStatics(d, b);
  		    };

  		    function __extends(d, b) {
  		        if (typeof b !== "function" && b !== null)
  		            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  		        extendStatics(d, b);
  		        function __() { this.constructor = d; }
  		        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  		    }

  		    var __assign = function() {
  		        __assign = Object.assign || function __assign(t) {
  		            for (var s, i = 1, n = arguments.length; i < n; i++) {
  		                s = arguments[i];
  		                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
  		            }
  		            return t;
  		        };
  		        return __assign.apply(this, arguments);
  		    };

  		    function __awaiter(thisArg, _arguments, P, generator) {
  		        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  		        return new (P || (P = Promise))(function (resolve, reject) {
  		            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
  		            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
  		            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
  		            step((generator = generator.apply(thisArg, _arguments || [])).next());
  		        });
  		    }

  		    function __generator(thisArg, body) {
  		        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
  		        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  		        function verb(n) { return function (v) { return step([n, v]); }; }
  		        function step(op) {
  		            if (f) throw new TypeError("Generator is already executing.");
  		            while (_) try {
  		                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
  		                if (y = 0, t) op = [op[0] & 2, t.value];
  		                switch (op[0]) {
  		                    case 0: case 1: t = op; break;
  		                    case 4: _.label++; return { value: op[1], done: false };
  		                    case 5: _.label++; y = op[1]; op = [0]; continue;
  		                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
  		                    default:
  		                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
  		                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
  		                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
  		                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
  		                        if (t[2]) _.ops.pop();
  		                        _.trys.pop(); continue;
  		                }
  		                op = body.call(thisArg, _);
  		            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
  		            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  		        }
  		    }

  		    function __spreadArray(to, from, pack) {
  		        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
  		            if (ar || !(i in from)) {
  		                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
  		                ar[i] = from[i];
  		            }
  		        }
  		        return to.concat(ar || from);
  		    }

  		    var Bounds = /** @class */ (function () {
  		        function Bounds(left, top, width, height) {
  		            this.left = left;
  		            this.top = top;
  		            this.width = width;
  		            this.height = height;
  		        }
  		        Bounds.prototype.add = function (x, y, w, h) {
  		            return new Bounds(this.left + x, this.top + y, this.width + w, this.height + h);
  		        };
  		        Bounds.fromClientRect = function (context, clientRect) {
  		            return new Bounds(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
  		        };
  		        Bounds.fromDOMRectList = function (context, domRectList) {
  		            var domRect = Array.from(domRectList).find(function (rect) { return rect.width !== 0; });
  		            return domRect
  		                ? new Bounds(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height)
  		                : Bounds.EMPTY;
  		        };
  		        Bounds.EMPTY = new Bounds(0, 0, 0, 0);
  		        return Bounds;
  		    }());
  		    var parseBounds = function (context, node) {
  		        return Bounds.fromClientRect(context, node.getBoundingClientRect());
  		    };
  		    var parseDocumentSize = function (document) {
  		        var body = document.body;
  		        var documentElement = document.documentElement;
  		        if (!body || !documentElement) {
  		            throw new Error("Unable to get document size");
  		        }
  		        var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  		        var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  		        return new Bounds(0, 0, width, height);
  		    };

  		    /*
  		     * css-line-break 2.1.0 <https://github.com/niklasvh/css-line-break#readme>
  		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
  		     * Released under MIT License
  		     */
  		    var toCodePoints$1 = function (str) {
  		        var codePoints = [];
  		        var i = 0;
  		        var length = str.length;
  		        while (i < length) {
  		            var value = str.charCodeAt(i++);
  		            if (value >= 0xd800 && value <= 0xdbff && i < length) {
  		                var extra = str.charCodeAt(i++);
  		                if ((extra & 0xfc00) === 0xdc00) {
  		                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
  		                }
  		                else {
  		                    codePoints.push(value);
  		                    i--;
  		                }
  		            }
  		            else {
  		                codePoints.push(value);
  		            }
  		        }
  		        return codePoints;
  		    };
  		    var fromCodePoint$1 = function () {
  		        var codePoints = [];
  		        for (var _i = 0; _i < arguments.length; _i++) {
  		            codePoints[_i] = arguments[_i];
  		        }
  		        if (String.fromCodePoint) {
  		            return String.fromCodePoint.apply(String, codePoints);
  		        }
  		        var length = codePoints.length;
  		        if (!length) {
  		            return '';
  		        }
  		        var codeUnits = [];
  		        var index = -1;
  		        var result = '';
  		        while (++index < length) {
  		            var codePoint = codePoints[index];
  		            if (codePoint <= 0xffff) {
  		                codeUnits.push(codePoint);
  		            }
  		            else {
  		                codePoint -= 0x10000;
  		                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
  		            }
  		            if (index + 1 === length || codeUnits.length > 0x4000) {
  		                result += String.fromCharCode.apply(String, codeUnits);
  		                codeUnits.length = 0;
  		            }
  		        }
  		        return result;
  		    };
  		    var chars$2 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  		    // Use a lookup table to find the index.
  		    var lookup$2 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  		    for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  		        lookup$2[chars$2.charCodeAt(i$2)] = i$2;
  		    }

  		    /*
  		     * utrie 1.0.2 <https://github.com/niklasvh/utrie>
  		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
  		     * Released under MIT License
  		     */
  		    var chars$1$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  		    // Use a lookup table to find the index.
  		    var lookup$1$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  		    for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  		        lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
  		    }
  		    var decode$1 = function (base64) {
  		        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  		        if (base64[base64.length - 1] === '=') {
  		            bufferLength--;
  		            if (base64[base64.length - 2] === '=') {
  		                bufferLength--;
  		            }
  		        }
  		        var buffer = typeof ArrayBuffer !== 'undefined' &&
  		            typeof Uint8Array !== 'undefined' &&
  		            typeof Uint8Array.prototype.slice !== 'undefined'
  		            ? new ArrayBuffer(bufferLength)
  		            : new Array(bufferLength);
  		        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  		        for (i = 0; i < len; i += 4) {
  		            encoded1 = lookup$1$1[base64.charCodeAt(i)];
  		            encoded2 = lookup$1$1[base64.charCodeAt(i + 1)];
  		            encoded3 = lookup$1$1[base64.charCodeAt(i + 2)];
  		            encoded4 = lookup$1$1[base64.charCodeAt(i + 3)];
  		            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
  		            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
  		            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
  		        }
  		        return buffer;
  		    };
  		    var polyUint16Array$1 = function (buffer) {
  		        var length = buffer.length;
  		        var bytes = [];
  		        for (var i = 0; i < length; i += 2) {
  		            bytes.push((buffer[i + 1] << 8) | buffer[i]);
  		        }
  		        return bytes;
  		    };
  		    var polyUint32Array$1 = function (buffer) {
  		        var length = buffer.length;
  		        var bytes = [];
  		        for (var i = 0; i < length; i += 4) {
  		            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
  		        }
  		        return bytes;
  		    };

  		    /** Shift size for getting the index-2 table offset. */
  		    var UTRIE2_SHIFT_2$1 = 5;
  		    /** Shift size for getting the index-1 table offset. */
  		    var UTRIE2_SHIFT_1$1 = 6 + 5;
  		    /**
  		     * Shift size for shifting left the index array values.
  		     * Increases possible data size with 16-bit index values at the cost
  		     * of compactability.
  		     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
  		     */
  		    var UTRIE2_INDEX_SHIFT$1 = 2;
  		    /**
  		     * Difference between the two shift sizes,
  		     * for getting an index-1 offset from an index-2 offset. 6=11-5
  		     */
  		    var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
  		    /**
  		     * The part of the index-2 table for U+D800..U+DBFF stores values for
  		     * lead surrogate code _units_ not code _points_.
  		     * Values for lead surrogate code _points_ are indexed with this portion of the table.
  		     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
  		     */
  		    var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 0x10000 >> UTRIE2_SHIFT_2$1;
  		    /** Number of entries in a data block. 32=0x20 */
  		    var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
  		    /** Mask for getting the lower bits for the in-data-block offset. */
  		    var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
  		    var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 0x400 >> UTRIE2_SHIFT_2$1;
  		    /** Count the lengths of both BMP pieces. 2080=0x820 */
  		    var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
  		    /**
  		     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
  		     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
  		     */
  		    var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
  		    var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  		    /**
  		     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
  		     * Variable length, for code points up to highStart, where the last single-value range starts.
  		     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
  		     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
  		     *
  		     * The part of the index-2 table for supplementary code points starts
  		     * after this index-1 table.
  		     *
  		     * Both the index-1 table and the following part of the index-2 table
  		     * are omitted completely if there is only BMP data.
  		     */
  		    var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
  		    /**
  		     * Number of index-1 entries for the BMP. 32=0x20
  		     * This part of the index-1 table is omitted from the serialized form.
  		     */
  		    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 0x10000 >> UTRIE2_SHIFT_1$1;
  		    /** Number of entries in an index-2 block. 64=0x40 */
  		    var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
  		    /** Mask for getting the lower bits for the in-index-2-block offset. */
  		    var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
  		    var slice16$1 = function (view, start, end) {
  		        if (view.slice) {
  		            return view.slice(start, end);
  		        }
  		        return new Uint16Array(Array.prototype.slice.call(view, start, end));
  		    };
  		    var slice32$1 = function (view, start, end) {
  		        if (view.slice) {
  		            return view.slice(start, end);
  		        }
  		        return new Uint32Array(Array.prototype.slice.call(view, start, end));
  		    };
  		    var createTrieFromBase64$1 = function (base64, _byteLength) {
  		        var buffer = decode$1(base64);
  		        var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
  		        var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
  		        var headerLength = 24;
  		        var index = slice16$1(view16, headerLength / 2, view32[4] / 2);
  		        var data = view32[5] === 2
  		            ? slice16$1(view16, (headerLength + view32[4]) / 2)
  		            : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  		        return new Trie$1(view32[0], view32[1], view32[2], view32[3], index, data);
  		    };
  		    var Trie$1 = /** @class */ (function () {
  		        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
  		            this.initialValue = initialValue;
  		            this.errorValue = errorValue;
  		            this.highStart = highStart;
  		            this.highValueIndex = highValueIndex;
  		            this.index = index;
  		            this.data = data;
  		        }
  		        /**
  		         * Get the value for a code point as stored in the Trie.
  		         *
  		         * @param codePoint the code point
  		         * @return the value
  		         */
  		        Trie.prototype.get = function (codePoint) {
  		            var ix;
  		            if (codePoint >= 0) {
  		                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
  		                    // Ordinary BMP code point, excluding leading surrogates.
  		                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
  		                    // 16 bit data is stored in the index array itself.
  		                    ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
  		                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
  		                    return this.data[ix];
  		                }
  		                if (codePoint <= 0xffff) {
  		                    // Lead Surrogate Code Point.  A Separate index section is stored for
  		                    // lead surrogate code units and code points.
  		                    //   The main index has the code unit data.
  		                    //   For this function, we need the code point data.
  		                    // Note: this expression could be refactored for slightly improved efficiency, but
  		                    //       surrogate code points will be so rare in practice that it's not worth it.
  		                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2$1)];
  		                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
  		                    return this.data[ix];
  		                }
  		                if (codePoint < this.highStart) {
  		                    // Supplemental code point, use two-level lookup.
  		                    ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
  		                    ix = this.index[ix];
  		                    ix += (codePoint >> UTRIE2_SHIFT_2$1) & UTRIE2_INDEX_2_MASK$1;
  		                    ix = this.index[ix];
  		                    ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
  		                    return this.data[ix];
  		                }
  		                if (codePoint <= 0x10ffff) {
  		                    return this.data[this.highValueIndex];
  		                }
  		            }
  		            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
  		            return this.errorValue;
  		        };
  		        return Trie;
  		    }());

  		    /*
  		     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
  		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
  		     * Released under MIT License
  		     */
  		    var chars$3 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  		    // Use a lookup table to find the index.
  		    var lookup$3 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  		    for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  		        lookup$3[chars$3.charCodeAt(i$3)] = i$3;
  		    }

  		    var base64$1 = 'KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==';

  		    var LETTER_NUMBER_MODIFIER = 50;
  		    // Non-tailorable Line Breaking Classes
  		    var BK = 1; //  Cause a line break (after)
  		    var CR$1 = 2; //  Cause a line break (after), except between CR and LF
  		    var LF$1 = 3; //  Cause a line break (after)
  		    var CM = 4; //  Prohibit a line break between the character and the preceding character
  		    var NL = 5; //  Cause a line break (after)
  		    var WJ = 7; //  Prohibit line breaks before and after
  		    var ZW = 8; //  Provide a break opportunity
  		    var GL = 9; //  Prohibit line breaks before and after
  		    var SP = 10; // Enable indirect line breaks
  		    var ZWJ$1 = 11; // Prohibit line breaks within joiner sequences
  		    // Break Opportunities
  		    var B2 = 12; //  Provide a line break opportunity before and after the character
  		    var BA = 13; //  Generally provide a line break opportunity after the character
  		    var BB = 14; //  Generally provide a line break opportunity before the character
  		    var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
  		    var CB = 16; //   Provide a line break opportunity contingent on additional information
  		    // Characters Prohibiting Certain Breaks
  		    var CL = 17; //  Prohibit line breaks before
  		    var CP = 18; //  Prohibit line breaks before
  		    var EX = 19; //  Prohibit line breaks before
  		    var IN = 20; //  Allow only indirect line breaks between pairs
  		    var NS = 21; //  Allow only indirect line breaks before
  		    var OP = 22; //  Prohibit line breaks after
  		    var QU = 23; //  Act like they are both opening and closing
  		    // Numeric Context
  		    var IS = 24; //  Prevent breaks after any and before numeric
  		    var NU = 25; //  Form numeric expressions for line breaking purposes
  		    var PO = 26; //  Do not break following a numeric expression
  		    var PR = 27; //  Do not break in front of a numeric expression
  		    var SY = 28; //  Prevent a break before; and allow a break after
  		    // Other Characters
  		    var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
  		    var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
  		    var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
  		    var EB = 32; //  Do not break from following Emoji Modifier
  		    var EM = 33; //  Do not break from preceding Emoji Base
  		    var H2 = 34; //  Form Korean syllable blocks
  		    var H3 = 35; //  Form Korean syllable blocks
  		    var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
  		    var ID = 37; //  Break before or after; except in some numeric context
  		    var JL = 38; //  Form Korean syllable blocks
  		    var JV = 39; //  Form Korean syllable blocks
  		    var JT = 40; //  Form Korean syllable blocks
  		    var RI$1 = 41; //  Keep pairs together. For pairs; break before and after other classes
  		    var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
  		    var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions
  		    var ea_OP = [0x2329, 0xff08];
  		    var BREAK_MANDATORY = '!';
  		    var BREAK_NOT_ALLOWED$1 = '';
  		    var BREAK_ALLOWED$1 = '';
  		    var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
  		    var ALPHABETICS = [AL, HL];
  		    var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
  		    var SPACE$1 = [SP, ZW];
  		    var PREFIX_POSTFIX = [PR, PO];
  		    var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
  		    var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
  		    var HYPHEN = [HY, BA];
  		    var codePointsToCharacterClasses = function (codePoints, lineBreak) {
  		        if (lineBreak === void 0) { lineBreak = 'strict'; }
  		        var types = [];
  		        var indices = [];
  		        var categories = [];
  		        codePoints.forEach(function (codePoint, index) {
  		            var classType = UnicodeTrie$1.get(codePoint);
  		            if (classType > LETTER_NUMBER_MODIFIER) {
  		                categories.push(true);
  		                classType -= LETTER_NUMBER_MODIFIER;
  		            }
  		            else {
  		                categories.push(false);
  		            }
  		            if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
  		                // U+2010,  U+2013,  U+301C,  U+30A0
  		                if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
  		                    indices.push(index);
  		                    return types.push(CB);
  		                }
  		            }
  		            if (classType === CM || classType === ZWJ$1) {
  		                // LB10 Treat any remaining combining mark or ZWJ as AL.
  		                if (index === 0) {
  		                    indices.push(index);
  		                    return types.push(AL);
  		                }
  		                // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
  		                // the base character in all of the following rules. Treat ZWJ as if it were CM.
  		                var prev = types[index - 1];
  		                if (LINE_BREAKS.indexOf(prev) === -1) {
  		                    indices.push(indices[index - 1]);
  		                    return types.push(prev);
  		                }
  		                indices.push(index);
  		                return types.push(AL);
  		            }
  		            indices.push(index);
  		            if (classType === CJ) {
  		                return types.push(lineBreak === 'strict' ? NS : ID);
  		            }
  		            if (classType === SA) {
  		                return types.push(AL);
  		            }
  		            if (classType === AI) {
  		                return types.push(AL);
  		            }
  		            // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
  		            // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
  		            // to take into account the actual line breaking properties for these characters.
  		            if (classType === XX) {
  		                if ((codePoint >= 0x20000 && codePoint <= 0x2fffd) || (codePoint >= 0x30000 && codePoint <= 0x3fffd)) {
  		                    return types.push(ID);
  		                }
  		                else {
  		                    return types.push(AL);
  		                }
  		            }
  		            types.push(classType);
  		        });
  		        return [indices, types, categories];
  		    };
  		    var isAdjacentWithSpaceIgnored = function (a, b, currentIndex, classTypes) {
  		        var current = classTypes[currentIndex];
  		        if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
  		            var i = currentIndex;
  		            while (i <= classTypes.length) {
  		                i++;
  		                var next = classTypes[i];
  		                if (next === b) {
  		                    return true;
  		                }
  		                if (next !== SP) {
  		                    break;
  		                }
  		            }
  		        }
  		        if (current === SP) {
  		            var i = currentIndex;
  		            while (i > 0) {
  		                i--;
  		                var prev = classTypes[i];
  		                if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
  		                    var n = currentIndex;
  		                    while (n <= classTypes.length) {
  		                        n++;
  		                        var next = classTypes[n];
  		                        if (next === b) {
  		                            return true;
  		                        }
  		                        if (next !== SP) {
  		                            break;
  		                        }
  		                    }
  		                }
  		                if (prev !== SP) {
  		                    break;
  		                }
  		            }
  		        }
  		        return false;
  		    };
  		    var previousNonSpaceClassType = function (currentIndex, classTypes) {
  		        var i = currentIndex;
  		        while (i >= 0) {
  		            var type = classTypes[i];
  		            if (type === SP) {
  		                i--;
  		            }
  		            else {
  		                return type;
  		            }
  		        }
  		        return 0;
  		    };
  		    var _lineBreakAtIndex = function (codePoints, classTypes, indicies, index, forbiddenBreaks) {
  		        if (indicies[index] === 0) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        var currentIndex = index - 1;
  		        if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        var beforeIndex = currentIndex - 1;
  		        var afterIndex = currentIndex + 1;
  		        var current = classTypes[currentIndex];
  		        // LB4 Always break after hard line breaks.
  		        // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
  		        var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  		        var next = classTypes[afterIndex];
  		        if (current === CR$1 && next === LF$1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
  		            return BREAK_MANDATORY;
  		        }
  		        // LB6 Do not break before hard line breaks.
  		        if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB7 Do not break before spaces or zero width space.
  		        if (SPACE$1.indexOf(next) !== -1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
  		        if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
  		            return BREAK_ALLOWED$1;
  		        }
  		        // LB8a Do not break after a zero width joiner.
  		        if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // zwj emojis
  		        if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB11 Do not break before or after Word joiner and related characters.
  		        if (current === WJ || next === WJ) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB12 Do not break after NBSP and related characters.
  		        if (current === GL) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
  		        if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB13 Do not break before ] or ! or ; or /, even after spaces.
  		        if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB14 Do not break after [, even after spaces.
  		        if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB15 Do not break within [, even with intervening spaces.
  		        if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
  		        if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB17 Do not break within , even with intervening spaces.
  		        if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB18 Break after spaces.
  		        if (current === SP) {
  		            return BREAK_ALLOWED$1;
  		        }
  		        // LB19 Do not break before or after quotation marks, such as   .
  		        if (current === QU || next === QU) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB20 Break before and after unresolved CB.
  		        if (next === CB || current === CB) {
  		            return BREAK_ALLOWED$1;
  		        }
  		        // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
  		        if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB21a Don't break after Hebrew + Hyphen.
  		        if (before === HL && HYPHEN.indexOf(current) !== -1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB21b Dont break between Solidus and Hebrew letters.
  		        if (current === SY && next === HL) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB22 Do not break before ellipsis.
  		        if (next === IN) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB23 Do not break between digits and letters.
  		        if ((ALPHABETICS.indexOf(next) !== -1 && current === NU) || (ALPHABETICS.indexOf(current) !== -1 && next === NU)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
  		        if ((current === PR && [ID, EB, EM].indexOf(next) !== -1) ||
  		            ([ID, EB, EM].indexOf(current) !== -1 && next === PO)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
  		        if ((ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1) ||
  		            (PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB25 Do not break between the following pairs of classes relevant to numbers:
  		        if (
  		        // (PR | PO)  ( OP | HY )? NU
  		        ([PR, PO].indexOf(current) !== -1 &&
  		            (next === NU || ([OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU))) ||
  		            // ( OP | HY )  NU
  		            ([OP, HY].indexOf(current) !== -1 && next === NU) ||
  		            // NU 	(NU | SY | IS)
  		            (current === NU && [NU, SY, IS].indexOf(next) !== -1)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // NU (NU | SY | IS)*  (NU | SY | IS | CL | CP)
  		        if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
  		            var prevIndex = currentIndex;
  		            while (prevIndex >= 0) {
  		                var type = classTypes[prevIndex];
  		                if (type === NU) {
  		                    return BREAK_NOT_ALLOWED$1;
  		                }
  		                else if ([SY, IS].indexOf(type) !== -1) {
  		                    prevIndex--;
  		                }
  		                else {
  		                    break;
  		                }
  		            }
  		        }
  		        // NU (NU | SY | IS)* (CL | CP)?  (PO | PR))
  		        if ([PR, PO].indexOf(next) !== -1) {
  		            var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
  		            while (prevIndex >= 0) {
  		                var type = classTypes[prevIndex];
  		                if (type === NU) {
  		                    return BREAK_NOT_ALLOWED$1;
  		                }
  		                else if ([SY, IS].indexOf(type) !== -1) {
  		                    prevIndex--;
  		                }
  		                else {
  		                    break;
  		                }
  		            }
  		        }
  		        // LB26 Do not break a Korean syllable.
  		        if ((JL === current && [JL, JV, H2, H3].indexOf(next) !== -1) ||
  		            ([JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1) ||
  		            ([JT, H3].indexOf(current) !== -1 && next === JT)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB27 Treat a Korean Syllable Block the same as ID.
  		        if ((KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1) ||
  		            (KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB28 Do not break between alphabetics (at).
  		        if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB29 Do not break between numeric punctuation and alphabetics (e.g.).
  		        if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
  		        if ((ALPHABETICS.concat(NU).indexOf(current) !== -1 &&
  		            next === OP &&
  		            ea_OP.indexOf(codePoints[afterIndex]) === -1) ||
  		            (ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP)) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
  		        // indicators preceding the position of the break.
  		        if (current === RI$1 && next === RI$1) {
  		            var i = indicies[currentIndex];
  		            var count = 1;
  		            while (i > 0) {
  		                i--;
  		                if (classTypes[i] === RI$1) {
  		                    count++;
  		                }
  		                else {
  		                    break;
  		                }
  		            }
  		            if (count % 2 !== 0) {
  		                return BREAK_NOT_ALLOWED$1;
  		            }
  		        }
  		        // LB30b Do not break between an emoji base and an emoji modifier.
  		        if (current === EB && next === EM) {
  		            return BREAK_NOT_ALLOWED$1;
  		        }
  		        return BREAK_ALLOWED$1;
  		    };
  		    var cssFormattedClasses = function (codePoints, options) {
  		        if (!options) {
  		            options = { lineBreak: 'normal', wordBreak: 'normal' };
  		        }
  		        var _a = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a[0], classTypes = _a[1], isLetterNumber = _a[2];
  		        if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
  		            classTypes = classTypes.map(function (type) { return ([NU, AL, SA].indexOf(type) !== -1 ? ID : type); });
  		        }
  		        var forbiddenBreakpoints = options.wordBreak === 'keep-all'
  		            ? isLetterNumber.map(function (letterNumber, i) {
  		                return letterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
  		            })
  		            : undefined;
  		        return [indicies, classTypes, forbiddenBreakpoints];
  		    };
  		    var Break = /** @class */ (function () {
  		        function Break(codePoints, lineBreak, start, end) {
  		            this.codePoints = codePoints;
  		            this.required = lineBreak === BREAK_MANDATORY;
  		            this.start = start;
  		            this.end = end;
  		        }
  		        Break.prototype.slice = function () {
  		            return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
  		        };
  		        return Break;
  		    }());
  		    var LineBreaker = function (str, options) {
  		        var codePoints = toCodePoints$1(str);
  		        var _a = cssFormattedClasses(codePoints, options), indicies = _a[0], classTypes = _a[1], forbiddenBreakpoints = _a[2];
  		        var length = codePoints.length;
  		        var lastEnd = 0;
  		        var nextIndex = 0;
  		        return {
  		            next: function () {
  		                if (nextIndex >= length) {
  		                    return { done: true, value: null };
  		                }
  		                var lineBreak = BREAK_NOT_ALLOWED$1;
  		                while (nextIndex < length &&
  		                    (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) ===
  		                        BREAK_NOT_ALLOWED$1) { }
  		                if (lineBreak !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
  		                    var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
  		                    lastEnd = nextIndex;
  		                    return { value: value, done: false };
  		                }
  		                return { done: true, value: null };
  		            },
  		        };
  		    };

  		    // https://www.w3.org/TR/css-syntax-3
  		    var FLAG_UNRESTRICTED = 1 << 0;
  		    var FLAG_ID = 1 << 1;
  		    var FLAG_INTEGER = 1 << 2;
  		    var FLAG_NUMBER = 1 << 3;
  		    var LINE_FEED = 0x000a;
  		    var SOLIDUS = 0x002f;
  		    var REVERSE_SOLIDUS = 0x005c;
  		    var CHARACTER_TABULATION = 0x0009;
  		    var SPACE = 0x0020;
  		    var QUOTATION_MARK = 0x0022;
  		    var EQUALS_SIGN = 0x003d;
  		    var NUMBER_SIGN = 0x0023;
  		    var DOLLAR_SIGN = 0x0024;
  		    var PERCENTAGE_SIGN = 0x0025;
  		    var APOSTROPHE = 0x0027;
  		    var LEFT_PARENTHESIS = 0x0028;
  		    var RIGHT_PARENTHESIS = 0x0029;
  		    var LOW_LINE = 0x005f;
  		    var HYPHEN_MINUS = 0x002d;
  		    var EXCLAMATION_MARK = 0x0021;
  		    var LESS_THAN_SIGN = 0x003c;
  		    var GREATER_THAN_SIGN = 0x003e;
  		    var COMMERCIAL_AT = 0x0040;
  		    var LEFT_SQUARE_BRACKET = 0x005b;
  		    var RIGHT_SQUARE_BRACKET = 0x005d;
  		    var CIRCUMFLEX_ACCENT = 0x003d;
  		    var LEFT_CURLY_BRACKET = 0x007b;
  		    var QUESTION_MARK = 0x003f;
  		    var RIGHT_CURLY_BRACKET = 0x007d;
  		    var VERTICAL_LINE = 0x007c;
  		    var TILDE = 0x007e;
  		    var CONTROL = 0x0080;
  		    var REPLACEMENT_CHARACTER = 0xfffd;
  		    var ASTERISK = 0x002a;
  		    var PLUS_SIGN = 0x002b;
  		    var COMMA = 0x002c;
  		    var COLON = 0x003a;
  		    var SEMICOLON = 0x003b;
  		    var FULL_STOP = 0x002e;
  		    var NULL = 0x0000;
  		    var BACKSPACE = 0x0008;
  		    var LINE_TABULATION = 0x000b;
  		    var SHIFT_OUT = 0x000e;
  		    var INFORMATION_SEPARATOR_ONE = 0x001f;
  		    var DELETE = 0x007f;
  		    var EOF = -1;
  		    var ZERO = 0x0030;
  		    var a = 0x0061;
  		    var e = 0x0065;
  		    var f = 0x0066;
  		    var u = 0x0075;
  		    var z = 0x007a;
  		    var A = 0x0041;
  		    var E = 0x0045;
  		    var F = 0x0046;
  		    var U = 0x0055;
  		    var Z = 0x005a;
  		    var isDigit = function (codePoint) { return codePoint >= ZERO && codePoint <= 0x0039; };
  		    var isSurrogateCodePoint = function (codePoint) { return codePoint >= 0xd800 && codePoint <= 0xdfff; };
  		    var isHex = function (codePoint) {
  		        return isDigit(codePoint) || (codePoint >= A && codePoint <= F) || (codePoint >= a && codePoint <= f);
  		    };
  		    var isLowerCaseLetter = function (codePoint) { return codePoint >= a && codePoint <= z; };
  		    var isUpperCaseLetter = function (codePoint) { return codePoint >= A && codePoint <= Z; };
  		    var isLetter = function (codePoint) { return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint); };
  		    var isNonASCIICodePoint = function (codePoint) { return codePoint >= CONTROL; };
  		    var isWhiteSpace = function (codePoint) {
  		        return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
  		    };
  		    var isNameStartCodePoint = function (codePoint) {
  		        return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
  		    };
  		    var isNameCodePoint = function (codePoint) {
  		        return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
  		    };
  		    var isNonPrintableCodePoint = function (codePoint) {
  		        return ((codePoint >= NULL && codePoint <= BACKSPACE) ||
  		            codePoint === LINE_TABULATION ||
  		            (codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE) ||
  		            codePoint === DELETE);
  		    };
  		    var isValidEscape = function (c1, c2) {
  		        if (c1 !== REVERSE_SOLIDUS) {
  		            return false;
  		        }
  		        return c2 !== LINE_FEED;
  		    };
  		    var isIdentifierStart = function (c1, c2, c3) {
  		        if (c1 === HYPHEN_MINUS) {
  		            return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  		        }
  		        else if (isNameStartCodePoint(c1)) {
  		            return true;
  		        }
  		        else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
  		            return true;
  		        }
  		        return false;
  		    };
  		    var isNumberStart = function (c1, c2, c3) {
  		        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
  		            if (isDigit(c2)) {
  		                return true;
  		            }
  		            return c2 === FULL_STOP && isDigit(c3);
  		        }
  		        if (c1 === FULL_STOP) {
  		            return isDigit(c2);
  		        }
  		        return isDigit(c1);
  		    };
  		    var stringToNumber = function (codePoints) {
  		        var c = 0;
  		        var sign = 1;
  		        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
  		            if (codePoints[c] === HYPHEN_MINUS) {
  		                sign = -1;
  		            }
  		            c++;
  		        }
  		        var integers = [];
  		        while (isDigit(codePoints[c])) {
  		            integers.push(codePoints[c++]);
  		        }
  		        var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  		        if (codePoints[c] === FULL_STOP) {
  		            c++;
  		        }
  		        var fraction = [];
  		        while (isDigit(codePoints[c])) {
  		            fraction.push(codePoints[c++]);
  		        }
  		        var fracd = fraction.length;
  		        var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  		        if (codePoints[c] === E || codePoints[c] === e) {
  		            c++;
  		        }
  		        var expsign = 1;
  		        if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
  		            if (codePoints[c] === HYPHEN_MINUS) {
  		                expsign = -1;
  		            }
  		            c++;
  		        }
  		        var exponent = [];
  		        while (isDigit(codePoints[c])) {
  		            exponent.push(codePoints[c++]);
  		        }
  		        var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  		        return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
  		    };
  		    var LEFT_PARENTHESIS_TOKEN = {
  		        type: 2 /* LEFT_PARENTHESIS_TOKEN */
  		    };
  		    var RIGHT_PARENTHESIS_TOKEN = {
  		        type: 3 /* RIGHT_PARENTHESIS_TOKEN */
  		    };
  		    var COMMA_TOKEN = { type: 4 /* COMMA_TOKEN */ };
  		    var SUFFIX_MATCH_TOKEN = { type: 13 /* SUFFIX_MATCH_TOKEN */ };
  		    var PREFIX_MATCH_TOKEN = { type: 8 /* PREFIX_MATCH_TOKEN */ };
  		    var COLUMN_TOKEN = { type: 21 /* COLUMN_TOKEN */ };
  		    var DASH_MATCH_TOKEN = { type: 9 /* DASH_MATCH_TOKEN */ };
  		    var INCLUDE_MATCH_TOKEN = { type: 10 /* INCLUDE_MATCH_TOKEN */ };
  		    var LEFT_CURLY_BRACKET_TOKEN = {
  		        type: 11 /* LEFT_CURLY_BRACKET_TOKEN */
  		    };
  		    var RIGHT_CURLY_BRACKET_TOKEN = {
  		        type: 12 /* RIGHT_CURLY_BRACKET_TOKEN */
  		    };
  		    var SUBSTRING_MATCH_TOKEN = { type: 14 /* SUBSTRING_MATCH_TOKEN */ };
  		    var BAD_URL_TOKEN = { type: 23 /* BAD_URL_TOKEN */ };
  		    var BAD_STRING_TOKEN = { type: 1 /* BAD_STRING_TOKEN */ };
  		    var CDO_TOKEN = { type: 25 /* CDO_TOKEN */ };
  		    var CDC_TOKEN = { type: 24 /* CDC_TOKEN */ };
  		    var COLON_TOKEN = { type: 26 /* COLON_TOKEN */ };
  		    var SEMICOLON_TOKEN = { type: 27 /* SEMICOLON_TOKEN */ };
  		    var LEFT_SQUARE_BRACKET_TOKEN = {
  		        type: 28 /* LEFT_SQUARE_BRACKET_TOKEN */
  		    };
  		    var RIGHT_SQUARE_BRACKET_TOKEN = {
  		        type: 29 /* RIGHT_SQUARE_BRACKET_TOKEN */
  		    };
  		    var WHITESPACE_TOKEN = { type: 31 /* WHITESPACE_TOKEN */ };
  		    var EOF_TOKEN = { type: 32 /* EOF_TOKEN */ };
  		    var Tokenizer = /** @class */ (function () {
  		        function Tokenizer() {
  		            this._value = [];
  		        }
  		        Tokenizer.prototype.write = function (chunk) {
  		            this._value = this._value.concat(toCodePoints$1(chunk));
  		        };
  		        Tokenizer.prototype.read = function () {
  		            var tokens = [];
  		            var token = this.consumeToken();
  		            while (token !== EOF_TOKEN) {
  		                tokens.push(token);
  		                token = this.consumeToken();
  		            }
  		            return tokens;
  		        };
  		        Tokenizer.prototype.consumeToken = function () {
  		            var codePoint = this.consumeCodePoint();
  		            switch (codePoint) {
  		                case QUOTATION_MARK:
  		                    return this.consumeStringToken(QUOTATION_MARK);
  		                case NUMBER_SIGN:
  		                    var c1 = this.peekCodePoint(0);
  		                    var c2 = this.peekCodePoint(1);
  		                    var c3 = this.peekCodePoint(2);
  		                    if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
  		                        var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
  		                        var value = this.consumeName();
  		                        return { type: 5 /* HASH_TOKEN */, value: value, flags: flags };
  		                    }
  		                    break;
  		                case DOLLAR_SIGN:
  		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
  		                        this.consumeCodePoint();
  		                        return SUFFIX_MATCH_TOKEN;
  		                    }
  		                    break;
  		                case APOSTROPHE:
  		                    return this.consumeStringToken(APOSTROPHE);
  		                case LEFT_PARENTHESIS:
  		                    return LEFT_PARENTHESIS_TOKEN;
  		                case RIGHT_PARENTHESIS:
  		                    return RIGHT_PARENTHESIS_TOKEN;
  		                case ASTERISK:
  		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
  		                        this.consumeCodePoint();
  		                        return SUBSTRING_MATCH_TOKEN;
  		                    }
  		                    break;
  		                case PLUS_SIGN:
  		                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
  		                        this.reconsumeCodePoint(codePoint);
  		                        return this.consumeNumericToken();
  		                    }
  		                    break;
  		                case COMMA:
  		                    return COMMA_TOKEN;
  		                case HYPHEN_MINUS:
  		                    var e1 = codePoint;
  		                    var e2 = this.peekCodePoint(0);
  		                    var e3 = this.peekCodePoint(1);
  		                    if (isNumberStart(e1, e2, e3)) {
  		                        this.reconsumeCodePoint(codePoint);
  		                        return this.consumeNumericToken();
  		                    }
  		                    if (isIdentifierStart(e1, e2, e3)) {
  		                        this.reconsumeCodePoint(codePoint);
  		                        return this.consumeIdentLikeToken();
  		                    }
  		                    if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
  		                        this.consumeCodePoint();
  		                        this.consumeCodePoint();
  		                        return CDC_TOKEN;
  		                    }
  		                    break;
  		                case FULL_STOP:
  		                    if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
  		                        this.reconsumeCodePoint(codePoint);
  		                        return this.consumeNumericToken();
  		                    }
  		                    break;
  		                case SOLIDUS:
  		                    if (this.peekCodePoint(0) === ASTERISK) {
  		                        this.consumeCodePoint();
  		                        while (true) {
  		                            var c = this.consumeCodePoint();
  		                            if (c === ASTERISK) {
  		                                c = this.consumeCodePoint();
  		                                if (c === SOLIDUS) {
  		                                    return this.consumeToken();
  		                                }
  		                            }
  		                            if (c === EOF) {
  		                                return this.consumeToken();
  		                            }
  		                        }
  		                    }
  		                    break;
  		                case COLON:
  		                    return COLON_TOKEN;
  		                case SEMICOLON:
  		                    return SEMICOLON_TOKEN;
  		                case LESS_THAN_SIGN:
  		                    if (this.peekCodePoint(0) === EXCLAMATION_MARK &&
  		                        this.peekCodePoint(1) === HYPHEN_MINUS &&
  		                        this.peekCodePoint(2) === HYPHEN_MINUS) {
  		                        this.consumeCodePoint();
  		                        this.consumeCodePoint();
  		                        return CDO_TOKEN;
  		                    }
  		                    break;
  		                case COMMERCIAL_AT:
  		                    var a1 = this.peekCodePoint(0);
  		                    var a2 = this.peekCodePoint(1);
  		                    var a3 = this.peekCodePoint(2);
  		                    if (isIdentifierStart(a1, a2, a3)) {
  		                        var value = this.consumeName();
  		                        return { type: 7 /* AT_KEYWORD_TOKEN */, value: value };
  		                    }
  		                    break;
  		                case LEFT_SQUARE_BRACKET:
  		                    return LEFT_SQUARE_BRACKET_TOKEN;
  		                case REVERSE_SOLIDUS:
  		                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
  		                        this.reconsumeCodePoint(codePoint);
  		                        return this.consumeIdentLikeToken();
  		                    }
  		                    break;
  		                case RIGHT_SQUARE_BRACKET:
  		                    return RIGHT_SQUARE_BRACKET_TOKEN;
  		                case CIRCUMFLEX_ACCENT:
  		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
  		                        this.consumeCodePoint();
  		                        return PREFIX_MATCH_TOKEN;
  		                    }
  		                    break;
  		                case LEFT_CURLY_BRACKET:
  		                    return LEFT_CURLY_BRACKET_TOKEN;
  		                case RIGHT_CURLY_BRACKET:
  		                    return RIGHT_CURLY_BRACKET_TOKEN;
  		                case u:
  		                case U:
  		                    var u1 = this.peekCodePoint(0);
  		                    var u2 = this.peekCodePoint(1);
  		                    if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
  		                        this.consumeCodePoint();
  		                        this.consumeUnicodeRangeToken();
  		                    }
  		                    this.reconsumeCodePoint(codePoint);
  		                    return this.consumeIdentLikeToken();
  		                case VERTICAL_LINE:
  		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
  		                        this.consumeCodePoint();
  		                        return DASH_MATCH_TOKEN;
  		                    }
  		                    if (this.peekCodePoint(0) === VERTICAL_LINE) {
  		                        this.consumeCodePoint();
  		                        return COLUMN_TOKEN;
  		                    }
  		                    break;
  		                case TILDE:
  		                    if (this.peekCodePoint(0) === EQUALS_SIGN) {
  		                        this.consumeCodePoint();
  		                        return INCLUDE_MATCH_TOKEN;
  		                    }
  		                    break;
  		                case EOF:
  		                    return EOF_TOKEN;
  		            }
  		            if (isWhiteSpace(codePoint)) {
  		                this.consumeWhiteSpace();
  		                return WHITESPACE_TOKEN;
  		            }
  		            if (isDigit(codePoint)) {
  		                this.reconsumeCodePoint(codePoint);
  		                return this.consumeNumericToken();
  		            }
  		            if (isNameStartCodePoint(codePoint)) {
  		                this.reconsumeCodePoint(codePoint);
  		                return this.consumeIdentLikeToken();
  		            }
  		            return { type: 6 /* DELIM_TOKEN */, value: fromCodePoint$1(codePoint) };
  		        };
  		        Tokenizer.prototype.consumeCodePoint = function () {
  		            var value = this._value.shift();
  		            return typeof value === 'undefined' ? -1 : value;
  		        };
  		        Tokenizer.prototype.reconsumeCodePoint = function (codePoint) {
  		            this._value.unshift(codePoint);
  		        };
  		        Tokenizer.prototype.peekCodePoint = function (delta) {
  		            if (delta >= this._value.length) {
  		                return -1;
  		            }
  		            return this._value[delta];
  		        };
  		        Tokenizer.prototype.consumeUnicodeRangeToken = function () {
  		            var digits = [];
  		            var codePoint = this.consumeCodePoint();
  		            while (isHex(codePoint) && digits.length < 6) {
  		                digits.push(codePoint);
  		                codePoint = this.consumeCodePoint();
  		            }
  		            var questionMarks = false;
  		            while (codePoint === QUESTION_MARK && digits.length < 6) {
  		                digits.push(codePoint);
  		                codePoint = this.consumeCodePoint();
  		                questionMarks = true;
  		            }
  		            if (questionMarks) {
  		                var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? ZERO : digit); })), 16);
  		                var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function (digit) { return (digit === QUESTION_MARK ? F : digit); })), 16);
  		                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start_1, end: end };
  		            }
  		            var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
  		            if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
  		                this.consumeCodePoint();
  		                codePoint = this.consumeCodePoint();
  		                var endDigits = [];
  		                while (isHex(codePoint) && endDigits.length < 6) {
  		                    endDigits.push(codePoint);
  		                    codePoint = this.consumeCodePoint();
  		                }
  		                var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
  		                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: end };
  		            }
  		            else {
  		                return { type: 30 /* UNICODE_RANGE_TOKEN */, start: start, end: start };
  		            }
  		        };
  		        Tokenizer.prototype.consumeIdentLikeToken = function () {
  		            var value = this.consumeName();
  		            if (value.toLowerCase() === 'url' && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
  		                this.consumeCodePoint();
  		                return this.consumeUrlToken();
  		            }
  		            else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
  		                this.consumeCodePoint();
  		                return { type: 19 /* FUNCTION_TOKEN */, value: value };
  		            }
  		            return { type: 20 /* IDENT_TOKEN */, value: value };
  		        };
  		        Tokenizer.prototype.consumeUrlToken = function () {
  		            var value = [];
  		            this.consumeWhiteSpace();
  		            if (this.peekCodePoint(0) === EOF) {
  		                return { type: 22 /* URL_TOKEN */, value: '' };
  		            }
  		            var next = this.peekCodePoint(0);
  		            if (next === APOSTROPHE || next === QUOTATION_MARK) {
  		                var stringToken = this.consumeStringToken(this.consumeCodePoint());
  		                if (stringToken.type === 0 /* STRING_TOKEN */) {
  		                    this.consumeWhiteSpace();
  		                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
  		                        this.consumeCodePoint();
  		                        return { type: 22 /* URL_TOKEN */, value: stringToken.value };
  		                    }
  		                }
  		                this.consumeBadUrlRemnants();
  		                return BAD_URL_TOKEN;
  		            }
  		            while (true) {
  		                var codePoint = this.consumeCodePoint();
  		                if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
  		                    return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
  		                }
  		                else if (isWhiteSpace(codePoint)) {
  		                    this.consumeWhiteSpace();
  		                    if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
  		                        this.consumeCodePoint();
  		                        return { type: 22 /* URL_TOKEN */, value: fromCodePoint$1.apply(void 0, value) };
  		                    }
  		                    this.consumeBadUrlRemnants();
  		                    return BAD_URL_TOKEN;
  		                }
  		                else if (codePoint === QUOTATION_MARK ||
  		                    codePoint === APOSTROPHE ||
  		                    codePoint === LEFT_PARENTHESIS ||
  		                    isNonPrintableCodePoint(codePoint)) {
  		                    this.consumeBadUrlRemnants();
  		                    return BAD_URL_TOKEN;
  		                }
  		                else if (codePoint === REVERSE_SOLIDUS) {
  		                    if (isValidEscape(codePoint, this.peekCodePoint(0))) {
  		                        value.push(this.consumeEscapedCodePoint());
  		                    }
  		                    else {
  		                        this.consumeBadUrlRemnants();
  		                        return BAD_URL_TOKEN;
  		                    }
  		                }
  		                else {
  		                    value.push(codePoint);
  		                }
  		            }
  		        };
  		        Tokenizer.prototype.consumeWhiteSpace = function () {
  		            while (isWhiteSpace(this.peekCodePoint(0))) {
  		                this.consumeCodePoint();
  		            }
  		        };
  		        Tokenizer.prototype.consumeBadUrlRemnants = function () {
  		            while (true) {
  		                var codePoint = this.consumeCodePoint();
  		                if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
  		                    return;
  		                }
  		                if (isValidEscape(codePoint, this.peekCodePoint(0))) {
  		                    this.consumeEscapedCodePoint();
  		                }
  		            }
  		        };
  		        Tokenizer.prototype.consumeStringSlice = function (count) {
  		            var SLICE_STACK_SIZE = 50000;
  		            var value = '';
  		            while (count > 0) {
  		                var amount = Math.min(SLICE_STACK_SIZE, count);
  		                value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
  		                count -= amount;
  		            }
  		            this._value.shift();
  		            return value;
  		        };
  		        Tokenizer.prototype.consumeStringToken = function (endingCodePoint) {
  		            var value = '';
  		            var i = 0;
  		            do {
  		                var codePoint = this._value[i];
  		                if (codePoint === EOF || codePoint === undefined || codePoint === endingCodePoint) {
  		                    value += this.consumeStringSlice(i);
  		                    return { type: 0 /* STRING_TOKEN */, value: value };
  		                }
  		                if (codePoint === LINE_FEED) {
  		                    this._value.splice(0, i);
  		                    return BAD_STRING_TOKEN;
  		                }
  		                if (codePoint === REVERSE_SOLIDUS) {
  		                    var next = this._value[i + 1];
  		                    if (next !== EOF && next !== undefined) {
  		                        if (next === LINE_FEED) {
  		                            value += this.consumeStringSlice(i);
  		                            i = -1;
  		                            this._value.shift();
  		                        }
  		                        else if (isValidEscape(codePoint, next)) {
  		                            value += this.consumeStringSlice(i);
  		                            value += fromCodePoint$1(this.consumeEscapedCodePoint());
  		                            i = -1;
  		                        }
  		                    }
  		                }
  		                i++;
  		            } while (true);
  		        };
  		        Tokenizer.prototype.consumeNumber = function () {
  		            var repr = [];
  		            var type = FLAG_INTEGER;
  		            var c1 = this.peekCodePoint(0);
  		            if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
  		                repr.push(this.consumeCodePoint());
  		            }
  		            while (isDigit(this.peekCodePoint(0))) {
  		                repr.push(this.consumeCodePoint());
  		            }
  		            c1 = this.peekCodePoint(0);
  		            var c2 = this.peekCodePoint(1);
  		            if (c1 === FULL_STOP && isDigit(c2)) {
  		                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
  		                type = FLAG_NUMBER;
  		                while (isDigit(this.peekCodePoint(0))) {
  		                    repr.push(this.consumeCodePoint());
  		                }
  		            }
  		            c1 = this.peekCodePoint(0);
  		            c2 = this.peekCodePoint(1);
  		            var c3 = this.peekCodePoint(2);
  		            if ((c1 === E || c1 === e) && (((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3)) || isDigit(c2))) {
  		                repr.push(this.consumeCodePoint(), this.consumeCodePoint());
  		                type = FLAG_NUMBER;
  		                while (isDigit(this.peekCodePoint(0))) {
  		                    repr.push(this.consumeCodePoint());
  		                }
  		            }
  		            return [stringToNumber(repr), type];
  		        };
  		        Tokenizer.prototype.consumeNumericToken = function () {
  		            var _a = this.consumeNumber(), number = _a[0], flags = _a[1];
  		            var c1 = this.peekCodePoint(0);
  		            var c2 = this.peekCodePoint(1);
  		            var c3 = this.peekCodePoint(2);
  		            if (isIdentifierStart(c1, c2, c3)) {
  		                var unit = this.consumeName();
  		                return { type: 15 /* DIMENSION_TOKEN */, number: number, flags: flags, unit: unit };
  		            }
  		            if (c1 === PERCENTAGE_SIGN) {
  		                this.consumeCodePoint();
  		                return { type: 16 /* PERCENTAGE_TOKEN */, number: number, flags: flags };
  		            }
  		            return { type: 17 /* NUMBER_TOKEN */, number: number, flags: flags };
  		        };
  		        Tokenizer.prototype.consumeEscapedCodePoint = function () {
  		            var codePoint = this.consumeCodePoint();
  		            if (isHex(codePoint)) {
  		                var hex = fromCodePoint$1(codePoint);
  		                while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
  		                    hex += fromCodePoint$1(this.consumeCodePoint());
  		                }
  		                if (isWhiteSpace(this.peekCodePoint(0))) {
  		                    this.consumeCodePoint();
  		                }
  		                var hexCodePoint = parseInt(hex, 16);
  		                if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 0x10ffff) {
  		                    return REPLACEMENT_CHARACTER;
  		                }
  		                return hexCodePoint;
  		            }
  		            if (codePoint === EOF) {
  		                return REPLACEMENT_CHARACTER;
  		            }
  		            return codePoint;
  		        };
  		        Tokenizer.prototype.consumeName = function () {
  		            var result = '';
  		            while (true) {
  		                var codePoint = this.consumeCodePoint();
  		                if (isNameCodePoint(codePoint)) {
  		                    result += fromCodePoint$1(codePoint);
  		                }
  		                else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
  		                    result += fromCodePoint$1(this.consumeEscapedCodePoint());
  		                }
  		                else {
  		                    this.reconsumeCodePoint(codePoint);
  		                    return result;
  		                }
  		            }
  		        };
  		        return Tokenizer;
  		    }());

  		    var Parser = /** @class */ (function () {
  		        function Parser(tokens) {
  		            this._tokens = tokens;
  		        }
  		        Parser.create = function (value) {
  		            var tokenizer = new Tokenizer();
  		            tokenizer.write(value);
  		            return new Parser(tokenizer.read());
  		        };
  		        Parser.parseValue = function (value) {
  		            return Parser.create(value).parseComponentValue();
  		        };
  		        Parser.parseValues = function (value) {
  		            return Parser.create(value).parseComponentValues();
  		        };
  		        Parser.prototype.parseComponentValue = function () {
  		            var token = this.consumeToken();
  		            while (token.type === 31 /* WHITESPACE_TOKEN */) {
  		                token = this.consumeToken();
  		            }
  		            if (token.type === 32 /* EOF_TOKEN */) {
  		                throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
  		            }
  		            this.reconsumeToken(token);
  		            var value = this.consumeComponentValue();
  		            do {
  		                token = this.consumeToken();
  		            } while (token.type === 31 /* WHITESPACE_TOKEN */);
  		            if (token.type === 32 /* EOF_TOKEN */) {
  		                return value;
  		            }
  		            throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
  		        };
  		        Parser.prototype.parseComponentValues = function () {
  		            var values = [];
  		            while (true) {
  		                var value = this.consumeComponentValue();
  		                if (value.type === 32 /* EOF_TOKEN */) {
  		                    return values;
  		                }
  		                values.push(value);
  		                values.push();
  		            }
  		        };
  		        Parser.prototype.consumeComponentValue = function () {
  		            var token = this.consumeToken();
  		            switch (token.type) {
  		                case 11 /* LEFT_CURLY_BRACKET_TOKEN */:
  		                case 28 /* LEFT_SQUARE_BRACKET_TOKEN */:
  		                case 2 /* LEFT_PARENTHESIS_TOKEN */:
  		                    return this.consumeSimpleBlock(token.type);
  		                case 19 /* FUNCTION_TOKEN */:
  		                    return this.consumeFunction(token);
  		            }
  		            return token;
  		        };
  		        Parser.prototype.consumeSimpleBlock = function (type) {
  		            var block = { type: type, values: [] };
  		            var token = this.consumeToken();
  		            while (true) {
  		                if (token.type === 32 /* EOF_TOKEN */ || isEndingTokenFor(token, type)) {
  		                    return block;
  		                }
  		                this.reconsumeToken(token);
  		                block.values.push(this.consumeComponentValue());
  		                token = this.consumeToken();
  		            }
  		        };
  		        Parser.prototype.consumeFunction = function (functionToken) {
  		            var cssFunction = {
  		                name: functionToken.value,
  		                values: [],
  		                type: 18 /* FUNCTION */
  		            };
  		            while (true) {
  		                var token = this.consumeToken();
  		                if (token.type === 32 /* EOF_TOKEN */ || token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */) {
  		                    return cssFunction;
  		                }
  		                this.reconsumeToken(token);
  		                cssFunction.values.push(this.consumeComponentValue());
  		            }
  		        };
  		        Parser.prototype.consumeToken = function () {
  		            var token = this._tokens.shift();
  		            return typeof token === 'undefined' ? EOF_TOKEN : token;
  		        };
  		        Parser.prototype.reconsumeToken = function (token) {
  		            this._tokens.unshift(token);
  		        };
  		        return Parser;
  		    }());
  		    var isDimensionToken = function (token) { return token.type === 15 /* DIMENSION_TOKEN */; };
  		    var isNumberToken = function (token) { return token.type === 17 /* NUMBER_TOKEN */; };
  		    var isIdentToken = function (token) { return token.type === 20 /* IDENT_TOKEN */; };
  		    var isStringToken = function (token) { return token.type === 0 /* STRING_TOKEN */; };
  		    var isIdentWithValue = function (token, value) {
  		        return isIdentToken(token) && token.value === value;
  		    };
  		    var nonWhiteSpace = function (token) { return token.type !== 31 /* WHITESPACE_TOKEN */; };
  		    var nonFunctionArgSeparator = function (token) {
  		        return token.type !== 31 /* WHITESPACE_TOKEN */ && token.type !== 4 /* COMMA_TOKEN */;
  		    };
  		    var parseFunctionArgs = function (tokens) {
  		        var args = [];
  		        var arg = [];
  		        tokens.forEach(function (token) {
  		            if (token.type === 4 /* COMMA_TOKEN */) {
  		                if (arg.length === 0) {
  		                    throw new Error("Error parsing function args, zero tokens for arg");
  		                }
  		                args.push(arg);
  		                arg = [];
  		                return;
  		            }
  		            if (token.type !== 31 /* WHITESPACE_TOKEN */) {
  		                arg.push(token);
  		            }
  		        });
  		        if (arg.length) {
  		            args.push(arg);
  		        }
  		        return args;
  		    };
  		    var isEndingTokenFor = function (token, type) {
  		        if (type === 11 /* LEFT_CURLY_BRACKET_TOKEN */ && token.type === 12 /* RIGHT_CURLY_BRACKET_TOKEN */) {
  		            return true;
  		        }
  		        if (type === 28 /* LEFT_SQUARE_BRACKET_TOKEN */ && token.type === 29 /* RIGHT_SQUARE_BRACKET_TOKEN */) {
  		            return true;
  		        }
  		        return type === 2 /* LEFT_PARENTHESIS_TOKEN */ && token.type === 3 /* RIGHT_PARENTHESIS_TOKEN */;
  		    };

  		    var isLength = function (token) {
  		        return token.type === 17 /* NUMBER_TOKEN */ || token.type === 15 /* DIMENSION_TOKEN */;
  		    };

  		    var isLengthPercentage = function (token) {
  		        return token.type === 16 /* PERCENTAGE_TOKEN */ || isLength(token);
  		    };
  		    var parseLengthPercentageTuple = function (tokens) {
  		        return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
  		    };
  		    var ZERO_LENGTH = {
  		        type: 17 /* NUMBER_TOKEN */,
  		        number: 0,
  		        flags: FLAG_INTEGER
  		    };
  		    var FIFTY_PERCENT = {
  		        type: 16 /* PERCENTAGE_TOKEN */,
  		        number: 50,
  		        flags: FLAG_INTEGER
  		    };
  		    var HUNDRED_PERCENT = {
  		        type: 16 /* PERCENTAGE_TOKEN */,
  		        number: 100,
  		        flags: FLAG_INTEGER
  		    };
  		    var getAbsoluteValueForTuple = function (tuple, width, height) {
  		        var x = tuple[0], y = tuple[1];
  		        return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== 'undefined' ? y : x, height)];
  		    };
  		    var getAbsoluteValue = function (token, parent) {
  		        if (token.type === 16 /* PERCENTAGE_TOKEN */) {
  		            return (token.number / 100) * parent;
  		        }
  		        if (isDimensionToken(token)) {
  		            switch (token.unit) {
  		                case 'rem':
  		                case 'em':
  		                    return 16 * token.number; // TODO use correct font-size
  		                case 'px':
  		                default:
  		                    return token.number;
  		            }
  		        }
  		        return token.number;
  		    };

  		    var DEG = 'deg';
  		    var GRAD = 'grad';
  		    var RAD = 'rad';
  		    var TURN = 'turn';
  		    var angle = {
  		        name: 'angle',
  		        parse: function (_context, value) {
  		            if (value.type === 15 /* DIMENSION_TOKEN */) {
  		                switch (value.unit) {
  		                    case DEG:
  		                        return (Math.PI * value.number) / 180;
  		                    case GRAD:
  		                        return (Math.PI / 200) * value.number;
  		                    case RAD:
  		                        return value.number;
  		                    case TURN:
  		                        return Math.PI * 2 * value.number;
  		                }
  		            }
  		            throw new Error("Unsupported angle type");
  		        }
  		    };
  		    var isAngle = function (value) {
  		        if (value.type === 15 /* DIMENSION_TOKEN */) {
  		            if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
  		                return true;
  		            }
  		        }
  		        return false;
  		    };
  		    var parseNamedSide = function (tokens) {
  		        var sideOrCorner = tokens
  		            .filter(isIdentToken)
  		            .map(function (ident) { return ident.value; })
  		            .join(' ');
  		        switch (sideOrCorner) {
  		            case 'to bottom right':
  		            case 'to right bottom':
  		            case 'left top':
  		            case 'top left':
  		                return [ZERO_LENGTH, ZERO_LENGTH];
  		            case 'to top':
  		            case 'bottom':
  		                return deg(0);
  		            case 'to bottom left':
  		            case 'to left bottom':
  		            case 'right top':
  		            case 'top right':
  		                return [ZERO_LENGTH, HUNDRED_PERCENT];
  		            case 'to right':
  		            case 'left':
  		                return deg(90);
  		            case 'to top left':
  		            case 'to left top':
  		            case 'right bottom':
  		            case 'bottom right':
  		                return [HUNDRED_PERCENT, HUNDRED_PERCENT];
  		            case 'to bottom':
  		            case 'top':
  		                return deg(180);
  		            case 'to top right':
  		            case 'to right top':
  		            case 'left bottom':
  		            case 'bottom left':
  		                return [HUNDRED_PERCENT, ZERO_LENGTH];
  		            case 'to left':
  		            case 'right':
  		                return deg(270);
  		        }
  		        return 0;
  		    };
  		    var deg = function (deg) { return (Math.PI * deg) / 180; };

  		    var color$1 = {
  		        name: 'color',
  		        parse: function (context, value) {
  		            if (value.type === 18 /* FUNCTION */) {
  		                var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
  		                if (typeof colorFunction === 'undefined') {
  		                    throw new Error("Attempting to parse an unsupported color function \"" + value.name + "\"");
  		                }
  		                return colorFunction(context, value.values);
  		            }
  		            if (value.type === 5 /* HASH_TOKEN */) {
  		                if (value.value.length === 3) {
  		                    var r = value.value.substring(0, 1);
  		                    var g = value.value.substring(1, 2);
  		                    var b = value.value.substring(2, 3);
  		                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
  		                }
  		                if (value.value.length === 4) {
  		                    var r = value.value.substring(0, 1);
  		                    var g = value.value.substring(1, 2);
  		                    var b = value.value.substring(2, 3);
  		                    var a = value.value.substring(3, 4);
  		                    return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a + a, 16) / 255);
  		                }
  		                if (value.value.length === 6) {
  		                    var r = value.value.substring(0, 2);
  		                    var g = value.value.substring(2, 4);
  		                    var b = value.value.substring(4, 6);
  		                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
  		                }
  		                if (value.value.length === 8) {
  		                    var r = value.value.substring(0, 2);
  		                    var g = value.value.substring(2, 4);
  		                    var b = value.value.substring(4, 6);
  		                    var a = value.value.substring(6, 8);
  		                    return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a, 16) / 255);
  		                }
  		            }
  		            if (value.type === 20 /* IDENT_TOKEN */) {
  		                var namedColor = COLORS[value.value.toUpperCase()];
  		                if (typeof namedColor !== 'undefined') {
  		                    return namedColor;
  		                }
  		            }
  		            return COLORS.TRANSPARENT;
  		        }
  		    };
  		    var isTransparent = function (color) { return (0xff & color) === 0; };
  		    var asString = function (color) {
  		        var alpha = 0xff & color;
  		        var blue = 0xff & (color >> 8);
  		        var green = 0xff & (color >> 16);
  		        var red = 0xff & (color >> 24);
  		        return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
  		    };
  		    var pack = function (r, g, b, a) {
  		        return ((r << 24) | (g << 16) | (b << 8) | (Math.round(a * 255) << 0)) >>> 0;
  		    };
  		    var getTokenColorValue = function (token, i) {
  		        if (token.type === 17 /* NUMBER_TOKEN */) {
  		            return token.number;
  		        }
  		        if (token.type === 16 /* PERCENTAGE_TOKEN */) {
  		            var max = i === 3 ? 1 : 255;
  		            return i === 3 ? (token.number / 100) * max : Math.round((token.number / 100) * max);
  		        }
  		        return 0;
  		    };
  		    var rgb = function (_context, args) {
  		        var tokens = args.filter(nonFunctionArgSeparator);
  		        if (tokens.length === 3) {
  		            var _a = tokens.map(getTokenColorValue), r = _a[0], g = _a[1], b = _a[2];
  		            return pack(r, g, b, 1);
  		        }
  		        if (tokens.length === 4) {
  		            var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a = _b[3];
  		            return pack(r, g, b, a);
  		        }
  		        return 0;
  		    };
  		    function hue2rgb(t1, t2, hue) {
  		        if (hue < 0) {
  		            hue += 1;
  		        }
  		        if (hue >= 1) {
  		            hue -= 1;
  		        }
  		        if (hue < 1 / 6) {
  		            return (t2 - t1) * hue * 6 + t1;
  		        }
  		        else if (hue < 1 / 2) {
  		            return t2;
  		        }
  		        else if (hue < 2 / 3) {
  		            return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
  		        }
  		        else {
  		            return t1;
  		        }
  		    }
  		    var hsl = function (context, args) {
  		        var tokens = args.filter(nonFunctionArgSeparator);
  		        var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  		        var h = (hue.type === 17 /* NUMBER_TOKEN */ ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  		        var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  		        var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  		        var a = typeof alpha !== 'undefined' && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  		        if (s === 0) {
  		            return pack(l * 255, l * 255, l * 255, 1);
  		        }
  		        var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  		        var t1 = l * 2 - t2;
  		        var r = hue2rgb(t1, t2, h + 1 / 3);
  		        var g = hue2rgb(t1, t2, h);
  		        var b = hue2rgb(t1, t2, h - 1 / 3);
  		        return pack(r * 255, g * 255, b * 255, a);
  		    };
  		    var SUPPORTED_COLOR_FUNCTIONS = {
  		        hsl: hsl,
  		        hsla: hsl,
  		        rgb: rgb,
  		        rgba: rgb
  		    };
  		    var parseColor = function (context, value) {
  		        return color$1.parse(context, Parser.create(value).parseComponentValue());
  		    };
  		    var COLORS = {
  		        ALICEBLUE: 0xf0f8ffff,
  		        ANTIQUEWHITE: 0xfaebd7ff,
  		        AQUA: 0x00ffffff,
  		        AQUAMARINE: 0x7fffd4ff,
  		        AZURE: 0xf0ffffff,
  		        BEIGE: 0xf5f5dcff,
  		        BISQUE: 0xffe4c4ff,
  		        BLACK: 0x000000ff,
  		        BLANCHEDALMOND: 0xffebcdff,
  		        BLUE: 0x0000ffff,
  		        BLUEVIOLET: 0x8a2be2ff,
  		        BROWN: 0xa52a2aff,
  		        BURLYWOOD: 0xdeb887ff,
  		        CADETBLUE: 0x5f9ea0ff,
  		        CHARTREUSE: 0x7fff00ff,
  		        CHOCOLATE: 0xd2691eff,
  		        CORAL: 0xff7f50ff,
  		        CORNFLOWERBLUE: 0x6495edff,
  		        CORNSILK: 0xfff8dcff,
  		        CRIMSON: 0xdc143cff,
  		        CYAN: 0x00ffffff,
  		        DARKBLUE: 0x00008bff,
  		        DARKCYAN: 0x008b8bff,
  		        DARKGOLDENROD: 0xb886bbff,
  		        DARKGRAY: 0xa9a9a9ff,
  		        DARKGREEN: 0x006400ff,
  		        DARKGREY: 0xa9a9a9ff,
  		        DARKKHAKI: 0xbdb76bff,
  		        DARKMAGENTA: 0x8b008bff,
  		        DARKOLIVEGREEN: 0x556b2fff,
  		        DARKORANGE: 0xff8c00ff,
  		        DARKORCHID: 0x9932ccff,
  		        DARKRED: 0x8b0000ff,
  		        DARKSALMON: 0xe9967aff,
  		        DARKSEAGREEN: 0x8fbc8fff,
  		        DARKSLATEBLUE: 0x483d8bff,
  		        DARKSLATEGRAY: 0x2f4f4fff,
  		        DARKSLATEGREY: 0x2f4f4fff,
  		        DARKTURQUOISE: 0x00ced1ff,
  		        DARKVIOLET: 0x9400d3ff,
  		        DEEPPINK: 0xff1493ff,
  		        DEEPSKYBLUE: 0x00bfffff,
  		        DIMGRAY: 0x696969ff,
  		        DIMGREY: 0x696969ff,
  		        DODGERBLUE: 0x1e90ffff,
  		        FIREBRICK: 0xb22222ff,
  		        FLORALWHITE: 0xfffaf0ff,
  		        FORESTGREEN: 0x228b22ff,
  		        FUCHSIA: 0xff00ffff,
  		        GAINSBORO: 0xdcdcdcff,
  		        GHOSTWHITE: 0xf8f8ffff,
  		        GOLD: 0xffd700ff,
  		        GOLDENROD: 0xdaa520ff,
  		        GRAY: 0x808080ff,
  		        GREEN: 0x008000ff,
  		        GREENYELLOW: 0xadff2fff,
  		        GREY: 0x808080ff,
  		        HONEYDEW: 0xf0fff0ff,
  		        HOTPINK: 0xff69b4ff,
  		        INDIANRED: 0xcd5c5cff,
  		        INDIGO: 0x4b0082ff,
  		        IVORY: 0xfffff0ff,
  		        KHAKI: 0xf0e68cff,
  		        LAVENDER: 0xe6e6faff,
  		        LAVENDERBLUSH: 0xfff0f5ff,
  		        LAWNGREEN: 0x7cfc00ff,
  		        LEMONCHIFFON: 0xfffacdff,
  		        LIGHTBLUE: 0xadd8e6ff,
  		        LIGHTCORAL: 0xf08080ff,
  		        LIGHTCYAN: 0xe0ffffff,
  		        LIGHTGOLDENRODYELLOW: 0xfafad2ff,
  		        LIGHTGRAY: 0xd3d3d3ff,
  		        LIGHTGREEN: 0x90ee90ff,
  		        LIGHTGREY: 0xd3d3d3ff,
  		        LIGHTPINK: 0xffb6c1ff,
  		        LIGHTSALMON: 0xffa07aff,
  		        LIGHTSEAGREEN: 0x20b2aaff,
  		        LIGHTSKYBLUE: 0x87cefaff,
  		        LIGHTSLATEGRAY: 0x778899ff,
  		        LIGHTSLATEGREY: 0x778899ff,
  		        LIGHTSTEELBLUE: 0xb0c4deff,
  		        LIGHTYELLOW: 0xffffe0ff,
  		        LIME: 0x00ff00ff,
  		        LIMEGREEN: 0x32cd32ff,
  		        LINEN: 0xfaf0e6ff,
  		        MAGENTA: 0xff00ffff,
  		        MAROON: 0x800000ff,
  		        MEDIUMAQUAMARINE: 0x66cdaaff,
  		        MEDIUMBLUE: 0x0000cdff,
  		        MEDIUMORCHID: 0xba55d3ff,
  		        MEDIUMPURPLE: 0x9370dbff,
  		        MEDIUMSEAGREEN: 0x3cb371ff,
  		        MEDIUMSLATEBLUE: 0x7b68eeff,
  		        MEDIUMSPRINGGREEN: 0x00fa9aff,
  		        MEDIUMTURQUOISE: 0x48d1ccff,
  		        MEDIUMVIOLETRED: 0xc71585ff,
  		        MIDNIGHTBLUE: 0x191970ff,
  		        MINTCREAM: 0xf5fffaff,
  		        MISTYROSE: 0xffe4e1ff,
  		        MOCCASIN: 0xffe4b5ff,
  		        NAVAJOWHITE: 0xffdeadff,
  		        NAVY: 0x000080ff,
  		        OLDLACE: 0xfdf5e6ff,
  		        OLIVE: 0x808000ff,
  		        OLIVEDRAB: 0x6b8e23ff,
  		        ORANGE: 0xffa500ff,
  		        ORANGERED: 0xff4500ff,
  		        ORCHID: 0xda70d6ff,
  		        PALEGOLDENROD: 0xeee8aaff,
  		        PALEGREEN: 0x98fb98ff,
  		        PALETURQUOISE: 0xafeeeeff,
  		        PALEVIOLETRED: 0xdb7093ff,
  		        PAPAYAWHIP: 0xffefd5ff,
  		        PEACHPUFF: 0xffdab9ff,
  		        PERU: 0xcd853fff,
  		        PINK: 0xffc0cbff,
  		        PLUM: 0xdda0ddff,
  		        POWDERBLUE: 0xb0e0e6ff,
  		        PURPLE: 0x800080ff,
  		        REBECCAPURPLE: 0x663399ff,
  		        RED: 0xff0000ff,
  		        ROSYBROWN: 0xbc8f8fff,
  		        ROYALBLUE: 0x4169e1ff,
  		        SADDLEBROWN: 0x8b4513ff,
  		        SALMON: 0xfa8072ff,
  		        SANDYBROWN: 0xf4a460ff,
  		        SEAGREEN: 0x2e8b57ff,
  		        SEASHELL: 0xfff5eeff,
  		        SIENNA: 0xa0522dff,
  		        SILVER: 0xc0c0c0ff,
  		        SKYBLUE: 0x87ceebff,
  		        SLATEBLUE: 0x6a5acdff,
  		        SLATEGRAY: 0x708090ff,
  		        SLATEGREY: 0x708090ff,
  		        SNOW: 0xfffafaff,
  		        SPRINGGREEN: 0x00ff7fff,
  		        STEELBLUE: 0x4682b4ff,
  		        TAN: 0xd2b48cff,
  		        TEAL: 0x008080ff,
  		        THISTLE: 0xd8bfd8ff,
  		        TOMATO: 0xff6347ff,
  		        TRANSPARENT: 0x00000000,
  		        TURQUOISE: 0x40e0d0ff,
  		        VIOLET: 0xee82eeff,
  		        WHEAT: 0xf5deb3ff,
  		        WHITE: 0xffffffff,
  		        WHITESMOKE: 0xf5f5f5ff,
  		        YELLOW: 0xffff00ff,
  		        YELLOWGREEN: 0x9acd32ff
  		    };

  		    var backgroundClip = {
  		        name: 'background-clip',
  		        initialValue: 'border-box',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return tokens.map(function (token) {
  		                if (isIdentToken(token)) {
  		                    switch (token.value) {
  		                        case 'padding-box':
  		                            return 1 /* PADDING_BOX */;
  		                        case 'content-box':
  		                            return 2 /* CONTENT_BOX */;
  		                    }
  		                }
  		                return 0 /* BORDER_BOX */;
  		            });
  		        }
  		    };

  		    var backgroundColor = {
  		        name: "background-color",
  		        initialValue: 'transparent',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'color'
  		    };

  		    var parseColorStop = function (context, args) {
  		        var color = color$1.parse(context, args[0]);
  		        var stop = args[1];
  		        return stop && isLengthPercentage(stop) ? { color: color, stop: stop } : { color: color, stop: null };
  		    };
  		    var processColorStops = function (stops, lineLength) {
  		        var first = stops[0];
  		        var last = stops[stops.length - 1];
  		        if (first.stop === null) {
  		            first.stop = ZERO_LENGTH;
  		        }
  		        if (last.stop === null) {
  		            last.stop = HUNDRED_PERCENT;
  		        }
  		        var processStops = [];
  		        var previous = 0;
  		        for (var i = 0; i < stops.length; i++) {
  		            var stop_1 = stops[i].stop;
  		            if (stop_1 !== null) {
  		                var absoluteValue = getAbsoluteValue(stop_1, lineLength);
  		                if (absoluteValue > previous) {
  		                    processStops.push(absoluteValue);
  		                }
  		                else {
  		                    processStops.push(previous);
  		                }
  		                previous = absoluteValue;
  		            }
  		            else {
  		                processStops.push(null);
  		            }
  		        }
  		        var gapBegin = null;
  		        for (var i = 0; i < processStops.length; i++) {
  		            var stop_2 = processStops[i];
  		            if (stop_2 === null) {
  		                if (gapBegin === null) {
  		                    gapBegin = i;
  		                }
  		            }
  		            else if (gapBegin !== null) {
  		                var gapLength = i - gapBegin;
  		                var beforeGap = processStops[gapBegin - 1];
  		                var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
  		                for (var g = 1; g <= gapLength; g++) {
  		                    processStops[gapBegin + g - 1] = gapValue * g;
  		                }
  		                gapBegin = null;
  		            }
  		        }
  		        return stops.map(function (_a, i) {
  		            var color = _a.color;
  		            return { color: color, stop: Math.max(Math.min(1, processStops[i] / lineLength), 0) };
  		        });
  		    };
  		    var getAngleFromCorner = function (corner, width, height) {
  		        var centerX = width / 2;
  		        var centerY = height / 2;
  		        var x = getAbsoluteValue(corner[0], width) - centerX;
  		        var y = centerY - getAbsoluteValue(corner[1], height);
  		        return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
  		    };
  		    var calculateGradientDirection = function (angle, width, height) {
  		        var radian = typeof angle === 'number' ? angle : getAngleFromCorner(angle, width, height);
  		        var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  		        var halfWidth = width / 2;
  		        var halfHeight = height / 2;
  		        var halfLineLength = lineLength / 2;
  		        var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  		        var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  		        return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
  		    };
  		    var distance = function (a, b) { return Math.sqrt(a * a + b * b); };
  		    var findCorner = function (width, height, x, y, closest) {
  		        var corners = [
  		            [0, 0],
  		            [0, height],
  		            [width, 0],
  		            [width, height]
  		        ];
  		        return corners.reduce(function (stat, corner) {
  		            var cx = corner[0], cy = corner[1];
  		            var d = distance(x - cx, y - cy);
  		            if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
  		                return {
  		                    optimumCorner: corner,
  		                    optimumDistance: d
  		                };
  		            }
  		            return stat;
  		        }, {
  		            optimumDistance: closest ? Infinity : -Infinity,
  		            optimumCorner: null
  		        }).optimumCorner;
  		    };
  		    var calculateRadius = function (gradient, x, y, width, height) {
  		        var rx = 0;
  		        var ry = 0;
  		        switch (gradient.size) {
  		            case 0 /* CLOSEST_SIDE */:
  		                // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradients center.
  		                // If the shape is an ellipse, it exactly meets the closest side in each dimension.
  		                if (gradient.shape === 0 /* CIRCLE */) {
  		                    rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
  		                }
  		                else if (gradient.shape === 1 /* ELLIPSE */) {
  		                    rx = Math.min(Math.abs(x), Math.abs(x - width));
  		                    ry = Math.min(Math.abs(y), Math.abs(y - height));
  		                }
  		                break;
  		            case 2 /* CLOSEST_CORNER */:
  		                // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradients center.
  		                // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
  		                if (gradient.shape === 0 /* CIRCLE */) {
  		                    rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
  		                }
  		                else if (gradient.shape === 1 /* ELLIPSE */) {
  		                    // Compute the ratio ry/rx (which is to be the same as for "closest-side")
  		                    var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
  		                    var _a = findCorner(width, height, x, y, true), cx = _a[0], cy = _a[1];
  		                    rx = distance(cx - x, (cy - y) / c);
  		                    ry = c * rx;
  		                }
  		                break;
  		            case 1 /* FARTHEST_SIDE */:
  		                // Same as closest-side, except the ending shape is sized based on the farthest side(s)
  		                if (gradient.shape === 0 /* CIRCLE */) {
  		                    rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
  		                }
  		                else if (gradient.shape === 1 /* ELLIPSE */) {
  		                    rx = Math.max(Math.abs(x), Math.abs(x - width));
  		                    ry = Math.max(Math.abs(y), Math.abs(y - height));
  		                }
  		                break;
  		            case 3 /* FARTHEST_CORNER */:
  		                // Same as closest-corner, except the ending shape is sized based on the farthest corner.
  		                // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
  		                if (gradient.shape === 0 /* CIRCLE */) {
  		                    rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
  		                }
  		                else if (gradient.shape === 1 /* ELLIPSE */) {
  		                    // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
  		                    var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
  		                    var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
  		                    rx = distance(cx - x, (cy - y) / c);
  		                    ry = c * rx;
  		                }
  		                break;
  		        }
  		        if (Array.isArray(gradient.size)) {
  		            rx = getAbsoluteValue(gradient.size[0], width);
  		            ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  		        }
  		        return [rx, ry];
  		    };

  		    var linearGradient = function (context, tokens) {
  		        var angle$1 = deg(180);
  		        var stops = [];
  		        parseFunctionArgs(tokens).forEach(function (arg, i) {
  		            if (i === 0) {
  		                var firstToken = arg[0];
  		                if (firstToken.type === 20 /* IDENT_TOKEN */ && firstToken.value === 'to') {
  		                    angle$1 = parseNamedSide(arg);
  		                    return;
  		                }
  		                else if (isAngle(firstToken)) {
  		                    angle$1 = angle.parse(context, firstToken);
  		                    return;
  		                }
  		            }
  		            var colorStop = parseColorStop(context, arg);
  		            stops.push(colorStop);
  		        });
  		        return { angle: angle$1, stops: stops, type: 1 /* LINEAR_GRADIENT */ };
  		    };

  		    var prefixLinearGradient = function (context, tokens) {
  		        var angle$1 = deg(180);
  		        var stops = [];
  		        parseFunctionArgs(tokens).forEach(function (arg, i) {
  		            if (i === 0) {
  		                var firstToken = arg[0];
  		                if (firstToken.type === 20 /* IDENT_TOKEN */ &&
  		                    ['top', 'left', 'right', 'bottom'].indexOf(firstToken.value) !== -1) {
  		                    angle$1 = parseNamedSide(arg);
  		                    return;
  		                }
  		                else if (isAngle(firstToken)) {
  		                    angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
  		                    return;
  		                }
  		            }
  		            var colorStop = parseColorStop(context, arg);
  		            stops.push(colorStop);
  		        });
  		        return {
  		            angle: angle$1,
  		            stops: stops,
  		            type: 1 /* LINEAR_GRADIENT */
  		        };
  		    };

  		    var webkitGradient = function (context, tokens) {
  		        var angle = deg(180);
  		        var stops = [];
  		        var type = 1 /* LINEAR_GRADIENT */;
  		        var shape = 0 /* CIRCLE */;
  		        var size = 3 /* FARTHEST_CORNER */;
  		        var position = [];
  		        parseFunctionArgs(tokens).forEach(function (arg, i) {
  		            var firstToken = arg[0];
  		            if (i === 0) {
  		                if (isIdentToken(firstToken) && firstToken.value === 'linear') {
  		                    type = 1 /* LINEAR_GRADIENT */;
  		                    return;
  		                }
  		                else if (isIdentToken(firstToken) && firstToken.value === 'radial') {
  		                    type = 2 /* RADIAL_GRADIENT */;
  		                    return;
  		                }
  		            }
  		            if (firstToken.type === 18 /* FUNCTION */) {
  		                if (firstToken.name === 'from') {
  		                    var color = color$1.parse(context, firstToken.values[0]);
  		                    stops.push({ stop: ZERO_LENGTH, color: color });
  		                }
  		                else if (firstToken.name === 'to') {
  		                    var color = color$1.parse(context, firstToken.values[0]);
  		                    stops.push({ stop: HUNDRED_PERCENT, color: color });
  		                }
  		                else if (firstToken.name === 'color-stop') {
  		                    var values = firstToken.values.filter(nonFunctionArgSeparator);
  		                    if (values.length === 2) {
  		                        var color = color$1.parse(context, values[1]);
  		                        var stop_1 = values[0];
  		                        if (isNumberToken(stop_1)) {
  		                            stops.push({
  		                                stop: { type: 16 /* PERCENTAGE_TOKEN */, number: stop_1.number * 100, flags: stop_1.flags },
  		                                color: color
  		                            });
  		                        }
  		                    }
  		                }
  		            }
  		        });
  		        return type === 1 /* LINEAR_GRADIENT */
  		            ? {
  		                angle: (angle + deg(180)) % deg(360),
  		                stops: stops,
  		                type: type
  		            }
  		            : { size: size, shape: shape, stops: stops, position: position, type: type };
  		    };

  		    var CLOSEST_SIDE = 'closest-side';
  		    var FARTHEST_SIDE = 'farthest-side';
  		    var CLOSEST_CORNER = 'closest-corner';
  		    var FARTHEST_CORNER = 'farthest-corner';
  		    var CIRCLE = 'circle';
  		    var ELLIPSE = 'ellipse';
  		    var COVER = 'cover';
  		    var CONTAIN = 'contain';
  		    var radialGradient = function (context, tokens) {
  		        var shape = 0 /* CIRCLE */;
  		        var size = 3 /* FARTHEST_CORNER */;
  		        var stops = [];
  		        var position = [];
  		        parseFunctionArgs(tokens).forEach(function (arg, i) {
  		            var isColorStop = true;
  		            if (i === 0) {
  		                var isAtPosition_1 = false;
  		                isColorStop = arg.reduce(function (acc, token) {
  		                    if (isAtPosition_1) {
  		                        if (isIdentToken(token)) {
  		                            switch (token.value) {
  		                                case 'center':
  		                                    position.push(FIFTY_PERCENT);
  		                                    return acc;
  		                                case 'top':
  		                                case 'left':
  		                                    position.push(ZERO_LENGTH);
  		                                    return acc;
  		                                case 'right':
  		                                case 'bottom':
  		                                    position.push(HUNDRED_PERCENT);
  		                                    return acc;
  		                            }
  		                        }
  		                        else if (isLengthPercentage(token) || isLength(token)) {
  		                            position.push(token);
  		                        }
  		                    }
  		                    else if (isIdentToken(token)) {
  		                        switch (token.value) {
  		                            case CIRCLE:
  		                                shape = 0 /* CIRCLE */;
  		                                return false;
  		                            case ELLIPSE:
  		                                shape = 1 /* ELLIPSE */;
  		                                return false;
  		                            case 'at':
  		                                isAtPosition_1 = true;
  		                                return false;
  		                            case CLOSEST_SIDE:
  		                                size = 0 /* CLOSEST_SIDE */;
  		                                return false;
  		                            case COVER:
  		                            case FARTHEST_SIDE:
  		                                size = 1 /* FARTHEST_SIDE */;
  		                                return false;
  		                            case CONTAIN:
  		                            case CLOSEST_CORNER:
  		                                size = 2 /* CLOSEST_CORNER */;
  		                                return false;
  		                            case FARTHEST_CORNER:
  		                                size = 3 /* FARTHEST_CORNER */;
  		                                return false;
  		                        }
  		                    }
  		                    else if (isLength(token) || isLengthPercentage(token)) {
  		                        if (!Array.isArray(size)) {
  		                            size = [];
  		                        }
  		                        size.push(token);
  		                        return false;
  		                    }
  		                    return acc;
  		                }, isColorStop);
  		            }
  		            if (isColorStop) {
  		                var colorStop = parseColorStop(context, arg);
  		                stops.push(colorStop);
  		            }
  		        });
  		        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  		    };

  		    var prefixRadialGradient = function (context, tokens) {
  		        var shape = 0 /* CIRCLE */;
  		        var size = 3 /* FARTHEST_CORNER */;
  		        var stops = [];
  		        var position = [];
  		        parseFunctionArgs(tokens).forEach(function (arg, i) {
  		            var isColorStop = true;
  		            if (i === 0) {
  		                isColorStop = arg.reduce(function (acc, token) {
  		                    if (isIdentToken(token)) {
  		                        switch (token.value) {
  		                            case 'center':
  		                                position.push(FIFTY_PERCENT);
  		                                return false;
  		                            case 'top':
  		                            case 'left':
  		                                position.push(ZERO_LENGTH);
  		                                return false;
  		                            case 'right':
  		                            case 'bottom':
  		                                position.push(HUNDRED_PERCENT);
  		                                return false;
  		                        }
  		                    }
  		                    else if (isLengthPercentage(token) || isLength(token)) {
  		                        position.push(token);
  		                        return false;
  		                    }
  		                    return acc;
  		                }, isColorStop);
  		            }
  		            else if (i === 1) {
  		                isColorStop = arg.reduce(function (acc, token) {
  		                    if (isIdentToken(token)) {
  		                        switch (token.value) {
  		                            case CIRCLE:
  		                                shape = 0 /* CIRCLE */;
  		                                return false;
  		                            case ELLIPSE:
  		                                shape = 1 /* ELLIPSE */;
  		                                return false;
  		                            case CONTAIN:
  		                            case CLOSEST_SIDE:
  		                                size = 0 /* CLOSEST_SIDE */;
  		                                return false;
  		                            case FARTHEST_SIDE:
  		                                size = 1 /* FARTHEST_SIDE */;
  		                                return false;
  		                            case CLOSEST_CORNER:
  		                                size = 2 /* CLOSEST_CORNER */;
  		                                return false;
  		                            case COVER:
  		                            case FARTHEST_CORNER:
  		                                size = 3 /* FARTHEST_CORNER */;
  		                                return false;
  		                        }
  		                    }
  		                    else if (isLength(token) || isLengthPercentage(token)) {
  		                        if (!Array.isArray(size)) {
  		                            size = [];
  		                        }
  		                        size.push(token);
  		                        return false;
  		                    }
  		                    return acc;
  		                }, isColorStop);
  		            }
  		            if (isColorStop) {
  		                var colorStop = parseColorStop(context, arg);
  		                stops.push(colorStop);
  		            }
  		        });
  		        return { size: size, shape: shape, stops: stops, position: position, type: 2 /* RADIAL_GRADIENT */ };
  		    };

  		    var isLinearGradient = function (background) {
  		        return background.type === 1 /* LINEAR_GRADIENT */;
  		    };
  		    var isRadialGradient = function (background) {
  		        return background.type === 2 /* RADIAL_GRADIENT */;
  		    };
  		    var image = {
  		        name: 'image',
  		        parse: function (context, value) {
  		            if (value.type === 22 /* URL_TOKEN */) {
  		                var image_1 = { url: value.value, type: 0 /* URL */ };
  		                context.cache.addImage(value.value);
  		                return image_1;
  		            }
  		            if (value.type === 18 /* FUNCTION */) {
  		                var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
  		                if (typeof imageFunction === 'undefined') {
  		                    throw new Error("Attempting to parse an unsupported image function \"" + value.name + "\"");
  		                }
  		                return imageFunction(context, value.values);
  		            }
  		            throw new Error("Unsupported image type " + value.type);
  		        }
  		    };
  		    function isSupportedImage(value) {
  		        return (!(value.type === 20 /* IDENT_TOKEN */ && value.value === 'none') &&
  		            (value.type !== 18 /* FUNCTION */ || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]));
  		    }
  		    var SUPPORTED_IMAGE_FUNCTIONS = {
  		        'linear-gradient': linearGradient,
  		        '-moz-linear-gradient': prefixLinearGradient,
  		        '-ms-linear-gradient': prefixLinearGradient,
  		        '-o-linear-gradient': prefixLinearGradient,
  		        '-webkit-linear-gradient': prefixLinearGradient,
  		        'radial-gradient': radialGradient,
  		        '-moz-radial-gradient': prefixRadialGradient,
  		        '-ms-radial-gradient': prefixRadialGradient,
  		        '-o-radial-gradient': prefixRadialGradient,
  		        '-webkit-radial-gradient': prefixRadialGradient,
  		        '-webkit-gradient': webkitGradient
  		    };

  		    var backgroundImage = {
  		        name: 'background-image',
  		        initialValue: 'none',
  		        type: 1 /* LIST */,
  		        prefix: false,
  		        parse: function (context, tokens) {
  		            if (tokens.length === 0) {
  		                return [];
  		            }
  		            var first = tokens[0];
  		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
  		                return [];
  		            }
  		            return tokens
  		                .filter(function (value) { return nonFunctionArgSeparator(value) && isSupportedImage(value); })
  		                .map(function (value) { return image.parse(context, value); });
  		        }
  		    };

  		    var backgroundOrigin = {
  		        name: 'background-origin',
  		        initialValue: 'border-box',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return tokens.map(function (token) {
  		                if (isIdentToken(token)) {
  		                    switch (token.value) {
  		                        case 'padding-box':
  		                            return 1 /* PADDING_BOX */;
  		                        case 'content-box':
  		                            return 2 /* CONTENT_BOX */;
  		                    }
  		                }
  		                return 0 /* BORDER_BOX */;
  		            });
  		        }
  		    };

  		    var backgroundPosition = {
  		        name: 'background-position',
  		        initialValue: '0% 0%',
  		        type: 1 /* LIST */,
  		        prefix: false,
  		        parse: function (_context, tokens) {
  		            return parseFunctionArgs(tokens)
  		                .map(function (values) { return values.filter(isLengthPercentage); })
  		                .map(parseLengthPercentageTuple);
  		        }
  		    };

  		    var backgroundRepeat = {
  		        name: 'background-repeat',
  		        initialValue: 'repeat',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return parseFunctionArgs(tokens)
  		                .map(function (values) {
  		                return values
  		                    .filter(isIdentToken)
  		                    .map(function (token) { return token.value; })
  		                    .join(' ');
  		            })
  		                .map(parseBackgroundRepeat);
  		        }
  		    };
  		    var parseBackgroundRepeat = function (value) {
  		        switch (value) {
  		            case 'no-repeat':
  		                return 1 /* NO_REPEAT */;
  		            case 'repeat-x':
  		            case 'repeat no-repeat':
  		                return 2 /* REPEAT_X */;
  		            case 'repeat-y':
  		            case 'no-repeat repeat':
  		                return 3 /* REPEAT_Y */;
  		            case 'repeat':
  		            default:
  		                return 0 /* REPEAT */;
  		        }
  		    };

  		    var BACKGROUND_SIZE;
  		    (function (BACKGROUND_SIZE) {
  		        BACKGROUND_SIZE["AUTO"] = "auto";
  		        BACKGROUND_SIZE["CONTAIN"] = "contain";
  		        BACKGROUND_SIZE["COVER"] = "cover";
  		    })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
  		    var backgroundSize = {
  		        name: 'background-size',
  		        initialValue: '0',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return parseFunctionArgs(tokens).map(function (values) { return values.filter(isBackgroundSizeInfoToken); });
  		        }
  		    };
  		    var isBackgroundSizeInfoToken = function (value) {
  		        return isIdentToken(value) || isLengthPercentage(value);
  		    };

  		    var borderColorForSide = function (side) { return ({
  		        name: "border-" + side + "-color",
  		        initialValue: 'transparent',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'color'
  		    }); };
  		    var borderTopColor = borderColorForSide('top');
  		    var borderRightColor = borderColorForSide('right');
  		    var borderBottomColor = borderColorForSide('bottom');
  		    var borderLeftColor = borderColorForSide('left');

  		    var borderRadiusForSide = function (side) { return ({
  		        name: "border-radius-" + side,
  		        initialValue: '0 0',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
  		        }
  		    }); };
  		    var borderTopLeftRadius = borderRadiusForSide('top-left');
  		    var borderTopRightRadius = borderRadiusForSide('top-right');
  		    var borderBottomRightRadius = borderRadiusForSide('bottom-right');
  		    var borderBottomLeftRadius = borderRadiusForSide('bottom-left');

  		    var borderStyleForSide = function (side) { return ({
  		        name: "border-" + side + "-style",
  		        initialValue: 'solid',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, style) {
  		            switch (style) {
  		                case 'none':
  		                    return 0 /* NONE */;
  		                case 'dashed':
  		                    return 2 /* DASHED */;
  		                case 'dotted':
  		                    return 3 /* DOTTED */;
  		                case 'double':
  		                    return 4 /* DOUBLE */;
  		            }
  		            return 1 /* SOLID */;
  		        }
  		    }); };
  		    var borderTopStyle = borderStyleForSide('top');
  		    var borderRightStyle = borderStyleForSide('right');
  		    var borderBottomStyle = borderStyleForSide('bottom');
  		    var borderLeftStyle = borderStyleForSide('left');

  		    var borderWidthForSide = function (side) { return ({
  		        name: "border-" + side + "-width",
  		        initialValue: '0',
  		        type: 0 /* VALUE */,
  		        prefix: false,
  		        parse: function (_context, token) {
  		            if (isDimensionToken(token)) {
  		                return token.number;
  		            }
  		            return 0;
  		        }
  		    }); };
  		    var borderTopWidth = borderWidthForSide('top');
  		    var borderRightWidth = borderWidthForSide('right');
  		    var borderBottomWidth = borderWidthForSide('bottom');
  		    var borderLeftWidth = borderWidthForSide('left');

  		    var color = {
  		        name: "color",
  		        initialValue: 'transparent',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'color'
  		    };

  		    var direction = {
  		        name: 'direction',
  		        initialValue: 'ltr',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, direction) {
  		            switch (direction) {
  		                case 'rtl':
  		                    return 1 /* RTL */;
  		                case 'ltr':
  		                default:
  		                    return 0 /* LTR */;
  		            }
  		        }
  		    };

  		    var display = {
  		        name: 'display',
  		        initialValue: 'inline-block',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return tokens.filter(isIdentToken).reduce(function (bit, token) {
  		                return bit | parseDisplayValue(token.value);
  		            }, 0 /* NONE */);
  		        }
  		    };
  		    var parseDisplayValue = function (display) {
  		        switch (display) {
  		            case 'block':
  		            case '-webkit-box':
  		                return 2 /* BLOCK */;
  		            case 'inline':
  		                return 4 /* INLINE */;
  		            case 'run-in':
  		                return 8 /* RUN_IN */;
  		            case 'flow':
  		                return 16 /* FLOW */;
  		            case 'flow-root':
  		                return 32 /* FLOW_ROOT */;
  		            case 'table':
  		                return 64 /* TABLE */;
  		            case 'flex':
  		            case '-webkit-flex':
  		                return 128 /* FLEX */;
  		            case 'grid':
  		            case '-ms-grid':
  		                return 256 /* GRID */;
  		            case 'ruby':
  		                return 512 /* RUBY */;
  		            case 'subgrid':
  		                return 1024 /* SUBGRID */;
  		            case 'list-item':
  		                return 2048 /* LIST_ITEM */;
  		            case 'table-row-group':
  		                return 4096 /* TABLE_ROW_GROUP */;
  		            case 'table-header-group':
  		                return 8192 /* TABLE_HEADER_GROUP */;
  		            case 'table-footer-group':
  		                return 16384 /* TABLE_FOOTER_GROUP */;
  		            case 'table-row':
  		                return 32768 /* TABLE_ROW */;
  		            case 'table-cell':
  		                return 65536 /* TABLE_CELL */;
  		            case 'table-column-group':
  		                return 131072 /* TABLE_COLUMN_GROUP */;
  		            case 'table-column':
  		                return 262144 /* TABLE_COLUMN */;
  		            case 'table-caption':
  		                return 524288 /* TABLE_CAPTION */;
  		            case 'ruby-base':
  		                return 1048576 /* RUBY_BASE */;
  		            case 'ruby-text':
  		                return 2097152 /* RUBY_TEXT */;
  		            case 'ruby-base-container':
  		                return 4194304 /* RUBY_BASE_CONTAINER */;
  		            case 'ruby-text-container':
  		                return 8388608 /* RUBY_TEXT_CONTAINER */;
  		            case 'contents':
  		                return 16777216 /* CONTENTS */;
  		            case 'inline-block':
  		                return 33554432 /* INLINE_BLOCK */;
  		            case 'inline-list-item':
  		                return 67108864 /* INLINE_LIST_ITEM */;
  		            case 'inline-table':
  		                return 134217728 /* INLINE_TABLE */;
  		            case 'inline-flex':
  		                return 268435456 /* INLINE_FLEX */;
  		            case 'inline-grid':
  		                return 536870912 /* INLINE_GRID */;
  		        }
  		        return 0 /* NONE */;
  		    };

  		    var float = {
  		        name: 'float',
  		        initialValue: 'none',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, float) {
  		            switch (float) {
  		                case 'left':
  		                    return 1 /* LEFT */;
  		                case 'right':
  		                    return 2 /* RIGHT */;
  		                case 'inline-start':
  		                    return 3 /* INLINE_START */;
  		                case 'inline-end':
  		                    return 4 /* INLINE_END */;
  		            }
  		            return 0 /* NONE */;
  		        }
  		    };

  		    var letterSpacing = {
  		        name: 'letter-spacing',
  		        initialValue: '0',
  		        prefix: false,
  		        type: 0 /* VALUE */,
  		        parse: function (_context, token) {
  		            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'normal') {
  		                return 0;
  		            }
  		            if (token.type === 17 /* NUMBER_TOKEN */) {
  		                return token.number;
  		            }
  		            if (token.type === 15 /* DIMENSION_TOKEN */) {
  		                return token.number;
  		            }
  		            return 0;
  		        }
  		    };

  		    var LINE_BREAK;
  		    (function (LINE_BREAK) {
  		        LINE_BREAK["NORMAL"] = "normal";
  		        LINE_BREAK["STRICT"] = "strict";
  		    })(LINE_BREAK || (LINE_BREAK = {}));
  		    var lineBreak = {
  		        name: 'line-break',
  		        initialValue: 'normal',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, lineBreak) {
  		            switch (lineBreak) {
  		                case 'strict':
  		                    return LINE_BREAK.STRICT;
  		                case 'normal':
  		                default:
  		                    return LINE_BREAK.NORMAL;
  		            }
  		        }
  		    };

  		    var lineHeight = {
  		        name: 'line-height',
  		        initialValue: 'normal',
  		        prefix: false,
  		        type: 4 /* TOKEN_VALUE */
  		    };
  		    var computeLineHeight = function (token, fontSize) {
  		        if (isIdentToken(token) && token.value === 'normal') {
  		            return 1.2 * fontSize;
  		        }
  		        else if (token.type === 17 /* NUMBER_TOKEN */) {
  		            return fontSize * token.number;
  		        }
  		        else if (isLengthPercentage(token)) {
  		            return getAbsoluteValue(token, fontSize);
  		        }
  		        return fontSize;
  		    };

  		    var listStyleImage = {
  		        name: 'list-style-image',
  		        initialValue: 'none',
  		        type: 0 /* VALUE */,
  		        prefix: false,
  		        parse: function (context, token) {
  		            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
  		                return null;
  		            }
  		            return image.parse(context, token);
  		        }
  		    };

  		    var listStylePosition = {
  		        name: 'list-style-position',
  		        initialValue: 'outside',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, position) {
  		            switch (position) {
  		                case 'inside':
  		                    return 0 /* INSIDE */;
  		                case 'outside':
  		                default:
  		                    return 1 /* OUTSIDE */;
  		            }
  		        }
  		    };

  		    var listStyleType = {
  		        name: 'list-style-type',
  		        initialValue: 'none',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, type) {
  		            switch (type) {
  		                case 'disc':
  		                    return 0 /* DISC */;
  		                case 'circle':
  		                    return 1 /* CIRCLE */;
  		                case 'square':
  		                    return 2 /* SQUARE */;
  		                case 'decimal':
  		                    return 3 /* DECIMAL */;
  		                case 'cjk-decimal':
  		                    return 4 /* CJK_DECIMAL */;
  		                case 'decimal-leading-zero':
  		                    return 5 /* DECIMAL_LEADING_ZERO */;
  		                case 'lower-roman':
  		                    return 6 /* LOWER_ROMAN */;
  		                case 'upper-roman':
  		                    return 7 /* UPPER_ROMAN */;
  		                case 'lower-greek':
  		                    return 8 /* LOWER_GREEK */;
  		                case 'lower-alpha':
  		                    return 9 /* LOWER_ALPHA */;
  		                case 'upper-alpha':
  		                    return 10 /* UPPER_ALPHA */;
  		                case 'arabic-indic':
  		                    return 11 /* ARABIC_INDIC */;
  		                case 'armenian':
  		                    return 12 /* ARMENIAN */;
  		                case 'bengali':
  		                    return 13 /* BENGALI */;
  		                case 'cambodian':
  		                    return 14 /* CAMBODIAN */;
  		                case 'cjk-earthly-branch':
  		                    return 15 /* CJK_EARTHLY_BRANCH */;
  		                case 'cjk-heavenly-stem':
  		                    return 16 /* CJK_HEAVENLY_STEM */;
  		                case 'cjk-ideographic':
  		                    return 17 /* CJK_IDEOGRAPHIC */;
  		                case 'devanagari':
  		                    return 18 /* DEVANAGARI */;
  		                case 'ethiopic-numeric':
  		                    return 19 /* ETHIOPIC_NUMERIC */;
  		                case 'georgian':
  		                    return 20 /* GEORGIAN */;
  		                case 'gujarati':
  		                    return 21 /* GUJARATI */;
  		                case 'gurmukhi':
  		                    return 22 /* GURMUKHI */;
  		                case 'hebrew':
  		                    return 22 /* HEBREW */;
  		                case 'hiragana':
  		                    return 23 /* HIRAGANA */;
  		                case 'hiragana-iroha':
  		                    return 24 /* HIRAGANA_IROHA */;
  		                case 'japanese-formal':
  		                    return 25 /* JAPANESE_FORMAL */;
  		                case 'japanese-informal':
  		                    return 26 /* JAPANESE_INFORMAL */;
  		                case 'kannada':
  		                    return 27 /* KANNADA */;
  		                case 'katakana':
  		                    return 28 /* KATAKANA */;
  		                case 'katakana-iroha':
  		                    return 29 /* KATAKANA_IROHA */;
  		                case 'khmer':
  		                    return 30 /* KHMER */;
  		                case 'korean-hangul-formal':
  		                    return 31 /* KOREAN_HANGUL_FORMAL */;
  		                case 'korean-hanja-formal':
  		                    return 32 /* KOREAN_HANJA_FORMAL */;
  		                case 'korean-hanja-informal':
  		                    return 33 /* KOREAN_HANJA_INFORMAL */;
  		                case 'lao':
  		                    return 34 /* LAO */;
  		                case 'lower-armenian':
  		                    return 35 /* LOWER_ARMENIAN */;
  		                case 'malayalam':
  		                    return 36 /* MALAYALAM */;
  		                case 'mongolian':
  		                    return 37 /* MONGOLIAN */;
  		                case 'myanmar':
  		                    return 38 /* MYANMAR */;
  		                case 'oriya':
  		                    return 39 /* ORIYA */;
  		                case 'persian':
  		                    return 40 /* PERSIAN */;
  		                case 'simp-chinese-formal':
  		                    return 41 /* SIMP_CHINESE_FORMAL */;
  		                case 'simp-chinese-informal':
  		                    return 42 /* SIMP_CHINESE_INFORMAL */;
  		                case 'tamil':
  		                    return 43 /* TAMIL */;
  		                case 'telugu':
  		                    return 44 /* TELUGU */;
  		                case 'thai':
  		                    return 45 /* THAI */;
  		                case 'tibetan':
  		                    return 46 /* TIBETAN */;
  		                case 'trad-chinese-formal':
  		                    return 47 /* TRAD_CHINESE_FORMAL */;
  		                case 'trad-chinese-informal':
  		                    return 48 /* TRAD_CHINESE_INFORMAL */;
  		                case 'upper-armenian':
  		                    return 49 /* UPPER_ARMENIAN */;
  		                case 'disclosure-open':
  		                    return 50 /* DISCLOSURE_OPEN */;
  		                case 'disclosure-closed':
  		                    return 51 /* DISCLOSURE_CLOSED */;
  		                case 'none':
  		                default:
  		                    return -1 /* NONE */;
  		            }
  		        }
  		    };

  		    var marginForSide = function (side) { return ({
  		        name: "margin-" + side,
  		        initialValue: '0',
  		        prefix: false,
  		        type: 4 /* TOKEN_VALUE */
  		    }); };
  		    var marginTop = marginForSide('top');
  		    var marginRight = marginForSide('right');
  		    var marginBottom = marginForSide('bottom');
  		    var marginLeft = marginForSide('left');

  		    var overflow = {
  		        name: 'overflow',
  		        initialValue: 'visible',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return tokens.filter(isIdentToken).map(function (overflow) {
  		                switch (overflow.value) {
  		                    case 'hidden':
  		                        return 1 /* HIDDEN */;
  		                    case 'scroll':
  		                        return 2 /* SCROLL */;
  		                    case 'clip':
  		                        return 3 /* CLIP */;
  		                    case 'auto':
  		                        return 4 /* AUTO */;
  		                    case 'visible':
  		                    default:
  		                        return 0 /* VISIBLE */;
  		                }
  		            });
  		        }
  		    };

  		    var overflowWrap = {
  		        name: 'overflow-wrap',
  		        initialValue: 'normal',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, overflow) {
  		            switch (overflow) {
  		                case 'break-word':
  		                    return "break-word" /* BREAK_WORD */;
  		                case 'normal':
  		                default:
  		                    return "normal" /* NORMAL */;
  		            }
  		        }
  		    };

  		    var paddingForSide = function (side) { return ({
  		        name: "padding-" + side,
  		        initialValue: '0',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'length-percentage'
  		    }); };
  		    var paddingTop = paddingForSide('top');
  		    var paddingRight = paddingForSide('right');
  		    var paddingBottom = paddingForSide('bottom');
  		    var paddingLeft = paddingForSide('left');

  		    var textAlign = {
  		        name: 'text-align',
  		        initialValue: 'left',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, textAlign) {
  		            switch (textAlign) {
  		                case 'right':
  		                    return 2 /* RIGHT */;
  		                case 'center':
  		                case 'justify':
  		                    return 1 /* CENTER */;
  		                case 'left':
  		                default:
  		                    return 0 /* LEFT */;
  		            }
  		        }
  		    };

  		    var position = {
  		        name: 'position',
  		        initialValue: 'static',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, position) {
  		            switch (position) {
  		                case 'relative':
  		                    return 1 /* RELATIVE */;
  		                case 'absolute':
  		                    return 2 /* ABSOLUTE */;
  		                case 'fixed':
  		                    return 3 /* FIXED */;
  		                case 'sticky':
  		                    return 4 /* STICKY */;
  		            }
  		            return 0 /* STATIC */;
  		        }
  		    };

  		    var textShadow = {
  		        name: 'text-shadow',
  		        initialValue: 'none',
  		        type: 1 /* LIST */,
  		        prefix: false,
  		        parse: function (context, tokens) {
  		            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
  		                return [];
  		            }
  		            return parseFunctionArgs(tokens).map(function (values) {
  		                var shadow = {
  		                    color: COLORS.TRANSPARENT,
  		                    offsetX: ZERO_LENGTH,
  		                    offsetY: ZERO_LENGTH,
  		                    blur: ZERO_LENGTH
  		                };
  		                var c = 0;
  		                for (var i = 0; i < values.length; i++) {
  		                    var token = values[i];
  		                    if (isLength(token)) {
  		                        if (c === 0) {
  		                            shadow.offsetX = token;
  		                        }
  		                        else if (c === 1) {
  		                            shadow.offsetY = token;
  		                        }
  		                        else {
  		                            shadow.blur = token;
  		                        }
  		                        c++;
  		                    }
  		                    else {
  		                        shadow.color = color$1.parse(context, token);
  		                    }
  		                }
  		                return shadow;
  		            });
  		        }
  		    };

  		    var textTransform = {
  		        name: 'text-transform',
  		        initialValue: 'none',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, textTransform) {
  		            switch (textTransform) {
  		                case 'uppercase':
  		                    return 2 /* UPPERCASE */;
  		                case 'lowercase':
  		                    return 1 /* LOWERCASE */;
  		                case 'capitalize':
  		                    return 3 /* CAPITALIZE */;
  		            }
  		            return 0 /* NONE */;
  		        }
  		    };

  		    var transform$1 = {
  		        name: 'transform',
  		        initialValue: 'none',
  		        prefix: true,
  		        type: 0 /* VALUE */,
  		        parse: function (_context, token) {
  		            if (token.type === 20 /* IDENT_TOKEN */ && token.value === 'none') {
  		                return null;
  		            }
  		            if (token.type === 18 /* FUNCTION */) {
  		                var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
  		                if (typeof transformFunction === 'undefined') {
  		                    throw new Error("Attempting to parse an unsupported transform function \"" + token.name + "\"");
  		                }
  		                return transformFunction(token.values);
  		            }
  		            return null;
  		        }
  		    };
  		    var matrix = function (args) {
  		        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
  		        return values.length === 6 ? values : null;
  		    };
  		    // doesn't support 3D transforms at the moment
  		    var matrix3d = function (args) {
  		        var values = args.filter(function (arg) { return arg.type === 17 /* NUMBER_TOKEN */; }).map(function (arg) { return arg.number; });
  		        var a1 = values[0], b1 = values[1]; values[2]; values[3]; var a2 = values[4], b2 = values[5]; values[6]; values[7]; values[8]; values[9]; values[10]; values[11]; var a4 = values[12], b4 = values[13]; values[14]; values[15];
  		        return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
  		    };
  		    var SUPPORTED_TRANSFORM_FUNCTIONS = {
  		        matrix: matrix,
  		        matrix3d: matrix3d
  		    };

  		    var DEFAULT_VALUE = {
  		        type: 16 /* PERCENTAGE_TOKEN */,
  		        number: 50,
  		        flags: FLAG_INTEGER
  		    };
  		    var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
  		    var transformOrigin = {
  		        name: 'transform-origin',
  		        initialValue: '50% 50%',
  		        prefix: true,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            var origins = tokens.filter(isLengthPercentage);
  		            if (origins.length !== 2) {
  		                return DEFAULT;
  		            }
  		            return [origins[0], origins[1]];
  		        }
  		    };

  		    var visibility = {
  		        name: 'visible',
  		        initialValue: 'none',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, visibility) {
  		            switch (visibility) {
  		                case 'hidden':
  		                    return 1 /* HIDDEN */;
  		                case 'collapse':
  		                    return 2 /* COLLAPSE */;
  		                case 'visible':
  		                default:
  		                    return 0 /* VISIBLE */;
  		            }
  		        }
  		    };

  		    var WORD_BREAK;
  		    (function (WORD_BREAK) {
  		        WORD_BREAK["NORMAL"] = "normal";
  		        WORD_BREAK["BREAK_ALL"] = "break-all";
  		        WORD_BREAK["KEEP_ALL"] = "keep-all";
  		    })(WORD_BREAK || (WORD_BREAK = {}));
  		    var wordBreak = {
  		        name: 'word-break',
  		        initialValue: 'normal',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, wordBreak) {
  		            switch (wordBreak) {
  		                case 'break-all':
  		                    return WORD_BREAK.BREAK_ALL;
  		                case 'keep-all':
  		                    return WORD_BREAK.KEEP_ALL;
  		                case 'normal':
  		                default:
  		                    return WORD_BREAK.NORMAL;
  		            }
  		        }
  		    };

  		    var zIndex = {
  		        name: 'z-index',
  		        initialValue: 'auto',
  		        prefix: false,
  		        type: 0 /* VALUE */,
  		        parse: function (_context, token) {
  		            if (token.type === 20 /* IDENT_TOKEN */) {
  		                return { auto: true, order: 0 };
  		            }
  		            if (isNumberToken(token)) {
  		                return { auto: false, order: token.number };
  		            }
  		            throw new Error("Invalid z-index number parsed");
  		        }
  		    };

  		    var time = {
  		        name: 'time',
  		        parse: function (_context, value) {
  		            if (value.type === 15 /* DIMENSION_TOKEN */) {
  		                switch (value.unit.toLowerCase()) {
  		                    case 's':
  		                        return 1000 * value.number;
  		                    case 'ms':
  		                        return value.number;
  		                }
  		            }
  		            throw new Error("Unsupported time type");
  		        }
  		    };

  		    var opacity = {
  		        name: 'opacity',
  		        initialValue: '1',
  		        type: 0 /* VALUE */,
  		        prefix: false,
  		        parse: function (_context, token) {
  		            if (isNumberToken(token)) {
  		                return token.number;
  		            }
  		            return 1;
  		        }
  		    };

  		    var textDecorationColor = {
  		        name: "text-decoration-color",
  		        initialValue: 'transparent',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'color'
  		    };

  		    var textDecorationLine = {
  		        name: 'text-decoration-line',
  		        initialValue: 'none',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            return tokens
  		                .filter(isIdentToken)
  		                .map(function (token) {
  		                switch (token.value) {
  		                    case 'underline':
  		                        return 1 /* UNDERLINE */;
  		                    case 'overline':
  		                        return 2 /* OVERLINE */;
  		                    case 'line-through':
  		                        return 3 /* LINE_THROUGH */;
  		                    case 'none':
  		                        return 4 /* BLINK */;
  		                }
  		                return 0 /* NONE */;
  		            })
  		                .filter(function (line) { return line !== 0 /* NONE */; });
  		        }
  		    };

  		    var fontFamily = {
  		        name: "font-family",
  		        initialValue: '',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            var accumulator = [];
  		            var results = [];
  		            tokens.forEach(function (token) {
  		                switch (token.type) {
  		                    case 20 /* IDENT_TOKEN */:
  		                    case 0 /* STRING_TOKEN */:
  		                        accumulator.push(token.value);
  		                        break;
  		                    case 17 /* NUMBER_TOKEN */:
  		                        accumulator.push(token.number.toString());
  		                        break;
  		                    case 4 /* COMMA_TOKEN */:
  		                        results.push(accumulator.join(' '));
  		                        accumulator.length = 0;
  		                        break;
  		                }
  		            });
  		            if (accumulator.length) {
  		                results.push(accumulator.join(' '));
  		            }
  		            return results.map(function (result) { return (result.indexOf(' ') === -1 ? result : "'" + result + "'"); });
  		        }
  		    };

  		    var fontSize = {
  		        name: "font-size",
  		        initialValue: '0',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'length'
  		    };

  		    var fontWeight = {
  		        name: 'font-weight',
  		        initialValue: 'normal',
  		        type: 0 /* VALUE */,
  		        prefix: false,
  		        parse: function (_context, token) {
  		            if (isNumberToken(token)) {
  		                return token.number;
  		            }
  		            if (isIdentToken(token)) {
  		                switch (token.value) {
  		                    case 'bold':
  		                        return 700;
  		                    case 'normal':
  		                    default:
  		                        return 400;
  		                }
  		            }
  		            return 400;
  		        }
  		    };

  		    var fontVariant = {
  		        name: 'font-variant',
  		        initialValue: 'none',
  		        type: 1 /* LIST */,
  		        prefix: false,
  		        parse: function (_context, tokens) {
  		            return tokens.filter(isIdentToken).map(function (token) { return token.value; });
  		        }
  		    };

  		    var fontStyle = {
  		        name: 'font-style',
  		        initialValue: 'normal',
  		        prefix: false,
  		        type: 2 /* IDENT_VALUE */,
  		        parse: function (_context, overflow) {
  		            switch (overflow) {
  		                case 'oblique':
  		                    return "oblique" /* OBLIQUE */;
  		                case 'italic':
  		                    return "italic" /* ITALIC */;
  		                case 'normal':
  		                default:
  		                    return "normal" /* NORMAL */;
  		            }
  		        }
  		    };

  		    var contains = function (bit, value) { return (bit & value) !== 0; };

  		    var content = {
  		        name: 'content',
  		        initialValue: 'none',
  		        type: 1 /* LIST */,
  		        prefix: false,
  		        parse: function (_context, tokens) {
  		            if (tokens.length === 0) {
  		                return [];
  		            }
  		            var first = tokens[0];
  		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
  		                return [];
  		            }
  		            return tokens;
  		        }
  		    };

  		    var counterIncrement = {
  		        name: 'counter-increment',
  		        initialValue: 'none',
  		        prefix: true,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            if (tokens.length === 0) {
  		                return null;
  		            }
  		            var first = tokens[0];
  		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
  		                return null;
  		            }
  		            var increments = [];
  		            var filtered = tokens.filter(nonWhiteSpace);
  		            for (var i = 0; i < filtered.length; i++) {
  		                var counter = filtered[i];
  		                var next = filtered[i + 1];
  		                if (counter.type === 20 /* IDENT_TOKEN */) {
  		                    var increment = next && isNumberToken(next) ? next.number : 1;
  		                    increments.push({ counter: counter.value, increment: increment });
  		                }
  		            }
  		            return increments;
  		        }
  		    };

  		    var counterReset = {
  		        name: 'counter-reset',
  		        initialValue: 'none',
  		        prefix: true,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            if (tokens.length === 0) {
  		                return [];
  		            }
  		            var resets = [];
  		            var filtered = tokens.filter(nonWhiteSpace);
  		            for (var i = 0; i < filtered.length; i++) {
  		                var counter = filtered[i];
  		                var next = filtered[i + 1];
  		                if (isIdentToken(counter) && counter.value !== 'none') {
  		                    var reset = next && isNumberToken(next) ? next.number : 0;
  		                    resets.push({ counter: counter.value, reset: reset });
  		                }
  		            }
  		            return resets;
  		        }
  		    };

  		    var duration = {
  		        name: 'duration',
  		        initialValue: '0s',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (context, tokens) {
  		            return tokens.filter(isDimensionToken).map(function (token) { return time.parse(context, token); });
  		        }
  		    };

  		    var quotes = {
  		        name: 'quotes',
  		        initialValue: 'none',
  		        prefix: true,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            if (tokens.length === 0) {
  		                return null;
  		            }
  		            var first = tokens[0];
  		            if (first.type === 20 /* IDENT_TOKEN */ && first.value === 'none') {
  		                return null;
  		            }
  		            var quotes = [];
  		            var filtered = tokens.filter(isStringToken);
  		            if (filtered.length % 2 !== 0) {
  		                return null;
  		            }
  		            for (var i = 0; i < filtered.length; i += 2) {
  		                var open_1 = filtered[i].value;
  		                var close_1 = filtered[i + 1].value;
  		                quotes.push({ open: open_1, close: close_1 });
  		            }
  		            return quotes;
  		        }
  		    };
  		    var getQuote = function (quotes, depth, open) {
  		        if (!quotes) {
  		            return '';
  		        }
  		        var quote = quotes[Math.min(depth, quotes.length - 1)];
  		        if (!quote) {
  		            return '';
  		        }
  		        return open ? quote.open : quote.close;
  		    };

  		    var boxShadow = {
  		        name: 'box-shadow',
  		        initialValue: 'none',
  		        type: 1 /* LIST */,
  		        prefix: false,
  		        parse: function (context, tokens) {
  		            if (tokens.length === 1 && isIdentWithValue(tokens[0], 'none')) {
  		                return [];
  		            }
  		            return parseFunctionArgs(tokens).map(function (values) {
  		                var shadow = {
  		                    color: 0x000000ff,
  		                    offsetX: ZERO_LENGTH,
  		                    offsetY: ZERO_LENGTH,
  		                    blur: ZERO_LENGTH,
  		                    spread: ZERO_LENGTH,
  		                    inset: false
  		                };
  		                var c = 0;
  		                for (var i = 0; i < values.length; i++) {
  		                    var token = values[i];
  		                    if (isIdentWithValue(token, 'inset')) {
  		                        shadow.inset = true;
  		                    }
  		                    else if (isLength(token)) {
  		                        if (c === 0) {
  		                            shadow.offsetX = token;
  		                        }
  		                        else if (c === 1) {
  		                            shadow.offsetY = token;
  		                        }
  		                        else if (c === 2) {
  		                            shadow.blur = token;
  		                        }
  		                        else {
  		                            shadow.spread = token;
  		                        }
  		                        c++;
  		                    }
  		                    else {
  		                        shadow.color = color$1.parse(context, token);
  		                    }
  		                }
  		                return shadow;
  		            });
  		        }
  		    };

  		    var paintOrder = {
  		        name: 'paint-order',
  		        initialValue: 'normal',
  		        prefix: false,
  		        type: 1 /* LIST */,
  		        parse: function (_context, tokens) {
  		            var DEFAULT_VALUE = [0 /* FILL */, 1 /* STROKE */, 2 /* MARKERS */];
  		            var layers = [];
  		            tokens.filter(isIdentToken).forEach(function (token) {
  		                switch (token.value) {
  		                    case 'stroke':
  		                        layers.push(1 /* STROKE */);
  		                        break;
  		                    case 'fill':
  		                        layers.push(0 /* FILL */);
  		                        break;
  		                    case 'markers':
  		                        layers.push(2 /* MARKERS */);
  		                        break;
  		                }
  		            });
  		            DEFAULT_VALUE.forEach(function (value) {
  		                if (layers.indexOf(value) === -1) {
  		                    layers.push(value);
  		                }
  		            });
  		            return layers;
  		        }
  		    };

  		    var webkitTextStrokeColor = {
  		        name: "-webkit-text-stroke-color",
  		        initialValue: 'currentcolor',
  		        prefix: false,
  		        type: 3 /* TYPE_VALUE */,
  		        format: 'color'
  		    };

  		    var webkitTextStrokeWidth = {
  		        name: "-webkit-text-stroke-width",
  		        initialValue: '0',
  		        type: 0 /* VALUE */,
  		        prefix: false,
  		        parse: function (_context, token) {
  		            if (isDimensionToken(token)) {
  		                return token.number;
  		            }
  		            return 0;
  		        }
  		    };

  		    var CSSParsedDeclaration = /** @class */ (function () {
  		        function CSSParsedDeclaration(context, declaration) {
  		            var _a, _b;
  		            this.animationDuration = parse(context, duration, declaration.animationDuration);
  		            this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
  		            this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
  		            this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
  		            this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
  		            this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
  		            this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
  		            this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
  		            this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
  		            this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
  		            this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
  		            this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
  		            this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
  		            this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
  		            this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
  		            this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
  		            this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
  		            this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
  		            this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
  		            this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
  		            this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
  		            this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
  		            this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
  		            this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
  		            this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
  		            this.color = parse(context, color, declaration.color);
  		            this.direction = parse(context, direction, declaration.direction);
  		            this.display = parse(context, display, declaration.display);
  		            this.float = parse(context, float, declaration.cssFloat);
  		            this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
  		            this.fontSize = parse(context, fontSize, declaration.fontSize);
  		            this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
  		            this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
  		            this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
  		            this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
  		            this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
  		            this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
  		            this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
  		            this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
  		            this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
  		            this.marginTop = parse(context, marginTop, declaration.marginTop);
  		            this.marginRight = parse(context, marginRight, declaration.marginRight);
  		            this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
  		            this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
  		            this.opacity = parse(context, opacity, declaration.opacity);
  		            var overflowTuple = parse(context, overflow, declaration.overflow);
  		            this.overflowX = overflowTuple[0];
  		            this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
  		            this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
  		            this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
  		            this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
  		            this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
  		            this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
  		            this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
  		            this.position = parse(context, position, declaration.position);
  		            this.textAlign = parse(context, textAlign, declaration.textAlign);
  		            this.textDecorationColor = parse(context, textDecorationColor, (_a = declaration.textDecorationColor) !== null && _a !== void 0 ? _a : declaration.color);
  		            this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
  		            this.textShadow = parse(context, textShadow, declaration.textShadow);
  		            this.textTransform = parse(context, textTransform, declaration.textTransform);
  		            this.transform = parse(context, transform$1, declaration.transform);
  		            this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
  		            this.visibility = parse(context, visibility, declaration.visibility);
  		            this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
  		            this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
  		            this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
  		            this.zIndex = parse(context, zIndex, declaration.zIndex);
  		        }
  		        CSSParsedDeclaration.prototype.isVisible = function () {
  		            return this.display > 0 && this.opacity > 0 && this.visibility === 0 /* VISIBLE */;
  		        };
  		        CSSParsedDeclaration.prototype.isTransparent = function () {
  		            return isTransparent(this.backgroundColor);
  		        };
  		        CSSParsedDeclaration.prototype.isTransformed = function () {
  		            return this.transform !== null;
  		        };
  		        CSSParsedDeclaration.prototype.isPositioned = function () {
  		            return this.position !== 0 /* STATIC */;
  		        };
  		        CSSParsedDeclaration.prototype.isPositionedWithZIndex = function () {
  		            return this.isPositioned() && !this.zIndex.auto;
  		        };
  		        CSSParsedDeclaration.prototype.isFloating = function () {
  		            return this.float !== 0 /* NONE */;
  		        };
  		        CSSParsedDeclaration.prototype.isInlineLevel = function () {
  		            return (contains(this.display, 4 /* INLINE */) ||
  		                contains(this.display, 33554432 /* INLINE_BLOCK */) ||
  		                contains(this.display, 268435456 /* INLINE_FLEX */) ||
  		                contains(this.display, 536870912 /* INLINE_GRID */) ||
  		                contains(this.display, 67108864 /* INLINE_LIST_ITEM */) ||
  		                contains(this.display, 134217728 /* INLINE_TABLE */));
  		        };
  		        return CSSParsedDeclaration;
  		    }());
  		    var CSSParsedPseudoDeclaration = /** @class */ (function () {
  		        function CSSParsedPseudoDeclaration(context, declaration) {
  		            this.content = parse(context, content, declaration.content);
  		            this.quotes = parse(context, quotes, declaration.quotes);
  		        }
  		        return CSSParsedPseudoDeclaration;
  		    }());
  		    var CSSParsedCounterDeclaration = /** @class */ (function () {
  		        function CSSParsedCounterDeclaration(context, declaration) {
  		            this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
  		            this.counterReset = parse(context, counterReset, declaration.counterReset);
  		        }
  		        return CSSParsedCounterDeclaration;
  		    }());
  		    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		    var parse = function (context, descriptor, style) {
  		        var tokenizer = new Tokenizer();
  		        var value = style !== null && typeof style !== 'undefined' ? style.toString() : descriptor.initialValue;
  		        tokenizer.write(value);
  		        var parser = new Parser(tokenizer.read());
  		        switch (descriptor.type) {
  		            case 2 /* IDENT_VALUE */:
  		                var token = parser.parseComponentValue();
  		                return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
  		            case 0 /* VALUE */:
  		                return descriptor.parse(context, parser.parseComponentValue());
  		            case 1 /* LIST */:
  		                return descriptor.parse(context, parser.parseComponentValues());
  		            case 4 /* TOKEN_VALUE */:
  		                return parser.parseComponentValue();
  		            case 3 /* TYPE_VALUE */:
  		                switch (descriptor.format) {
  		                    case 'angle':
  		                        return angle.parse(context, parser.parseComponentValue());
  		                    case 'color':
  		                        return color$1.parse(context, parser.parseComponentValue());
  		                    case 'image':
  		                        return image.parse(context, parser.parseComponentValue());
  		                    case 'length':
  		                        var length_1 = parser.parseComponentValue();
  		                        return isLength(length_1) ? length_1 : ZERO_LENGTH;
  		                    case 'length-percentage':
  		                        var value_1 = parser.parseComponentValue();
  		                        return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
  		                    case 'time':
  		                        return time.parse(context, parser.parseComponentValue());
  		                }
  		                break;
  		        }
  		    };

  		    var elementDebuggerAttribute = 'data-html2canvas-debug';
  		    var getElementDebugType = function (element) {
  		        var attribute = element.getAttribute(elementDebuggerAttribute);
  		        switch (attribute) {
  		            case 'all':
  		                return 1 /* ALL */;
  		            case 'clone':
  		                return 2 /* CLONE */;
  		            case 'parse':
  		                return 3 /* PARSE */;
  		            case 'render':
  		                return 4 /* RENDER */;
  		            default:
  		                return 0 /* NONE */;
  		        }
  		    };
  		    var isDebugging = function (element, type) {
  		        var elementType = getElementDebugType(element);
  		        return elementType === 1 /* ALL */ || type === elementType;
  		    };

  		    var ElementContainer = /** @class */ (function () {
  		        function ElementContainer(context, element) {
  		            this.context = context;
  		            this.textNodes = [];
  		            this.elements = [];
  		            this.flags = 0;
  		            if (isDebugging(element, 3 /* PARSE */)) {
  		                debugger;
  		            }
  		            this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
  		            if (isHTMLElementNode(element)) {
  		                if (this.styles.animationDuration.some(function (duration) { return duration > 0; })) {
  		                    element.style.animationDuration = '0s';
  		                }
  		                if (this.styles.transform !== null) {
  		                    // getBoundingClientRect takes transforms into account
  		                    element.style.transform = 'none';
  		                }
  		            }
  		            this.bounds = parseBounds(this.context, element);
  		            if (isDebugging(element, 4 /* RENDER */)) {
  		                this.flags |= 16 /* DEBUG_RENDER */;
  		            }
  		        }
  		        return ElementContainer;
  		    }());

  		    /*
  		     * text-segmentation 1.0.3 <https://github.com/niklasvh/text-segmentation>
  		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
  		     * Released under MIT License
  		     */
  		    var base64 = 'AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=';

  		    /*
  		     * utrie 1.0.2 <https://github.com/niklasvh/utrie>
  		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
  		     * Released under MIT License
  		     */
  		    var chars$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  		    // Use a lookup table to find the index.
  		    var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  		    for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
  		        lookup$1[chars$1.charCodeAt(i$1)] = i$1;
  		    }
  		    var decode = function (base64) {
  		        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  		        if (base64[base64.length - 1] === '=') {
  		            bufferLength--;
  		            if (base64[base64.length - 2] === '=') {
  		                bufferLength--;
  		            }
  		        }
  		        var buffer = typeof ArrayBuffer !== 'undefined' &&
  		            typeof Uint8Array !== 'undefined' &&
  		            typeof Uint8Array.prototype.slice !== 'undefined'
  		            ? new ArrayBuffer(bufferLength)
  		            : new Array(bufferLength);
  		        var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  		        for (i = 0; i < len; i += 4) {
  		            encoded1 = lookup$1[base64.charCodeAt(i)];
  		            encoded2 = lookup$1[base64.charCodeAt(i + 1)];
  		            encoded3 = lookup$1[base64.charCodeAt(i + 2)];
  		            encoded4 = lookup$1[base64.charCodeAt(i + 3)];
  		            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
  		            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
  		            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
  		        }
  		        return buffer;
  		    };
  		    var polyUint16Array = function (buffer) {
  		        var length = buffer.length;
  		        var bytes = [];
  		        for (var i = 0; i < length; i += 2) {
  		            bytes.push((buffer[i + 1] << 8) | buffer[i]);
  		        }
  		        return bytes;
  		    };
  		    var polyUint32Array = function (buffer) {
  		        var length = buffer.length;
  		        var bytes = [];
  		        for (var i = 0; i < length; i += 4) {
  		            bytes.push((buffer[i + 3] << 24) | (buffer[i + 2] << 16) | (buffer[i + 1] << 8) | buffer[i]);
  		        }
  		        return bytes;
  		    };

  		    /** Shift size for getting the index-2 table offset. */
  		    var UTRIE2_SHIFT_2 = 5;
  		    /** Shift size for getting the index-1 table offset. */
  		    var UTRIE2_SHIFT_1 = 6 + 5;
  		    /**
  		     * Shift size for shifting left the index array values.
  		     * Increases possible data size with 16-bit index values at the cost
  		     * of compactability.
  		     * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
  		     */
  		    var UTRIE2_INDEX_SHIFT = 2;
  		    /**
  		     * Difference between the two shift sizes,
  		     * for getting an index-1 offset from an index-2 offset. 6=11-5
  		     */
  		    var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
  		    /**
  		     * The part of the index-2 table for U+D800..U+DBFF stores values for
  		     * lead surrogate code _units_ not code _points_.
  		     * Values for lead surrogate code _points_ are indexed with this portion of the table.
  		     * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
  		     */
  		    var UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;
  		    /** Number of entries in a data block. 32=0x20 */
  		    var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
  		    /** Mask for getting the lower bits for the in-data-block offset. */
  		    var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
  		    var UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
  		    /** Count the lengths of both BMP pieces. 2080=0x820 */
  		    var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
  		    /**
  		     * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
  		     * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
  		     */
  		    var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
  		    var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
  		    /**
  		     * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
  		     * Variable length, for code points up to highStart, where the last single-value range starts.
  		     * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
  		     * (For 0x100000 supplementary code points U+10000..U+10ffff.)
  		     *
  		     * The part of the index-2 table for supplementary code points starts
  		     * after this index-1 table.
  		     *
  		     * Both the index-1 table and the following part of the index-2 table
  		     * are omitted completely if there is only BMP data.
  		     */
  		    var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
  		    /**
  		     * Number of index-1 entries for the BMP. 32=0x20
  		     * This part of the index-1 table is omitted from the serialized form.
  		     */
  		    var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;
  		    /** Number of entries in an index-2 block. 64=0x40 */
  		    var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
  		    /** Mask for getting the lower bits for the in-index-2-block offset. */
  		    var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
  		    var slice16 = function (view, start, end) {
  		        if (view.slice) {
  		            return view.slice(start, end);
  		        }
  		        return new Uint16Array(Array.prototype.slice.call(view, start, end));
  		    };
  		    var slice32 = function (view, start, end) {
  		        if (view.slice) {
  		            return view.slice(start, end);
  		        }
  		        return new Uint32Array(Array.prototype.slice.call(view, start, end));
  		    };
  		    var createTrieFromBase64 = function (base64, _byteLength) {
  		        var buffer = decode(base64);
  		        var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
  		        var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
  		        var headerLength = 24;
  		        var index = slice16(view16, headerLength / 2, view32[4] / 2);
  		        var data = view32[5] === 2
  		            ? slice16(view16, (headerLength + view32[4]) / 2)
  		            : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  		        return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
  		    };
  		    var Trie = /** @class */ (function () {
  		        function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
  		            this.initialValue = initialValue;
  		            this.errorValue = errorValue;
  		            this.highStart = highStart;
  		            this.highValueIndex = highValueIndex;
  		            this.index = index;
  		            this.data = data;
  		        }
  		        /**
  		         * Get the value for a code point as stored in the Trie.
  		         *
  		         * @param codePoint the code point
  		         * @return the value
  		         */
  		        Trie.prototype.get = function (codePoint) {
  		            var ix;
  		            if (codePoint >= 0) {
  		                if (codePoint < 0x0d800 || (codePoint > 0x0dbff && codePoint <= 0x0ffff)) {
  		                    // Ordinary BMP code point, excluding leading surrogates.
  		                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
  		                    // 16 bit data is stored in the index array itself.
  		                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];
  		                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
  		                    return this.data[ix];
  		                }
  		                if (codePoint <= 0xffff) {
  		                    // Lead Surrogate Code Point.  A Separate index section is stored for
  		                    // lead surrogate code units and code points.
  		                    //   The main index has the code unit data.
  		                    //   For this function, we need the code point data.
  		                    // Note: this expression could be refactored for slightly improved efficiency, but
  		                    //       surrogate code points will be so rare in practice that it's not worth it.
  		                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> UTRIE2_SHIFT_2)];
  		                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
  		                    return this.data[ix];
  		                }
  		                if (codePoint < this.highStart) {
  		                    // Supplemental code point, use two-level lookup.
  		                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
  		                    ix = this.index[ix];
  		                    ix += (codePoint >> UTRIE2_SHIFT_2) & UTRIE2_INDEX_2_MASK;
  		                    ix = this.index[ix];
  		                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
  		                    return this.data[ix];
  		                }
  		                if (codePoint <= 0x10ffff) {
  		                    return this.data[this.highValueIndex];
  		                }
  		            }
  		            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
  		            return this.errorValue;
  		        };
  		        return Trie;
  		    }());

  		    /*
  		     * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>
  		     * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
  		     * Released under MIT License
  		     */
  		    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  		    // Use a lookup table to find the index.
  		    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
  		    for (var i = 0; i < chars.length; i++) {
  		        lookup[chars.charCodeAt(i)] = i;
  		    }

  		    var Prepend = 1;
  		    var CR = 2;
  		    var LF = 3;
  		    var Control = 4;
  		    var Extend = 5;
  		    var SpacingMark = 7;
  		    var L = 8;
  		    var V = 9;
  		    var T = 10;
  		    var LV = 11;
  		    var LVT = 12;
  		    var ZWJ = 13;
  		    var Extended_Pictographic = 14;
  		    var RI = 15;
  		    var toCodePoints = function (str) {
  		        var codePoints = [];
  		        var i = 0;
  		        var length = str.length;
  		        while (i < length) {
  		            var value = str.charCodeAt(i++);
  		            if (value >= 0xd800 && value <= 0xdbff && i < length) {
  		                var extra = str.charCodeAt(i++);
  		                if ((extra & 0xfc00) === 0xdc00) {
  		                    codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
  		                }
  		                else {
  		                    codePoints.push(value);
  		                    i--;
  		                }
  		            }
  		            else {
  		                codePoints.push(value);
  		            }
  		        }
  		        return codePoints;
  		    };
  		    var fromCodePoint = function () {
  		        var codePoints = [];
  		        for (var _i = 0; _i < arguments.length; _i++) {
  		            codePoints[_i] = arguments[_i];
  		        }
  		        if (String.fromCodePoint) {
  		            return String.fromCodePoint.apply(String, codePoints);
  		        }
  		        var length = codePoints.length;
  		        if (!length) {
  		            return '';
  		        }
  		        var codeUnits = [];
  		        var index = -1;
  		        var result = '';
  		        while (++index < length) {
  		            var codePoint = codePoints[index];
  		            if (codePoint <= 0xffff) {
  		                codeUnits.push(codePoint);
  		            }
  		            else {
  		                codePoint -= 0x10000;
  		                codeUnits.push((codePoint >> 10) + 0xd800, (codePoint % 0x400) + 0xdc00);
  		            }
  		            if (index + 1 === length || codeUnits.length > 0x4000) {
  		                result += String.fromCharCode.apply(String, codeUnits);
  		                codeUnits.length = 0;
  		            }
  		        }
  		        return result;
  		    };
  		    var UnicodeTrie = createTrieFromBase64(base64);
  		    var BREAK_NOT_ALLOWED = '';
  		    var BREAK_ALLOWED = '';
  		    var codePointToClass = function (codePoint) { return UnicodeTrie.get(codePoint); };
  		    var _graphemeBreakAtIndex = function (_codePoints, classTypes, index) {
  		        var prevIndex = index - 2;
  		        var prev = classTypes[prevIndex];
  		        var current = classTypes[index - 1];
  		        var next = classTypes[index];
  		        // GB3 Do not break between a CR and LF
  		        if (current === CR && next === LF) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // GB4 Otherwise, break before and after controls.
  		        if (current === CR || current === LF || current === Control) {
  		            return BREAK_ALLOWED;
  		        }
  		        // GB5
  		        if (next === CR || next === LF || next === Control) {
  		            return BREAK_ALLOWED;
  		        }
  		        // Do not break Hangul syllable sequences.
  		        // GB6
  		        if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // GB7
  		        if ((current === LV || current === V) && (next === V || next === T)) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // GB8
  		        if ((current === LVT || current === T) && next === T) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // GB9 Do not break before extending characters or ZWJ.
  		        if (next === ZWJ || next === Extend) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // Do not break before SpacingMarks, or after Prepend characters.
  		        // GB9a
  		        if (next === SpacingMark) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // GB9a
  		        if (current === Prepend) {
  		            return BREAK_NOT_ALLOWED;
  		        }
  		        // GB11 Do not break within emoji modifier sequences or emoji zwj sequences.
  		        if (current === ZWJ && next === Extended_Pictographic) {
  		            while (prev === Extend) {
  		                prev = classTypes[--prevIndex];
  		            }
  		            if (prev === Extended_Pictographic) {
  		                return BREAK_NOT_ALLOWED;
  		            }
  		        }
  		        // GB12 Do not break within emoji flag sequences.
  		        // That is, do not break between regional indicator (RI) symbols
  		        // if there is an odd number of RI characters before the break point.
  		        if (current === RI && next === RI) {
  		            var countRI = 0;
  		            while (prev === RI) {
  		                countRI++;
  		                prev = classTypes[--prevIndex];
  		            }
  		            if (countRI % 2 === 0) {
  		                return BREAK_NOT_ALLOWED;
  		            }
  		        }
  		        return BREAK_ALLOWED;
  		    };
  		    var GraphemeBreaker = function (str) {
  		        var codePoints = toCodePoints(str);
  		        var length = codePoints.length;
  		        var index = 0;
  		        var lastEnd = 0;
  		        var classTypes = codePoints.map(codePointToClass);
  		        return {
  		            next: function () {
  		                if (index >= length) {
  		                    return { done: true, value: null };
  		                }
  		                var graphemeBreak = BREAK_NOT_ALLOWED;
  		                while (index < length &&
  		                    (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index)) === BREAK_NOT_ALLOWED) { }
  		                if (graphemeBreak !== BREAK_NOT_ALLOWED || index === length) {
  		                    var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index));
  		                    lastEnd = index;
  		                    return { value: value, done: false };
  		                }
  		                return { done: true, value: null };
  		            },
  		        };
  		    };
  		    var splitGraphemes = function (str) {
  		        var breaker = GraphemeBreaker(str);
  		        var graphemes = [];
  		        var bk;
  		        while (!(bk = breaker.next()).done) {
  		            if (bk.value) {
  		                graphemes.push(bk.value.slice());
  		            }
  		        }
  		        return graphemes;
  		    };

  		    var testRangeBounds = function (document) {
  		        var TEST_HEIGHT = 123;
  		        if (document.createRange) {
  		            var range = document.createRange();
  		            if (range.getBoundingClientRect) {
  		                var testElement = document.createElement('boundtest');
  		                testElement.style.height = TEST_HEIGHT + "px";
  		                testElement.style.display = 'block';
  		                document.body.appendChild(testElement);
  		                range.selectNode(testElement);
  		                var rangeBounds = range.getBoundingClientRect();
  		                var rangeHeight = Math.round(rangeBounds.height);
  		                document.body.removeChild(testElement);
  		                if (rangeHeight === TEST_HEIGHT) {
  		                    return true;
  		                }
  		            }
  		        }
  		        return false;
  		    };
  		    var testIOSLineBreak = function (document) {
  		        var testElement = document.createElement('boundtest');
  		        testElement.style.width = '50px';
  		        testElement.style.display = 'block';
  		        testElement.style.fontSize = '12px';
  		        testElement.style.letterSpacing = '0px';
  		        testElement.style.wordSpacing = '0px';
  		        document.body.appendChild(testElement);
  		        var range = document.createRange();
  		        testElement.innerHTML = typeof ''.repeat === 'function' ? '&#128104;'.repeat(10) : '';
  		        var node = testElement.firstChild;
  		        var textList = toCodePoints$1(node.data).map(function (i) { return fromCodePoint$1(i); });
  		        var offset = 0;
  		        var prev = {};
  		        // ios 13 does not handle range getBoundingClientRect line changes correctly #2177
  		        var supports = textList.every(function (text, i) {
  		            range.setStart(node, offset);
  		            range.setEnd(node, offset + text.length);
  		            var rect = range.getBoundingClientRect();
  		            offset += text.length;
  		            var boundAhead = rect.x > prev.x || rect.y > prev.y;
  		            prev = rect;
  		            if (i === 0) {
  		                return true;
  		            }
  		            return boundAhead;
  		        });
  		        document.body.removeChild(testElement);
  		        return supports;
  		    };
  		    var testCORS = function () { return typeof new Image().crossOrigin !== 'undefined'; };
  		    var testResponseType = function () { return typeof new XMLHttpRequest().responseType === 'string'; };
  		    var testSVG = function (document) {
  		        var img = new Image();
  		        var canvas = document.createElement('canvas');
  		        var ctx = canvas.getContext('2d');
  		        if (!ctx) {
  		            return false;
  		        }
  		        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  		        try {
  		            ctx.drawImage(img, 0, 0);
  		            canvas.toDataURL();
  		        }
  		        catch (e) {
  		            return false;
  		        }
  		        return true;
  		    };
  		    var isGreenPixel = function (data) {
  		        return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
  		    };
  		    var testForeignObject = function (document) {
  		        var canvas = document.createElement('canvas');
  		        var size = 100;
  		        canvas.width = size;
  		        canvas.height = size;
  		        var ctx = canvas.getContext('2d');
  		        if (!ctx) {
  		            return Promise.reject(false);
  		        }
  		        ctx.fillStyle = 'rgb(0, 255, 0)';
  		        ctx.fillRect(0, 0, size, size);
  		        var img = new Image();
  		        var greenImageSrc = canvas.toDataURL();
  		        img.src = greenImageSrc;
  		        var svg = createForeignObjectSVG(size, size, 0, 0, img);
  		        ctx.fillStyle = 'red';
  		        ctx.fillRect(0, 0, size, size);
  		        return loadSerializedSVG$1(svg)
  		            .then(function (img) {
  		            ctx.drawImage(img, 0, 0);
  		            var data = ctx.getImageData(0, 0, size, size).data;
  		            ctx.fillStyle = 'red';
  		            ctx.fillRect(0, 0, size, size);
  		            var node = document.createElement('div');
  		            node.style.backgroundImage = "url(" + greenImageSrc + ")";
  		            node.style.height = size + "px";
  		            // Firefox 55 does not render inline <img /> tags
  		            return isGreenPixel(data)
  		                ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node))
  		                : Promise.reject(false);
  		        })
  		            .then(function (img) {
  		            ctx.drawImage(img, 0, 0);
  		            // Edge does not render background-images
  		            return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  		        })
  		            .catch(function () { return false; });
  		    };
  		    var createForeignObjectSVG = function (width, height, x, y, node) {
  		        var xmlns = 'http://www.w3.org/2000/svg';
  		        var svg = document.createElementNS(xmlns, 'svg');
  		        var foreignObject = document.createElementNS(xmlns, 'foreignObject');
  		        svg.setAttributeNS(null, 'width', width.toString());
  		        svg.setAttributeNS(null, 'height', height.toString());
  		        foreignObject.setAttributeNS(null, 'width', '100%');
  		        foreignObject.setAttributeNS(null, 'height', '100%');
  		        foreignObject.setAttributeNS(null, 'x', x.toString());
  		        foreignObject.setAttributeNS(null, 'y', y.toString());
  		        foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
  		        svg.appendChild(foreignObject);
  		        foreignObject.appendChild(node);
  		        return svg;
  		    };
  		    var loadSerializedSVG$1 = function (svg) {
  		        return new Promise(function (resolve, reject) {
  		            var img = new Image();
  		            img.onload = function () { return resolve(img); };
  		            img.onerror = reject;
  		            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  		        });
  		    };
  		    var FEATURES = {
  		        get SUPPORT_RANGE_BOUNDS() {
  		            var value = testRangeBounds(document);
  		            Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_WORD_BREAKING() {
  		            var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
  		            Object.defineProperty(FEATURES, 'SUPPORT_WORD_BREAKING', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_SVG_DRAWING() {
  		            var value = testSVG(document);
  		            Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_FOREIGNOBJECT_DRAWING() {
  		            var value = typeof Array.from === 'function' && typeof window.fetch === 'function'
  		                ? testForeignObject(document)
  		                : Promise.resolve(false);
  		            Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_CORS_IMAGES() {
  		            var value = testCORS();
  		            Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_RESPONSE_TYPE() {
  		            var value = testResponseType();
  		            Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_CORS_XHR() {
  		            var value = 'withCredentials' in new XMLHttpRequest();
  		            Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
  		            return value;
  		        },
  		        get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
  		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		            var value = !!(typeof Intl !== 'undefined' && Intl.Segmenter);
  		            Object.defineProperty(FEATURES, 'SUPPORT_NATIVE_TEXT_SEGMENTATION', { value: value });
  		            return value;
  		        }
  		    };

  		    var TextBounds = /** @class */ (function () {
  		        function TextBounds(text, bounds) {
  		            this.text = text;
  		            this.bounds = bounds;
  		        }
  		        return TextBounds;
  		    }());
  		    var parseTextBounds = function (context, value, styles, node) {
  		        var textList = breakText(value, styles);
  		        var textBounds = [];
  		        var offset = 0;
  		        textList.forEach(function (text) {
  		            if (styles.textDecorationLine.length || text.trim().length > 0) {
  		                if (FEATURES.SUPPORT_RANGE_BOUNDS) {
  		                    var clientRects = createRange(node, offset, text.length).getClientRects();
  		                    if (clientRects.length > 1) {
  		                        var subSegments = segmentGraphemes(text);
  		                        var subOffset_1 = 0;
  		                        subSegments.forEach(function (subSegment) {
  		                            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
  		                            subOffset_1 += subSegment.length;
  		                        });
  		                    }
  		                    else {
  		                        textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
  		                    }
  		                }
  		                else {
  		                    var replacementNode = node.splitText(text.length);
  		                    textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
  		                    node = replacementNode;
  		                }
  		            }
  		            else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
  		                node = node.splitText(text.length);
  		            }
  		            offset += text.length;
  		        });
  		        return textBounds;
  		    };
  		    var getWrapperBounds = function (context, node) {
  		        var ownerDocument = node.ownerDocument;
  		        if (ownerDocument) {
  		            var wrapper = ownerDocument.createElement('html2canvaswrapper');
  		            wrapper.appendChild(node.cloneNode(true));
  		            var parentNode = node.parentNode;
  		            if (parentNode) {
  		                parentNode.replaceChild(wrapper, node);
  		                var bounds = parseBounds(context, wrapper);
  		                if (wrapper.firstChild) {
  		                    parentNode.replaceChild(wrapper.firstChild, wrapper);
  		                }
  		                return bounds;
  		            }
  		        }
  		        return Bounds.EMPTY;
  		    };
  		    var createRange = function (node, offset, length) {
  		        var ownerDocument = node.ownerDocument;
  		        if (!ownerDocument) {
  		            throw new Error('Node has no owner document');
  		        }
  		        var range = ownerDocument.createRange();
  		        range.setStart(node, offset);
  		        range.setEnd(node, offset + length);
  		        return range;
  		    };
  		    var segmentGraphemes = function (value) {
  		        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
  		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		            var segmenter = new Intl.Segmenter(void 0, { granularity: 'grapheme' });
  		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
  		        }
  		        return splitGraphemes(value);
  		    };
  		    var segmentWords = function (value, styles) {
  		        if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
  		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		            var segmenter = new Intl.Segmenter(void 0, {
  		                granularity: 'word'
  		            });
  		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		            return Array.from(segmenter.segment(value)).map(function (segment) { return segment.segment; });
  		        }
  		        return breakWords(value, styles);
  		    };
  		    var breakText = function (value, styles) {
  		        return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
  		    };
  		    // https://drafts.csswg.org/css-text/#word-separator
  		    var wordSeparators = [0x0020, 0x00a0, 0x1361, 0x10100, 0x10101, 0x1039, 0x1091];
  		    var breakWords = function (str, styles) {
  		        var breaker = LineBreaker(str, {
  		            lineBreak: styles.lineBreak,
  		            wordBreak: styles.overflowWrap === "break-word" /* BREAK_WORD */ ? 'break-word' : styles.wordBreak
  		        });
  		        var words = [];
  		        var bk;
  		        var _loop_1 = function () {
  		            if (bk.value) {
  		                var value = bk.value.slice();
  		                var codePoints = toCodePoints$1(value);
  		                var word_1 = '';
  		                codePoints.forEach(function (codePoint) {
  		                    if (wordSeparators.indexOf(codePoint) === -1) {
  		                        word_1 += fromCodePoint$1(codePoint);
  		                    }
  		                    else {
  		                        if (word_1.length) {
  		                            words.push(word_1);
  		                        }
  		                        words.push(fromCodePoint$1(codePoint));
  		                        word_1 = '';
  		                    }
  		                });
  		                if (word_1.length) {
  		                    words.push(word_1);
  		                }
  		            }
  		        };
  		        while (!(bk = breaker.next()).done) {
  		            _loop_1();
  		        }
  		        return words;
  		    };

  		    var TextContainer = /** @class */ (function () {
  		        function TextContainer(context, node, styles) {
  		            this.text = transform(node.data, styles.textTransform);
  		            this.textBounds = parseTextBounds(context, this.text, styles, node);
  		        }
  		        return TextContainer;
  		    }());
  		    var transform = function (text, transform) {
  		        switch (transform) {
  		            case 1 /* LOWERCASE */:
  		                return text.toLowerCase();
  		            case 3 /* CAPITALIZE */:
  		                return text.replace(CAPITALIZE, capitalize);
  		            case 2 /* UPPERCASE */:
  		                return text.toUpperCase();
  		            default:
  		                return text;
  		        }
  		    };
  		    var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
  		    var capitalize = function (m, p1, p2) {
  		        if (m.length > 0) {
  		            return p1 + p2.toUpperCase();
  		        }
  		        return m;
  		    };

  		    var ImageElementContainer = /** @class */ (function (_super) {
  		        __extends(ImageElementContainer, _super);
  		        function ImageElementContainer(context, img) {
  		            var _this = _super.call(this, context, img) || this;
  		            _this.src = img.currentSrc || img.src;
  		            _this.intrinsicWidth = img.naturalWidth;
  		            _this.intrinsicHeight = img.naturalHeight;
  		            _this.context.cache.addImage(_this.src);
  		            return _this;
  		        }
  		        return ImageElementContainer;
  		    }(ElementContainer));

  		    var CanvasElementContainer = /** @class */ (function (_super) {
  		        __extends(CanvasElementContainer, _super);
  		        function CanvasElementContainer(context, canvas) {
  		            var _this = _super.call(this, context, canvas) || this;
  		            _this.canvas = canvas;
  		            _this.intrinsicWidth = canvas.width;
  		            _this.intrinsicHeight = canvas.height;
  		            return _this;
  		        }
  		        return CanvasElementContainer;
  		    }(ElementContainer));

  		    var SVGElementContainer = /** @class */ (function (_super) {
  		        __extends(SVGElementContainer, _super);
  		        function SVGElementContainer(context, img) {
  		            var _this = _super.call(this, context, img) || this;
  		            var s = new XMLSerializer();
  		            var bounds = parseBounds(context, img);
  		            img.setAttribute('width', bounds.width + "px");
  		            img.setAttribute('height', bounds.height + "px");
  		            _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
  		            _this.intrinsicWidth = img.width.baseVal.value;
  		            _this.intrinsicHeight = img.height.baseVal.value;
  		            _this.context.cache.addImage(_this.svg);
  		            return _this;
  		        }
  		        return SVGElementContainer;
  		    }(ElementContainer));

  		    var LIElementContainer = /** @class */ (function (_super) {
  		        __extends(LIElementContainer, _super);
  		        function LIElementContainer(context, element) {
  		            var _this = _super.call(this, context, element) || this;
  		            _this.value = element.value;
  		            return _this;
  		        }
  		        return LIElementContainer;
  		    }(ElementContainer));

  		    var OLElementContainer = /** @class */ (function (_super) {
  		        __extends(OLElementContainer, _super);
  		        function OLElementContainer(context, element) {
  		            var _this = _super.call(this, context, element) || this;
  		            _this.start = element.start;
  		            _this.reversed = typeof element.reversed === 'boolean' && element.reversed === true;
  		            return _this;
  		        }
  		        return OLElementContainer;
  		    }(ElementContainer));

  		    var CHECKBOX_BORDER_RADIUS = [
  		        {
  		            type: 15 /* DIMENSION_TOKEN */,
  		            flags: 0,
  		            unit: 'px',
  		            number: 3
  		        }
  		    ];
  		    var RADIO_BORDER_RADIUS = [
  		        {
  		            type: 16 /* PERCENTAGE_TOKEN */,
  		            flags: 0,
  		            number: 50
  		        }
  		    ];
  		    var reformatInputBounds = function (bounds) {
  		        if (bounds.width > bounds.height) {
  		            return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  		        }
  		        else if (bounds.width < bounds.height) {
  		            return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  		        }
  		        return bounds;
  		    };
  		    var getInputValue = function (node) {
  		        var value = node.type === PASSWORD ? new Array(node.value.length + 1).join('\u2022') : node.value;
  		        return value.length === 0 ? node.placeholder || '' : value;
  		    };
  		    var CHECKBOX = 'checkbox';
  		    var RADIO = 'radio';
  		    var PASSWORD = 'password';
  		    var INPUT_COLOR = 0x2a2a2aff;
  		    var InputElementContainer = /** @class */ (function (_super) {
  		        __extends(InputElementContainer, _super);
  		        function InputElementContainer(context, input) {
  		            var _this = _super.call(this, context, input) || this;
  		            _this.type = input.type.toLowerCase();
  		            _this.checked = input.checked;
  		            _this.value = getInputValue(input);
  		            if (_this.type === CHECKBOX || _this.type === RADIO) {
  		                _this.styles.backgroundColor = 0xdededeff;
  		                _this.styles.borderTopColor =
  		                    _this.styles.borderRightColor =
  		                        _this.styles.borderBottomColor =
  		                            _this.styles.borderLeftColor =
  		                                0xa5a5a5ff;
  		                _this.styles.borderTopWidth =
  		                    _this.styles.borderRightWidth =
  		                        _this.styles.borderBottomWidth =
  		                            _this.styles.borderLeftWidth =
  		                                1;
  		                _this.styles.borderTopStyle =
  		                    _this.styles.borderRightStyle =
  		                        _this.styles.borderBottomStyle =
  		                            _this.styles.borderLeftStyle =
  		                                1 /* SOLID */;
  		                _this.styles.backgroundClip = [0 /* BORDER_BOX */];
  		                _this.styles.backgroundOrigin = [0 /* BORDER_BOX */];
  		                _this.bounds = reformatInputBounds(_this.bounds);
  		            }
  		            switch (_this.type) {
  		                case CHECKBOX:
  		                    _this.styles.borderTopRightRadius =
  		                        _this.styles.borderTopLeftRadius =
  		                            _this.styles.borderBottomRightRadius =
  		                                _this.styles.borderBottomLeftRadius =
  		                                    CHECKBOX_BORDER_RADIUS;
  		                    break;
  		                case RADIO:
  		                    _this.styles.borderTopRightRadius =
  		                        _this.styles.borderTopLeftRadius =
  		                            _this.styles.borderBottomRightRadius =
  		                                _this.styles.borderBottomLeftRadius =
  		                                    RADIO_BORDER_RADIUS;
  		                    break;
  		            }
  		            return _this;
  		        }
  		        return InputElementContainer;
  		    }(ElementContainer));

  		    var SelectElementContainer = /** @class */ (function (_super) {
  		        __extends(SelectElementContainer, _super);
  		        function SelectElementContainer(context, element) {
  		            var _this = _super.call(this, context, element) || this;
  		            var option = element.options[element.selectedIndex || 0];
  		            _this.value = option ? option.text || '' : '';
  		            return _this;
  		        }
  		        return SelectElementContainer;
  		    }(ElementContainer));

  		    var TextareaElementContainer = /** @class */ (function (_super) {
  		        __extends(TextareaElementContainer, _super);
  		        function TextareaElementContainer(context, element) {
  		            var _this = _super.call(this, context, element) || this;
  		            _this.value = element.value;
  		            return _this;
  		        }
  		        return TextareaElementContainer;
  		    }(ElementContainer));

  		    var IFrameElementContainer = /** @class */ (function (_super) {
  		        __extends(IFrameElementContainer, _super);
  		        function IFrameElementContainer(context, iframe) {
  		            var _this = _super.call(this, context, iframe) || this;
  		            _this.src = iframe.src;
  		            _this.width = parseInt(iframe.width, 10) || 0;
  		            _this.height = parseInt(iframe.height, 10) || 0;
  		            _this.backgroundColor = _this.styles.backgroundColor;
  		            try {
  		                if (iframe.contentWindow &&
  		                    iframe.contentWindow.document &&
  		                    iframe.contentWindow.document.documentElement) {
  		                    _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
  		                    // http://www.w3.org/TR/css3-background/#special-backgrounds
  		                    var documentBackgroundColor = iframe.contentWindow.document.documentElement
  		                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor)
  		                        : COLORS.TRANSPARENT;
  		                    var bodyBackgroundColor = iframe.contentWindow.document.body
  		                        ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor)
  		                        : COLORS.TRANSPARENT;
  		                    _this.backgroundColor = isTransparent(documentBackgroundColor)
  		                        ? isTransparent(bodyBackgroundColor)
  		                            ? _this.styles.backgroundColor
  		                            : bodyBackgroundColor
  		                        : documentBackgroundColor;
  		                }
  		            }
  		            catch (e) { }
  		            return _this;
  		        }
  		        return IFrameElementContainer;
  		    }(ElementContainer));

  		    var LIST_OWNERS = ['OL', 'UL', 'MENU'];
  		    var parseNodeTree = function (context, node, parent, root) {
  		        for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
  		            nextNode = childNode.nextSibling;
  		            if (isTextNode(childNode) && childNode.data.trim().length > 0) {
  		                parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
  		            }
  		            else if (isElementNode(childNode)) {
  		                if (isSlotElement(childNode) && childNode.assignedNodes) {
  		                    childNode.assignedNodes().forEach(function (childNode) { return parseNodeTree(context, childNode, parent, root); });
  		                }
  		                else {
  		                    var container = createContainer(context, childNode);
  		                    if (container.styles.isVisible()) {
  		                        if (createsRealStackingContext(childNode, container, root)) {
  		                            container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
  		                        }
  		                        else if (createsStackingContext(container.styles)) {
  		                            container.flags |= 2 /* CREATES_STACKING_CONTEXT */;
  		                        }
  		                        if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
  		                            container.flags |= 8 /* IS_LIST_OWNER */;
  		                        }
  		                        parent.elements.push(container);
  		                        childNode.slot;
  		                        if (childNode.shadowRoot) {
  		                            parseNodeTree(context, childNode.shadowRoot, container, root);
  		                        }
  		                        else if (!isTextareaElement(childNode) &&
  		                            !isSVGElement(childNode) &&
  		                            !isSelectElement(childNode)) {
  		                            parseNodeTree(context, childNode, container, root);
  		                        }
  		                    }
  		                }
  		            }
  		        }
  		    };
  		    var createContainer = function (context, element) {
  		        if (isImageElement(element)) {
  		            return new ImageElementContainer(context, element);
  		        }
  		        if (isCanvasElement(element)) {
  		            return new CanvasElementContainer(context, element);
  		        }
  		        if (isSVGElement(element)) {
  		            return new SVGElementContainer(context, element);
  		        }
  		        if (isLIElement(element)) {
  		            return new LIElementContainer(context, element);
  		        }
  		        if (isOLElement(element)) {
  		            return new OLElementContainer(context, element);
  		        }
  		        if (isInputElement(element)) {
  		            return new InputElementContainer(context, element);
  		        }
  		        if (isSelectElement(element)) {
  		            return new SelectElementContainer(context, element);
  		        }
  		        if (isTextareaElement(element)) {
  		            return new TextareaElementContainer(context, element);
  		        }
  		        if (isIFrameElement(element)) {
  		            return new IFrameElementContainer(context, element);
  		        }
  		        return new ElementContainer(context, element);
  		    };
  		    var parseTree = function (context, element) {
  		        var container = createContainer(context, element);
  		        container.flags |= 4 /* CREATES_REAL_STACKING_CONTEXT */;
  		        parseNodeTree(context, element, container, container);
  		        return container;
  		    };
  		    var createsRealStackingContext = function (node, container, root) {
  		        return (container.styles.isPositionedWithZIndex() ||
  		            container.styles.opacity < 1 ||
  		            container.styles.isTransformed() ||
  		            (isBodyElement(node) && root.styles.isTransparent()));
  		    };
  		    var createsStackingContext = function (styles) { return styles.isPositioned() || styles.isFloating(); };
  		    var isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
  		    var isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
  		    var isHTMLElementNode = function (node) {
  		        return isElementNode(node) && typeof node.style !== 'undefined' && !isSVGElementNode(node);
  		    };
  		    var isSVGElementNode = function (element) {
  		        return typeof element.className === 'object';
  		    };
  		    var isLIElement = function (node) { return node.tagName === 'LI'; };
  		    var isOLElement = function (node) { return node.tagName === 'OL'; };
  		    var isInputElement = function (node) { return node.tagName === 'INPUT'; };
  		    var isHTMLElement = function (node) { return node.tagName === 'HTML'; };
  		    var isSVGElement = function (node) { return node.tagName === 'svg'; };
  		    var isBodyElement = function (node) { return node.tagName === 'BODY'; };
  		    var isCanvasElement = function (node) { return node.tagName === 'CANVAS'; };
  		    var isVideoElement = function (node) { return node.tagName === 'VIDEO'; };
  		    var isImageElement = function (node) { return node.tagName === 'IMG'; };
  		    var isIFrameElement = function (node) { return node.tagName === 'IFRAME'; };
  		    var isStyleElement = function (node) { return node.tagName === 'STYLE'; };
  		    var isScriptElement = function (node) { return node.tagName === 'SCRIPT'; };
  		    var isTextareaElement = function (node) { return node.tagName === 'TEXTAREA'; };
  		    var isSelectElement = function (node) { return node.tagName === 'SELECT'; };
  		    var isSlotElement = function (node) { return node.tagName === 'SLOT'; };
  		    // https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
  		    var isCustomElement = function (node) { return node.tagName.indexOf('-') > 0; };

  		    var CounterState = /** @class */ (function () {
  		        function CounterState() {
  		            this.counters = {};
  		        }
  		        CounterState.prototype.getCounterValue = function (name) {
  		            var counter = this.counters[name];
  		            if (counter && counter.length) {
  		                return counter[counter.length - 1];
  		            }
  		            return 1;
  		        };
  		        CounterState.prototype.getCounterValues = function (name) {
  		            var counter = this.counters[name];
  		            return counter ? counter : [];
  		        };
  		        CounterState.prototype.pop = function (counters) {
  		            var _this = this;
  		            counters.forEach(function (counter) { return _this.counters[counter].pop(); });
  		        };
  		        CounterState.prototype.parse = function (style) {
  		            var _this = this;
  		            var counterIncrement = style.counterIncrement;
  		            var counterReset = style.counterReset;
  		            var canReset = true;
  		            if (counterIncrement !== null) {
  		                counterIncrement.forEach(function (entry) {
  		                    var counter = _this.counters[entry.counter];
  		                    if (counter && entry.increment !== 0) {
  		                        canReset = false;
  		                        if (!counter.length) {
  		                            counter.push(1);
  		                        }
  		                        counter[Math.max(0, counter.length - 1)] += entry.increment;
  		                    }
  		                });
  		            }
  		            var counterNames = [];
  		            if (canReset) {
  		                counterReset.forEach(function (entry) {
  		                    var counter = _this.counters[entry.counter];
  		                    counterNames.push(entry.counter);
  		                    if (!counter) {
  		                        counter = _this.counters[entry.counter] = [];
  		                    }
  		                    counter.push(entry.reset);
  		                });
  		            }
  		            return counterNames;
  		        };
  		        return CounterState;
  		    }());
  		    var ROMAN_UPPER = {
  		        integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  		        values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
  		    };
  		    var ARMENIAN = {
  		        integers: [
  		            9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70,
  		            60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
  		        ],
  		        values: [
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            ''
  		        ]
  		    };
  		    var HEBREW = {
  		        integers: [
  		            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20,
  		            19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
  		        ],
  		        values: [
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            ''
  		        ]
  		    };
  		    var GEORGIAN = {
  		        integers: [
  		            10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90,
  		            80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
  		        ],
  		        values: [
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            '',
  		            ''
  		        ]
  		    };
  		    var createAdditiveCounter = function (value, min, max, symbols, fallback, suffix) {
  		        if (value < min || value > max) {
  		            return createCounterText(value, fallback, suffix.length > 0);
  		        }
  		        return (symbols.integers.reduce(function (string, integer, index) {
  		            while (value >= integer) {
  		                value -= integer;
  		                string += symbols.values[index];
  		            }
  		            return string;
  		        }, '') + suffix);
  		    };
  		    var createCounterStyleWithSymbolResolver = function (value, codePointRangeLength, isNumeric, resolver) {
  		        var string = '';
  		        do {
  		            if (!isNumeric) {
  		                value--;
  		            }
  		            string = resolver(value) + string;
  		            value /= codePointRangeLength;
  		        } while (value * codePointRangeLength >= codePointRangeLength);
  		        return string;
  		    };
  		    var createCounterStyleFromRange = function (value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  		        var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  		        return ((value < 0 ? '-' : '') +
  		            (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
  		                return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  		            }) +
  		                suffix));
  		    };
  		    var createCounterStyleFromSymbols = function (value, symbols, suffix) {
  		        if (suffix === void 0) { suffix = '. '; }
  		        var codePointRangeLength = symbols.length;
  		        return (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) { return symbols[Math.floor(codePoint % codePointRangeLength)]; }) + suffix);
  		    };
  		    var CJK_ZEROS = 1 << 0;
  		    var CJK_TEN_COEFFICIENTS = 1 << 1;
  		    var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
  		    var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
  		    var createCJKCounter = function (value, numbers, multipliers, negativeSign, suffix, flags) {
  		        if (value < -9999 || value > 9999) {
  		            return createCounterText(value, 4 /* CJK_DECIMAL */, suffix.length > 0);
  		        }
  		        var tmp = Math.abs(value);
  		        var string = suffix;
  		        if (tmp === 0) {
  		            return numbers[0] + string;
  		        }
  		        for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
  		            var coefficient = tmp % 10;
  		            if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== '') {
  		                string = numbers[coefficient] + string;
  		            }
  		            else if (coefficient > 1 ||
  		                (coefficient === 1 && digit === 0) ||
  		                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS)) ||
  		                (coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100) ||
  		                (coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS))) {
  		                string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
  		            }
  		            else if (coefficient === 1 && digit > 0) {
  		                string = multipliers[digit - 1] + string;
  		            }
  		            tmp = Math.floor(tmp / 10);
  		        }
  		        return (value < 0 ? negativeSign : '') + string;
  		    };
  		    var CHINESE_INFORMAL_MULTIPLIERS = '';
  		    var CHINESE_FORMAL_MULTIPLIERS = '';
  		    var JAPANESE_NEGATIVE = '';
  		    var KOREAN_NEGATIVE = '';
  		    var createCounterText = function (value, type, appendSuffix) {
  		        var defaultSuffix = appendSuffix ? '. ' : '';
  		        var cjkSuffix = appendSuffix ? '' : '';
  		        var koreanSuffix = appendSuffix ? ', ' : '';
  		        var spaceSuffix = appendSuffix ? ' ' : '';
  		        switch (type) {
  		            case 0 /* DISC */:
  		                return '' + spaceSuffix;
  		            case 1 /* CIRCLE */:
  		                return '' + spaceSuffix;
  		            case 2 /* SQUARE */:
  		                return '' + spaceSuffix;
  		            case 5 /* DECIMAL_LEADING_ZERO */:
  		                var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  		                return string.length < 4 ? "0" + string : string;
  		            case 4 /* CJK_DECIMAL */:
  		                return createCounterStyleFromSymbols(value, '', cjkSuffix);
  		            case 6 /* LOWER_ROMAN */:
  		                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
  		            case 7 /* UPPER_ROMAN */:
  		                return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3 /* DECIMAL */, defaultSuffix);
  		            case 8 /* LOWER_GREEK */:
  		                return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
  		            case 9 /* LOWER_ALPHA */:
  		                return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
  		            case 10 /* UPPER_ALPHA */:
  		                return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
  		            case 11 /* ARABIC_INDIC */:
  		                return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
  		            case 12 /* ARMENIAN */:
  		            case 49 /* UPPER_ARMENIAN */:
  		                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix);
  		            case 35 /* LOWER_ARMENIAN */:
  		                return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3 /* DECIMAL */, defaultSuffix).toLowerCase();
  		            case 13 /* BENGALI */:
  		                return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
  		            case 14 /* CAMBODIAN */:
  		            case 30 /* KHMER */:
  		                return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
  		            case 15 /* CJK_EARTHLY_BRANCH */:
  		                return createCounterStyleFromSymbols(value, '', cjkSuffix);
  		            case 16 /* CJK_HEAVENLY_STEM */:
  		                return createCounterStyleFromSymbols(value, '', cjkSuffix);
  		            case 17 /* CJK_IDEOGRAPHIC */:
  		            case 48 /* TRAD_CHINESE_INFORMAL */:
  		                return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
  		            case 47 /* TRAD_CHINESE_FORMAL */:
  		                return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
  		            case 42 /* SIMP_CHINESE_INFORMAL */:
  		                return createCJKCounter(value, '', CHINESE_INFORMAL_MULTIPLIERS, '', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
  		            case 41 /* SIMP_CHINESE_FORMAL */:
  		                return createCJKCounter(value, '', CHINESE_FORMAL_MULTIPLIERS, '', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
  		            case 26 /* JAPANESE_INFORMAL */:
  		                return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, 0);
  		            case 25 /* JAPANESE_FORMAL */:
  		                return createCJKCounter(value, '', '', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
  		            case 31 /* KOREAN_HANGUL_FORMAL */:
  		                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
  		            case 33 /* KOREAN_HANJA_INFORMAL */:
  		                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, 0);
  		            case 32 /* KOREAN_HANJA_FORMAL */:
  		                return createCJKCounter(value, '', '', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
  		            case 18 /* DEVANAGARI */:
  		                return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
  		            case 20 /* GEORGIAN */:
  		                return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3 /* DECIMAL */, defaultSuffix);
  		            case 21 /* GUJARATI */:
  		                return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
  		            case 22 /* GURMUKHI */:
  		                return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
  		            case 22 /* HEBREW */:
  		                return createAdditiveCounter(value, 1, 10999, HEBREW, 3 /* DECIMAL */, defaultSuffix);
  		            case 23 /* HIRAGANA */:
  		                return createCounterStyleFromSymbols(value, '');
  		            case 24 /* HIRAGANA_IROHA */:
  		                return createCounterStyleFromSymbols(value, '');
  		            case 27 /* KANNADA */:
  		                return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
  		            case 28 /* KATAKANA */:
  		                return createCounterStyleFromSymbols(value, '', cjkSuffix);
  		            case 29 /* KATAKANA_IROHA */:
  		                return createCounterStyleFromSymbols(value, '', cjkSuffix);
  		            case 34 /* LAO */:
  		                return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
  		            case 37 /* MONGOLIAN */:
  		                return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
  		            case 38 /* MYANMAR */:
  		                return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
  		            case 39 /* ORIYA */:
  		                return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
  		            case 40 /* PERSIAN */:
  		                return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
  		            case 43 /* TAMIL */:
  		                return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
  		            case 44 /* TELUGU */:
  		                return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
  		            case 45 /* THAI */:
  		                return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
  		            case 46 /* TIBETAN */:
  		                return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
  		            case 3 /* DECIMAL */:
  		            default:
  		                return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  		        }
  		    };

  		    var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';
  		    var DocumentCloner = /** @class */ (function () {
  		        function DocumentCloner(context, element, options) {
  		            this.context = context;
  		            this.options = options;
  		            this.scrolledElements = [];
  		            this.referenceElement = element;
  		            this.counters = new CounterState();
  		            this.quoteDepth = 0;
  		            if (!element.ownerDocument) {
  		                throw new Error('Cloned element does not have an owner document');
  		            }
  		            this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
  		        }
  		        DocumentCloner.prototype.toIFrame = function (ownerDocument, windowSize) {
  		            var _this = this;
  		            var iframe = createIFrameContainer(ownerDocument, windowSize);
  		            if (!iframe.contentWindow) {
  		                return Promise.reject("Unable to find iframe window");
  		            }
  		            var scrollX = ownerDocument.defaultView.pageXOffset;
  		            var scrollY = ownerDocument.defaultView.pageYOffset;
  		            var cloneWindow = iframe.contentWindow;
  		            var documentClone = cloneWindow.document;
  		            /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
  		             if window url is about:blank, we can assign the url to current by writing onto the document
  		             */
  		            var iframeLoad = iframeLoader(iframe).then(function () { return __awaiter(_this, void 0, void 0, function () {
  		                var onclone, referenceElement;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            this.scrolledElements.forEach(restoreNodeScroll);
  		                            if (cloneWindow) {
  		                                cloneWindow.scrollTo(windowSize.left, windowSize.top);
  		                                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) &&
  		                                    (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
  		                                    this.context.logger.warn('Unable to restore scroll position for cloned document');
  		                                    this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
  		                                }
  		                            }
  		                            onclone = this.options.onclone;
  		                            referenceElement = this.clonedReferenceElement;
  		                            if (typeof referenceElement === 'undefined') {
  		                                return [2 /*return*/, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
  		                            }
  		                            if (!(documentClone.fonts && documentClone.fonts.ready)) return [3 /*break*/, 2];
  		                            return [4 /*yield*/, documentClone.fonts.ready];
  		                        case 1:
  		                            _a.sent();
  		                            _a.label = 2;
  		                        case 2:
  		                            if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3 /*break*/, 4];
  		                            return [4 /*yield*/, imagesReady(documentClone)];
  		                        case 3:
  		                            _a.sent();
  		                            _a.label = 4;
  		                        case 4:
  		                            if (typeof onclone === 'function') {
  		                                return [2 /*return*/, Promise.resolve()
  		                                        .then(function () { return onclone(documentClone, referenceElement); })
  		                                        .then(function () { return iframe; })];
  		                            }
  		                            return [2 /*return*/, iframe];
  		                    }
  		                });
  		            }); });
  		            documentClone.open();
  		            documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
  		            // Chrome scrolls the parent document for some reason after the write to the cloned window???
  		            restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
  		            documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
  		            documentClone.close();
  		            return iframeLoad;
  		        };
  		        DocumentCloner.prototype.createElementClone = function (node) {
  		            if (isDebugging(node, 2 /* CLONE */)) {
  		                debugger;
  		            }
  		            if (isCanvasElement(node)) {
  		                return this.createCanvasClone(node);
  		            }
  		            if (isVideoElement(node)) {
  		                return this.createVideoClone(node);
  		            }
  		            if (isStyleElement(node)) {
  		                return this.createStyleClone(node);
  		            }
  		            var clone = node.cloneNode(false);
  		            if (isImageElement(clone)) {
  		                if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
  		                    clone.src = node.currentSrc;
  		                    clone.srcset = '';
  		                }
  		                if (clone.loading === 'lazy') {
  		                    clone.loading = 'eager';
  		                }
  		            }
  		            if (isCustomElement(clone)) {
  		                return this.createCustomElementClone(clone);
  		            }
  		            return clone;
  		        };
  		        DocumentCloner.prototype.createCustomElementClone = function (node) {
  		            var clone = document.createElement('html2canvascustomelement');
  		            copyCSSStyles(node.style, clone);
  		            return clone;
  		        };
  		        DocumentCloner.prototype.createStyleClone = function (node) {
  		            try {
  		                var sheet = node.sheet;
  		                if (sheet && sheet.cssRules) {
  		                    var css = [].slice.call(sheet.cssRules, 0).reduce(function (css, rule) {
  		                        if (rule && typeof rule.cssText === 'string') {
  		                            return css + rule.cssText;
  		                        }
  		                        return css;
  		                    }, '');
  		                    var style = node.cloneNode(false);
  		                    style.textContent = css;
  		                    return style;
  		                }
  		            }
  		            catch (e) {
  		                // accessing node.sheet.cssRules throws a DOMException
  		                this.context.logger.error('Unable to access cssRules property', e);
  		                if (e.name !== 'SecurityError') {
  		                    throw e;
  		                }
  		            }
  		            return node.cloneNode(false);
  		        };
  		        DocumentCloner.prototype.createCanvasClone = function (canvas) {
  		            var _a;
  		            if (this.options.inlineImages && canvas.ownerDocument) {
  		                var img = canvas.ownerDocument.createElement('img');
  		                try {
  		                    img.src = canvas.toDataURL();
  		                    return img;
  		                }
  		                catch (e) {
  		                    this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
  		                }
  		            }
  		            var clonedCanvas = canvas.cloneNode(false);
  		            try {
  		                clonedCanvas.width = canvas.width;
  		                clonedCanvas.height = canvas.height;
  		                var ctx = canvas.getContext('2d');
  		                var clonedCtx = clonedCanvas.getContext('2d');
  		                if (clonedCtx) {
  		                    if (!this.options.allowTaint && ctx) {
  		                        clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
  		                    }
  		                    else {
  		                        var gl = (_a = canvas.getContext('webgl2')) !== null && _a !== void 0 ? _a : canvas.getContext('webgl');
  		                        if (gl) {
  		                            var attribs = gl.getContextAttributes();
  		                            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
  		                                this.context.logger.warn('Unable to clone WebGL context as it has preserveDrawingBuffer=false', canvas);
  		                            }
  		                        }
  		                        clonedCtx.drawImage(canvas, 0, 0);
  		                    }
  		                }
  		                return clonedCanvas;
  		            }
  		            catch (e) {
  		                this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
  		            }
  		            return clonedCanvas;
  		        };
  		        DocumentCloner.prototype.createVideoClone = function (video) {
  		            var canvas = video.ownerDocument.createElement('canvas');
  		            canvas.width = video.offsetWidth;
  		            canvas.height = video.offsetHeight;
  		            var ctx = canvas.getContext('2d');
  		            try {
  		                if (ctx) {
  		                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  		                    if (!this.options.allowTaint) {
  		                        ctx.getImageData(0, 0, canvas.width, canvas.height);
  		                    }
  		                }
  		                return canvas;
  		            }
  		            catch (e) {
  		                this.context.logger.info("Unable to clone video as it is tainted", video);
  		            }
  		            var blankCanvas = video.ownerDocument.createElement('canvas');
  		            blankCanvas.width = video.offsetWidth;
  		            blankCanvas.height = video.offsetHeight;
  		            return blankCanvas;
  		        };
  		        DocumentCloner.prototype.appendChildNode = function (clone, child, copyStyles) {
  		            if (!isElementNode(child) ||
  		                (!isScriptElement(child) &&
  		                    !child.hasAttribute(IGNORE_ATTRIBUTE) &&
  		                    (typeof this.options.ignoreElements !== 'function' || !this.options.ignoreElements(child)))) {
  		                if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
  		                    clone.appendChild(this.cloneNode(child, copyStyles));
  		                }
  		            }
  		        };
  		        DocumentCloner.prototype.cloneChildNodes = function (node, clone, copyStyles) {
  		            var _this = this;
  		            for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
  		                if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === 'function') {
  		                    var assignedNodes = child.assignedNodes();
  		                    if (assignedNodes.length) {
  		                        assignedNodes.forEach(function (assignedNode) { return _this.appendChildNode(clone, assignedNode, copyStyles); });
  		                    }
  		                }
  		                else {
  		                    this.appendChildNode(clone, child, copyStyles);
  		                }
  		            }
  		        };
  		        DocumentCloner.prototype.cloneNode = function (node, copyStyles) {
  		            if (isTextNode(node)) {
  		                return document.createTextNode(node.data);
  		            }
  		            if (!node.ownerDocument) {
  		                return node.cloneNode(false);
  		            }
  		            var window = node.ownerDocument.defaultView;
  		            if (window && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
  		                var clone = this.createElementClone(node);
  		                clone.style.transitionProperty = 'none';
  		                var style = window.getComputedStyle(node);
  		                var styleBefore = window.getComputedStyle(node, ':before');
  		                var styleAfter = window.getComputedStyle(node, ':after');
  		                if (this.referenceElement === node && isHTMLElementNode(clone)) {
  		                    this.clonedReferenceElement = clone;
  		                }
  		                if (isBodyElement(clone)) {
  		                    createPseudoHideStyles(clone);
  		                }
  		                var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
  		                var before = this.resolvePseudoContent(node, clone, styleBefore, PseudoElementType.BEFORE);
  		                if (isCustomElement(node)) {
  		                    copyStyles = true;
  		                }
  		                if (!isVideoElement(node)) {
  		                    this.cloneChildNodes(node, clone, copyStyles);
  		                }
  		                if (before) {
  		                    clone.insertBefore(before, clone.firstChild);
  		                }
  		                var after = this.resolvePseudoContent(node, clone, styleAfter, PseudoElementType.AFTER);
  		                if (after) {
  		                    clone.appendChild(after);
  		                }
  		                this.counters.pop(counters);
  		                if ((style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node)) ||
  		                    copyStyles) {
  		                    copyCSSStyles(style, clone);
  		                }
  		                if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
  		                    this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
  		                }
  		                if ((isTextareaElement(node) || isSelectElement(node)) &&
  		                    (isTextareaElement(clone) || isSelectElement(clone))) {
  		                    clone.value = node.value;
  		                }
  		                return clone;
  		            }
  		            return node.cloneNode(false);
  		        };
  		        DocumentCloner.prototype.resolvePseudoContent = function (node, clone, style, pseudoElt) {
  		            var _this = this;
  		            if (!style) {
  		                return;
  		            }
  		            var value = style.content;
  		            var document = clone.ownerDocument;
  		            if (!document || !value || value === 'none' || value === '-moz-alt-content' || style.display === 'none') {
  		                return;
  		            }
  		            this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
  		            var declaration = new CSSParsedPseudoDeclaration(this.context, style);
  		            var anonymousReplacedElement = document.createElement('html2canvaspseudoelement');
  		            copyCSSStyles(style, anonymousReplacedElement);
  		            declaration.content.forEach(function (token) {
  		                if (token.type === 0 /* STRING_TOKEN */) {
  		                    anonymousReplacedElement.appendChild(document.createTextNode(token.value));
  		                }
  		                else if (token.type === 22 /* URL_TOKEN */) {
  		                    var img = document.createElement('img');
  		                    img.src = token.value;
  		                    img.style.opacity = '1';
  		                    anonymousReplacedElement.appendChild(img);
  		                }
  		                else if (token.type === 18 /* FUNCTION */) {
  		                    if (token.name === 'attr') {
  		                        var attr = token.values.filter(isIdentToken);
  		                        if (attr.length) {
  		                            anonymousReplacedElement.appendChild(document.createTextNode(node.getAttribute(attr[0].value) || ''));
  		                        }
  		                    }
  		                    else if (token.name === 'counter') {
  		                        var _a = token.values.filter(nonFunctionArgSeparator), counter = _a[0], counterStyle = _a[1];
  		                        if (counter && isIdentToken(counter)) {
  		                            var counterState = _this.counters.getCounterValue(counter.value);
  		                            var counterType = counterStyle && isIdentToken(counterStyle)
  		                                ? listStyleType.parse(_this.context, counterStyle.value)
  		                                : 3 /* DECIMAL */;
  		                            anonymousReplacedElement.appendChild(document.createTextNode(createCounterText(counterState, counterType, false)));
  		                        }
  		                    }
  		                    else if (token.name === 'counters') {
  		                        var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
  		                        if (counter && isIdentToken(counter)) {
  		                            var counterStates = _this.counters.getCounterValues(counter.value);
  		                            var counterType_1 = counterStyle && isIdentToken(counterStyle)
  		                                ? listStyleType.parse(_this.context, counterStyle.value)
  		                                : 3 /* DECIMAL */;
  		                            var separator = delim && delim.type === 0 /* STRING_TOKEN */ ? delim.value : '';
  		                            var text = counterStates
  		                                .map(function (value) { return createCounterText(value, counterType_1, false); })
  		                                .join(separator);
  		                            anonymousReplacedElement.appendChild(document.createTextNode(text));
  		                        }
  		                    }
  		                    else ;
  		                }
  		                else if (token.type === 20 /* IDENT_TOKEN */) {
  		                    switch (token.value) {
  		                        case 'open-quote':
  		                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
  		                            break;
  		                        case 'close-quote':
  		                            anonymousReplacedElement.appendChild(document.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
  		                            break;
  		                        default:
  		                            // safari doesn't parse string tokens correctly because of lack of quotes
  		                            anonymousReplacedElement.appendChild(document.createTextNode(token.value));
  		                    }
  		                }
  		            });
  		            anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
  		            var newClassName = pseudoElt === PseudoElementType.BEFORE
  		                ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE
  		                : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
  		            if (isSVGElementNode(clone)) {
  		                clone.className.baseValue += newClassName;
  		            }
  		            else {
  		                clone.className += newClassName;
  		            }
  		            return anonymousReplacedElement;
  		        };
  		        DocumentCloner.destroy = function (container) {
  		            if (container.parentNode) {
  		                container.parentNode.removeChild(container);
  		                return true;
  		            }
  		            return false;
  		        };
  		        return DocumentCloner;
  		    }());
  		    var PseudoElementType;
  		    (function (PseudoElementType) {
  		        PseudoElementType[PseudoElementType["BEFORE"] = 0] = "BEFORE";
  		        PseudoElementType[PseudoElementType["AFTER"] = 1] = "AFTER";
  		    })(PseudoElementType || (PseudoElementType = {}));
  		    var createIFrameContainer = function (ownerDocument, bounds) {
  		        var cloneIframeContainer = ownerDocument.createElement('iframe');
  		        cloneIframeContainer.className = 'html2canvas-container';
  		        cloneIframeContainer.style.visibility = 'hidden';
  		        cloneIframeContainer.style.position = 'fixed';
  		        cloneIframeContainer.style.left = '-10000px';
  		        cloneIframeContainer.style.top = '0px';
  		        cloneIframeContainer.style.border = '0';
  		        cloneIframeContainer.width = bounds.width.toString();
  		        cloneIframeContainer.height = bounds.height.toString();
  		        cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
  		        cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
  		        ownerDocument.body.appendChild(cloneIframeContainer);
  		        return cloneIframeContainer;
  		    };
  		    var imageReady = function (img) {
  		        return new Promise(function (resolve) {
  		            if (img.complete) {
  		                resolve();
  		                return;
  		            }
  		            if (!img.src) {
  		                resolve();
  		                return;
  		            }
  		            img.onload = resolve;
  		            img.onerror = resolve;
  		        });
  		    };
  		    var imagesReady = function (document) {
  		        return Promise.all([].slice.call(document.images, 0).map(imageReady));
  		    };
  		    var iframeLoader = function (iframe) {
  		        return new Promise(function (resolve, reject) {
  		            var cloneWindow = iframe.contentWindow;
  		            if (!cloneWindow) {
  		                return reject("No window assigned for iframe");
  		            }
  		            var documentClone = cloneWindow.document;
  		            cloneWindow.onload = iframe.onload = function () {
  		                cloneWindow.onload = iframe.onload = null;
  		                var interval = setInterval(function () {
  		                    if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
  		                        clearInterval(interval);
  		                        resolve(iframe);
  		                    }
  		                }, 50);
  		            };
  		        });
  		    };
  		    var ignoredStyleProperties = [
  		        'all',
  		        'd',
  		        'content' // Safari shows pseudoelements if content is set
  		    ];
  		    var copyCSSStyles = function (style, target) {
  		        // Edge does not provide value for cssText
  		        for (var i = style.length - 1; i >= 0; i--) {
  		            var property = style.item(i);
  		            if (ignoredStyleProperties.indexOf(property) === -1) {
  		                target.style.setProperty(property, style.getPropertyValue(property));
  		            }
  		        }
  		        return target;
  		    };
  		    var serializeDoctype = function (doctype) {
  		        var str = '';
  		        if (doctype) {
  		            str += '<!DOCTYPE ';
  		            if (doctype.name) {
  		                str += doctype.name;
  		            }
  		            if (doctype.internalSubset) {
  		                str += doctype.internalSubset;
  		            }
  		            if (doctype.publicId) {
  		                str += "\"" + doctype.publicId + "\"";
  		            }
  		            if (doctype.systemId) {
  		                str += "\"" + doctype.systemId + "\"";
  		            }
  		            str += '>';
  		        }
  		        return str;
  		    };
  		    var restoreOwnerScroll = function (ownerDocument, x, y) {
  		        if (ownerDocument &&
  		            ownerDocument.defaultView &&
  		            (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
  		            ownerDocument.defaultView.scrollTo(x, y);
  		        }
  		    };
  		    var restoreNodeScroll = function (_a) {
  		        var element = _a[0], x = _a[1], y = _a[2];
  		        element.scrollLeft = x;
  		        element.scrollTop = y;
  		    };
  		    var PSEUDO_BEFORE = ':before';
  		    var PSEUDO_AFTER = ':after';
  		    var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
  		    var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';
  		    var PSEUDO_HIDE_ELEMENT_STYLE = "{\n    content: \"\" !important;\n    display: none !important;\n}";
  		    var createPseudoHideStyles = function (body) {
  		        createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
  		    };
  		    var createStyles = function (body, styles) {
  		        var document = body.ownerDocument;
  		        if (document) {
  		            var style = document.createElement('style');
  		            style.textContent = styles;
  		            body.appendChild(style);
  		        }
  		    };

  		    var CacheStorage = /** @class */ (function () {
  		        function CacheStorage() {
  		        }
  		        CacheStorage.getOrigin = function (url) {
  		            var link = CacheStorage._link;
  		            if (!link) {
  		                return 'about:blank';
  		            }
  		            link.href = url;
  		            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
  		            return link.protocol + link.hostname + link.port;
  		        };
  		        CacheStorage.isSameOrigin = function (src) {
  		            return CacheStorage.getOrigin(src) === CacheStorage._origin;
  		        };
  		        CacheStorage.setContext = function (window) {
  		            CacheStorage._link = window.document.createElement('a');
  		            CacheStorage._origin = CacheStorage.getOrigin(window.location.href);
  		        };
  		        CacheStorage._origin = 'about:blank';
  		        return CacheStorage;
  		    }());
  		    var Cache = /** @class */ (function () {
  		        function Cache(context, _options) {
  		            this.context = context;
  		            this._options = _options;
  		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		            this._cache = {};
  		        }
  		        Cache.prototype.addImage = function (src) {
  		            var result = Promise.resolve();
  		            if (this.has(src)) {
  		                return result;
  		            }
  		            if (isBlobImage(src) || isRenderable(src)) {
  		                (this._cache[src] = this.loadImage(src)).catch(function () {
  		                    // prevent unhandled rejection
  		                });
  		                return result;
  		            }
  		            return result;
  		        };
  		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		        Cache.prototype.match = function (src) {
  		            return this._cache[src];
  		        };
  		        Cache.prototype.loadImage = function (key) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var isSameOrigin, useCORS, useProxy, src;
  		                var _this = this;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            isSameOrigin = CacheStorage.isSameOrigin(key);
  		                            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
  		                            useProxy = !isInlineImage(key) &&
  		                                !isSameOrigin &&
  		                                !isBlobImage(key) &&
  		                                typeof this._options.proxy === 'string' &&
  		                                FEATURES.SUPPORT_CORS_XHR &&
  		                                !useCORS;
  		                            if (!isSameOrigin &&
  		                                this._options.allowTaint === false &&
  		                                !isInlineImage(key) &&
  		                                !isBlobImage(key) &&
  		                                !useProxy &&
  		                                !useCORS) {
  		                                return [2 /*return*/];
  		                            }
  		                            src = key;
  		                            if (!useProxy) return [3 /*break*/, 2];
  		                            return [4 /*yield*/, this.proxy(src)];
  		                        case 1:
  		                            src = _a.sent();
  		                            _a.label = 2;
  		                        case 2:
  		                            this.context.logger.debug("Added image " + key.substring(0, 256));
  		                            return [4 /*yield*/, new Promise(function (resolve, reject) {
  		                                    var img = new Image();
  		                                    img.onload = function () { return resolve(img); };
  		                                    img.onerror = reject;
  		                                    //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
  		                                    if (isInlineBase64Image(src) || useCORS) {
  		                                        img.crossOrigin = 'anonymous';
  		                                    }
  		                                    img.src = src;
  		                                    if (img.complete === true) {
  		                                        // Inline XML images may fail to parse, throwing an Error later on
  		                                        setTimeout(function () { return resolve(img); }, 500);
  		                                    }
  		                                    if (_this._options.imageTimeout > 0) {
  		                                        setTimeout(function () { return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image"); }, _this._options.imageTimeout);
  		                                    }
  		                                })];
  		                        case 3: return [2 /*return*/, _a.sent()];
  		                    }
  		                });
  		            });
  		        };
  		        Cache.prototype.has = function (key) {
  		            return typeof this._cache[key] !== 'undefined';
  		        };
  		        Cache.prototype.keys = function () {
  		            return Promise.resolve(Object.keys(this._cache));
  		        };
  		        Cache.prototype.proxy = function (src) {
  		            var _this = this;
  		            var proxy = this._options.proxy;
  		            if (!proxy) {
  		                throw new Error('No proxy defined');
  		            }
  		            var key = src.substring(0, 256);
  		            return new Promise(function (resolve, reject) {
  		                var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
  		                var xhr = new XMLHttpRequest();
  		                xhr.onload = function () {
  		                    if (xhr.status === 200) {
  		                        if (responseType === 'text') {
  		                            resolve(xhr.response);
  		                        }
  		                        else {
  		                            var reader_1 = new FileReader();
  		                            reader_1.addEventListener('load', function () { return resolve(reader_1.result); }, false);
  		                            reader_1.addEventListener('error', function (e) { return reject(e); }, false);
  		                            reader_1.readAsDataURL(xhr.response);
  		                        }
  		                    }
  		                    else {
  		                        reject("Failed to proxy resource " + key + " with status code " + xhr.status);
  		                    }
  		                };
  		                xhr.onerror = reject;
  		                var queryString = proxy.indexOf('?') > -1 ? '&' : '?';
  		                xhr.open('GET', "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
  		                if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
  		                    xhr.responseType = responseType;
  		                }
  		                if (_this._options.imageTimeout) {
  		                    var timeout_1 = _this._options.imageTimeout;
  		                    xhr.timeout = timeout_1;
  		                    xhr.ontimeout = function () { return reject("Timed out (" + timeout_1 + "ms) proxying " + key); };
  		                }
  		                xhr.send();
  		            });
  		        };
  		        return Cache;
  		    }());
  		    var INLINE_SVG = /^data:image\/svg\+xml/i;
  		    var INLINE_BASE64 = /^data:image\/.*;base64,/i;
  		    var INLINE_IMG = /^data:image\/.*/i;
  		    var isRenderable = function (src) { return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src); };
  		    var isInlineImage = function (src) { return INLINE_IMG.test(src); };
  		    var isInlineBase64Image = function (src) { return INLINE_BASE64.test(src); };
  		    var isBlobImage = function (src) { return src.substr(0, 4) === 'blob'; };
  		    var isSVG = function (src) { return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src); };

  		    var Vector = /** @class */ (function () {
  		        function Vector(x, y) {
  		            this.type = 0 /* VECTOR */;
  		            this.x = x;
  		            this.y = y;
  		        }
  		        Vector.prototype.add = function (deltaX, deltaY) {
  		            return new Vector(this.x + deltaX, this.y + deltaY);
  		        };
  		        return Vector;
  		    }());

  		    var lerp = function (a, b, t) {
  		        return new Vector(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
  		    };
  		    var BezierCurve = /** @class */ (function () {
  		        function BezierCurve(start, startControl, endControl, end) {
  		            this.type = 1 /* BEZIER_CURVE */;
  		            this.start = start;
  		            this.startControl = startControl;
  		            this.endControl = endControl;
  		            this.end = end;
  		        }
  		        BezierCurve.prototype.subdivide = function (t, firstHalf) {
  		            var ab = lerp(this.start, this.startControl, t);
  		            var bc = lerp(this.startControl, this.endControl, t);
  		            var cd = lerp(this.endControl, this.end, t);
  		            var abbc = lerp(ab, bc, t);
  		            var bccd = lerp(bc, cd, t);
  		            var dest = lerp(abbc, bccd, t);
  		            return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
  		        };
  		        BezierCurve.prototype.add = function (deltaX, deltaY) {
  		            return new BezierCurve(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
  		        };
  		        BezierCurve.prototype.reverse = function () {
  		            return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
  		        };
  		        return BezierCurve;
  		    }());
  		    var isBezierCurve = function (path) { return path.type === 1 /* BEZIER_CURVE */; };

  		    var BoundCurves = /** @class */ (function () {
  		        function BoundCurves(element) {
  		            var styles = element.styles;
  		            var bounds = element.bounds;
  		            var _a = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a[0], tlv = _a[1];
  		            var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
  		            var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
  		            var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
  		            var factors = [];
  		            factors.push((tlh + trh) / bounds.width);
  		            factors.push((blh + brh) / bounds.width);
  		            factors.push((tlv + blv) / bounds.height);
  		            factors.push((trv + brv) / bounds.height);
  		            var maxFactor = Math.max.apply(Math, factors);
  		            if (maxFactor > 1) {
  		                tlh /= maxFactor;
  		                tlv /= maxFactor;
  		                trh /= maxFactor;
  		                trv /= maxFactor;
  		                brh /= maxFactor;
  		                brv /= maxFactor;
  		                blh /= maxFactor;
  		                blv /= maxFactor;
  		            }
  		            var topWidth = bounds.width - trh;
  		            var rightHeight = bounds.height - brv;
  		            var bottomWidth = bounds.width - brh;
  		            var leftHeight = bounds.height - blv;
  		            var borderTopWidth = styles.borderTopWidth;
  		            var borderRightWidth = styles.borderRightWidth;
  		            var borderBottomWidth = styles.borderBottomWidth;
  		            var borderLeftWidth = styles.borderLeftWidth;
  		            var paddingTop = getAbsoluteValue(styles.paddingTop, element.bounds.width);
  		            var paddingRight = getAbsoluteValue(styles.paddingRight, element.bounds.width);
  		            var paddingBottom = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
  		            var paddingLeft = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
  		            this.topLeftBorderDoubleOuterBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3, tlh - borderLeftWidth / 3, tlv - borderTopWidth / 3, CORNER.TOP_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + borderTopWidth / 3);
  		            this.topRightBorderDoubleOuterBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 3, trh - borderRightWidth / 3, trv - borderTopWidth / 3, CORNER.TOP_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + borderTopWidth / 3);
  		            this.bottomRightBorderDoubleOuterBox =
  		                brh > 0 || brv > 0
  		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 3, brv - borderBottomWidth / 3, CORNER.BOTTOM_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
  		            this.bottomLeftBorderDoubleOuterBox =
  		                blh > 0 || blv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth / 3, bounds.top + leftHeight, blh - borderLeftWidth / 3, blv - borderBottomWidth / 3, CORNER.BOTTOM_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth / 3, bounds.top + bounds.height - borderBottomWidth / 3);
  		            this.topLeftBorderDoubleInnerBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3, tlh - (borderLeftWidth * 2) / 3, tlv - (borderTopWidth * 2) / 3, CORNER.TOP_LEFT)
  		                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
  		            this.topRightBorderDoubleInnerBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + topWidth, bounds.top + (borderTopWidth * 2) / 3, trh - (borderRightWidth * 2) / 3, trv - (borderTopWidth * 2) / 3, CORNER.TOP_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + (borderTopWidth * 2) / 3);
  		            this.bottomRightBorderDoubleInnerBox =
  		                brh > 0 || brv > 0
  		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - (borderRightWidth * 2) / 3, brv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - (borderRightWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
  		            this.bottomLeftBorderDoubleInnerBox =
  		                blh > 0 || blv > 0
  		                    ? getCurvePoints(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + leftHeight, blh - (borderLeftWidth * 2) / 3, blv - (borderBottomWidth * 2) / 3, CORNER.BOTTOM_LEFT)
  		                    : new Vector(bounds.left + (borderLeftWidth * 2) / 3, bounds.top + bounds.height - (borderBottomWidth * 2) / 3);
  		            this.topLeftBorderStroke =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2, tlh - borderLeftWidth / 2, tlv - borderTopWidth / 2, CORNER.TOP_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + borderTopWidth / 2);
  		            this.topRightBorderStroke =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth / 2, trh - borderRightWidth / 2, trv - borderTopWidth / 2, CORNER.TOP_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + borderTopWidth / 2);
  		            this.bottomRightBorderStroke =
  		                brh > 0 || brv > 0
  		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth / 2, brv - borderBottomWidth / 2, CORNER.BOTTOM_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - borderRightWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
  		            this.bottomLeftBorderStroke =
  		                blh > 0 || blv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth / 2, bounds.top + leftHeight, blh - borderLeftWidth / 2, blv - borderBottomWidth / 2, CORNER.BOTTOM_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth / 2, bounds.top + bounds.height - borderBottomWidth / 2);
  		            this.topLeftBorderBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT)
  		                    : new Vector(bounds.left, bounds.top);
  		            this.topRightBorderBox =
  		                trh > 0 || trv > 0
  		                    ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT)
  		                    : new Vector(bounds.left + bounds.width, bounds.top);
  		            this.bottomRightBorderBox =
  		                brh > 0 || brv > 0
  		                    ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT)
  		                    : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
  		            this.bottomLeftBorderBox =
  		                blh > 0 || blv > 0
  		                    ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT)
  		                    : new Vector(bounds.left, bounds.top + bounds.height);
  		            this.topLeftPaddingBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + borderTopWidth, Math.max(0, tlh - borderLeftWidth), Math.max(0, tlv - borderTopWidth), CORNER.TOP_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth, bounds.top + borderTopWidth);
  		            this.topRightPaddingBox =
  		                trh > 0 || trv > 0
  		                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth), bounds.top + borderTopWidth, topWidth > bounds.width + borderRightWidth ? 0 : Math.max(0, trh - borderRightWidth), Math.max(0, trv - borderTopWidth), CORNER.TOP_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + borderTopWidth);
  		            this.bottomRightPaddingBox =
  		                brh > 0 || brv > 0
  		                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth), Math.max(0, brh - borderRightWidth), Math.max(0, brv - borderBottomWidth), CORNER.BOTTOM_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - borderRightWidth, bounds.top + bounds.height - borderBottomWidth);
  		            this.bottomLeftPaddingBox =
  		                blh > 0 || blv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth), Math.max(0, blh - borderLeftWidth), Math.max(0, blv - borderBottomWidth), CORNER.BOTTOM_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth, bounds.top + bounds.height - borderBottomWidth);
  		            this.topLeftContentBox =
  		                tlh > 0 || tlv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop, Math.max(0, tlh - (borderLeftWidth + paddingLeft)), Math.max(0, tlv - (borderTopWidth + paddingTop)), CORNER.TOP_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + borderTopWidth + paddingTop);
  		            this.topRightContentBox =
  		                trh > 0 || trv > 0
  		                    ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth + paddingLeft), bounds.top + borderTopWidth + paddingTop, topWidth > bounds.width + borderLeftWidth + paddingLeft ? 0 : trh - borderLeftWidth + paddingLeft, trv - (borderTopWidth + paddingTop), CORNER.TOP_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + borderTopWidth + paddingTop);
  		            this.bottomRightContentBox =
  		                brh > 0 || brv > 0
  		                    ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth + paddingLeft)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth + paddingTop), Math.max(0, brh - (borderRightWidth + paddingRight)), brv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_RIGHT)
  		                    : new Vector(bounds.left + bounds.width - (borderRightWidth + paddingRight), bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
  		            this.bottomLeftContentBox =
  		                blh > 0 || blv > 0
  		                    ? getCurvePoints(bounds.left + borderLeftWidth + paddingLeft, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth + paddingLeft)), blv - (borderBottomWidth + paddingBottom), CORNER.BOTTOM_LEFT)
  		                    : new Vector(bounds.left + borderLeftWidth + paddingLeft, bounds.top + bounds.height - (borderBottomWidth + paddingBottom));
  		        }
  		        return BoundCurves;
  		    }());
  		    var CORNER;
  		    (function (CORNER) {
  		        CORNER[CORNER["TOP_LEFT"] = 0] = "TOP_LEFT";
  		        CORNER[CORNER["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  		        CORNER[CORNER["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  		        CORNER[CORNER["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
  		    })(CORNER || (CORNER = {}));
  		    var getCurvePoints = function (x, y, r1, r2, position) {
  		        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  		        var ox = r1 * kappa; // control point offset horizontal
  		        var oy = r2 * kappa; // control point offset vertical
  		        var xm = x + r1; // x-middle
  		        var ym = y + r2; // y-middle
  		        switch (position) {
  		            case CORNER.TOP_LEFT:
  		                return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
  		            case CORNER.TOP_RIGHT:
  		                return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
  		            case CORNER.BOTTOM_RIGHT:
  		                return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
  		            case CORNER.BOTTOM_LEFT:
  		            default:
  		                return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
  		        }
  		    };
  		    var calculateBorderBoxPath = function (curves) {
  		        return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
  		    };
  		    var calculateContentBoxPath = function (curves) {
  		        return [
  		            curves.topLeftContentBox,
  		            curves.topRightContentBox,
  		            curves.bottomRightContentBox,
  		            curves.bottomLeftContentBox
  		        ];
  		    };
  		    var calculatePaddingBoxPath = function (curves) {
  		        return [
  		            curves.topLeftPaddingBox,
  		            curves.topRightPaddingBox,
  		            curves.bottomRightPaddingBox,
  		            curves.bottomLeftPaddingBox
  		        ];
  		    };

  		    var TransformEffect = /** @class */ (function () {
  		        function TransformEffect(offsetX, offsetY, matrix) {
  		            this.offsetX = offsetX;
  		            this.offsetY = offsetY;
  		            this.matrix = matrix;
  		            this.type = 0 /* TRANSFORM */;
  		            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
  		        }
  		        return TransformEffect;
  		    }());
  		    var ClipEffect = /** @class */ (function () {
  		        function ClipEffect(path, target) {
  		            this.path = path;
  		            this.target = target;
  		            this.type = 1 /* CLIP */;
  		        }
  		        return ClipEffect;
  		    }());
  		    var OpacityEffect = /** @class */ (function () {
  		        function OpacityEffect(opacity) {
  		            this.opacity = opacity;
  		            this.type = 2 /* OPACITY */;
  		            this.target = 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */;
  		        }
  		        return OpacityEffect;
  		    }());
  		    var isTransformEffect = function (effect) {
  		        return effect.type === 0 /* TRANSFORM */;
  		    };
  		    var isClipEffect = function (effect) { return effect.type === 1 /* CLIP */; };
  		    var isOpacityEffect = function (effect) { return effect.type === 2 /* OPACITY */; };

  		    var equalPath = function (a, b) {
  		        if (a.length === b.length) {
  		            return a.some(function (v, i) { return v === b[i]; });
  		        }
  		        return false;
  		    };
  		    var transformPath = function (path, deltaX, deltaY, deltaW, deltaH) {
  		        return path.map(function (point, index) {
  		            switch (index) {
  		                case 0:
  		                    return point.add(deltaX, deltaY);
  		                case 1:
  		                    return point.add(deltaX + deltaW, deltaY);
  		                case 2:
  		                    return point.add(deltaX + deltaW, deltaY + deltaH);
  		                case 3:
  		                    return point.add(deltaX, deltaY + deltaH);
  		            }
  		            return point;
  		        });
  		    };

  		    var StackingContext = /** @class */ (function () {
  		        function StackingContext(container) {
  		            this.element = container;
  		            this.inlineLevel = [];
  		            this.nonInlineLevel = [];
  		            this.negativeZIndex = [];
  		            this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
  		            this.positiveZIndex = [];
  		            this.nonPositionedFloats = [];
  		            this.nonPositionedInlineLevel = [];
  		        }
  		        return StackingContext;
  		    }());
  		    var ElementPaint = /** @class */ (function () {
  		        function ElementPaint(container, parent) {
  		            this.container = container;
  		            this.parent = parent;
  		            this.effects = [];
  		            this.curves = new BoundCurves(this.container);
  		            if (this.container.styles.opacity < 1) {
  		                this.effects.push(new OpacityEffect(this.container.styles.opacity));
  		            }
  		            if (this.container.styles.transform !== null) {
  		                var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
  		                var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
  		                var matrix = this.container.styles.transform;
  		                this.effects.push(new TransformEffect(offsetX, offsetY, matrix));
  		            }
  		            if (this.container.styles.overflowX !== 0 /* VISIBLE */) {
  		                var borderBox = calculateBorderBoxPath(this.curves);
  		                var paddingBox = calculatePaddingBoxPath(this.curves);
  		                if (equalPath(borderBox, paddingBox)) {
  		                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
  		                }
  		                else {
  		                    this.effects.push(new ClipEffect(borderBox, 2 /* BACKGROUND_BORDERS */));
  		                    this.effects.push(new ClipEffect(paddingBox, 4 /* CONTENT */));
  		                }
  		            }
  		        }
  		        ElementPaint.prototype.getEffects = function (target) {
  		            var inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(this.container.styles.position) === -1;
  		            var parent = this.parent;
  		            var effects = this.effects.slice(0);
  		            while (parent) {
  		                var croplessEffects = parent.effects.filter(function (effect) { return !isClipEffect(effect); });
  		                if (inFlow || parent.container.styles.position !== 0 /* STATIC */ || !parent.parent) {
  		                    effects.unshift.apply(effects, croplessEffects);
  		                    inFlow = [2 /* ABSOLUTE */, 3 /* FIXED */].indexOf(parent.container.styles.position) === -1;
  		                    if (parent.container.styles.overflowX !== 0 /* VISIBLE */) {
  		                        var borderBox = calculateBorderBoxPath(parent.curves);
  		                        var paddingBox = calculatePaddingBoxPath(parent.curves);
  		                        if (!equalPath(borderBox, paddingBox)) {
  		                            effects.unshift(new ClipEffect(paddingBox, 2 /* BACKGROUND_BORDERS */ | 4 /* CONTENT */));
  		                        }
  		                    }
  		                }
  		                else {
  		                    effects.unshift.apply(effects, croplessEffects);
  		                }
  		                parent = parent.parent;
  		            }
  		            return effects.filter(function (effect) { return contains(effect.target, target); });
  		        };
  		        return ElementPaint;
  		    }());
  		    var parseStackTree = function (parent, stackingContext, realStackingContext, listItems) {
  		        parent.container.elements.forEach(function (child) {
  		            var treatAsRealStackingContext = contains(child.flags, 4 /* CREATES_REAL_STACKING_CONTEXT */);
  		            var createsStackingContext = contains(child.flags, 2 /* CREATES_STACKING_CONTEXT */);
  		            var paintContainer = new ElementPaint(child, parent);
  		            if (contains(child.styles.display, 2048 /* LIST_ITEM */)) {
  		                listItems.push(paintContainer);
  		            }
  		            var listOwnerItems = contains(child.flags, 8 /* IS_LIST_OWNER */) ? [] : listItems;
  		            if (treatAsRealStackingContext || createsStackingContext) {
  		                var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
  		                var stack = new StackingContext(paintContainer);
  		                if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
  		                    var order_1 = child.styles.zIndex.order;
  		                    if (order_1 < 0) {
  		                        var index_1 = 0;
  		                        parentStack.negativeZIndex.some(function (current, i) {
  		                            if (order_1 > current.element.container.styles.zIndex.order) {
  		                                index_1 = i;
  		                                return false;
  		                            }
  		                            else if (index_1 > 0) {
  		                                return true;
  		                            }
  		                            return false;
  		                        });
  		                        parentStack.negativeZIndex.splice(index_1, 0, stack);
  		                    }
  		                    else if (order_1 > 0) {
  		                        var index_2 = 0;
  		                        parentStack.positiveZIndex.some(function (current, i) {
  		                            if (order_1 >= current.element.container.styles.zIndex.order) {
  		                                index_2 = i + 1;
  		                                return false;
  		                            }
  		                            else if (index_2 > 0) {
  		                                return true;
  		                            }
  		                            return false;
  		                        });
  		                        parentStack.positiveZIndex.splice(index_2, 0, stack);
  		                    }
  		                    else {
  		                        parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
  		                    }
  		                }
  		                else {
  		                    if (child.styles.isFloating()) {
  		                        parentStack.nonPositionedFloats.push(stack);
  		                    }
  		                    else {
  		                        parentStack.nonPositionedInlineLevel.push(stack);
  		                    }
  		                }
  		                parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
  		            }
  		            else {
  		                if (child.styles.isInlineLevel()) {
  		                    stackingContext.inlineLevel.push(paintContainer);
  		                }
  		                else {
  		                    stackingContext.nonInlineLevel.push(paintContainer);
  		                }
  		                parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
  		            }
  		            if (contains(child.flags, 8 /* IS_LIST_OWNER */)) {
  		                processListItems(child, listOwnerItems);
  		            }
  		        });
  		    };
  		    var processListItems = function (owner, elements) {
  		        var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  		        var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  		        for (var i = 0; i < elements.length; i++) {
  		            var item = elements[i];
  		            if (item.container instanceof LIElementContainer &&
  		                typeof item.container.value === 'number' &&
  		                item.container.value !== 0) {
  		                numbering = item.container.value;
  		            }
  		            item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
  		            numbering += reversed ? -1 : 1;
  		        }
  		    };
  		    var parseStackingContexts = function (container) {
  		        var paintContainer = new ElementPaint(container, null);
  		        var root = new StackingContext(paintContainer);
  		        var listItems = [];
  		        parseStackTree(paintContainer, root, root, listItems);
  		        processListItems(paintContainer.container, listItems);
  		        return root;
  		    };

  		    var parsePathForBorder = function (curves, borderSide) {
  		        switch (borderSide) {
  		            case 0:
  		                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
  		            case 1:
  		                return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
  		            case 2:
  		                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
  		            case 3:
  		            default:
  		                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  		        }
  		    };
  		    var parsePathForBorderDoubleOuter = function (curves, borderSide) {
  		        switch (borderSide) {
  		            case 0:
  		                return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
  		            case 1:
  		                return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
  		            case 2:
  		                return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
  		            case 3:
  		            default:
  		                return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  		        }
  		    };
  		    var parsePathForBorderDoubleInner = function (curves, borderSide) {
  		        switch (borderSide) {
  		            case 0:
  		                return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
  		            case 1:
  		                return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
  		            case 2:
  		                return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
  		            case 3:
  		            default:
  		                return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  		        }
  		    };
  		    var parsePathForBorderStroke = function (curves, borderSide) {
  		        switch (borderSide) {
  		            case 0:
  		                return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
  		            case 1:
  		                return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
  		            case 2:
  		                return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
  		            case 3:
  		            default:
  		                return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  		        }
  		    };
  		    var createStrokePathFromCurves = function (outer1, outer2) {
  		        var path = [];
  		        if (isBezierCurve(outer1)) {
  		            path.push(outer1.subdivide(0.5, false));
  		        }
  		        else {
  		            path.push(outer1);
  		        }
  		        if (isBezierCurve(outer2)) {
  		            path.push(outer2.subdivide(0.5, true));
  		        }
  		        else {
  		            path.push(outer2);
  		        }
  		        return path;
  		    };
  		    var createPathFromCurves = function (outer1, inner1, outer2, inner2) {
  		        var path = [];
  		        if (isBezierCurve(outer1)) {
  		            path.push(outer1.subdivide(0.5, false));
  		        }
  		        else {
  		            path.push(outer1);
  		        }
  		        if (isBezierCurve(outer2)) {
  		            path.push(outer2.subdivide(0.5, true));
  		        }
  		        else {
  		            path.push(outer2);
  		        }
  		        if (isBezierCurve(inner2)) {
  		            path.push(inner2.subdivide(0.5, true).reverse());
  		        }
  		        else {
  		            path.push(inner2);
  		        }
  		        if (isBezierCurve(inner1)) {
  		            path.push(inner1.subdivide(0.5, false).reverse());
  		        }
  		        else {
  		            path.push(inner1);
  		        }
  		        return path;
  		    };

  		    var paddingBox = function (element) {
  		        var bounds = element.bounds;
  		        var styles = element.styles;
  		        return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
  		    };
  		    var contentBox = function (element) {
  		        var styles = element.styles;
  		        var bounds = element.bounds;
  		        var paddingLeft = getAbsoluteValue(styles.paddingLeft, bounds.width);
  		        var paddingRight = getAbsoluteValue(styles.paddingRight, bounds.width);
  		        var paddingTop = getAbsoluteValue(styles.paddingTop, bounds.width);
  		        var paddingBottom = getAbsoluteValue(styles.paddingBottom, bounds.width);
  		        return bounds.add(paddingLeft + styles.borderLeftWidth, paddingTop + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft + paddingRight), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop + paddingBottom));
  		    };

  		    var calculateBackgroundPositioningArea = function (backgroundOrigin, element) {
  		        if (backgroundOrigin === 0 /* BORDER_BOX */) {
  		            return element.bounds;
  		        }
  		        if (backgroundOrigin === 2 /* CONTENT_BOX */) {
  		            return contentBox(element);
  		        }
  		        return paddingBox(element);
  		    };
  		    var calculateBackgroundPaintingArea = function (backgroundClip, element) {
  		        if (backgroundClip === 0 /* BORDER_BOX */) {
  		            return element.bounds;
  		        }
  		        if (backgroundClip === 2 /* CONTENT_BOX */) {
  		            return contentBox(element);
  		        }
  		        return paddingBox(element);
  		    };
  		    var calculateBackgroundRendering = function (container, index, intrinsicSize) {
  		        var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index), container);
  		        var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index), container);
  		        var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index), intrinsicSize, backgroundPositioningArea);
  		        var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  		        var position = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  		        var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index), position, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  		        var offsetX = Math.round(backgroundPositioningArea.left + position[0]);
  		        var offsetY = Math.round(backgroundPositioningArea.top + position[1]);
  		        return [path, offsetX, offsetY, sizeWidth, sizeHeight];
  		    };
  		    var isAuto = function (token) { return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO; };
  		    var hasIntrinsicValue = function (value) { return typeof value === 'number'; };
  		    var calculateBackgroundSize = function (size, _a, bounds) {
  		        var intrinsicWidth = _a[0], intrinsicHeight = _a[1], intrinsicProportion = _a[2];
  		        var first = size[0], second = size[1];
  		        if (!first) {
  		            return [0, 0];
  		        }
  		        if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
  		            return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  		        }
  		        var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  		        if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
  		            if (hasIntrinsicValue(intrinsicProportion)) {
  		                var targetRatio = bounds.width / bounds.height;
  		                return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER)
  		                    ? [bounds.width, bounds.width / intrinsicProportion]
  		                    : [bounds.height * intrinsicProportion, bounds.height];
  		            }
  		            return [bounds.width, bounds.height];
  		        }
  		        var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  		        var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  		        var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  		        // If the background-size is auto or auto auto:
  		        if (isAuto(first) && (!second || isAuto(second))) {
  		            // If the image has both horizontal and vertical intrinsic dimensions, it's rendered at that size.
  		            if (hasIntrinsicWidth && hasIntrinsicHeight) {
  		                return [intrinsicWidth, intrinsicHeight];
  		            }
  		            // If the image has no intrinsic dimensions and has no intrinsic proportions,
  		            // it's rendered at the size of the background positioning area.
  		            if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
  		                return [bounds.width, bounds.height];
  		            }
  		            // TODO If the image has no intrinsic dimensions but has intrinsic proportions, it's rendered as if contain had been specified instead.
  		            // If the image has only one intrinsic dimension and has intrinsic proportions, it's rendered at the size corresponding to that one dimension.
  		            // The other dimension is computed using the specified dimension and the intrinsic proportions.
  		            if (hasIntrinsicDimensions && hasIntrinsicProportion) {
  		                var width_1 = hasIntrinsicWidth
  		                    ? intrinsicWidth
  		                    : intrinsicHeight * intrinsicProportion;
  		                var height_1 = hasIntrinsicHeight
  		                    ? intrinsicHeight
  		                    : intrinsicWidth / intrinsicProportion;
  		                return [width_1, height_1];
  		            }
  		            // If the image has only one intrinsic dimension but has no intrinsic proportions,
  		            // it's rendered using the specified dimension and the other dimension of the background positioning area.
  		            var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
  		            var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
  		            return [width_2, height_2];
  		        }
  		        // If the image has intrinsic proportions, it's stretched to the specified dimension.
  		        // The unspecified dimension is computed using the specified dimension and the intrinsic proportions.
  		        if (hasIntrinsicProportion) {
  		            var width_3 = 0;
  		            var height_3 = 0;
  		            if (isLengthPercentage(first)) {
  		                width_3 = getAbsoluteValue(first, bounds.width);
  		            }
  		            else if (isLengthPercentage(second)) {
  		                height_3 = getAbsoluteValue(second, bounds.height);
  		            }
  		            if (isAuto(first)) {
  		                width_3 = height_3 * intrinsicProportion;
  		            }
  		            else if (!second || isAuto(second)) {
  		                height_3 = width_3 / intrinsicProportion;
  		            }
  		            return [width_3, height_3];
  		        }
  		        // If the image has no intrinsic proportions, it's stretched to the specified dimension.
  		        // The unspecified dimension is computed using the image's corresponding intrinsic dimension,
  		        // if there is one. If there is no such intrinsic dimension,
  		        // it becomes the corresponding dimension of the background positioning area.
  		        var width = null;
  		        var height = null;
  		        if (isLengthPercentage(first)) {
  		            width = getAbsoluteValue(first, bounds.width);
  		        }
  		        else if (second && isLengthPercentage(second)) {
  		            height = getAbsoluteValue(second, bounds.height);
  		        }
  		        if (width !== null && (!second || isAuto(second))) {
  		            height =
  		                hasIntrinsicWidth && hasIntrinsicHeight
  		                    ? (width / intrinsicWidth) * intrinsicHeight
  		                    : bounds.height;
  		        }
  		        if (height !== null && isAuto(first)) {
  		            width =
  		                hasIntrinsicWidth && hasIntrinsicHeight
  		                    ? (height / intrinsicHeight) * intrinsicWidth
  		                    : bounds.width;
  		        }
  		        if (width !== null && height !== null) {
  		            return [width, height];
  		        }
  		        throw new Error("Unable to calculate background-size for element");
  		    };
  		    var getBackgroundValueForIndex = function (values, index) {
  		        var value = values[index];
  		        if (typeof value === 'undefined') {
  		            return values[0];
  		        }
  		        return value;
  		    };
  		    var calculateBackgroundRepeatPath = function (repeat, _a, _b, backgroundPositioningArea, backgroundPaintingArea) {
  		        var x = _a[0], y = _a[1];
  		        var width = _b[0], height = _b[1];
  		        switch (repeat) {
  		            case 2 /* REPEAT_X */:
  		                return [
  		                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
  		                    new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
  		                ];
  		            case 3 /* REPEAT_Y */:
  		                return [
  		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
  		                ];
  		            case 1 /* NO_REPEAT */:
  		                return [
  		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
  		                    new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
  		                ];
  		            default:
  		                return [
  		                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
  		                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
  		                    new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
  		                    new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
  		                ];
  		        }
  		    };

  		    var SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

  		    var SAMPLE_TEXT = 'Hidden Text';
  		    var FontMetrics = /** @class */ (function () {
  		        function FontMetrics(document) {
  		            this._data = {};
  		            this._document = document;
  		        }
  		        FontMetrics.prototype.parseMetrics = function (fontFamily, fontSize) {
  		            var container = this._document.createElement('div');
  		            var img = this._document.createElement('img');
  		            var span = this._document.createElement('span');
  		            var body = this._document.body;
  		            container.style.visibility = 'hidden';
  		            container.style.fontFamily = fontFamily;
  		            container.style.fontSize = fontSize;
  		            container.style.margin = '0';
  		            container.style.padding = '0';
  		            container.style.whiteSpace = 'nowrap';
  		            body.appendChild(container);
  		            img.src = SMALL_IMAGE;
  		            img.width = 1;
  		            img.height = 1;
  		            img.style.margin = '0';
  		            img.style.padding = '0';
  		            img.style.verticalAlign = 'baseline';
  		            span.style.fontFamily = fontFamily;
  		            span.style.fontSize = fontSize;
  		            span.style.margin = '0';
  		            span.style.padding = '0';
  		            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
  		            container.appendChild(span);
  		            container.appendChild(img);
  		            var baseline = img.offsetTop - span.offsetTop + 2;
  		            container.removeChild(span);
  		            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
  		            container.style.lineHeight = 'normal';
  		            img.style.verticalAlign = 'super';
  		            var middle = img.offsetTop - container.offsetTop + 2;
  		            body.removeChild(container);
  		            return { baseline: baseline, middle: middle };
  		        };
  		        FontMetrics.prototype.getMetrics = function (fontFamily, fontSize) {
  		            var key = fontFamily + " " + fontSize;
  		            if (typeof this._data[key] === 'undefined') {
  		                this._data[key] = this.parseMetrics(fontFamily, fontSize);
  		            }
  		            return this._data[key];
  		        };
  		        return FontMetrics;
  		    }());

  		    var Renderer = /** @class */ (function () {
  		        function Renderer(context, options) {
  		            this.context = context;
  		            this.options = options;
  		        }
  		        return Renderer;
  		    }());

  		    var MASK_OFFSET = 10000;
  		    var CanvasRenderer = /** @class */ (function (_super) {
  		        __extends(CanvasRenderer, _super);
  		        function CanvasRenderer(context, options) {
  		            var _this = _super.call(this, context, options) || this;
  		            _this._activeEffects = [];
  		            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
  		            _this.ctx = _this.canvas.getContext('2d');
  		            if (!options.canvas) {
  		                _this.canvas.width = Math.floor(options.width * options.scale);
  		                _this.canvas.height = Math.floor(options.height * options.scale);
  		                _this.canvas.style.width = options.width + "px";
  		                _this.canvas.style.height = options.height + "px";
  		            }
  		            _this.fontMetrics = new FontMetrics(document);
  		            _this.ctx.scale(_this.options.scale, _this.options.scale);
  		            _this.ctx.translate(-options.x, -options.y);
  		            _this.ctx.textBaseline = 'bottom';
  		            _this._activeEffects = [];
  		            _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
  		            return _this;
  		        }
  		        CanvasRenderer.prototype.applyEffects = function (effects) {
  		            var _this = this;
  		            while (this._activeEffects.length) {
  		                this.popEffect();
  		            }
  		            effects.forEach(function (effect) { return _this.applyEffect(effect); });
  		        };
  		        CanvasRenderer.prototype.applyEffect = function (effect) {
  		            this.ctx.save();
  		            if (isOpacityEffect(effect)) {
  		                this.ctx.globalAlpha = effect.opacity;
  		            }
  		            if (isTransformEffect(effect)) {
  		                this.ctx.translate(effect.offsetX, effect.offsetY);
  		                this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
  		                this.ctx.translate(-effect.offsetX, -effect.offsetY);
  		            }
  		            if (isClipEffect(effect)) {
  		                this.path(effect.path);
  		                this.ctx.clip();
  		            }
  		            this._activeEffects.push(effect);
  		        };
  		        CanvasRenderer.prototype.popEffect = function () {
  		            this._activeEffects.pop();
  		            this.ctx.restore();
  		        };
  		        CanvasRenderer.prototype.renderStack = function (stack) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var styles;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            styles = stack.element.container.styles;
  		                            if (!styles.isVisible()) return [3 /*break*/, 2];
  		                            return [4 /*yield*/, this.renderStackContent(stack)];
  		                        case 1:
  		                            _a.sent();
  		                            _a.label = 2;
  		                        case 2: return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderNode = function (paint) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            if (contains(paint.container.flags, 16 /* DEBUG_RENDER */)) {
  		                                debugger;
  		                            }
  		                            if (!paint.container.styles.isVisible()) return [3 /*break*/, 3];
  		                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(paint)];
  		                        case 1:
  		                            _a.sent();
  		                            return [4 /*yield*/, this.renderNodeContent(paint)];
  		                        case 2:
  		                            _a.sent();
  		                            _a.label = 3;
  		                        case 3: return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderTextWithLetterSpacing = function (text, letterSpacing, baseline) {
  		            var _this = this;
  		            if (letterSpacing === 0) {
  		                this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
  		            }
  		            else {
  		                var letters = segmentGraphemes(text.text);
  		                letters.reduce(function (left, letter) {
  		                    _this.ctx.fillText(letter, left, text.bounds.top + baseline);
  		                    return left + _this.ctx.measureText(letter).width;
  		                }, text.bounds.left);
  		            }
  		        };
  		        CanvasRenderer.prototype.createFontStyle = function (styles) {
  		            var fontVariant = styles.fontVariant
  		                .filter(function (variant) { return variant === 'normal' || variant === 'small-caps'; })
  		                .join('');
  		            var fontFamily = fixIOSSystemFonts(styles.fontFamily).join(', ');
  		            var fontSize = isDimensionToken(styles.fontSize)
  		                ? "" + styles.fontSize.number + styles.fontSize.unit
  		                : styles.fontSize.number + "px";
  		            return [
  		                [styles.fontStyle, fontVariant, styles.fontWeight, fontSize, fontFamily].join(' '),
  		                fontFamily,
  		                fontSize
  		            ];
  		        };
  		        CanvasRenderer.prototype.renderTextNode = function (text, styles) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var _a, font, fontFamily, fontSize, _b, baseline, middle, paintOrder;
  		                var _this = this;
  		                return __generator(this, function (_c) {
  		                    _a = this.createFontStyle(styles), font = _a[0], fontFamily = _a[1], fontSize = _a[2];
  		                    this.ctx.font = font;
  		                    this.ctx.direction = styles.direction === 1 /* RTL */ ? 'rtl' : 'ltr';
  		                    this.ctx.textAlign = 'left';
  		                    this.ctx.textBaseline = 'alphabetic';
  		                    _b = this.fontMetrics.getMetrics(fontFamily, fontSize), baseline = _b.baseline, middle = _b.middle;
  		                    paintOrder = styles.paintOrder;
  		                    text.textBounds.forEach(function (text) {
  		                        paintOrder.forEach(function (paintOrderLayer) {
  		                            switch (paintOrderLayer) {
  		                                case 0 /* FILL */:
  		                                    _this.ctx.fillStyle = asString(styles.color);
  		                                    _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
  		                                    var textShadows = styles.textShadow;
  		                                    if (textShadows.length && text.text.trim().length) {
  		                                        textShadows
  		                                            .slice(0)
  		                                            .reverse()
  		                                            .forEach(function (textShadow) {
  		                                            _this.ctx.shadowColor = asString(textShadow.color);
  		                                            _this.ctx.shadowOffsetX = textShadow.offsetX.number * _this.options.scale;
  		                                            _this.ctx.shadowOffsetY = textShadow.offsetY.number * _this.options.scale;
  		                                            _this.ctx.shadowBlur = textShadow.blur.number;
  		                                            _this.renderTextWithLetterSpacing(text, styles.letterSpacing, baseline);
  		                                        });
  		                                        _this.ctx.shadowColor = '';
  		                                        _this.ctx.shadowOffsetX = 0;
  		                                        _this.ctx.shadowOffsetY = 0;
  		                                        _this.ctx.shadowBlur = 0;
  		                                    }
  		                                    if (styles.textDecorationLine.length) {
  		                                        _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
  		                                        styles.textDecorationLine.forEach(function (textDecorationLine) {
  		                                            switch (textDecorationLine) {
  		                                                case 1 /* UNDERLINE */:
  		                                                    // Draws a line at the baseline of the font
  		                                                    // TODO As some browsers display the line as more than 1px if the font-size is big,
  		                                                    // need to take that into account both in position and size
  		                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1);
  		                                                    break;
  		                                                case 2 /* OVERLINE */:
  		                                                    _this.ctx.fillRect(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1);
  		                                                    break;
  		                                                case 3 /* LINE_THROUGH */:
  		                                                    // TODO try and find exact position for line-through
  		                                                    _this.ctx.fillRect(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1);
  		                                                    break;
  		                                            }
  		                                        });
  		                                    }
  		                                    break;
  		                                case 1 /* STROKE */:
  		                                    if (styles.webkitTextStrokeWidth && text.text.trim().length) {
  		                                        _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
  		                                        _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
  		                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		                                        _this.ctx.lineJoin = !!window.chrome ? 'miter' : 'round';
  		                                        _this.ctx.strokeText(text.text, text.bounds.left, text.bounds.top + baseline);
  		                                    }
  		                                    _this.ctx.strokeStyle = '';
  		                                    _this.ctx.lineWidth = 0;
  		                                    _this.ctx.lineJoin = 'miter';
  		                                    break;
  		                            }
  		                        });
  		                    });
  		                    return [2 /*return*/];
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderReplacedElement = function (container, curves, image) {
  		            if (image && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
  		                var box = contentBox(container);
  		                var path = calculatePaddingBoxPath(curves);
  		                this.path(path);
  		                this.ctx.save();
  		                this.ctx.clip();
  		                this.ctx.drawImage(image, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
  		                this.ctx.restore();
  		            }
  		        };
  		        CanvasRenderer.prototype.renderNodeContent = function (paint) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var container, curves, styles, _i, _a, child, image, image, iframeRenderer, canvas, size, _b, fontFamily, fontSize, baseline, bounds, x, textBounds, img, image, url, fontFamily, bounds;
  		                return __generator(this, function (_c) {
  		                    switch (_c.label) {
  		                        case 0:
  		                            this.applyEffects(paint.getEffects(4 /* CONTENT */));
  		                            container = paint.container;
  		                            curves = paint.curves;
  		                            styles = container.styles;
  		                            _i = 0, _a = container.textNodes;
  		                            _c.label = 1;
  		                        case 1:
  		                            if (!(_i < _a.length)) return [3 /*break*/, 4];
  		                            child = _a[_i];
  		                            return [4 /*yield*/, this.renderTextNode(child, styles)];
  		                        case 2:
  		                            _c.sent();
  		                            _c.label = 3;
  		                        case 3:
  		                            _i++;
  		                            return [3 /*break*/, 1];
  		                        case 4:
  		                            if (!(container instanceof ImageElementContainer)) return [3 /*break*/, 8];
  		                            _c.label = 5;
  		                        case 5:
  		                            _c.trys.push([5, 7, , 8]);
  		                            return [4 /*yield*/, this.context.cache.match(container.src)];
  		                        case 6:
  		                            image = _c.sent();
  		                            this.renderReplacedElement(container, curves, image);
  		                            return [3 /*break*/, 8];
  		                        case 7:
  		                            _c.sent();
  		                            this.context.logger.error("Error loading image " + container.src);
  		                            return [3 /*break*/, 8];
  		                        case 8:
  		                            if (container instanceof CanvasElementContainer) {
  		                                this.renderReplacedElement(container, curves, container.canvas);
  		                            }
  		                            if (!(container instanceof SVGElementContainer)) return [3 /*break*/, 12];
  		                            _c.label = 9;
  		                        case 9:
  		                            _c.trys.push([9, 11, , 12]);
  		                            return [4 /*yield*/, this.context.cache.match(container.svg)];
  		                        case 10:
  		                            image = _c.sent();
  		                            this.renderReplacedElement(container, curves, image);
  		                            return [3 /*break*/, 12];
  		                        case 11:
  		                            _c.sent();
  		                            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
  		                            return [3 /*break*/, 12];
  		                        case 12:
  		                            if (!(container instanceof IFrameElementContainer && container.tree)) return [3 /*break*/, 14];
  		                            iframeRenderer = new CanvasRenderer(this.context, {
  		                                scale: this.options.scale,
  		                                backgroundColor: container.backgroundColor,
  		                                x: 0,
  		                                y: 0,
  		                                width: container.width,
  		                                height: container.height
  		                            });
  		                            return [4 /*yield*/, iframeRenderer.render(container.tree)];
  		                        case 13:
  		                            canvas = _c.sent();
  		                            if (container.width && container.height) {
  		                                this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
  		                            }
  		                            _c.label = 14;
  		                        case 14:
  		                            if (container instanceof InputElementContainer) {
  		                                size = Math.min(container.bounds.width, container.bounds.height);
  		                                if (container.type === CHECKBOX) {
  		                                    if (container.checked) {
  		                                        this.ctx.save();
  		                                        this.path([
  		                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
  		                                            new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
  		                                            new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
  		                                            new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
  		                                            new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
  		                                            new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
  		                                            new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
  		                                        ]);
  		                                        this.ctx.fillStyle = asString(INPUT_COLOR);
  		                                        this.ctx.fill();
  		                                        this.ctx.restore();
  		                                    }
  		                                }
  		                                else if (container.type === RADIO) {
  		                                    if (container.checked) {
  		                                        this.ctx.save();
  		                                        this.ctx.beginPath();
  		                                        this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
  		                                        this.ctx.fillStyle = asString(INPUT_COLOR);
  		                                        this.ctx.fill();
  		                                        this.ctx.restore();
  		                                    }
  		                                }
  		                            }
  		                            if (isTextInputElement(container) && container.value.length) {
  		                                _b = this.createFontStyle(styles), fontFamily = _b[0], fontSize = _b[1];
  		                                baseline = this.fontMetrics.getMetrics(fontFamily, fontSize).baseline;
  		                                this.ctx.font = fontFamily;
  		                                this.ctx.fillStyle = asString(styles.color);
  		                                this.ctx.textBaseline = 'alphabetic';
  		                                this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
  		                                bounds = contentBox(container);
  		                                x = 0;
  		                                switch (container.styles.textAlign) {
  		                                    case 1 /* CENTER */:
  		                                        x += bounds.width / 2;
  		                                        break;
  		                                    case 2 /* RIGHT */:
  		                                        x += bounds.width;
  		                                        break;
  		                                }
  		                                textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
  		                                this.ctx.save();
  		                                this.path([
  		                                    new Vector(bounds.left, bounds.top),
  		                                    new Vector(bounds.left + bounds.width, bounds.top),
  		                                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
  		                                    new Vector(bounds.left, bounds.top + bounds.height)
  		                                ]);
  		                                this.ctx.clip();
  		                                this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
  		                                this.ctx.restore();
  		                                this.ctx.textBaseline = 'alphabetic';
  		                                this.ctx.textAlign = 'left';
  		                            }
  		                            if (!contains(container.styles.display, 2048 /* LIST_ITEM */)) return [3 /*break*/, 20];
  		                            if (!(container.styles.listStyleImage !== null)) return [3 /*break*/, 19];
  		                            img = container.styles.listStyleImage;
  		                            if (!(img.type === 0 /* URL */)) return [3 /*break*/, 18];
  		                            image = void 0;
  		                            url = img.url;
  		                            _c.label = 15;
  		                        case 15:
  		                            _c.trys.push([15, 17, , 18]);
  		                            return [4 /*yield*/, this.context.cache.match(url)];
  		                        case 16:
  		                            image = _c.sent();
  		                            this.ctx.drawImage(image, container.bounds.left - (image.width + 10), container.bounds.top);
  		                            return [3 /*break*/, 18];
  		                        case 17:
  		                            _c.sent();
  		                            this.context.logger.error("Error loading list-style-image " + url);
  		                            return [3 /*break*/, 18];
  		                        case 18: return [3 /*break*/, 20];
  		                        case 19:
  		                            if (paint.listValue && container.styles.listStyleType !== -1 /* NONE */) {
  		                                fontFamily = this.createFontStyle(styles)[0];
  		                                this.ctx.font = fontFamily;
  		                                this.ctx.fillStyle = asString(styles.color);
  		                                this.ctx.textBaseline = 'middle';
  		                                this.ctx.textAlign = 'right';
  		                                bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
  		                                this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
  		                                this.ctx.textBaseline = 'bottom';
  		                                this.ctx.textAlign = 'left';
  		                            }
  		                            _c.label = 20;
  		                        case 20: return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderStackContent = function (stack) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var _i, _a, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
  		                return __generator(this, function (_p) {
  		                    switch (_p.label) {
  		                        case 0:
  		                            if (contains(stack.element.container.flags, 16 /* DEBUG_RENDER */)) {
  		                                debugger;
  		                            }
  		                            // https://www.w3.org/TR/css-position-3/#painting-order
  		                            // 1. the background and borders of the element forming the stacking context.
  		                            return [4 /*yield*/, this.renderNodeBackgroundAndBorders(stack.element)];
  		                        case 1:
  		                            // https://www.w3.org/TR/css-position-3/#painting-order
  		                            // 1. the background and borders of the element forming the stacking context.
  		                            _p.sent();
  		                            _i = 0, _a = stack.negativeZIndex;
  		                            _p.label = 2;
  		                        case 2:
  		                            if (!(_i < _a.length)) return [3 /*break*/, 5];
  		                            child = _a[_i];
  		                            return [4 /*yield*/, this.renderStack(child)];
  		                        case 3:
  		                            _p.sent();
  		                            _p.label = 4;
  		                        case 4:
  		                            _i++;
  		                            return [3 /*break*/, 2];
  		                        case 5: 
  		                        // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
  		                        return [4 /*yield*/, this.renderNodeContent(stack.element)];
  		                        case 6:
  		                            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
  		                            _p.sent();
  		                            _b = 0, _c = stack.nonInlineLevel;
  		                            _p.label = 7;
  		                        case 7:
  		                            if (!(_b < _c.length)) return [3 /*break*/, 10];
  		                            child = _c[_b];
  		                            return [4 /*yield*/, this.renderNode(child)];
  		                        case 8:
  		                            _p.sent();
  		                            _p.label = 9;
  		                        case 9:
  		                            _b++;
  		                            return [3 /*break*/, 7];
  		                        case 10:
  		                            _d = 0, _e = stack.nonPositionedFloats;
  		                            _p.label = 11;
  		                        case 11:
  		                            if (!(_d < _e.length)) return [3 /*break*/, 14];
  		                            child = _e[_d];
  		                            return [4 /*yield*/, this.renderStack(child)];
  		                        case 12:
  		                            _p.sent();
  		                            _p.label = 13;
  		                        case 13:
  		                            _d++;
  		                            return [3 /*break*/, 11];
  		                        case 14:
  		                            _f = 0, _g = stack.nonPositionedInlineLevel;
  		                            _p.label = 15;
  		                        case 15:
  		                            if (!(_f < _g.length)) return [3 /*break*/, 18];
  		                            child = _g[_f];
  		                            return [4 /*yield*/, this.renderStack(child)];
  		                        case 16:
  		                            _p.sent();
  		                            _p.label = 17;
  		                        case 17:
  		                            _f++;
  		                            return [3 /*break*/, 15];
  		                        case 18:
  		                            _h = 0, _j = stack.inlineLevel;
  		                            _p.label = 19;
  		                        case 19:
  		                            if (!(_h < _j.length)) return [3 /*break*/, 22];
  		                            child = _j[_h];
  		                            return [4 /*yield*/, this.renderNode(child)];
  		                        case 20:
  		                            _p.sent();
  		                            _p.label = 21;
  		                        case 21:
  		                            _h++;
  		                            return [3 /*break*/, 19];
  		                        case 22:
  		                            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
  		                            _p.label = 23;
  		                        case 23:
  		                            if (!(_k < _l.length)) return [3 /*break*/, 26];
  		                            child = _l[_k];
  		                            return [4 /*yield*/, this.renderStack(child)];
  		                        case 24:
  		                            _p.sent();
  		                            _p.label = 25;
  		                        case 25:
  		                            _k++;
  		                            return [3 /*break*/, 23];
  		                        case 26:
  		                            _m = 0, _o = stack.positiveZIndex;
  		                            _p.label = 27;
  		                        case 27:
  		                            if (!(_m < _o.length)) return [3 /*break*/, 30];
  		                            child = _o[_m];
  		                            return [4 /*yield*/, this.renderStack(child)];
  		                        case 28:
  		                            _p.sent();
  		                            _p.label = 29;
  		                        case 29:
  		                            _m++;
  		                            return [3 /*break*/, 27];
  		                        case 30: return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.mask = function (paths) {
  		            this.ctx.beginPath();
  		            this.ctx.moveTo(0, 0);
  		            this.ctx.lineTo(this.canvas.width, 0);
  		            this.ctx.lineTo(this.canvas.width, this.canvas.height);
  		            this.ctx.lineTo(0, this.canvas.height);
  		            this.ctx.lineTo(0, 0);
  		            this.formatPath(paths.slice(0).reverse());
  		            this.ctx.closePath();
  		        };
  		        CanvasRenderer.prototype.path = function (paths) {
  		            this.ctx.beginPath();
  		            this.formatPath(paths);
  		            this.ctx.closePath();
  		        };
  		        CanvasRenderer.prototype.formatPath = function (paths) {
  		            var _this = this;
  		            paths.forEach(function (point, index) {
  		                var start = isBezierCurve(point) ? point.start : point;
  		                if (index === 0) {
  		                    _this.ctx.moveTo(start.x, start.y);
  		                }
  		                else {
  		                    _this.ctx.lineTo(start.x, start.y);
  		                }
  		                if (isBezierCurve(point)) {
  		                    _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
  		                }
  		            });
  		        };
  		        CanvasRenderer.prototype.renderRepeat = function (path, pattern, offsetX, offsetY) {
  		            this.path(path);
  		            this.ctx.fillStyle = pattern;
  		            this.ctx.translate(offsetX, offsetY);
  		            this.ctx.fill();
  		            this.ctx.translate(-offsetX, -offsetY);
  		        };
  		        CanvasRenderer.prototype.resizeImage = function (image, width, height) {
  		            var _a;
  		            if (image.width === width && image.height === height) {
  		                return image;
  		            }
  		            var ownerDocument = (_a = this.canvas.ownerDocument) !== null && _a !== void 0 ? _a : document;
  		            var canvas = ownerDocument.createElement('canvas');
  		            canvas.width = Math.max(1, width);
  		            canvas.height = Math.max(1, height);
  		            var ctx = canvas.getContext('2d');
  		            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, width, height);
  		            return canvas;
  		        };
  		        CanvasRenderer.prototype.renderBackgroundImage = function (container) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var index, _loop_1, this_1, _i, _a, backgroundImage;
  		                return __generator(this, function (_b) {
  		                    switch (_b.label) {
  		                        case 0:
  		                            index = container.styles.backgroundImage.length - 1;
  		                            _loop_1 = function (backgroundImage) {
  		                                var image, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position, x, y, _g, rx, ry, radialGradient_1, midX, midY, f, invF;
  		                                return __generator(this, function (_h) {
  		                                    switch (_h.label) {
  		                                        case 0:
  		                                            if (!(backgroundImage.type === 0 /* URL */)) return [3 /*break*/, 5];
  		                                            image = void 0;
  		                                            url = backgroundImage.url;
  		                                            _h.label = 1;
  		                                        case 1:
  		                                            _h.trys.push([1, 3, , 4]);
  		                                            return [4 /*yield*/, this_1.context.cache.match(url)];
  		                                        case 2:
  		                                            image = _h.sent();
  		                                            return [3 /*break*/, 4];
  		                                        case 3:
  		                                            _h.sent();
  		                                            this_1.context.logger.error("Error loading background-image " + url);
  		                                            return [3 /*break*/, 4];
  		                                        case 4:
  		                                            if (image) {
  		                                                _c = calculateBackgroundRendering(container, index, [
  		                                                    image.width,
  		                                                    image.height,
  		                                                    image.width / image.height
  		                                                ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
  		                                                pattern = this_1.ctx.createPattern(this_1.resizeImage(image, width, height), 'repeat');
  		                                                this_1.renderRepeat(path, pattern, x, y);
  		                                            }
  		                                            return [3 /*break*/, 6];
  		                                        case 5:
  		                                            if (isLinearGradient(backgroundImage)) {
  		                                                _d = calculateBackgroundRendering(container, index, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
  		                                                _e = calculateGradientDirection(backgroundImage.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
  		                                                canvas = document.createElement('canvas');
  		                                                canvas.width = width;
  		                                                canvas.height = height;
  		                                                ctx = canvas.getContext('2d');
  		                                                gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
  		                                                processColorStops(backgroundImage.stops, lineLength).forEach(function (colorStop) {
  		                                                    return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
  		                                                });
  		                                                ctx.fillStyle = gradient_1;
  		                                                ctx.fillRect(0, 0, width, height);
  		                                                if (width > 0 && height > 0) {
  		                                                    pattern = this_1.ctx.createPattern(canvas, 'repeat');
  		                                                    this_1.renderRepeat(path, pattern, x, y);
  		                                                }
  		                                            }
  		                                            else if (isRadialGradient(backgroundImage)) {
  		                                                _f = calculateBackgroundRendering(container, index, [
  		                                                    null,
  		                                                    null,
  		                                                    null
  		                                                ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
  		                                                position = backgroundImage.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage.position;
  		                                                x = getAbsoluteValue(position[0], width);
  		                                                y = getAbsoluteValue(position[position.length - 1], height);
  		                                                _g = calculateRadius(backgroundImage, x, y, width, height), rx = _g[0], ry = _g[1];
  		                                                if (rx > 0 && ry > 0) {
  		                                                    radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
  		                                                    processColorStops(backgroundImage.stops, rx * 2).forEach(function (colorStop) {
  		                                                        return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
  		                                                    });
  		                                                    this_1.path(path);
  		                                                    this_1.ctx.fillStyle = radialGradient_1;
  		                                                    if (rx !== ry) {
  		                                                        midX = container.bounds.left + 0.5 * container.bounds.width;
  		                                                        midY = container.bounds.top + 0.5 * container.bounds.height;
  		                                                        f = ry / rx;
  		                                                        invF = 1 / f;
  		                                                        this_1.ctx.save();
  		                                                        this_1.ctx.translate(midX, midY);
  		                                                        this_1.ctx.transform(1, 0, 0, f, 0, 0);
  		                                                        this_1.ctx.translate(-midX, -midY);
  		                                                        this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
  		                                                        this_1.ctx.restore();
  		                                                    }
  		                                                    else {
  		                                                        this_1.ctx.fill();
  		                                                    }
  		                                                }
  		                                            }
  		                                            _h.label = 6;
  		                                        case 6:
  		                                            index--;
  		                                            return [2 /*return*/];
  		                                    }
  		                                });
  		                            };
  		                            this_1 = this;
  		                            _i = 0, _a = container.styles.backgroundImage.slice(0).reverse();
  		                            _b.label = 1;
  		                        case 1:
  		                            if (!(_i < _a.length)) return [3 /*break*/, 4];
  		                            backgroundImage = _a[_i];
  		                            return [5 /*yield**/, _loop_1(backgroundImage)];
  		                        case 2:
  		                            _b.sent();
  		                            _b.label = 3;
  		                        case 3:
  		                            _i++;
  		                            return [3 /*break*/, 1];
  		                        case 4: return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderSolidBorder = function (color, side, curvePoints) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                return __generator(this, function (_a) {
  		                    this.path(parsePathForBorder(curvePoints, side));
  		                    this.ctx.fillStyle = asString(color);
  		                    this.ctx.fill();
  		                    return [2 /*return*/];
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderDoubleBorder = function (color, width, side, curvePoints) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var outerPaths, innerPaths;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            if (!(width < 3)) return [3 /*break*/, 2];
  		                            return [4 /*yield*/, this.renderSolidBorder(color, side, curvePoints)];
  		                        case 1:
  		                            _a.sent();
  		                            return [2 /*return*/];
  		                        case 2:
  		                            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
  		                            this.path(outerPaths);
  		                            this.ctx.fillStyle = asString(color);
  		                            this.ctx.fill();
  		                            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
  		                            this.path(innerPaths);
  		                            this.ctx.fill();
  		                            return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderNodeBackgroundAndBorders = function (paint) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
  		                var _this = this;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            this.applyEffects(paint.getEffects(2 /* BACKGROUND_BORDERS */));
  		                            styles = paint.container.styles;
  		                            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
  		                            borders = [
  		                                { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
  		                                { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
  		                                { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
  		                                { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
  		                            ];
  		                            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
  		                            if (!(hasBackground || styles.boxShadow.length)) return [3 /*break*/, 2];
  		                            this.ctx.save();
  		                            this.path(backgroundPaintingArea);
  		                            this.ctx.clip();
  		                            if (!isTransparent(styles.backgroundColor)) {
  		                                this.ctx.fillStyle = asString(styles.backgroundColor);
  		                                this.ctx.fill();
  		                            }
  		                            return [4 /*yield*/, this.renderBackgroundImage(paint.container)];
  		                        case 1:
  		                            _a.sent();
  		                            this.ctx.restore();
  		                            styles.boxShadow
  		                                .slice(0)
  		                                .reverse()
  		                                .forEach(function (shadow) {
  		                                _this.ctx.save();
  		                                var borderBoxArea = calculateBorderBoxPath(paint.curves);
  		                                var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
  		                                var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
  		                                if (shadow.inset) {
  		                                    _this.path(borderBoxArea);
  		                                    _this.ctx.clip();
  		                                    _this.mask(shadowPaintingArea);
  		                                }
  		                                else {
  		                                    _this.mask(borderBoxArea);
  		                                    _this.ctx.clip();
  		                                    _this.path(shadowPaintingArea);
  		                                }
  		                                _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
  		                                _this.ctx.shadowOffsetY = shadow.offsetY.number;
  		                                _this.ctx.shadowColor = asString(shadow.color);
  		                                _this.ctx.shadowBlur = shadow.blur.number;
  		                                _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : 'rgba(0,0,0,1)';
  		                                _this.ctx.fill();
  		                                _this.ctx.restore();
  		                            });
  		                            _a.label = 2;
  		                        case 2:
  		                            side = 0;
  		                            _i = 0, borders_1 = borders;
  		                            _a.label = 3;
  		                        case 3:
  		                            if (!(_i < borders_1.length)) return [3 /*break*/, 13];
  		                            border = borders_1[_i];
  		                            if (!(border.style !== 0 /* NONE */ && !isTransparent(border.color) && border.width > 0)) return [3 /*break*/, 11];
  		                            if (!(border.style === 2 /* DASHED */)) return [3 /*break*/, 5];
  		                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2 /* DASHED */)];
  		                        case 4:
  		                            _a.sent();
  		                            return [3 /*break*/, 11];
  		                        case 5:
  		                            if (!(border.style === 3 /* DOTTED */)) return [3 /*break*/, 7];
  		                            return [4 /*yield*/, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3 /* DOTTED */)];
  		                        case 6:
  		                            _a.sent();
  		                            return [3 /*break*/, 11];
  		                        case 7:
  		                            if (!(border.style === 4 /* DOUBLE */)) return [3 /*break*/, 9];
  		                            return [4 /*yield*/, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
  		                        case 8:
  		                            _a.sent();
  		                            return [3 /*break*/, 11];
  		                        case 9: return [4 /*yield*/, this.renderSolidBorder(border.color, side, paint.curves)];
  		                        case 10:
  		                            _a.sent();
  		                            _a.label = 11;
  		                        case 11:
  		                            side++;
  		                            _a.label = 12;
  		                        case 12:
  		                            _i++;
  		                            return [3 /*break*/, 3];
  		                        case 13: return [2 /*return*/];
  		                    }
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.renderDashedDottedBorder = function (color, width, side, curvePoints, style) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
  		                return __generator(this, function (_a) {
  		                    this.ctx.save();
  		                    strokePaths = parsePathForBorderStroke(curvePoints, side);
  		                    boxPaths = parsePathForBorder(curvePoints, side);
  		                    if (style === 2 /* DASHED */) {
  		                        this.path(boxPaths);
  		                        this.ctx.clip();
  		                    }
  		                    if (isBezierCurve(boxPaths[0])) {
  		                        startX = boxPaths[0].start.x;
  		                        startY = boxPaths[0].start.y;
  		                    }
  		                    else {
  		                        startX = boxPaths[0].x;
  		                        startY = boxPaths[0].y;
  		                    }
  		                    if (isBezierCurve(boxPaths[1])) {
  		                        endX = boxPaths[1].end.x;
  		                        endY = boxPaths[1].end.y;
  		                    }
  		                    else {
  		                        endX = boxPaths[1].x;
  		                        endY = boxPaths[1].y;
  		                    }
  		                    if (side === 0 || side === 2) {
  		                        length = Math.abs(startX - endX);
  		                    }
  		                    else {
  		                        length = Math.abs(startY - endY);
  		                    }
  		                    this.ctx.beginPath();
  		                    if (style === 3 /* DOTTED */) {
  		                        this.formatPath(strokePaths);
  		                    }
  		                    else {
  		                        this.formatPath(boxPaths.slice(0, 2));
  		                    }
  		                    dashLength = width < 3 ? width * 3 : width * 2;
  		                    spaceLength = width < 3 ? width * 2 : width;
  		                    if (style === 3 /* DOTTED */) {
  		                        dashLength = width;
  		                        spaceLength = width;
  		                    }
  		                    useLineDash = true;
  		                    if (length <= dashLength * 2) {
  		                        useLineDash = false;
  		                    }
  		                    else if (length <= dashLength * 2 + spaceLength) {
  		                        multiplier = length / (2 * dashLength + spaceLength);
  		                        dashLength *= multiplier;
  		                        spaceLength *= multiplier;
  		                    }
  		                    else {
  		                        numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
  		                        minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
  		                        maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
  		                        spaceLength =
  		                            maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace)
  		                                ? minSpace
  		                                : maxSpace;
  		                    }
  		                    if (useLineDash) {
  		                        if (style === 3 /* DOTTED */) {
  		                            this.ctx.setLineDash([0, dashLength + spaceLength]);
  		                        }
  		                        else {
  		                            this.ctx.setLineDash([dashLength, spaceLength]);
  		                        }
  		                    }
  		                    if (style === 3 /* DOTTED */) {
  		                        this.ctx.lineCap = 'round';
  		                        this.ctx.lineWidth = width;
  		                    }
  		                    else {
  		                        this.ctx.lineWidth = width * 2 + 1.1;
  		                    }
  		                    this.ctx.strokeStyle = asString(color);
  		                    this.ctx.stroke();
  		                    this.ctx.setLineDash([]);
  		                    // dashed round edge gap
  		                    if (style === 2 /* DASHED */) {
  		                        if (isBezierCurve(boxPaths[0])) {
  		                            path1 = boxPaths[3];
  		                            path2 = boxPaths[0];
  		                            this.ctx.beginPath();
  		                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
  		                            this.ctx.stroke();
  		                        }
  		                        if (isBezierCurve(boxPaths[1])) {
  		                            path1 = boxPaths[1];
  		                            path2 = boxPaths[2];
  		                            this.ctx.beginPath();
  		                            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
  		                            this.ctx.stroke();
  		                        }
  		                    }
  		                    this.ctx.restore();
  		                    return [2 /*return*/];
  		                });
  		            });
  		        };
  		        CanvasRenderer.prototype.render = function (element) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var stack;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            if (this.options.backgroundColor) {
  		                                this.ctx.fillStyle = asString(this.options.backgroundColor);
  		                                this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
  		                            }
  		                            stack = parseStackingContexts(element);
  		                            return [4 /*yield*/, this.renderStack(stack)];
  		                        case 1:
  		                            _a.sent();
  		                            this.applyEffects([]);
  		                            return [2 /*return*/, this.canvas];
  		                    }
  		                });
  		            });
  		        };
  		        return CanvasRenderer;
  		    }(Renderer));
  		    var isTextInputElement = function (container) {
  		        if (container instanceof TextareaElementContainer) {
  		            return true;
  		        }
  		        else if (container instanceof SelectElementContainer) {
  		            return true;
  		        }
  		        else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
  		            return true;
  		        }
  		        return false;
  		    };
  		    var calculateBackgroundCurvedPaintingArea = function (clip, curves) {
  		        switch (clip) {
  		            case 0 /* BORDER_BOX */:
  		                return calculateBorderBoxPath(curves);
  		            case 2 /* CONTENT_BOX */:
  		                return calculateContentBoxPath(curves);
  		            case 1 /* PADDING_BOX */:
  		            default:
  		                return calculatePaddingBoxPath(curves);
  		        }
  		    };
  		    var canvasTextAlign = function (textAlign) {
  		        switch (textAlign) {
  		            case 1 /* CENTER */:
  		                return 'center';
  		            case 2 /* RIGHT */:
  		                return 'right';
  		            case 0 /* LEFT */:
  		            default:
  		                return 'left';
  		        }
  		    };
  		    // see https://github.com/niklasvh/html2canvas/pull/2645
  		    var iOSBrokenFonts = ['-apple-system', 'system-ui'];
  		    var fixIOSSystemFonts = function (fontFamilies) {
  		        return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent)
  		            ? fontFamilies.filter(function (fontFamily) { return iOSBrokenFonts.indexOf(fontFamily) === -1; })
  		            : fontFamilies;
  		    };

  		    var ForeignObjectRenderer = /** @class */ (function (_super) {
  		        __extends(ForeignObjectRenderer, _super);
  		        function ForeignObjectRenderer(context, options) {
  		            var _this = _super.call(this, context, options) || this;
  		            _this.canvas = options.canvas ? options.canvas : document.createElement('canvas');
  		            _this.ctx = _this.canvas.getContext('2d');
  		            _this.options = options;
  		            _this.canvas.width = Math.floor(options.width * options.scale);
  		            _this.canvas.height = Math.floor(options.height * options.scale);
  		            _this.canvas.style.width = options.width + "px";
  		            _this.canvas.style.height = options.height + "px";
  		            _this.ctx.scale(_this.options.scale, _this.options.scale);
  		            _this.ctx.translate(-options.x, -options.y);
  		            _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
  		            return _this;
  		        }
  		        ForeignObjectRenderer.prototype.render = function (element) {
  		            return __awaiter(this, void 0, void 0, function () {
  		                var svg, img;
  		                return __generator(this, function (_a) {
  		                    switch (_a.label) {
  		                        case 0:
  		                            svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
  		                            return [4 /*yield*/, loadSerializedSVG(svg)];
  		                        case 1:
  		                            img = _a.sent();
  		                            if (this.options.backgroundColor) {
  		                                this.ctx.fillStyle = asString(this.options.backgroundColor);
  		                                this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
  		                            }
  		                            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
  		                            return [2 /*return*/, this.canvas];
  		                    }
  		                });
  		            });
  		        };
  		        return ForeignObjectRenderer;
  		    }(Renderer));
  		    var loadSerializedSVG = function (svg) {
  		        return new Promise(function (resolve, reject) {
  		            var img = new Image();
  		            img.onload = function () {
  		                resolve(img);
  		            };
  		            img.onerror = reject;
  		            img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  		        });
  		    };

  		    var Logger = /** @class */ (function () {
  		        function Logger(_a) {
  		            var id = _a.id, enabled = _a.enabled;
  		            this.id = id;
  		            this.enabled = enabled;
  		            this.start = Date.now();
  		        }
  		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		        Logger.prototype.debug = function () {
  		            var args = [];
  		            for (var _i = 0; _i < arguments.length; _i++) {
  		                args[_i] = arguments[_i];
  		            }
  		            if (this.enabled) {
  		                // eslint-disable-next-line no-console
  		                if (typeof window !== 'undefined' && window.console && typeof console.debug === 'function') {
  		                    // eslint-disable-next-line no-console
  		                    console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
  		                }
  		                else {
  		                    this.info.apply(this, args);
  		                }
  		            }
  		        };
  		        Logger.prototype.getTime = function () {
  		            return Date.now() - this.start;
  		        };
  		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		        Logger.prototype.info = function () {
  		            var args = [];
  		            for (var _i = 0; _i < arguments.length; _i++) {
  		                args[_i] = arguments[_i];
  		            }
  		            if (this.enabled) {
  		                // eslint-disable-next-line no-console
  		                if (typeof window !== 'undefined' && window.console && typeof console.info === 'function') {
  		                    // eslint-disable-next-line no-console
  		                    console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
  		                }
  		            }
  		        };
  		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		        Logger.prototype.warn = function () {
  		            var args = [];
  		            for (var _i = 0; _i < arguments.length; _i++) {
  		                args[_i] = arguments[_i];
  		            }
  		            if (this.enabled) {
  		                // eslint-disable-next-line no-console
  		                if (typeof window !== 'undefined' && window.console && typeof console.warn === 'function') {
  		                    // eslint-disable-next-line no-console
  		                    console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
  		                }
  		                else {
  		                    this.info.apply(this, args);
  		                }
  		            }
  		        };
  		        // eslint-disable-next-line @typescript-eslint/no-explicit-any
  		        Logger.prototype.error = function () {
  		            var args = [];
  		            for (var _i = 0; _i < arguments.length; _i++) {
  		                args[_i] = arguments[_i];
  		            }
  		            if (this.enabled) {
  		                // eslint-disable-next-line no-console
  		                if (typeof window !== 'undefined' && window.console && typeof console.error === 'function') {
  		                    // eslint-disable-next-line no-console
  		                    console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
  		                }
  		                else {
  		                    this.info.apply(this, args);
  		                }
  		            }
  		        };
  		        Logger.instances = {};
  		        return Logger;
  		    }());

  		    var Context = /** @class */ (function () {
  		        function Context(options, windowBounds) {
  		            var _a;
  		            this.windowBounds = windowBounds;
  		            this.instanceName = "#" + Context.instanceCount++;
  		            this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
  		            this.cache = (_a = options.cache) !== null && _a !== void 0 ? _a : new Cache(this, options);
  		        }
  		        Context.instanceCount = 1;
  		        return Context;
  		    }());

  		    var html2canvas = function (element, options) {
  		        if (options === void 0) { options = {}; }
  		        return renderElement(element, options);
  		    };
  		    if (typeof window !== 'undefined') {
  		        CacheStorage.setContext(window);
  		    }
  		    var renderElement = function (element, opts) { return __awaiter(void 0, void 0, void 0, function () {
  		        var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a, width, height, left, top, backgroundColor, renderOptions, canvas, renderer, root, renderer;
  		        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  		        return __generator(this, function (_u) {
  		            switch (_u.label) {
  		                case 0:
  		                    if (!element || typeof element !== 'object') {
  		                        return [2 /*return*/, Promise.reject('Invalid element provided as first argument')];
  		                    }
  		                    ownerDocument = element.ownerDocument;
  		                    if (!ownerDocument) {
  		                        throw new Error("Element is not attached to a Document");
  		                    }
  		                    defaultView = ownerDocument.defaultView;
  		                    if (!defaultView) {
  		                        throw new Error("Document is not attached to a Window");
  		                    }
  		                    resourceOptions = {
  		                        allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
  		                        imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15000,
  		                        proxy: opts.proxy,
  		                        useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
  		                    };
  		                    contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
  		                    windowOptions = {
  		                        windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
  		                        windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
  		                        scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
  		                        scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
  		                    };
  		                    windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
  		                    context = new Context(contextOptions, windowBounds);
  		                    foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
  		                    cloneOptions = {
  		                        allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
  		                        onclone: opts.onclone,
  		                        ignoreElements: opts.ignoreElements,
  		                        inlineImages: foreignObjectRendering,
  		                        copyStyles: foreignObjectRendering
  		                    };
  		                    context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
  		                    documentCloner = new DocumentCloner(context, element, cloneOptions);
  		                    clonedElement = documentCloner.clonedReferenceElement;
  		                    if (!clonedElement) {
  		                        return [2 /*return*/, Promise.reject("Unable to find element in cloned iframe")];
  		                    }
  		                    return [4 /*yield*/, documentCloner.toIFrame(ownerDocument, windowBounds)];
  		                case 1:
  		                    container = _u.sent();
  		                    _a = isBodyElement(clonedElement) || isHTMLElement(clonedElement)
  		                        ? parseDocumentSize(clonedElement.ownerDocument)
  		                        : parseBounds(context, clonedElement), width = _a.width, height = _a.height, left = _a.left, top = _a.top;
  		                    backgroundColor = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
  		                    renderOptions = {
  		                        canvas: opts.canvas,
  		                        backgroundColor: backgroundColor,
  		                        scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
  		                        x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
  		                        y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
  		                        width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
  		                        height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
  		                    };
  		                    if (!foreignObjectRendering) return [3 /*break*/, 3];
  		                    context.logger.debug("Document cloned, using foreign object rendering");
  		                    renderer = new ForeignObjectRenderer(context, renderOptions);
  		                    return [4 /*yield*/, renderer.render(clonedElement)];
  		                case 2:
  		                    canvas = _u.sent();
  		                    return [3 /*break*/, 5];
  		                case 3:
  		                    context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
  		                    context.logger.debug("Starting DOM parsing");
  		                    root = parseTree(context, clonedElement);
  		                    if (backgroundColor === root.styles.backgroundColor) {
  		                        root.styles.backgroundColor = COLORS.TRANSPARENT;
  		                    }
  		                    context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
  		                    renderer = new CanvasRenderer(context, renderOptions);
  		                    return [4 /*yield*/, renderer.render(root)];
  		                case 4:
  		                    canvas = _u.sent();
  		                    _u.label = 5;
  		                case 5:
  		                    if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
  		                        if (!DocumentCloner.destroy(container)) {
  		                            context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
  		                        }
  		                    }
  		                    context.logger.debug("Finished rendering");
  		                    return [2 /*return*/, canvas];
  		            }
  		        });
  		    }); };
  		    var parseBackgroundColor = function (context, element, backgroundColorOverride) {
  		        var ownerDocument = element.ownerDocument;
  		        // http://www.w3.org/TR/css3-background/#special-backgrounds
  		        var documentBackgroundColor = ownerDocument.documentElement
  		            ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor)
  		            : COLORS.TRANSPARENT;
  		        var bodyBackgroundColor = ownerDocument.body
  		            ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor)
  		            : COLORS.TRANSPARENT;
  		        var defaultBackgroundColor = typeof backgroundColorOverride === 'string'
  		            ? parseColor(context, backgroundColorOverride)
  		            : backgroundColorOverride === null
  		                ? COLORS.TRANSPARENT
  		                : 0xffffffff;
  		        return element === ownerDocument.documentElement
  		            ? isTransparent(documentBackgroundColor)
  		                ? isTransparent(bodyBackgroundColor)
  		                    ? defaultBackgroundColor
  		                    : bodyBackgroundColor
  		                : documentBackgroundColor
  		            : defaultBackgroundColor;
  		    };

  		    return html2canvas;

  		})));
  		
  	} (html2canvas$2, html2canvas$2.exports));
  	return html2canvas$2.exports;
  }

  var html2canvasExports = requireHtml2canvas();
  var html2canvas = /*@__PURE__*/getDefaultExportFromCjs(html2canvasExports);

  /*! https://mths.be/codepointat v0.2.0 by @mathias */
  if (!String.prototype.codePointAt) {
  	(function() {
  		var defineProperty = (function() {
  			// IE 8 only supports `Object.defineProperty` on DOM elements
  			try {
  				var object = {};
  				var $defineProperty = Object.defineProperty;
  				var result = $defineProperty(object, object, object) && $defineProperty;
  			} catch(error) {}
  			return result;
  		}());
  		var codePointAt = function(position) {
  			if (this == null) {
  				throw TypeError();
  			}
  			var string = String(this);
  			var size = string.length;
  			// `ToInteger`
  			var index = position ? Number(position) : 0;
  			if (index != index) { // better `isNaN`
  				index = 0;
  			}
  			// Account for out-of-bounds indices:
  			if (index < 0 || index >= size) {
  				return undefined;
  			}
  			// Get the first code unit
  			var first = string.charCodeAt(index);
  			var second;
  			if ( // check if its the start of a surrogate pair
  				first >= 0xD800 && first <= 0xDBFF && // high surrogate
  				size > index + 1 // there is a next code unit
  			) {
  				second = string.charCodeAt(index + 1);
  				if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
  					// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
  					return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
  				}
  			}
  			return first;
  		};
  		if (defineProperty) {
  			defineProperty(String.prototype, 'codePointAt', {
  				'value': codePointAt,
  				'configurable': true,
  				'writable': true
  			});
  		} else {
  			String.prototype.codePointAt = codePointAt;
  		}
  	}());
  }

  var TINF_OK = 0;
  var TINF_DATA_ERROR = -3;

  function Tree() {
    this.table = new Uint16Array(16);   /* table of code length counts */
    this.trans = new Uint16Array(288);  /* code -> symbol translation table */
  }

  function Data(source, dest) {
    this.source = source;
    this.sourceIndex = 0;
    this.tag = 0;
    this.bitcount = 0;
    
    this.dest = dest;
    this.destLen = 0;
    
    this.ltree = new Tree();  /* dynamic length/symbol tree */
    this.dtree = new Tree();  /* dynamic distance tree */
  }

  /* --------------------------------------------------- *
   * -- uninitialized global data (static structures) -- *
   * --------------------------------------------------- */

  var sltree = new Tree();
  var sdtree = new Tree();

  /* extra bits and base tables for length codes */
  var length_bits = new Uint8Array(30);
  var length_base = new Uint16Array(30);

  /* extra bits and base tables for distance codes */
  var dist_bits = new Uint8Array(30);
  var dist_base = new Uint16Array(30);

  /* special ordering of code length codes */
  var clcidx = new Uint8Array([
    16, 17, 18, 0, 8, 7, 9, 6,
    10, 5, 11, 4, 12, 3, 13, 2,
    14, 1, 15
  ]);

  /* used by tinf_decode_trees, avoids allocations every call */
  var code_tree = new Tree();
  var lengths = new Uint8Array(288 + 32);

  /* ----------------------- *
   * -- utility functions -- *
   * ----------------------- */

  /* build extra bits and base tables */
  function tinf_build_bits_base(bits, base, delta, first) {
    var i, sum;

    /* build bits table */
    for (i = 0; i < delta; ++i) { bits[i] = 0; }
    for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

    /* build base table */
    for (sum = first, i = 0; i < 30; ++i) {
      base[i] = sum;
      sum += 1 << bits[i];
    }
  }

  /* build the fixed huffman trees */
  function tinf_build_fixed_trees(lt, dt) {
    var i;

    /* build fixed length tree */
    for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

    lt.table[7] = 24;
    lt.table[8] = 152;
    lt.table[9] = 112;

    for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
    for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
    for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
    for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

    /* build fixed distance tree */
    for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

    dt.table[5] = 32;

    for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
  }

  /* given an array of code lengths, build a tree */
  var offs = new Uint16Array(16);

  function tinf_build_tree(t, lengths, off, num) {
    var i, sum;

    /* clear code length count table */
    for (i = 0; i < 16; ++i) { t.table[i] = 0; }

    /* scan symbol lengths, and sum code length counts */
    for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

    t.table[0] = 0;

    /* compute offset table for distribution sort */
    for (sum = 0, i = 0; i < 16; ++i) {
      offs[i] = sum;
      sum += t.table[i];
    }

    /* create code->symbol translation table (symbols sorted by code) */
    for (i = 0; i < num; ++i) {
      if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
    }
  }

  /* ---------------------- *
   * -- decode functions -- *
   * ---------------------- */

  /* get one bit from source stream */
  function tinf_getbit(d) {
    /* check if tag is empty */
    if (!d.bitcount--) {
      /* load next tag */
      d.tag = d.source[d.sourceIndex++];
      d.bitcount = 7;
    }

    /* shift bit out of tag */
    var bit = d.tag & 1;
    d.tag >>>= 1;

    return bit;
  }

  /* read a num bit value from a stream and add base */
  function tinf_read_bits(d, num, base) {
    if (!num)
      { return base; }

    while (d.bitcount < 24) {
      d.tag |= d.source[d.sourceIndex++] << d.bitcount;
      d.bitcount += 8;
    }

    var val = d.tag & (0xffff >>> (16 - num));
    d.tag >>>= num;
    d.bitcount -= num;
    return val + base;
  }

  /* given a data stream and a tree, decode a symbol */
  function tinf_decode_symbol(d, t) {
    while (d.bitcount < 24) {
      d.tag |= d.source[d.sourceIndex++] << d.bitcount;
      d.bitcount += 8;
    }
    
    var sum = 0, cur = 0, len = 0;
    var tag = d.tag;

    /* get more bits while code value is above sum */
    do {
      cur = 2 * cur + (tag & 1);
      tag >>>= 1;
      ++len;

      sum += t.table[len];
      cur -= t.table[len];
    } while (cur >= 0);
    
    d.tag = tag;
    d.bitcount -= len;

    return t.trans[sum + cur];
  }

  /* given a data stream, decode dynamic trees from it */
  function tinf_decode_trees(d, lt, dt) {
    var hlit, hdist, hclen;
    var i, num, length;

    /* get 5 bits HLIT (257-286) */
    hlit = tinf_read_bits(d, 5, 257);

    /* get 5 bits HDIST (1-32) */
    hdist = tinf_read_bits(d, 5, 1);

    /* get 4 bits HCLEN (4-19) */
    hclen = tinf_read_bits(d, 4, 4);

    for (i = 0; i < 19; ++i) { lengths[i] = 0; }

    /* read code lengths for code length alphabet */
    for (i = 0; i < hclen; ++i) {
      /* get 3 bits code length (0-7) */
      var clen = tinf_read_bits(d, 3, 0);
      lengths[clcidx[i]] = clen;
    }

    /* build code length tree */
    tinf_build_tree(code_tree, lengths, 0, 19);

    /* decode code lengths for the dynamic trees */
    for (num = 0; num < hlit + hdist;) {
      var sym = tinf_decode_symbol(d, code_tree);

      switch (sym) {
        case 16:
          /* copy previous code length 3-6 times (read 2 bits) */
          var prev = lengths[num - 1];
          for (length = tinf_read_bits(d, 2, 3); length; --length) {
            lengths[num++] = prev;
          }
          break;
        case 17:
          /* repeat code length 0 for 3-10 times (read 3 bits) */
          for (length = tinf_read_bits(d, 3, 3); length; --length) {
            lengths[num++] = 0;
          }
          break;
        case 18:
          /* repeat code length 0 for 11-138 times (read 7 bits) */
          for (length = tinf_read_bits(d, 7, 11); length; --length) {
            lengths[num++] = 0;
          }
          break;
        default:
          /* values 0-15 represent the actual code lengths */
          lengths[num++] = sym;
          break;
      }
    }

    /* build dynamic trees */
    tinf_build_tree(lt, lengths, 0, hlit);
    tinf_build_tree(dt, lengths, hlit, hdist);
  }

  /* ----------------------------- *
   * -- block inflate functions -- *
   * ----------------------------- */

  /* given a stream and two trees, inflate a block of data */
  function tinf_inflate_block_data(d, lt, dt) {
    while (1) {
      var sym = tinf_decode_symbol(d, lt);

      /* check for end of block */
      if (sym === 256) {
        return TINF_OK;
      }

      if (sym < 256) {
        d.dest[d.destLen++] = sym;
      } else {
        var length, dist, offs;
        var i;

        sym -= 257;

        /* possibly get more bits from length code */
        length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

        dist = tinf_decode_symbol(d, dt);

        /* possibly get more bits from distance code */
        offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

        /* copy match */
        for (i = offs; i < offs + length; ++i) {
          d.dest[d.destLen++] = d.dest[i];
        }
      }
    }
  }

  /* inflate an uncompressed block of data */
  function tinf_inflate_uncompressed_block(d) {
    var length, invlength;
    var i;
    
    /* unread from bitbuffer */
    while (d.bitcount > 8) {
      d.sourceIndex--;
      d.bitcount -= 8;
    }

    /* get length */
    length = d.source[d.sourceIndex + 1];
    length = 256 * length + d.source[d.sourceIndex];

    /* get one's complement of length */
    invlength = d.source[d.sourceIndex + 3];
    invlength = 256 * invlength + d.source[d.sourceIndex + 2];

    /* check length */
    if (length !== (~invlength & 0x0000ffff))
      { return TINF_DATA_ERROR; }

    d.sourceIndex += 4;

    /* copy block */
    for (i = length; i; --i)
      { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

    /* make sure we start next block on a byte boundary */
    d.bitcount = 0;

    return TINF_OK;
  }

  /* inflate stream from source to dest */
  function tinf_uncompress(source, dest) {
    var d = new Data(source, dest);
    var bfinal, btype, res;

    do {
      /* read final block flag */
      bfinal = tinf_getbit(d);

      /* read block type (2 bits) */
      btype = tinf_read_bits(d, 2, 0);

      /* decompress block */
      switch (btype) {
        case 0:
          /* decompress uncompressed block */
          res = tinf_inflate_uncompressed_block(d);
          break;
        case 1:
          /* decompress block with fixed huffman trees */
          res = tinf_inflate_block_data(d, sltree, sdtree);
          break;
        case 2:
          /* decompress block with dynamic huffman trees */
          tinf_decode_trees(d, d.ltree, d.dtree);
          res = tinf_inflate_block_data(d, d.ltree, d.dtree);
          break;
        default:
          res = TINF_DATA_ERROR;
      }

      if (res !== TINF_OK)
        { throw new Error('Data error'); }

    } while (!bfinal);

    if (d.destLen < d.dest.length) {
      if (typeof d.dest.slice === 'function')
        { return d.dest.slice(0, d.destLen); }
      else
        { return d.dest.subarray(0, d.destLen); }
    }
    
    return d.dest;
  }

  /* -------------------- *
   * -- initialization -- *
   * -------------------- */

  /* build fixed huffman trees */
  tinf_build_fixed_trees(sltree, sdtree);

  /* build extra bits and base tables */
  tinf_build_bits_base(length_bits, length_base, 4, 3);
  tinf_build_bits_base(dist_bits, dist_base, 2, 1);

  /* fix a special case */
  length_bits[28] = 0;
  length_base[28] = 258;

  var tinyInflate = tinf_uncompress;

  // The Bounding Box object

  function derive(v0, v1, v2, v3, t) {
      return Math.pow(1 - t, 3) * v0 +
          3 * Math.pow(1 - t, 2) * t * v1 +
          3 * (1 - t) * Math.pow(t, 2) * v2 +
          Math.pow(t, 3) * v3;
  }
  /**
   * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
   * It is used to calculate the bounding box of a glyph or text path.
   *
   * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
   *
   * @exports opentype.BoundingBox
   * @class
   * @constructor
   */
  function BoundingBox() {
      this.x1 = Number.NaN;
      this.y1 = Number.NaN;
      this.x2 = Number.NaN;
      this.y2 = Number.NaN;
  }

  /**
   * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
   */
  BoundingBox.prototype.isEmpty = function() {
      return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
  };

  /**
   * Add the point to the bounding box.
   * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
   * @param {number} x - The X coordinate of the point.
   * @param {number} y - The Y coordinate of the point.
   */
  BoundingBox.prototype.addPoint = function(x, y) {
      if (typeof x === 'number') {
          if (isNaN(this.x1) || isNaN(this.x2)) {
              this.x1 = x;
              this.x2 = x;
          }
          if (x < this.x1) {
              this.x1 = x;
          }
          if (x > this.x2) {
              this.x2 = x;
          }
      }
      if (typeof y === 'number') {
          if (isNaN(this.y1) || isNaN(this.y2)) {
              this.y1 = y;
              this.y2 = y;
          }
          if (y < this.y1) {
              this.y1 = y;
          }
          if (y > this.y2) {
              this.y2 = y;
          }
      }
  };

  /**
   * Add a X coordinate to the bounding box.
   * This extends the bounding box to include the X coordinate.
   * This function is used internally inside of addBezier.
   * @param {number} x - The X coordinate of the point.
   */
  BoundingBox.prototype.addX = function(x) {
      this.addPoint(x, null);
  };

  /**
   * Add a Y coordinate to the bounding box.
   * This extends the bounding box to include the Y coordinate.
   * This function is used internally inside of addBezier.
   * @param {number} y - The Y coordinate of the point.
   */
  BoundingBox.prototype.addY = function(y) {
      this.addPoint(null, y);
  };

  /**
   * Add a Bzier curve to the bounding box.
   * This extends the bounding box to include the entire Bzier.
   * @param {number} x0 - The starting X coordinate.
   * @param {number} y0 - The starting Y coordinate.
   * @param {number} x1 - The X coordinate of the first control point.
   * @param {number} y1 - The Y coordinate of the first control point.
   * @param {number} x2 - The X coordinate of the second control point.
   * @param {number} y2 - The Y coordinate of the second control point.
   * @param {number} x - The ending X coordinate.
   * @param {number} y - The ending Y coordinate.
   */
  BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
      // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
      // and https://github.com/icons8/svg-path-bounding-box

      var p0 = [x0, y0];
      var p1 = [x1, y1];
      var p2 = [x2, y2];
      var p3 = [x, y];

      this.addPoint(x0, y0);
      this.addPoint(x, y);

      for (var i = 0; i <= 1; i++) {
          var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
          var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
          var c = 3 * p1[i] - 3 * p0[i];

          if (a === 0) {
              if (b === 0) { continue; }
              var t = -c / b;
              if (0 < t && t < 1) {
                  if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                  if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
              }
              continue;
          }

          var b2ac = Math.pow(b, 2) - 4 * c * a;
          if (b2ac < 0) { continue; }
          var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
          if (0 < t1 && t1 < 1) {
              if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
              if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
          }
          var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
          if (0 < t2 && t2 < 1) {
              if (i === 0) { this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
              if (i === 1) { this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
          }
      }
  };

  /**
   * Add a quadratic curve to the bounding box.
   * This extends the bounding box to include the entire quadratic curve.
   * @param {number} x0 - The starting X coordinate.
   * @param {number} y0 - The starting Y coordinate.
   * @param {number} x1 - The X coordinate of the control point.
   * @param {number} y1 - The Y coordinate of the control point.
   * @param {number} x - The ending X coordinate.
   * @param {number} y - The ending Y coordinate.
   */
  BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
      var cp1x = x0 + 2 / 3 * (x1 - x0);
      var cp1y = y0 + 2 / 3 * (y1 - y0);
      var cp2x = cp1x + 1 / 3 * (x - x0);
      var cp2y = cp1y + 1 / 3 * (y - y0);
      this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
  };

  // Geometric objects

  /**
   * A bzier path containing a set of path commands similar to a SVG path.
   * Paths can be drawn on a context using `draw`.
   * @exports opentype.Path
   * @class
   * @constructor
   */
  function Path() {
      this.commands = [];
      this.fill = 'black';
      this.stroke = null;
      this.strokeWidth = 1;
  }

  /**
   * @param  {number} x
   * @param  {number} y
   */
  Path.prototype.moveTo = function(x, y) {
      this.commands.push({
          type: 'M',
          x: x,
          y: y
      });
  };

  /**
   * @param  {number} x
   * @param  {number} y
   */
  Path.prototype.lineTo = function(x, y) {
      this.commands.push({
          type: 'L',
          x: x,
          y: y
      });
  };

  /**
   * Draws cubic curve
   * @function
   * curveTo
   * @memberof opentype.Path.prototype
   * @param  {number} x1 - x of control 1
   * @param  {number} y1 - y of control 1
   * @param  {number} x2 - x of control 2
   * @param  {number} y2 - y of control 2
   * @param  {number} x - x of path point
   * @param  {number} y - y of path point
   */

  /**
   * Draws cubic curve
   * @function
   * bezierCurveTo
   * @memberof opentype.Path.prototype
   * @param  {number} x1 - x of control 1
   * @param  {number} y1 - y of control 1
   * @param  {number} x2 - x of control 2
   * @param  {number} y2 - y of control 2
   * @param  {number} x - x of path point
   * @param  {number} y - y of path point
   * @see curveTo
   */
  Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
      this.commands.push({
          type: 'C',
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          x: x,
          y: y
      });
  };

  /**
   * Draws quadratic curve
   * @function
   * quadraticCurveTo
   * @memberof opentype.Path.prototype
   * @param  {number} x1 - x of control
   * @param  {number} y1 - y of control
   * @param  {number} x - x of path point
   * @param  {number} y - y of path point
   */

  /**
   * Draws quadratic curve
   * @function
   * quadTo
   * @memberof opentype.Path.prototype
   * @param  {number} x1 - x of control
   * @param  {number} y1 - y of control
   * @param  {number} x - x of path point
   * @param  {number} y - y of path point
   */
  Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
      this.commands.push({
          type: 'Q',
          x1: x1,
          y1: y1,
          x: x,
          y: y
      });
  };

  /**
   * Closes the path
   * @function closePath
   * @memberof opentype.Path.prototype
   */

  /**
   * Close the path
   * @function close
   * @memberof opentype.Path.prototype
   */
  Path.prototype.close = Path.prototype.closePath = function() {
      this.commands.push({
          type: 'Z'
      });
  };

  /**
   * Add the given path or list of commands to the commands of this path.
   * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
   */
  Path.prototype.extend = function(pathOrCommands) {
      if (pathOrCommands.commands) {
          pathOrCommands = pathOrCommands.commands;
      } else if (pathOrCommands instanceof BoundingBox) {
          var box = pathOrCommands;
          this.moveTo(box.x1, box.y1);
          this.lineTo(box.x2, box.y1);
          this.lineTo(box.x2, box.y2);
          this.lineTo(box.x1, box.y2);
          this.close();
          return;
      }

      Array.prototype.push.apply(this.commands, pathOrCommands);
  };

  /**
   * Calculate the bounding box of the path.
   * @returns {opentype.BoundingBox}
   */
  Path.prototype.getBoundingBox = function() {
      var box = new BoundingBox();

      var startX = 0;
      var startY = 0;
      var prevX = 0;
      var prevY = 0;
      for (var i = 0; i < this.commands.length; i++) {
          var cmd = this.commands[i];
          switch (cmd.type) {
              case 'M':
                  box.addPoint(cmd.x, cmd.y);
                  startX = prevX = cmd.x;
                  startY = prevY = cmd.y;
                  break;
              case 'L':
                  box.addPoint(cmd.x, cmd.y);
                  prevX = cmd.x;
                  prevY = cmd.y;
                  break;
              case 'Q':
                  box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                  prevX = cmd.x;
                  prevY = cmd.y;
                  break;
              case 'C':
                  box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                  prevX = cmd.x;
                  prevY = cmd.y;
                  break;
              case 'Z':
                  prevX = startX;
                  prevY = startY;
                  break;
              default:
                  throw new Error('Unexpected path command ' + cmd.type);
          }
      }
      if (box.isEmpty()) {
          box.addPoint(0, 0);
      }
      return box;
  };

  /**
   * Draw the path to a 2D context.
   * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
   */
  Path.prototype.draw = function(ctx) {
      ctx.beginPath();
      for (var i = 0; i < this.commands.length; i += 1) {
          var cmd = this.commands[i];
          if (cmd.type === 'M') {
              ctx.moveTo(cmd.x, cmd.y);
          } else if (cmd.type === 'L') {
              ctx.lineTo(cmd.x, cmd.y);
          } else if (cmd.type === 'C') {
              ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
          } else if (cmd.type === 'Q') {
              ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
          } else if (cmd.type === 'Z') {
              ctx.closePath();
          }
      }

      if (this.fill) {
          ctx.fillStyle = this.fill;
          ctx.fill();
      }

      if (this.stroke) {
          ctx.strokeStyle = this.stroke;
          ctx.lineWidth = this.strokeWidth;
          ctx.stroke();
      }
  };

  /**
   * Convert the Path to a string of path data instructions
   * See http://www.w3.org/TR/SVG/paths.html#PathData
   * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
   * @return {string}
   */
  Path.prototype.toPathData = function(decimalPlaces) {
      decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

      function floatToString(v) {
          if (Math.round(v) === v) {
              return '' + Math.round(v);
          } else {
              return v.toFixed(decimalPlaces);
          }
      }

      function packValues() {
          var arguments$1 = arguments;

          var s = '';
          for (var i = 0; i < arguments.length; i += 1) {
              var v = arguments$1[i];
              if (v >= 0 && i > 0) {
                  s += ' ';
              }

              s += floatToString(v);
          }

          return s;
      }

      var d = '';
      for (var i = 0; i < this.commands.length; i += 1) {
          var cmd = this.commands[i];
          if (cmd.type === 'M') {
              d += 'M' + packValues(cmd.x, cmd.y);
          } else if (cmd.type === 'L') {
              d += 'L' + packValues(cmd.x, cmd.y);
          } else if (cmd.type === 'C') {
              d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
          } else if (cmd.type === 'Q') {
              d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
          } else if (cmd.type === 'Z') {
              d += 'Z';
          }
      }

      return d;
  };

  /**
   * Convert the path to an SVG <path> element, as a string.
   * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
   * @return {string}
   */
  Path.prototype.toSVG = function(decimalPlaces) {
      var svg = '<path d="';
      svg += this.toPathData(decimalPlaces);
      svg += '"';
      if (this.fill && this.fill !== 'black') {
          if (this.fill === null) {
              svg += ' fill="none"';
          } else {
              svg += ' fill="' + this.fill + '"';
          }
      }

      if (this.stroke) {
          svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
      }

      svg += '/>';
      return svg;
  };

  /**
   * Convert the path to a DOM element.
   * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
   * @return {SVGPathElement}
   */
  Path.prototype.toDOMElement = function(decimalPlaces) {
      var temporaryPath = this.toPathData(decimalPlaces);
      var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

      newPath.setAttribute('d', temporaryPath);

      return newPath;
  };

  // Run-time checking of preconditions.

  function fail(message) {
      throw new Error(message);
  }

  // Precondition function that checks if the given predicate is true.
  // If not, it will throw an error.
  function argument(predicate, message) {
      if (!predicate) {
          fail(message);
      }
  }
  var check = { fail: fail, argument: argument, assert: argument };

  // Data types used in the OpenType font file.

  var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
  var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

  /**
   * @exports opentype.decode
   * @class
   */
  var decode = {};
  /**
   * @exports opentype.encode
   * @class
   */
  var encode = {};
  /**
   * @exports opentype.sizeOf
   * @class
   */
  var sizeOf = {};

  // Return a function that always returns the same value.
  function constant(v) {
      return function() {
          return v;
      };
  }

  // OpenType data types //////////////////////////////////////////////////////

  /**
   * Convert an 8-bit unsigned integer to a list of 1 byte.
   * @param {number}
   * @returns {Array}
   */
  encode.BYTE = function(v) {
      check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
      return [v];
  };
  /**
   * @constant
   * @type {number}
   */
  sizeOf.BYTE = constant(1);

  /**
   * Convert a 8-bit signed integer to a list of 1 byte.
   * @param {string}
   * @returns {Array}
   */
  encode.CHAR = function(v) {
      return [v.charCodeAt(0)];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.CHAR = constant(1);

  /**
   * Convert an ASCII string to a list of bytes.
   * @param {string}
   * @returns {Array}
   */
  encode.CHARARRAY = function(v) {
      if (typeof v === 'undefined') {
          v = '';
          console.warn('Undefined CHARARRAY encountered and treated as an empty string. This is probably caused by a missing glyph name.');
      }
      var b = [];
      for (var i = 0; i < v.length; i += 1) {
          b[i] = v.charCodeAt(i);
      }

      return b;
  };

  /**
   * @param {Array}
   * @returns {number}
   */
  sizeOf.CHARARRAY = function(v) {
      if (typeof v === 'undefined') {
          return 0;
      }
      return v.length;
  };

  /**
   * Convert a 16-bit unsigned integer to a list of 2 bytes.
   * @param {number}
   * @returns {Array}
   */
  encode.USHORT = function(v) {
      return [(v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.USHORT = constant(2);

  /**
   * Convert a 16-bit signed integer to a list of 2 bytes.
   * @param {number}
   * @returns {Array}
   */
  encode.SHORT = function(v) {
      // Two's complement
      if (v >= LIMIT16) {
          v = -(2 * LIMIT16 - v);
      }

      return [(v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.SHORT = constant(2);

  /**
   * Convert a 24-bit unsigned integer to a list of 3 bytes.
   * @param {number}
   * @returns {Array}
   */
  encode.UINT24 = function(v) {
      return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.UINT24 = constant(3);

  /**
   * Convert a 32-bit unsigned integer to a list of 4 bytes.
   * @param {number}
   * @returns {Array}
   */
  encode.ULONG = function(v) {
      return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.ULONG = constant(4);

  /**
   * Convert a 32-bit unsigned integer to a list of 4 bytes.
   * @param {number}
   * @returns {Array}
   */
  encode.LONG = function(v) {
      // Two's complement
      if (v >= LIMIT32) {
          v = -(2 * LIMIT32 - v);
      }

      return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.LONG = constant(4);

  encode.FIXED = encode.ULONG;
  sizeOf.FIXED = sizeOf.ULONG;

  encode.FWORD = encode.SHORT;
  sizeOf.FWORD = sizeOf.SHORT;

  encode.UFWORD = encode.USHORT;
  sizeOf.UFWORD = sizeOf.USHORT;

  /**
   * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
   * @param {number}
   * @returns {Array}
   */
  encode.LONGDATETIME = function(v) {
      return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.LONGDATETIME = constant(8);

  /**
   * Convert a 4-char tag to a list of 4 bytes.
   * @param {string}
   * @returns {Array}
   */
  encode.TAG = function(v) {
      check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
      return [v.charCodeAt(0),
              v.charCodeAt(1),
              v.charCodeAt(2),
              v.charCodeAt(3)];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.TAG = constant(4);

  // CFF data types ///////////////////////////////////////////////////////////

  encode.Card8 = encode.BYTE;
  sizeOf.Card8 = sizeOf.BYTE;

  encode.Card16 = encode.USHORT;
  sizeOf.Card16 = sizeOf.USHORT;

  encode.OffSize = encode.BYTE;
  sizeOf.OffSize = sizeOf.BYTE;

  encode.SID = encode.USHORT;
  sizeOf.SID = sizeOf.USHORT;

  // Convert a numeric operand or charstring number to a variable-size list of bytes.
  /**
   * Convert a numeric operand or charstring number to a variable-size list of bytes.
   * @param {number}
   * @returns {Array}
   */
  encode.NUMBER = function(v) {
      if (v >= -107 && v <= 107) {
          return [v + 139];
      } else if (v >= 108 && v <= 1131) {
          v = v - 108;
          return [(v >> 8) + 247, v & 0xFF];
      } else if (v >= -1131 && v <= -108) {
          v = -v - 108;
          return [(v >> 8) + 251, v & 0xFF];
      } else if (v >= -32768 && v <= 32767) {
          return encode.NUMBER16(v);
      } else {
          return encode.NUMBER32(v);
      }
  };

  /**
   * @param {number}
   * @returns {number}
   */
  sizeOf.NUMBER = function(v) {
      return encode.NUMBER(v).length;
  };

  /**
   * Convert a signed number between -32768 and +32767 to a three-byte value.
   * This ensures we always use three bytes, but is not the most compact format.
   * @param {number}
   * @returns {Array}
   */
  encode.NUMBER16 = function(v) {
      return [28, (v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.NUMBER16 = constant(3);

  /**
   * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
   * This is useful if you want to be sure you always use four bytes,
   * at the expense of wasting a few bytes for smaller numbers.
   * @param {number}
   * @returns {Array}
   */
  encode.NUMBER32 = function(v) {
      return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
  };

  /**
   * @constant
   * @type {number}
   */
  sizeOf.NUMBER32 = constant(5);

  /**
   * @param {number}
   * @returns {Array}
   */
  encode.REAL = function(v) {
      var value = v.toString();

      // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
      // This code converts it back to a number without the epsilon.
      var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
      if (m) {
          var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
          value = (Math.round(v * epsilon) / epsilon).toString();
      }

      var nibbles = '';
      for (var i = 0, ii = value.length; i < ii; i += 1) {
          var c = value[i];
          if (c === 'e') {
              nibbles += value[++i] === '-' ? 'c' : 'b';
          } else if (c === '.') {
              nibbles += 'a';
          } else if (c === '-') {
              nibbles += 'e';
          } else {
              nibbles += c;
          }
      }

      nibbles += (nibbles.length & 1) ? 'f' : 'ff';
      var out = [30];
      for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
          out.push(parseInt(nibbles.substr(i$1, 2), 16));
      }

      return out;
  };

  /**
   * @param {number}
   * @returns {number}
   */
  sizeOf.REAL = function(v) {
      return encode.REAL(v).length;
  };

  encode.NAME = encode.CHARARRAY;
  sizeOf.NAME = sizeOf.CHARARRAY;

  encode.STRING = encode.CHARARRAY;
  sizeOf.STRING = sizeOf.CHARARRAY;

  /**
   * @param {DataView} data
   * @param {number} offset
   * @param {number} numBytes
   * @returns {string}
   */
  decode.UTF8 = function(data, offset, numBytes) {
      var codePoints = [];
      var numChars = numBytes;
      for (var j = 0; j < numChars; j++, offset += 1) {
          codePoints[j] = data.getUint8(offset);
      }

      return String.fromCharCode.apply(null, codePoints);
  };

  /**
   * @param {DataView} data
   * @param {number} offset
   * @param {number} numBytes
   * @returns {string}
   */
  decode.UTF16 = function(data, offset, numBytes) {
      var codePoints = [];
      var numChars = numBytes / 2;
      for (var j = 0; j < numChars; j++, offset += 2) {
          codePoints[j] = data.getUint16(offset);
      }

      return String.fromCharCode.apply(null, codePoints);
  };

  /**
   * Convert a JavaScript string to UTF16-BE.
   * @param {string}
   * @returns {Array}
   */
  encode.UTF16 = function(v) {
      var b = [];
      for (var i = 0; i < v.length; i += 1) {
          var codepoint = v.charCodeAt(i);
          b[b.length] = (codepoint >> 8) & 0xFF;
          b[b.length] = codepoint & 0xFF;
      }

      return b;
  };

  /**
   * @param {string}
   * @returns {number}
   */
  sizeOf.UTF16 = function(v) {
      return v.length * 2;
  };

  // Data for converting old eight-bit Macintosh encodings to Unicode.
  // This representation is optimized for decoding; encoding is slower
  // and needs more memory. The assumption is that all opentype.js users
  // want to open fonts, but saving a font will be comparatively rare
  // so it can be more expensive. Keyed by IANA character set name.
  //
  // Python script for generating these strings:
  //
  //     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
  //     print(s.encode('utf-8'))
  /**
   * @private
   */
  var eightBitMacEncodings = {
      'x-mac-croatian':  // Python: 'mac_croatian'
      '' +
      '',
      'x-mac-cyrillic':  // Python: 'mac_cyrillic'
      '' +
      '',
      'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
      '' +
      '',
      'x-mac-greek':  // Python: 'mac_greek'
      '' +
      '\u00AD',
      'x-mac-icelandic':  // Python: 'mac_iceland'
      '' +
      '',
      'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
      '' +
      '',
      'x-mac-ce':  // Python: 'mac_latin2'
      '' +
      '',
      macintosh:  // Python: 'mac_roman'
      '' +
      '',
      'x-mac-romanian':  // Python: 'mac_romanian'
      '' +
      '',
      'x-mac-turkish':  // Python: 'mac_turkish'
      '' +
      ''
  };

  /**
   * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
   * string, or 'undefined' if the encoding is unsupported. For example, we do
   * not support Chinese, Japanese or Korean because these would need large
   * mapping tables.
   * @param {DataView} dataView
   * @param {number} offset
   * @param {number} dataLength
   * @param {string} encoding
   * @returns {string}
   */
  decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
      var table = eightBitMacEncodings[encoding];
      if (table === undefined) {
          return undefined;
      }

      var result = '';
      for (var i = 0; i < dataLength; i++) {
          var c = dataView.getUint8(offset + i);
          // In all eight-bit Mac encodings, the characters 0x00..0x7F are
          // mapped to U+0000..U+007F; we only need to look up the others.
          if (c <= 0x7F) {
              result += String.fromCharCode(c);
          } else {
              result += table[c & 0x7F];
          }
      }

      return result;
  };

  // Helper function for encode.MACSTRING. Returns a dictionary for mapping
  // Unicode character codes to their 8-bit MacOS equivalent. This table
  // is not exactly a super cheap data structure, but we do not care because
  // encoding Macintosh strings is only rarely needed in typical applications.
  var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
  var macEncodingCacheKeys;
  var getMacEncodingTable = function (encoding) {
      // Since we use encoding as a cache key for WeakMap, it has to be
      // a String object and not a literal. And at least on NodeJS 2.10.1,
      // WeakMap requires that the same String instance is passed for cache hits.
      if (!macEncodingCacheKeys) {
          macEncodingCacheKeys = {};
          for (var e in eightBitMacEncodings) {
              /*jshint -W053 */  // Suppress "Do not use String as a constructor."
              macEncodingCacheKeys[e] = new String(e);
          }
      }

      var cacheKey = macEncodingCacheKeys[encoding];
      if (cacheKey === undefined) {
          return undefined;
      }

      // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
      // since garbage collection may run at any time, it could also kick in
      // between the calls to cache.has() and cache.get(). In that case,
      // we would return 'undefined' even though we do support the encoding.
      if (macEncodingTableCache) {
          var cachedTable = macEncodingTableCache.get(cacheKey);
          if (cachedTable !== undefined) {
              return cachedTable;
          }
      }

      var decodingTable = eightBitMacEncodings[encoding];
      if (decodingTable === undefined) {
          return undefined;
      }

      var encodingTable = {};
      for (var i = 0; i < decodingTable.length; i++) {
          encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
      }

      if (macEncodingTableCache) {
          macEncodingTableCache.set(cacheKey, encodingTable);
      }

      return encodingTable;
  };

  /**
   * Encodes an old-style Macintosh string. Returns a byte array upon success.
   * If the requested encoding is unsupported, or if the input string contains
   * a character that cannot be expressed in the encoding, the function returns
   * 'undefined'.
   * @param {string} str
   * @param {string} encoding
   * @returns {Array}
   */
  encode.MACSTRING = function(str, encoding) {
      var table = getMacEncodingTable(encoding);
      if (table === undefined) {
          return undefined;
      }

      var result = [];
      for (var i = 0; i < str.length; i++) {
          var c = str.charCodeAt(i);

          // In all eight-bit Mac encodings, the characters 0x00..0x7F are
          // mapped to U+0000..U+007F; we only need to look up the others.
          if (c >= 0x80) {
              c = table[c];
              if (c === undefined) {
                  // str contains a Unicode character that cannot be encoded
                  // in the requested encoding.
                  return undefined;
              }
          }
          result[i] = c;
          // result.push(c);
      }

      return result;
  };

  /**
   * @param {string} str
   * @param {string} encoding
   * @returns {number}
   */
  sizeOf.MACSTRING = function(str, encoding) {
      var b = encode.MACSTRING(str, encoding);
      if (b !== undefined) {
          return b.length;
      } else {
          return 0;
      }
  };

  // Helper for encode.VARDELTAS
  function isByteEncodable(value) {
      return value >= -128 && value <= 127;
  }

  // Helper for encode.VARDELTAS
  function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
      var runLength = 0;
      var numDeltas = deltas.length;
      while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
          ++pos;
          ++runLength;
      }
      result.push(0x80 | (runLength - 1));
      return pos;
  }

  // Helper for encode.VARDELTAS
  function encodeVarDeltaRunAsBytes(deltas, offset, result) {
      var runLength = 0;
      var numDeltas = deltas.length;
      var pos = offset;
      while (pos < numDeltas && runLength < 64) {
          var value = deltas[pos];
          if (!isByteEncodable(value)) {
              break;
          }

          // Within a byte-encoded run of deltas, a single zero is best
          // stored literally as 0x00 value. However, if we have two or
          // more zeroes in a sequence, it is better to start a new run.
          // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
          // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
          // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
          // when starting a new run.
          if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
              break;
          }

          ++pos;
          ++runLength;
      }
      result.push(runLength - 1);
      for (var i = offset; i < pos; ++i) {
          result.push((deltas[i] + 256) & 0xff);
      }
      return pos;
  }

  // Helper for encode.VARDELTAS
  function encodeVarDeltaRunAsWords(deltas, offset, result) {
      var runLength = 0;
      var numDeltas = deltas.length;
      var pos = offset;
      while (pos < numDeltas && runLength < 64) {
          var value = deltas[pos];

          // Within a word-encoded run of deltas, it is easiest to start
          // a new run (with a different encoding) whenever we encounter
          // a zero value. For example, the sequence [0x6666, 0, 0x7777]
          // needs 7 bytes when storing the zero inside the current run
          // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
          // new run (40 66 66 80 40 77 77).
          if (value === 0) {
              break;
          }

          // Within a word-encoded run of deltas, a single value in the
          // range (-128..127) should be encoded within the current run
          // because it is more compact. For example, the sequence
          // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
          // literally (42 66 66 00 02 77 77), but 8 bytes when starting
          // a new run (40 66 66 00 02 40 77 77).
          if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
              break;
          }

          ++pos;
          ++runLength;
      }
      result.push(0x40 | (runLength - 1));
      for (var i = offset; i < pos; ++i) {
          var val = deltas[i];
          result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
      }
      return pos;
  }

  /**
   * Encode a list of variation adjustment deltas.
   *
   * Variation adjustment deltas are used in gvar and cvar tables.
   * They indicate how points (in gvar) or values (in cvar) get adjusted
   * when generating instances of variation fonts.
   *
   * @see https://www.microsoft.com/typography/otspec/gvar.htm
   * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
   * @param {Array}
   * @return {Array}
   */
  encode.VARDELTAS = function(deltas) {
      var pos = 0;
      var result = [];
      while (pos < deltas.length) {
          var value = deltas[pos];
          if (value === 0) {
              pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
          } else if (value >= -128 && value <= 127) {
              pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
          } else {
              pos = encodeVarDeltaRunAsWords(deltas, pos, result);
          }
      }
      return result;
  };

  // Convert a list of values to a CFF INDEX structure.
  // The values should be objects containing name / type / value.
  /**
   * @param {Array} l
   * @returns {Array}
   */
  encode.INDEX = function(l) {
      //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
      //    i, v;
      // Because we have to know which data type to use to encode the offsets,
      // we have to go through the values twice: once to encode the data and
      // calculate the offsets, then again to encode the offsets using the fitting data type.
      var offset = 1; // First offset is always 1.
      var offsets = [offset];
      var data = [];
      for (var i = 0; i < l.length; i += 1) {
          var v = encode.OBJECT(l[i]);
          Array.prototype.push.apply(data, v);
          offset += v.length;
          offsets.push(offset);
      }

      if (data.length === 0) {
          return [0, 0];
      }

      var encodedOffsets = [];
      var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
      var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
      for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
          var encodedOffset = offsetEncoder(offsets[i$1]);
          Array.prototype.push.apply(encodedOffsets, encodedOffset);
      }

      return Array.prototype.concat(encode.Card16(l.length),
                             encode.OffSize(offSize),
                             encodedOffsets,
                             data);
  };

  /**
   * @param {Array}
   * @returns {number}
   */
  sizeOf.INDEX = function(v) {
      return encode.INDEX(v).length;
  };

  /**
   * Convert an object to a CFF DICT structure.
   * The keys should be numeric.
   * The values should be objects containing name / type / value.
   * @param {Object} m
   * @returns {Array}
   */
  encode.DICT = function(m) {
      var d = [];
      var keys = Object.keys(m);
      var length = keys.length;

      for (var i = 0; i < length; i += 1) {
          // Object.keys() return string keys, but our keys are always numeric.
          var k = parseInt(keys[i], 0);
          var v = m[k];
          // Value comes before the key.
          d = d.concat(encode.OPERAND(v.value, v.type));
          d = d.concat(encode.OPERATOR(k));
      }

      return d;
  };

  /**
   * @param {Object}
   * @returns {number}
   */
  sizeOf.DICT = function(m) {
      return encode.DICT(m).length;
  };

  /**
   * @param {number}
   * @returns {Array}
   */
  encode.OPERATOR = function(v) {
      if (v < 1200) {
          return [v];
      } else {
          return [12, v - 1200];
      }
  };

  /**
   * @param {Array} v
   * @param {string}
   * @returns {Array}
   */
  encode.OPERAND = function(v, type) {
      var d = [];
      if (Array.isArray(type)) {
          for (var i = 0; i < type.length; i += 1) {
              check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
              d = d.concat(encode.OPERAND(v[i], type[i]));
          }
      } else {
          if (type === 'SID') {
              d = d.concat(encode.NUMBER(v));
          } else if (type === 'offset') {
              // We make it easy for ourselves and always encode offsets as
              // 4 bytes. This makes offset calculation for the top dict easier.
              d = d.concat(encode.NUMBER32(v));
          } else if (type === 'number') {
              d = d.concat(encode.NUMBER(v));
          } else if (type === 'real') {
              d = d.concat(encode.REAL(v));
          } else {
              throw new Error('Unknown operand type ' + type);
              // FIXME Add support for booleans
          }
      }

      return d;
  };

  encode.OP = encode.BYTE;
  sizeOf.OP = sizeOf.BYTE;

  // memoize charstring encoding using WeakMap if available
  var wmm = typeof WeakMap === 'function' && new WeakMap();

  /**
   * Convert a list of CharString operations to bytes.
   * @param {Array}
   * @returns {Array}
   */
  encode.CHARSTRING = function(ops) {
      // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
      if (wmm) {
          var cachedValue = wmm.get(ops);
          if (cachedValue !== undefined) {
              return cachedValue;
          }
      }

      var d = [];
      var length = ops.length;

      for (var i = 0; i < length; i += 1) {
          var op = ops[i];
          d = d.concat(encode[op.type](op.value));
      }

      if (wmm) {
          wmm.set(ops, d);
      }

      return d;
  };

  /**
   * @param {Array}
   * @returns {number}
   */
  sizeOf.CHARSTRING = function(ops) {
      return encode.CHARSTRING(ops).length;
  };

  // Utility functions ////////////////////////////////////////////////////////

  /**
   * Convert an object containing name / type / value to bytes.
   * @param {Object}
   * @returns {Array}
   */
  encode.OBJECT = function(v) {
      var encodingFunction = encode[v.type];
      check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
      return encodingFunction(v.value);
  };

  /**
   * @param {Object}
   * @returns {number}
   */
  sizeOf.OBJECT = function(v) {
      var sizeOfFunction = sizeOf[v.type];
      check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
      return sizeOfFunction(v.value);
  };

  /**
   * Convert a table object to bytes.
   * A table contains a list of fields containing the metadata (name, type and default value).
   * The table itself has the field values set as attributes.
   * @param {opentype.Table}
   * @returns {Array}
   */
  encode.TABLE = function(table) {
      var d = [];
      var length = table.fields.length;
      var subtables = [];
      var subtableOffsets = [];

      for (var i = 0; i < length; i += 1) {
          var field = table.fields[i];
          var encodingFunction = encode[field.type];
          check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
          var value = table[field.name];
          if (value === undefined) {
              value = field.value;
          }

          var bytes = encodingFunction(value);

          if (field.type === 'TABLE') {
              subtableOffsets.push(d.length);
              d = d.concat([0, 0]);
              subtables.push(bytes);
          } else {
              d = d.concat(bytes);
          }
      }

      for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
          var o = subtableOffsets[i$1];
          var offset = d.length;
          check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
          d[o] = offset >> 8;
          d[o + 1] = offset & 0xff;
          d = d.concat(subtables[i$1]);
      }

      return d;
  };

  /**
   * @param {opentype.Table}
   * @returns {number}
   */
  sizeOf.TABLE = function(table) {
      var numBytes = 0;
      var length = table.fields.length;

      for (var i = 0; i < length; i += 1) {
          var field = table.fields[i];
          var sizeOfFunction = sizeOf[field.type];
          check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
          var value = table[field.name];
          if (value === undefined) {
              value = field.value;
          }

          numBytes += sizeOfFunction(value);

          // Subtables take 2 more bytes for offsets.
          if (field.type === 'TABLE') {
              numBytes += 2;
          }
      }

      return numBytes;
  };

  encode.RECORD = encode.TABLE;
  sizeOf.RECORD = sizeOf.TABLE;

  // Merge in a list of bytes.
  encode.LITERAL = function(v) {
      return v;
  };

  sizeOf.LITERAL = function(v) {
      return v.length;
  };

  // Table metadata

  /**
   * @exports opentype.Table
   * @class
   * @param {string} tableName
   * @param {Array} fields
   * @param {Object} options
   * @constructor
   */
  function Table(tableName, fields, options) {
      // For coverage tables with coverage format 2, we do not want to add the coverage data directly to the table object,
      // as this will result in wrong encoding order of the coverage data on serialization to bytes.
      // The fallback of using the field values directly when not present on the table is handled in types.encode.TABLE() already.
      if (fields.length && (fields[0].name !== 'coverageFormat' || fields[0].value === 1)) {
          for (var i = 0; i < fields.length; i += 1) {
              var field = fields[i];
              this[field.name] = field.value;
          }
      }

      this.tableName = tableName;
      this.fields = fields;
      if (options) {
          var optionKeys = Object.keys(options);
          for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
              var k = optionKeys[i$1];
              var v = options[k];
              if (this[k] !== undefined) {
                  this[k] = v;
              }
          }
      }
  }

  /**
   * Encodes the table and returns an array of bytes
   * @return {Array}
   */
  Table.prototype.encode = function() {
      return encode.TABLE(this);
  };

  /**
   * Get the size of the table.
   * @return {number}
   */
  Table.prototype.sizeOf = function() {
      return sizeOf.TABLE(this);
  };

  /**
   * @private
   */
  function ushortList(itemName, list, count) {
      if (count === undefined) {
          count = list.length;
      }
      var fields = new Array(list.length + 1);
      fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
      for (var i = 0; i < list.length; i++) {
          fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
      }
      return fields;
  }

  /**
   * @private
   */
  function tableList(itemName, records, itemCallback) {
      var count = records.length;
      var fields = new Array(count + 1);
      fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
      for (var i = 0; i < count; i++) {
          fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
      }
      return fields;
  }

  /**
   * @private
   */
  function recordList(itemName, records, itemCallback) {
      var count = records.length;
      var fields = [];
      fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
      for (var i = 0; i < count; i++) {
          fields = fields.concat(itemCallback(records[i], i));
      }
      return fields;
  }

  // Common Layout Tables

  /**
   * @exports opentype.Coverage
   * @class
   * @param {opentype.Table}
   * @constructor
   * @extends opentype.Table
   */
  function Coverage(coverageTable) {
      if (coverageTable.format === 1) {
          Table.call(this, 'coverageTable',
              [{name: 'coverageFormat', type: 'USHORT', value: 1}]
              .concat(ushortList('glyph', coverageTable.glyphs))
          );
      } else if (coverageTable.format === 2) {
          Table.call(this, 'coverageTable',
              [{name: 'coverageFormat', type: 'USHORT', value: 2}]
              .concat(recordList('rangeRecord', coverageTable.ranges, function(RangeRecord) {
                  return [
                      {name: 'startGlyphID', type: 'USHORT', value: RangeRecord.start},
                      {name: 'endGlyphID', type: 'USHORT', value: RangeRecord.end},
                      {name: 'startCoverageIndex', type: 'USHORT', value: RangeRecord.index} ];
              }))
          );
      } else {
          check.assert(false, 'Coverage format must be 1 or 2.');
      }
  }
  Coverage.prototype = Object.create(Table.prototype);
  Coverage.prototype.constructor = Coverage;

  function ScriptList(scriptListTable) {
      Table.call(this, 'scriptListTable',
          recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
              var script = scriptRecord.script;
              var defaultLangSys = script.defaultLangSys;
              check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
              return [
                  {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                  {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                      {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                          {name: 'lookupOrder', type: 'USHORT', value: 0},
                          {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                          .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                      ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                          var langSys = langSysRecord.langSys;
                          return [
                              {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                              {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                                  {name: 'lookupOrder', type: 'USHORT', value: 0},
                                  {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                                  ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                          ];
                      })))}
              ];
          })
      );
  }
  ScriptList.prototype = Object.create(Table.prototype);
  ScriptList.prototype.constructor = ScriptList;

  /**
   * @exports opentype.FeatureList
   * @class
   * @param {opentype.Table}
   * @constructor
   * @extends opentype.Table
   */
  function FeatureList(featureListTable) {
      Table.call(this, 'featureListTable',
          recordList('featureRecord', featureListTable, function(featureRecord, i) {
              var feature = featureRecord.feature;
              return [
                  {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                  {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                      {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
              ];
          })
      );
  }
  FeatureList.prototype = Object.create(Table.prototype);
  FeatureList.prototype.constructor = FeatureList;

  /**
   * @exports opentype.LookupList
   * @class
   * @param {opentype.Table}
   * @param {Object}
   * @constructor
   * @extends opentype.Table
   */
  function LookupList(lookupListTable, subtableMakers) {
      Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
          var subtableCallback = subtableMakers[lookupTable.lookupType];
          check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
          return new Table('lookupTable', [
              {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
              {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
          ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
      }));
  }
  LookupList.prototype = Object.create(Table.prototype);
  LookupList.prototype.constructor = LookupList;

  // Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
  // Don't use offsets inside Records (probable bug), only in Tables.
  var table$1 = {
      Table: Table,
      Record: Table,
      Coverage: Coverage,
      ScriptList: ScriptList,
      FeatureList: FeatureList,
      LookupList: LookupList,
      ushortList: ushortList,
      tableList: tableList,
      recordList: recordList,
  };

  // Parsing utility functions

  // Retrieve an unsigned byte from the DataView.
  function getByte(dataView, offset) {
      return dataView.getUint8(offset);
  }

  // Retrieve an unsigned 16-bit short from the DataView.
  // The value is stored in big endian.
  function getUShort(dataView, offset) {
      return dataView.getUint16(offset, false);
  }

  // Retrieve a signed 16-bit short from the DataView.
  // The value is stored in big endian.
  function getShort(dataView, offset) {
      return dataView.getInt16(offset, false);
  }

  // Retrieve an unsigned 32-bit long from the DataView.
  // The value is stored in big endian.
  function getULong(dataView, offset) {
      return dataView.getUint32(offset, false);
  }

  // Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
  // The value is stored in big endian.
  function getFixed(dataView, offset) {
      var decimal = dataView.getInt16(offset, false);
      var fraction = dataView.getUint16(offset + 2, false);
      return decimal + fraction / 65535;
  }

  // Retrieve a 4-character tag from the DataView.
  // Tags are used to identify tables.
  function getTag(dataView, offset) {
      var tag = '';
      for (var i = offset; i < offset + 4; i += 1) {
          tag += String.fromCharCode(dataView.getInt8(i));
      }

      return tag;
  }

  // Retrieve an offset from the DataView.
  // Offsets are 1 to 4 bytes in length, depending on the offSize argument.
  function getOffset(dataView, offset, offSize) {
      var v = 0;
      for (var i = 0; i < offSize; i += 1) {
          v <<= 8;
          v += dataView.getUint8(offset + i);
      }

      return v;
  }

  // Retrieve a number of bytes from start offset to the end offset from the DataView.
  function getBytes(dataView, startOffset, endOffset) {
      var bytes = [];
      for (var i = startOffset; i < endOffset; i += 1) {
          bytes.push(dataView.getUint8(i));
      }

      return bytes;
  }

  // Convert the list of bytes to a string.
  function bytesToString(bytes) {
      var s = '';
      for (var i = 0; i < bytes.length; i += 1) {
          s += String.fromCharCode(bytes[i]);
      }

      return s;
  }

  var typeOffsets = {
      byte: 1,
      uShort: 2,
      short: 2,
      uLong: 4,
      fixed: 4,
      longDateTime: 8,
      tag: 4
  };

  // A stateful parser that changes the offset whenever a value is retrieved.
  // The data is a DataView.
  function Parser(data, offset) {
      this.data = data;
      this.offset = offset;
      this.relativeOffset = 0;
  }

  Parser.prototype.parseByte = function() {
      var v = this.data.getUint8(this.offset + this.relativeOffset);
      this.relativeOffset += 1;
      return v;
  };

  Parser.prototype.parseChar = function() {
      var v = this.data.getInt8(this.offset + this.relativeOffset);
      this.relativeOffset += 1;
      return v;
  };

  Parser.prototype.parseCard8 = Parser.prototype.parseByte;

  Parser.prototype.parseUShort = function() {
      var v = this.data.getUint16(this.offset + this.relativeOffset);
      this.relativeOffset += 2;
      return v;
  };

  Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
  Parser.prototype.parseSID = Parser.prototype.parseUShort;
  Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

  Parser.prototype.parseShort = function() {
      var v = this.data.getInt16(this.offset + this.relativeOffset);
      this.relativeOffset += 2;
      return v;
  };

  Parser.prototype.parseF2Dot14 = function() {
      var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
      this.relativeOffset += 2;
      return v;
  };

  Parser.prototype.parseULong = function() {
      var v = getULong(this.data, this.offset + this.relativeOffset);
      this.relativeOffset += 4;
      return v;
  };

  Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

  Parser.prototype.parseFixed = function() {
      var v = getFixed(this.data, this.offset + this.relativeOffset);
      this.relativeOffset += 4;
      return v;
  };

  Parser.prototype.parseString = function(length) {
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      var string = '';
      this.relativeOffset += length;
      for (var i = 0; i < length; i++) {
          string += String.fromCharCode(dataView.getUint8(offset + i));
      }

      return string;
  };

  Parser.prototype.parseTag = function() {
      return this.parseString(4);
  };

  // LONGDATETIME is a 64-bit integer.
  // JavaScript and unix timestamps traditionally use 32 bits, so we
  // only take the last 32 bits.
  // + Since until 2038 those bits will be filled by zeros we can ignore them.
  Parser.prototype.parseLongDateTime = function() {
      var v = getULong(this.data, this.offset + this.relativeOffset + 4);
      // Subtract seconds between 01/01/1904 and 01/01/1970
      // to convert Apple Mac timestamp to Standard Unix timestamp
      v -= 2082844800;
      this.relativeOffset += 8;
      return v;
  };

  Parser.prototype.parseVersion = function(minorBase) {
      var major = getUShort(this.data, this.offset + this.relativeOffset);

      // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
      // Default returns the correct number if minor = 0xN000 where N is 0-9
      // Set minorBase to 1 for tables that use minor = N where N is 0-9
      var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
      this.relativeOffset += 4;
      if (minorBase === undefined) { minorBase = 0x1000; }
      return major + minor / minorBase / 10;
  };

  Parser.prototype.skip = function(type, amount) {
      if (amount === undefined) {
          amount = 1;
      }

      this.relativeOffset += typeOffsets[type] * amount;
  };

  ///// Parsing lists and records ///////////////////////////////

  // Parse a list of 32 bit unsigned integers.
  Parser.prototype.parseULongList = function(count) {
      if (count === undefined) { count = this.parseULong(); }
      var offsets = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0; i < count; i++) {
          offsets[i] = dataView.getUint32(offset);
          offset += 4;
      }

      this.relativeOffset += count * 4;
      return offsets;
  };

  // Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
  // or provided as an argument.
  Parser.prototype.parseOffset16List =
  Parser.prototype.parseUShortList = function(count) {
      if (count === undefined) { count = this.parseUShort(); }
      var offsets = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0; i < count; i++) {
          offsets[i] = dataView.getUint16(offset);
          offset += 2;
      }

      this.relativeOffset += count * 2;
      return offsets;
  };

  // Parses a list of 16 bit signed integers.
  Parser.prototype.parseShortList = function(count) {
      var list = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0; i < count; i++) {
          list[i] = dataView.getInt16(offset);
          offset += 2;
      }

      this.relativeOffset += count * 2;
      return list;
  };

  // Parses a list of bytes.
  Parser.prototype.parseByteList = function(count) {
      var list = new Array(count);
      var dataView = this.data;
      var offset = this.offset + this.relativeOffset;
      for (var i = 0; i < count; i++) {
          list[i] = dataView.getUint8(offset++);
      }

      this.relativeOffset += count;
      return list;
  };

  /**
   * Parse a list of items.
   * Record count is optional, if omitted it is read from the stream.
   * itemCallback is one of the Parser methods.
   */
  Parser.prototype.parseList = function(count, itemCallback) {
      if (!itemCallback) {
          itemCallback = count;
          count = this.parseUShort();
      }
      var list = new Array(count);
      for (var i = 0; i < count; i++) {
          list[i] = itemCallback.call(this);
      }
      return list;
  };

  Parser.prototype.parseList32 = function(count, itemCallback) {
      if (!itemCallback) {
          itemCallback = count;
          count = this.parseULong();
      }
      var list = new Array(count);
      for (var i = 0; i < count; i++) {
          list[i] = itemCallback.call(this);
      }
      return list;
  };

  /**
   * Parse a list of records.
   * Record count is optional, if omitted it is read from the stream.
   * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
   */
  Parser.prototype.parseRecordList = function(count, recordDescription) {
      // If the count argument is absent, read it in the stream.
      if (!recordDescription) {
          recordDescription = count;
          count = this.parseUShort();
      }
      var records = new Array(count);
      var fields = Object.keys(recordDescription);
      for (var i = 0; i < count; i++) {
          var rec = {};
          for (var j = 0; j < fields.length; j++) {
              var fieldName = fields[j];
              var fieldType = recordDescription[fieldName];
              rec[fieldName] = fieldType.call(this);
          }
          records[i] = rec;
      }
      return records;
  };

  Parser.prototype.parseRecordList32 = function(count, recordDescription) {
      // If the count argument is absent, read it in the stream.
      if (!recordDescription) {
          recordDescription = count;
          count = this.parseULong();
      }
      var records = new Array(count);
      var fields = Object.keys(recordDescription);
      for (var i = 0; i < count; i++) {
          var rec = {};
          for (var j = 0; j < fields.length; j++) {
              var fieldName = fields[j];
              var fieldType = recordDescription[fieldName];
              rec[fieldName] = fieldType.call(this);
          }
          records[i] = rec;
      }
      return records;
  };

  // Parse a data structure into an object
  // Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
  Parser.prototype.parseStruct = function(description) {
      if (typeof description === 'function') {
          return description.call(this);
      } else {
          var fields = Object.keys(description);
          var struct = {};
          for (var j = 0; j < fields.length; j++) {
              var fieldName = fields[j];
              var fieldType = description[fieldName];
              struct[fieldName] = fieldType.call(this);
          }
          return struct;
      }
  };

  /**
   * Parse a GPOS valueRecord
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
   * valueFormat is optional, if omitted it is read from the stream.
   */
  Parser.prototype.parseValueRecord = function(valueFormat) {
      if (valueFormat === undefined) {
          valueFormat = this.parseUShort();
      }
      if (valueFormat === 0) {
          // valueFormat2 in kerning pairs is most often 0
          // in this case return undefined instead of an empty object, to save space
          return;
      }
      var valueRecord = {};

      if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
      if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
      if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
      if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

      // Device table (non-variable font) / VariationIndex table (variable font) not supported
      // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
      if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
      if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
      if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
      if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

      return valueRecord;
  };

  /**
   * Parse a list of GPOS valueRecords
   * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
   * valueFormat and valueCount are read from the stream.
   */
  Parser.prototype.parseValueRecordList = function() {
      var valueFormat = this.parseUShort();
      var valueCount = this.parseUShort();
      var values = new Array(valueCount);
      for (var i = 0; i < valueCount; i++) {
          values[i] = this.parseValueRecord(valueFormat);
      }
      return values;
  };

  Parser.prototype.parsePointer = function(description) {
      var structOffset = this.parseOffset16();
      if (structOffset > 0) {
          // NULL offset => return undefined
          return new Parser(this.data, this.offset + structOffset).parseStruct(description);
      }
      return undefined;
  };

  Parser.prototype.parsePointer32 = function(description) {
      var structOffset = this.parseOffset32();
      if (structOffset > 0) {
          // NULL offset => return undefined
          return new Parser(this.data, this.offset + structOffset).parseStruct(description);
      }
      return undefined;
  };

  /**
   * Parse a list of offsets to lists of 16-bit integers,
   * or a list of offsets to lists of offsets to any kind of items.
   * If itemCallback is not provided, a list of list of UShort is assumed.
   * If provided, itemCallback is called on each item and must parse the item.
   * See examples in tables/gsub.js
   */
  Parser.prototype.parseListOfLists = function(itemCallback) {
      var offsets = this.parseOffset16List();
      var count = offsets.length;
      var relativeOffset = this.relativeOffset;
      var list = new Array(count);
      for (var i = 0; i < count; i++) {
          var start = offsets[i];
          if (start === 0) {
              // NULL offset
              // Add i as owned property to list. Convenient with assert.
              list[i] = undefined;
              continue;
          }
          this.relativeOffset = start;
          if (itemCallback) {
              var subOffsets = this.parseOffset16List();
              var subList = new Array(subOffsets.length);
              for (var j = 0; j < subOffsets.length; j++) {
                  this.relativeOffset = start + subOffsets[j];
                  subList[j] = itemCallback.call(this);
              }
              list[i] = subList;
          } else {
              list[i] = this.parseUShortList();
          }
      }
      this.relativeOffset = relativeOffset;
      return list;
  };

  ///// Complex tables parsing //////////////////////////////////

  // Parse a coverage table in a GSUB, GPOS or GDEF table.
  // https://www.microsoft.com/typography/OTSPEC/chapter2.htm
  // parser.offset must point to the start of the table containing the coverage.
  Parser.prototype.parseCoverage = function() {
      var startOffset = this.offset + this.relativeOffset;
      var format = this.parseUShort();
      var count = this.parseUShort();
      if (format === 1) {
          return {
              format: 1,
              glyphs: this.parseUShortList(count)
          };
      } else if (format === 2) {
          var ranges = new Array(count);
          for (var i = 0; i < count; i++) {
              ranges[i] = {
                  start: this.parseUShort(),
                  end: this.parseUShort(),
                  index: this.parseUShort()
              };
          }
          return {
              format: 2,
              ranges: ranges
          };
      }
      throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
  };

  // Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
  // https://www.microsoft.com/typography/OTSPEC/chapter2.htm
  Parser.prototype.parseClassDef = function() {
      var startOffset = this.offset + this.relativeOffset;
      var format = this.parseUShort();
      if (format === 1) {
          return {
              format: 1,
              startGlyph: this.parseUShort(),
              classes: this.parseUShortList()
          };
      } else if (format === 2) {
          return {
              format: 2,
              ranges: this.parseRecordList({
                  start: Parser.uShort,
                  end: Parser.uShort,
                  classId: Parser.uShort
              })
          };
      }
      throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
  };

  ///// Static methods ///////////////////////////////////
  // These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

  Parser.list = function(count, itemCallback) {
      return function() {
          return this.parseList(count, itemCallback);
      };
  };

  Parser.list32 = function(count, itemCallback) {
      return function() {
          return this.parseList32(count, itemCallback);
      };
  };

  Parser.recordList = function(count, recordDescription) {
      return function() {
          return this.parseRecordList(count, recordDescription);
      };
  };

  Parser.recordList32 = function(count, recordDescription) {
      return function() {
          return this.parseRecordList32(count, recordDescription);
      };
  };

  Parser.pointer = function(description) {
      return function() {
          return this.parsePointer(description);
      };
  };

  Parser.pointer32 = function(description) {
      return function() {
          return this.parsePointer32(description);
      };
  };

  Parser.tag = Parser.prototype.parseTag;
  Parser.byte = Parser.prototype.parseByte;
  Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
  Parser.uShortList = Parser.prototype.parseUShortList;
  Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
  Parser.uLongList = Parser.prototype.parseULongList;
  Parser.struct = Parser.prototype.parseStruct;
  Parser.coverage = Parser.prototype.parseCoverage;
  Parser.classDef = Parser.prototype.parseClassDef;

  ///// Script, Feature, Lookup lists ///////////////////////////////////////////////
  // https://www.microsoft.com/typography/OTSPEC/chapter2.htm

  var langSysTable = {
      reserved: Parser.uShort,
      reqFeatureIndex: Parser.uShort,
      featureIndexes: Parser.uShortList
  };

  Parser.prototype.parseScriptList = function() {
      return this.parsePointer(Parser.recordList({
          tag: Parser.tag,
          script: Parser.pointer({
              defaultLangSys: Parser.pointer(langSysTable),
              langSysRecords: Parser.recordList({
                  tag: Parser.tag,
                  langSys: Parser.pointer(langSysTable)
              })
          })
      })) || [];
  };

  Parser.prototype.parseFeatureList = function() {
      return this.parsePointer(Parser.recordList({
          tag: Parser.tag,
          feature: Parser.pointer({
              featureParams: Parser.offset16,
              lookupListIndexes: Parser.uShortList
          })
      })) || [];
  };

  Parser.prototype.parseLookupList = function(lookupTableParsers) {
      return this.parsePointer(Parser.list(Parser.pointer(function() {
          var lookupType = this.parseUShort();
          check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
          var lookupFlag = this.parseUShort();
          var useMarkFilteringSet = lookupFlag & 0x10;
          return {
              lookupType: lookupType,
              lookupFlag: lookupFlag,
              subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
              markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
          };
      }))) || [];
  };

  Parser.prototype.parseFeatureVariationsList = function() {
      return this.parsePointer32(function() {
          var majorVersion = this.parseUShort();
          var minorVersion = this.parseUShort();
          check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
          var featureVariations = this.parseRecordList32({
              conditionSetOffset: Parser.offset32,
              featureTableSubstitutionOffset: Parser.offset32
          });
          return featureVariations;
      }) || [];
  };

  var parse$2 = {
      getByte: getByte,
      getCard8: getByte,
      getUShort: getUShort,
      getCard16: getUShort,
      getShort: getShort,
      getULong: getULong,
      getFixed: getFixed,
      getTag: getTag,
      getOffset: getOffset,
      getBytes: getBytes,
      bytesToString: bytesToString,
      Parser: Parser,
  };

  // The `cmap` table stores the mappings from characters to glyphs.

  function parseCmapTableFormat12(cmap, p) {
      //Skip reserved.
      p.parseUShort();

      // Length in bytes of the sub-tables.
      cmap.length = p.parseULong();
      cmap.language = p.parseULong();

      var groupCount;
      cmap.groupCount = groupCount = p.parseULong();
      cmap.glyphIndexMap = {};

      for (var i = 0; i < groupCount; i += 1) {
          var startCharCode = p.parseULong();
          var endCharCode = p.parseULong();
          var startGlyphId = p.parseULong();

          for (var c = startCharCode; c <= endCharCode; c += 1) {
              cmap.glyphIndexMap[c] = startGlyphId;
              startGlyphId++;
          }
      }
  }

  function parseCmapTableFormat4(cmap, p, data, start, offset) {
      // Length in bytes of the sub-tables.
      cmap.length = p.parseUShort();
      cmap.language = p.parseUShort();

      // segCount is stored x 2.
      var segCount;
      cmap.segCount = segCount = p.parseUShort() >> 1;

      // Skip searchRange, entrySelector, rangeShift.
      p.skip('uShort', 3);

      // The "unrolled" mapping from character codes to glyph indices.
      cmap.glyphIndexMap = {};
      var endCountParser = new parse$2.Parser(data, start + offset + 14);
      var startCountParser = new parse$2.Parser(data, start + offset + 16 + segCount * 2);
      var idDeltaParser = new parse$2.Parser(data, start + offset + 16 + segCount * 4);
      var idRangeOffsetParser = new parse$2.Parser(data, start + offset + 16 + segCount * 6);
      var glyphIndexOffset = start + offset + 16 + segCount * 8;
      for (var i = 0; i < segCount - 1; i += 1) {
          var glyphIndex = (void 0);
          var endCount = endCountParser.parseUShort();
          var startCount = startCountParser.parseUShort();
          var idDelta = idDeltaParser.parseShort();
          var idRangeOffset = idRangeOffsetParser.parseUShort();
          for (var c = startCount; c <= endCount; c += 1) {
              if (idRangeOffset !== 0) {
                  // The idRangeOffset is relative to the current position in the idRangeOffset array.
                  // Take the current offset in the idRangeOffset array.
                  glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

                  // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                  glyphIndexOffset += idRangeOffset;

                  // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                  glyphIndexOffset += (c - startCount) * 2;
                  glyphIndex = parse$2.getUShort(data, glyphIndexOffset);
                  if (glyphIndex !== 0) {
                      glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                  }
              } else {
                  glyphIndex = (c + idDelta) & 0xFFFF;
              }

              cmap.glyphIndexMap[c] = glyphIndex;
          }
      }
  }

  // Parse the `cmap` table. This table stores the mappings from characters to glyphs.
  // There are many available formats, but we only support the Windows format 4 and 12.
  // This function returns a `CmapEncoding` object or null if no supported format could be found.
  function parseCmapTable(data, start) {
      var cmap = {};
      cmap.version = parse$2.getUShort(data, start);
      check.argument(cmap.version === 0, 'cmap table version should be 0.');

      // The cmap table can contain many sub-tables, each with their own format.
      // We're only interested in a "platform 0" (Unicode format) and "platform 3" (Windows format) table.
      cmap.numTables = parse$2.getUShort(data, start + 2);
      var offset = -1;
      for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
          var platformId = parse$2.getUShort(data, start + 4 + (i * 8));
          var encodingId = parse$2.getUShort(data, start + 4 + (i * 8) + 2);
          if ((platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) ||
              (platformId === 0 && (encodingId === 0 || encodingId === 1 || encodingId === 2 || encodingId === 3 || encodingId === 4))) {
              offset = parse$2.getULong(data, start + 4 + (i * 8) + 4);
              break;
          }
      }

      if (offset === -1) {
          // There is no cmap table in the font that we support.
          throw new Error('No valid cmap sub-tables found.');
      }

      var p = new parse$2.Parser(data, start + offset);
      cmap.format = p.parseUShort();

      if (cmap.format === 12) {
          parseCmapTableFormat12(cmap, p);
      } else if (cmap.format === 4) {
          parseCmapTableFormat4(cmap, p, data, start, offset);
      } else {
          throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
      }

      return cmap;
  }

  function addSegment(t, code, glyphIndex) {
      t.segments.push({
          end: code,
          start: code,
          delta: -(code - glyphIndex),
          offset: 0,
          glyphIndex: glyphIndex
      });
  }

  function addTerminatorSegment(t) {
      t.segments.push({
          end: 0xFFFF,
          start: 0xFFFF,
          delta: 1,
          offset: 0
      });
  }

  // Make cmap table, format 4 by default, 12 if needed only
  function makeCmapTable(glyphs) {
      // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
      var isPlan0Only = true;
      var i;

      // Check if we need to add cmap format 12 or if format 4 only is fine
      for (i = glyphs.length - 1; i > 0; i -= 1) {
          var g = glyphs.get(i);
          if (g.unicode > 65535) {
              console.log('Adding CMAP format 12 (needed!)');
              isPlan0Only = false;
              break;
          }
      }

      var cmapTable = [
          {name: 'version', type: 'USHORT', value: 0},
          {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

          // CMAP 4 header
          {name: 'platformID', type: 'USHORT', value: 3},
          {name: 'encodingID', type: 'USHORT', value: 1},
          {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
      ];

      if (!isPlan0Only)
          { cmapTable = cmapTable.concat([
              // CMAP 12 header
              {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
              {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
              {name: 'cmap12Offset', type: 'ULONG', value: 0}
          ]); }

      cmapTable = cmapTable.concat([
          // CMAP 4 Subtable
          {name: 'format', type: 'USHORT', value: 4},
          {name: 'cmap4Length', type: 'USHORT', value: 0},
          {name: 'language', type: 'USHORT', value: 0},
          {name: 'segCountX2', type: 'USHORT', value: 0},
          {name: 'searchRange', type: 'USHORT', value: 0},
          {name: 'entrySelector', type: 'USHORT', value: 0},
          {name: 'rangeShift', type: 'USHORT', value: 0}
      ]);

      var t = new table$1.Table('cmap', cmapTable);

      t.segments = [];
      for (i = 0; i < glyphs.length; i += 1) {
          var glyph = glyphs.get(i);
          for (var j = 0; j < glyph.unicodes.length; j += 1) {
              addSegment(t, glyph.unicodes[j], i);
          }

          t.segments = t.segments.sort(function (a, b) {
              return a.start - b.start;
          });
      }

      addTerminatorSegment(t);

      var segCount = t.segments.length;
      var segCountToRemove = 0;

      // CMAP 4
      // Set up parallel segment arrays.
      var endCounts = [];
      var startCounts = [];
      var idDeltas = [];
      var idRangeOffsets = [];
      var glyphIds = [];

      // CMAP 12
      var cmap12Groups = [];

      // Reminder this loop is not following the specification at 100%
      // The specification -> find suites of characters and make a group
      // Here we're doing one group for each letter
      // Doing as the spec can save 8 times (or more) space
      for (i = 0; i < segCount; i += 1) {
          var segment = t.segments[i];

          // CMAP 4
          if (segment.end <= 65535 && segment.start <= 65535) {
              endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
              startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
              idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
              idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
              if (segment.glyphId !== undefined) {
                  glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
              }
          } else {
              // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
              segCountToRemove += 1;
          }

          // CMAP 12
          // Skip Terminator Segment
          if (!isPlan0Only && segment.glyphIndex !== undefined) {
              cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
              cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
              cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
          }
      }

      // CMAP 4 Subtable
      t.segCountX2 = (segCount - segCountToRemove) * 2;
      t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
      t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
      t.rangeShift = t.segCountX2 - t.searchRange;

      t.fields = t.fields.concat(endCounts);
      t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
      t.fields = t.fields.concat(startCounts);
      t.fields = t.fields.concat(idDeltas);
      t.fields = t.fields.concat(idRangeOffsets);
      t.fields = t.fields.concat(glyphIds);

      t.cmap4Length = 14 + // Subtable header
          endCounts.length * 2 +
          2 + // reservedPad
          startCounts.length * 2 +
          idDeltas.length * 2 +
          idRangeOffsets.length * 2 +
          glyphIds.length * 2;

      if (!isPlan0Only) {
          // CMAP 12 Subtable
          var cmap12Length = 16 + // Subtable header
              cmap12Groups.length * 4;

          t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
          t.fields = t.fields.concat([
              {name: 'cmap12Format', type: 'USHORT', value: 12},
              {name: 'cmap12Reserved', type: 'USHORT', value: 0},
              {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
              {name: 'cmap12Language', type: 'ULONG', value: 0},
              {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
          ]);

          t.fields = t.fields.concat(cmap12Groups);
      }

      return t;
  }

  var cmap$1 = { parse: parseCmapTable, make: makeCmapTable };

  // Glyph encoding

  var cffStandardStrings$1 = [
      '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
      'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
      'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
      'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
      'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
      'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
      'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
      'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
      'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
      'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
      'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
      'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
      'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
      'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
      'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
      'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
      'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
      'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
      'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
      'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
      'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
      'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
      'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
      'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
      'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
      'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
      'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
      'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
      'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
      'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
      'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
      'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
      'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
      'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
      'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
      'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
      'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
      'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
      'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
      'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
      'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
      'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
      '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

  var cffStandardEncoding = [
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
      'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
      'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
      'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
      'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
      'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
      'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
      'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
      'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
      'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
      'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
      'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
      '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
      'lslash', 'oslash', 'oe', 'germandbls'];

  var cffExpertEncoding = [
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
      'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
      'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
      'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
      'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
      'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
      'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
      'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
      'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
      'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
      'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
      'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
      'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
      '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
      'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
      '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
      'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
      'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
      'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
      'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
      'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
      'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
      'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
      'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

  var standardNames = [
      '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
      'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
      'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
      'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
      'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
      'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
      'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
      'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
      'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
      'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
      'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
      'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
      'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
      'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
      'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
      'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
      'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
      'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
      'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
      'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
      'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
      'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
      'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
      'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

  /**
   * This is the encoding used for fonts created from scratch.
   * It loops through all glyphs and finds the appropriate unicode value.
   * Since it's linear time, other encodings will be faster.
   * @exports opentype.DefaultEncoding
   * @class
   * @constructor
   * @param {opentype.Font}
   */
  function DefaultEncoding(font) {
      this.font = font;
  }

  DefaultEncoding.prototype.charToGlyphIndex = function(c) {
      var code = c.codePointAt(0);
      var glyphs = this.font.glyphs;
      if (glyphs) {
          for (var i = 0; i < glyphs.length; i += 1) {
              var glyph = glyphs.get(i);
              for (var j = 0; j < glyph.unicodes.length; j += 1) {
                  if (glyph.unicodes[j] === code) {
                      return i;
                  }
              }
          }
      }
      return null;
  };

  /**
   * @exports opentype.CmapEncoding
   * @class
   * @constructor
   * @param {Object} cmap - a object with the cmap encoded data
   */
  function CmapEncoding(cmap) {
      this.cmap = cmap;
  }

  /**
   * @param  {string} c - the character
   * @return {number} The glyph index.
   */
  CmapEncoding.prototype.charToGlyphIndex = function(c) {
      return this.cmap.glyphIndexMap[c.codePointAt(0)] || 0;
  };

  /**
   * @exports opentype.CffEncoding
   * @class
   * @constructor
   * @param {string} encoding - The encoding
   * @param {Array} charset - The character set.
   */
  function CffEncoding(encoding, charset) {
      this.encoding = encoding;
      this.charset = charset;
  }

  /**
   * @param  {string} s - The character
   * @return {number} The index.
   */
  CffEncoding.prototype.charToGlyphIndex = function(s) {
      var code = s.codePointAt(0);
      var charName = this.encoding[code];
      return this.charset.indexOf(charName);
  };

  /**
   * @exports opentype.GlyphNames
   * @class
   * @constructor
   * @param {Object} post
   */
  function GlyphNames(post) {
      switch (post.version) {
          case 1:
              this.names = standardNames.slice();
              break;
          case 2:
              this.names = new Array(post.numberOfGlyphs);
              for (var i = 0; i < post.numberOfGlyphs; i++) {
                  if (post.glyphNameIndex[i] < standardNames.length) {
                      this.names[i] = standardNames[post.glyphNameIndex[i]];
                  } else {
                      this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                  }
              }

              break;
          case 2.5:
              this.names = new Array(post.numberOfGlyphs);
              for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                  this.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
              }

              break;
          case 3:
              this.names = [];
              break;
          default:
              this.names = [];
              break;
      }
  }

  /**
   * Gets the index of a glyph by name.
   * @param  {string} name - The glyph name
   * @return {number} The index
   */
  GlyphNames.prototype.nameToGlyphIndex = function(name) {
      return this.names.indexOf(name);
  };

  /**
   * @param  {number} gid
   * @return {string}
   */
  GlyphNames.prototype.glyphIndexToName = function(gid) {
      return this.names[gid];
  };

  function addGlyphNamesAll(font) {
      var glyph;
      var glyphIndexMap = font.tables.cmap.glyphIndexMap;
      var charCodes = Object.keys(glyphIndexMap);

      for (var i = 0; i < charCodes.length; i += 1) {
          var c = charCodes[i];
          var glyphIndex = glyphIndexMap[c];
          glyph = font.glyphs.get(glyphIndex);
          glyph.addUnicode(parseInt(c));
      }

      for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
          glyph = font.glyphs.get(i$1);
          if (font.cffEncoding) {
              if (font.isCIDFont) {
                  glyph.name = 'gid' + i$1;
              } else {
                  glyph.name = font.cffEncoding.charset[i$1];
              }
          } else if (font.glyphNames.names) {
              glyph.name = font.glyphNames.glyphIndexToName(i$1);
          }
      }
  }

  function addGlyphNamesToUnicodeMap(font) {
      font._IndexToUnicodeMap = {};

      var glyphIndexMap = font.tables.cmap.glyphIndexMap;
      var charCodes = Object.keys(glyphIndexMap);

      for (var i = 0; i < charCodes.length; i += 1) {
          var c = charCodes[i];
          var glyphIndex = glyphIndexMap[c];
          if (font._IndexToUnicodeMap[glyphIndex] === undefined) {
              font._IndexToUnicodeMap[glyphIndex] = {
                  unicodes: [parseInt(c)]
              };
          } else {
              font._IndexToUnicodeMap[glyphIndex].unicodes.push(parseInt(c));
          }
      }
  }

  /**
   * @alias opentype.addGlyphNames
   * @param {opentype.Font}
   * @param {Object}
   */
  function addGlyphNames(font, opt) {
      if (opt.lowMemory) {
          addGlyphNamesToUnicodeMap(font);
      } else {
          addGlyphNamesAll(font);
      }
  }

  // Drawing utility functions.

  // Draw a line on the given context from point `x1,y1` to point `x2,y2`.
  function line(ctx, x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
  }

  var draw = { line: line };

  // The Glyph object
  // import glyf from './tables/glyf' Can't be imported here, because it's a circular dependency

  function getPathDefinition(glyph, path) {
      var _path = path || new Path();
      return {
          configurable: true,

          get: function() {
              if (typeof _path === 'function') {
                  _path = _path();
              }

              return _path;
          },

          set: function(p) {
              _path = p;
          }
      };
  }
  /**
   * @typedef GlyphOptions
   * @type Object
   * @property {string} [name] - The glyph name
   * @property {number} [unicode]
   * @property {Array} [unicodes]
   * @property {number} [xMin]
   * @property {number} [yMin]
   * @property {number} [xMax]
   * @property {number} [yMax]
   * @property {number} [advanceWidth]
   */

  // A Glyph is an individual mark that often corresponds to a character.
  // Some glyphs, such as ligatures, are a combination of many characters.
  // Glyphs are the basic building blocks of a font.
  //
  // The `Glyph` class contains utility methods for drawing the path and its points.
  /**
   * @exports opentype.Glyph
   * @class
   * @param {GlyphOptions}
   * @constructor
   */
  function Glyph(options) {
      // By putting all the code on a prototype function (which is only declared once)
      // we reduce the memory requirements for larger fonts by some 2%
      this.bindConstructorValues(options);
  }

  /**
   * @param  {GlyphOptions}
   */
  Glyph.prototype.bindConstructorValues = function(options) {
      this.index = options.index || 0;

      // These three values cannot be deferred for memory optimization:
      this.name = options.name || null;
      this.unicode = options.unicode || undefined;
      this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

      // But by binding these values only when necessary, we reduce can
      // the memory requirements by almost 3% for larger fonts.
      if ('xMin' in options) {
          this.xMin = options.xMin;
      }

      if ('yMin' in options) {
          this.yMin = options.yMin;
      }

      if ('xMax' in options) {
          this.xMax = options.xMax;
      }

      if ('yMax' in options) {
          this.yMax = options.yMax;
      }

      if ('advanceWidth' in options) {
          this.advanceWidth = options.advanceWidth;
      }

      // The path for a glyph is the most memory intensive, and is bound as a value
      // with a getter/setter to ensure we actually do path parsing only once the
      // path is actually needed by anything.
      Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
  };

  /**
   * @param {number}
   */
  Glyph.prototype.addUnicode = function(unicode) {
      if (this.unicodes.length === 0) {
          this.unicode = unicode;
      }

      this.unicodes.push(unicode);
  };

  /**
   * Calculate the minimum bounding box for this glyph.
   * @return {opentype.BoundingBox}
   */
  Glyph.prototype.getBoundingBox = function() {
      return this.path.getBoundingBox();
  };

  /**
   * Convert the glyph to a Path we can draw on a drawing context.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {Object=} options - xScale, yScale to stretch the glyph.
   * @param  {opentype.Font} if hinting is to be used, the font
   * @return {opentype.Path}
   */
  Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 72;
      var commands;
      var hPoints;
      if (!options) { options = { }; }
      var xScale = options.xScale;
      var yScale = options.yScale;

      if (options.hinting && font && font.hinting) {
          // in case of hinting, the hinting engine takes care
          // of scaling the points (not the path) before hinting.
          hPoints = this.path && font.hinting.exec(this, fontSize);
          // in case the hinting engine failed hPoints is undefined
          // and thus reverts to plain rending
      }

      if (hPoints) {
          // Call font.hinting.getCommands instead of `glyf.getPath(hPoints).commands` to avoid a circular dependency
          commands = font.hinting.getCommands(hPoints);
          x = Math.round(x);
          y = Math.round(y);
          // TODO in case of hinting xyScaling is not yet supported
          xScale = yScale = 1;
      } else {
          commands = this.path.commands;
          var scale = 1 / (this.path.unitsPerEm || 1000) * fontSize;
          if (xScale === undefined) { xScale = scale; }
          if (yScale === undefined) { yScale = scale; }
      }

      var p = new Path();
      for (var i = 0; i < commands.length; i += 1) {
          var cmd = commands[i];
          if (cmd.type === 'M') {
              p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
          } else if (cmd.type === 'L') {
              p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
          } else if (cmd.type === 'Q') {
              p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                                 x + (cmd.x * xScale), y + (-cmd.y * yScale));
          } else if (cmd.type === 'C') {
              p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                        x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                        x + (cmd.x * xScale), y + (-cmd.y * yScale));
          } else if (cmd.type === 'Z') {
              p.closePath();
          }
      }

      return p;
  };

  /**
   * Split the glyph into contours.
   * This function is here for backwards compatibility, and to
   * provide raw access to the TrueType glyph outlines.
   * @return {Array}
   */
  Glyph.prototype.getContours = function() {
      if (this.points === undefined) {
          return [];
      }

      var contours = [];
      var currentContour = [];
      for (var i = 0; i < this.points.length; i += 1) {
          var pt = this.points[i];
          currentContour.push(pt);
          if (pt.lastPointOfContour) {
              contours.push(currentContour);
              currentContour = [];
          }
      }

      check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
      return contours;
  };

  /**
   * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
   * @return {Object}
   */
  Glyph.prototype.getMetrics = function() {
      var commands = this.path.commands;
      var xCoords = [];
      var yCoords = [];
      for (var i = 0; i < commands.length; i += 1) {
          var cmd = commands[i];
          if (cmd.type !== 'Z') {
              xCoords.push(cmd.x);
              yCoords.push(cmd.y);
          }

          if (cmd.type === 'Q' || cmd.type === 'C') {
              xCoords.push(cmd.x1);
              yCoords.push(cmd.y1);
          }

          if (cmd.type === 'C') {
              xCoords.push(cmd.x2);
              yCoords.push(cmd.y2);
          }
      }

      var metrics = {
          xMin: Math.min.apply(null, xCoords),
          yMin: Math.min.apply(null, yCoords),
          xMax: Math.max.apply(null, xCoords),
          yMax: Math.max.apply(null, yCoords),
          leftSideBearing: this.leftSideBearing
      };

      if (!isFinite(metrics.xMin)) {
          metrics.xMin = 0;
      }

      if (!isFinite(metrics.xMax)) {
          metrics.xMax = this.advanceWidth;
      }

      if (!isFinite(metrics.yMin)) {
          metrics.yMin = 0;
      }

      if (!isFinite(metrics.yMax)) {
          metrics.yMax = 0;
      }

      metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
      return metrics;
  };

  /**
   * Draw the glyph on the given context.
   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {Object=} options - xScale, yScale to stretch the glyph.
   */
  Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
      this.getPath(x, y, fontSize, options).draw(ctx);
  };

  /**
   * Draw the points of the glyph.
   * On-curve points will be drawn in blue, off-curve points will be drawn in red.
   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   */
  Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
      function drawCircles(l, x, y, scale) {
          ctx.beginPath();
          for (var j = 0; j < l.length; j += 1) {
              ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
              ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, Math.PI * 2, false);
          }

          ctx.closePath();
          ctx.fill();
      }

      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 24;
      var scale = 1 / this.path.unitsPerEm * fontSize;

      var blueCircles = [];
      var redCircles = [];
      var path = this.path;
      for (var i = 0; i < path.commands.length; i += 1) {
          var cmd = path.commands[i];
          if (cmd.x !== undefined) {
              blueCircles.push({x: cmd.x, y: -cmd.y});
          }

          if (cmd.x1 !== undefined) {
              redCircles.push({x: cmd.x1, y: -cmd.y1});
          }

          if (cmd.x2 !== undefined) {
              redCircles.push({x: cmd.x2, y: -cmd.y2});
          }
      }

      ctx.fillStyle = 'blue';
      drawCircles(blueCircles, x, y, scale);
      ctx.fillStyle = 'red';
      drawCircles(redCircles, x, y, scale);
  };

  /**
   * Draw lines indicating important font measurements.
   * Black lines indicate the origin of the coordinate system (point 0,0).
   * Blue lines indicate the glyph bounding box.
   * Green line indicates the advance width of the glyph.
   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   */
  Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
      var scale;
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 24;
      scale = 1 / this.path.unitsPerEm * fontSize;
      ctx.lineWidth = 1;

      // Draw the origin
      ctx.strokeStyle = 'black';
      draw.line(ctx, x, -10000, x, 10000);
      draw.line(ctx, -10000, y, 10000, y);

      // This code is here due to memory optimization: by not using
      // defaults in the constructor, we save a notable amount of memory.
      var xMin = this.xMin || 0;
      var yMin = this.yMin || 0;
      var xMax = this.xMax || 0;
      var yMax = this.yMax || 0;
      var advanceWidth = this.advanceWidth || 0;

      // Draw the glyph box
      ctx.strokeStyle = 'blue';
      draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
      draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
      draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
      draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

      // Draw the advance width
      ctx.strokeStyle = 'green';
      draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
  };

  // The GlyphSet object

  // Define a property on the glyph that depends on the path being loaded.
  function defineDependentProperty(glyph, externalName, internalName) {
      Object.defineProperty(glyph, externalName, {
          get: function() {
              // Request the path property to make sure the path is loaded.
              glyph.path; // jshint ignore:line
              return glyph[internalName];
          },
          set: function(newValue) {
              glyph[internalName] = newValue;
          },
          enumerable: true,
          configurable: true
      });
  }

  /**
   * A GlyphSet represents all glyphs available in the font, but modelled using
   * a deferred glyph loader, for retrieving glyphs only once they are absolutely
   * necessary, to keep the memory footprint down.
   * @exports opentype.GlyphSet
   * @class
   * @param {opentype.Font}
   * @param {Array}
   */
  function GlyphSet(font, glyphs) {
      this.font = font;
      this.glyphs = {};
      if (Array.isArray(glyphs)) {
          for (var i = 0; i < glyphs.length; i++) {
              var glyph = glyphs[i];
              glyph.path.unitsPerEm = font.unitsPerEm;
              this.glyphs[i] = glyph;
          }
      }

      this.length = (glyphs && glyphs.length) || 0;
  }

  /**
   * @param  {number} index
   * @return {opentype.Glyph}
   */
  GlyphSet.prototype.get = function(index) {
      // this.glyphs[index] is 'undefined' when low memory mode is on. glyph is pushed on request only.
      if (this.glyphs[index] === undefined) {
          this.font._push(index);
          if (typeof this.glyphs[index] === 'function') {
              this.glyphs[index] = this.glyphs[index]();
          }

          var glyph = this.glyphs[index];
          var unicodeObj = this.font._IndexToUnicodeMap[index];

          if (unicodeObj) {
              for (var j = 0; j < unicodeObj.unicodes.length; j++)
                  { glyph.addUnicode(unicodeObj.unicodes[j]); }
          }

          if (this.font.cffEncoding) {
              if (this.font.isCIDFont) {
                  glyph.name = 'gid' + index;
              } else {
                  glyph.name = this.font.cffEncoding.charset[index];
              }
          } else if (this.font.glyphNames.names) {
              glyph.name = this.font.glyphNames.glyphIndexToName(index);
          }

          this.glyphs[index].advanceWidth = this.font._hmtxTableData[index].advanceWidth;
          this.glyphs[index].leftSideBearing = this.font._hmtxTableData[index].leftSideBearing;
      } else {
          if (typeof this.glyphs[index] === 'function') {
              this.glyphs[index] = this.glyphs[index]();
          }
      }

      return this.glyphs[index];
  };

  /**
   * @param  {number} index
   * @param  {Object}
   */
  GlyphSet.prototype.push = function(index, loader) {
      this.glyphs[index] = loader;
      this.length++;
  };

  /**
   * @alias opentype.glyphLoader
   * @param  {opentype.Font} font
   * @param  {number} index
   * @return {opentype.Glyph}
   */
  function glyphLoader(font, index) {
      return new Glyph({index: index, font: font});
  }

  /**
   * Generate a stub glyph that can be filled with all metadata *except*
   * the "points" and "path" properties, which must be loaded only once
   * the glyph's path is actually requested for text shaping.
   * @alias opentype.ttfGlyphLoader
   * @param  {opentype.Font} font
   * @param  {number} index
   * @param  {Function} parseGlyph
   * @param  {Object} data
   * @param  {number} position
   * @param  {Function} buildPath
   * @return {opentype.Glyph}
   */
  function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
      return function() {
          var glyph = new Glyph({index: index, font: font});

          glyph.path = function() {
              parseGlyph(glyph, data, position);
              var path = buildPath(font.glyphs, glyph);
              path.unitsPerEm = font.unitsPerEm;
              return path;
          };

          defineDependentProperty(glyph, 'xMin', '_xMin');
          defineDependentProperty(glyph, 'xMax', '_xMax');
          defineDependentProperty(glyph, 'yMin', '_yMin');
          defineDependentProperty(glyph, 'yMax', '_yMax');

          return glyph;
      };
  }
  /**
   * @alias opentype.cffGlyphLoader
   * @param  {opentype.Font} font
   * @param  {number} index
   * @param  {Function} parseCFFCharstring
   * @param  {string} charstring
   * @return {opentype.Glyph}
   */
  function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
      return function() {
          var glyph = new Glyph({index: index, font: font});

          glyph.path = function() {
              var path = parseCFFCharstring(font, glyph, charstring);
              path.unitsPerEm = font.unitsPerEm;
              return path;
          };

          return glyph;
      };
  }

  var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

  // The `CFF` table contains the glyph outlines in PostScript format.

  // Custom equals function that can also check lists.
  function equals(a, b) {
      if (a === b) {
          return true;
      } else if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length) {
              return false;
          }

          for (var i = 0; i < a.length; i += 1) {
              if (!equals(a[i], b[i])) {
                  return false;
              }
          }

          return true;
      } else {
          return false;
      }
  }

  // Subroutines are encoded using the negative half of the number space.
  // See type 2 chapter 4.7 "Subroutine operators".
  function calcCFFSubroutineBias(subrs) {
      var bias;
      if (subrs.length < 1240) {
          bias = 107;
      } else if (subrs.length < 33900) {
          bias = 1131;
      } else {
          bias = 32768;
      }

      return bias;
  }

  // Parse a `CFF` INDEX array.
  // An index array consists of a list of offsets, then a list of objects at those offsets.
  function parseCFFIndex(data, start, conversionFn) {
      var offsets = [];
      var objects = [];
      var count = parse$2.getCard16(data, start);
      var objectOffset;
      var endOffset;
      if (count !== 0) {
          var offsetSize = parse$2.getByte(data, start + 2);
          objectOffset = start + ((count + 1) * offsetSize) + 2;
          var pos = start + 3;
          for (var i = 0; i < count + 1; i += 1) {
              offsets.push(parse$2.getOffset(data, pos, offsetSize));
              pos += offsetSize;
          }

          // The total size of the index array is 4 header bytes + the value of the last offset.
          endOffset = objectOffset + offsets[count];
      } else {
          endOffset = start + 2;
      }

      for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
          var value = parse$2.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
          if (conversionFn) {
              value = conversionFn(value);
          }

          objects.push(value);
      }

      return {objects: objects, startOffset: start, endOffset: endOffset};
  }

  function parseCFFIndexLowMemory(data, start) {
      var offsets = [];
      var count = parse$2.getCard16(data, start);
      var objectOffset;
      var endOffset;
      if (count !== 0) {
          var offsetSize = parse$2.getByte(data, start + 2);
          objectOffset = start + ((count + 1) * offsetSize) + 2;
          var pos = start + 3;
          for (var i = 0; i < count + 1; i += 1) {
              offsets.push(parse$2.getOffset(data, pos, offsetSize));
              pos += offsetSize;
          }

          // The total size of the index array is 4 header bytes + the value of the last offset.
          endOffset = objectOffset + offsets[count];
      } else {
          endOffset = start + 2;
      }

      return {offsets: offsets, startOffset: start, endOffset: endOffset};
  }
  function getCffIndexObject(i, offsets, data, start, conversionFn) {
      var count = parse$2.getCard16(data, start);
      var objectOffset = 0;
      if (count !== 0) {
          var offsetSize = parse$2.getByte(data, start + 2);
          objectOffset = start + ((count + 1) * offsetSize) + 2;
      }

      var value = parse$2.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);
      if (conversionFn) {
          value = conversionFn(value);
      }
      return value;
  }

  // Parse a `CFF` DICT real value.
  function parseFloatOperand(parser) {
      var s = '';
      var eof = 15;
      var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
      while (true) {
          var b = parser.parseByte();
          var n1 = b >> 4;
          var n2 = b & 15;

          if (n1 === eof) {
              break;
          }

          s += lookup[n1];

          if (n2 === eof) {
              break;
          }

          s += lookup[n2];
      }

      return parseFloat(s);
  }

  // Parse a `CFF` DICT operand.
  function parseOperand(parser, b0) {
      var b1;
      var b2;
      var b3;
      var b4;
      if (b0 === 28) {
          b1 = parser.parseByte();
          b2 = parser.parseByte();
          return b1 << 8 | b2;
      }

      if (b0 === 29) {
          b1 = parser.parseByte();
          b2 = parser.parseByte();
          b3 = parser.parseByte();
          b4 = parser.parseByte();
          return b1 << 24 | b2 << 16 | b3 << 8 | b4;
      }

      if (b0 === 30) {
          return parseFloatOperand(parser);
      }

      if (b0 >= 32 && b0 <= 246) {
          return b0 - 139;
      }

      if (b0 >= 247 && b0 <= 250) {
          b1 = parser.parseByte();
          return (b0 - 247) * 256 + b1 + 108;
      }

      if (b0 >= 251 && b0 <= 254) {
          b1 = parser.parseByte();
          return -(b0 - 251) * 256 - b1 - 108;
      }

      throw new Error('Invalid b0 ' + b0);
  }

  // Convert the entries returned by `parseDict` to a proper dictionary.
  // If a value is a list of one, it is unpacked.
  function entriesToObject(entries) {
      var o = {};
      for (var i = 0; i < entries.length; i += 1) {
          var key = entries[i][0];
          var values = entries[i][1];
          var value = (void 0);
          if (values.length === 1) {
              value = values[0];
          } else {
              value = values;
          }

          if (o.hasOwnProperty(key) && !isNaN(o[key])) {
              throw new Error('Object ' + o + ' already has key ' + key);
          }

          o[key] = value;
      }

      return o;
  }

  // Parse a `CFF` DICT object.
  // A dictionary contains key-value pairs in a compact tokenized format.
  function parseCFFDict$1(data, start, size) {
      start = start !== undefined ? start : 0;
      var parser = new parse$2.Parser(data, start);
      var entries = [];
      var operands = [];
      size = size !== undefined ? size : data.length;

      while (parser.relativeOffset < size) {
          var op = parser.parseByte();

          // The first byte for each dict item distinguishes between operator (key) and operand (value).
          // Values <= 21 are operators.
          if (op <= 21) {
              // Two-byte operators have an initial escape byte of 12.
              if (op === 12) {
                  op = 1200 + parser.parseByte();
              }

              entries.push([op, operands]);
              operands = [];
          } else {
              // Since the operands (values) come before the operators (keys), we store all operands in a list
              // until we encounter an operator.
              operands.push(parseOperand(parser, op));
          }
      }

      return entriesToObject(entries);
  }

  // Given a String Index (SID), return the value of the string.
  // Strings below index 392 are standard CFF strings and are not encoded in the font.
  function getCFFString$1(strings, index) {
      if (index <= 390) {
          index = cffStandardStrings$1[index];
      } else {
          index = strings[index - 391];
      }

      return index;
  }

  // Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
  // This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
  function interpretDict(dict, meta, strings) {
      var newDict = {};
      var value;

      // Because we also want to include missing values, we start out from the meta list
      // and lookup values in the dict.
      for (var i = 0; i < meta.length; i += 1) {
          var m = meta[i];

          if (Array.isArray(m.type)) {
              var values = [];
              values.length = m.type.length;
              for (var j = 0; j < m.type.length; j++) {
                  value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                  if (value === undefined) {
                      value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                  }
                  if (m.type[j] === 'SID') {
                      value = getCFFString$1(strings, value);
                  }
                  values[j] = value;
              }
              newDict[m.name] = values;
          } else {
              value = dict[m.op];
              if (value === undefined) {
                  value = m.value !== undefined ? m.value : null;
              }

              if (m.type === 'SID') {
                  value = getCFFString$1(strings, value);
              }
              newDict[m.name] = value;
          }
      }

      return newDict;
  }

  // Parse the CFF header.
  function parseCFFHeader(data, start) {
      var header = {};
      header.formatMajor = parse$2.getCard8(data, start);
      header.formatMinor = parse$2.getCard8(data, start + 1);
      header.size = parse$2.getCard8(data, start + 2);
      header.offsetSize = parse$2.getCard8(data, start + 3);
      header.startOffset = start;
      header.endOffset = start + 4;
      return header;
  }

  var TOP_DICT_META = [
      {name: 'version', op: 0, type: 'SID'},
      {name: 'notice', op: 1, type: 'SID'},
      {name: 'copyright', op: 1200, type: 'SID'},
      {name: 'fullName', op: 2, type: 'SID'},
      {name: 'familyName', op: 3, type: 'SID'},
      {name: 'weight', op: 4, type: 'SID'},
      {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
      {name: 'italicAngle', op: 1202, type: 'number', value: 0},
      {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
      {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
      {name: 'paintType', op: 1205, type: 'number', value: 0},
      {name: 'charstringType', op: 1206, type: 'number', value: 2},
      {
          name: 'fontMatrix',
          op: 1207,
          type: ['real', 'real', 'real', 'real', 'real', 'real'],
          value: [0.001, 0, 0, 0.001, 0, 0]
      },
      {name: 'uniqueId', op: 13, type: 'number'},
      {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
      {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
      {name: 'xuid', op: 14, type: [], value: null},
      {name: 'charset', op: 15, type: 'offset', value: 0},
      {name: 'encoding', op: 16, type: 'offset', value: 0},
      {name: 'charStrings', op: 17, type: 'offset', value: 0},
      {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
      {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
      {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
      {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
      {name: 'cidFontType', op: 1233, type: 'number', value: 0},
      {name: 'cidCount', op: 1234, type: 'number', value: 8720},
      {name: 'uidBase', op: 1235, type: 'number'},
      {name: 'fdArray', op: 1236, type: 'offset'},
      {name: 'fdSelect', op: 1237, type: 'offset'},
      {name: 'fontName', op: 1238, type: 'SID'}
  ];

  var PRIVATE_DICT_META = [
      {name: 'subrs', op: 19, type: 'offset', value: 0},
      {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
      {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
  ];

  // Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
  // The top dictionary contains the essential metadata for the font, together with the private dictionary.
  function parseCFFTopDict(data, strings) {
      var dict = parseCFFDict$1(data, 0, data.byteLength);
      return interpretDict(dict, TOP_DICT_META, strings);
  }

  // Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
  function parseCFFPrivateDict(data, start, size, strings) {
      var dict = parseCFFDict$1(data, start, size);
      return interpretDict(dict, PRIVATE_DICT_META, strings);
  }

  // Returns a list of "Top DICT"s found using an INDEX list.
  // Used to read both the usual high-level Top DICTs and also the FDArray
  // discovered inside CID-keyed fonts.  When a Top DICT has a reference to
  // a Private DICT that is read and saved into the Top DICT.
  //
  // In addition to the expected/optional values as outlined in TOP_DICT_META
  // the following values might be saved into the Top DICT.
  //
  //    _subrs []        array of local CFF subroutines from Private DICT
  //    _subrsBias       bias value computed from number of subroutines
  //                      (see calcCFFSubroutineBias() and parseCFFCharstring())
  //    _defaultWidthX   default widths for CFF characters
  //    _nominalWidthX   bias added to width embedded within glyph description
  //
  //    _privateDict     saved copy of parsed Private DICT from Top DICT
  function gatherCFFTopDicts(data, start, cffIndex, strings) {
      var topDictArray = [];
      for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
          var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
          var topDict = parseCFFTopDict(topDictData, strings);
          topDict._subrs = [];
          topDict._subrsBias = 0;
          topDict._defaultWidthX = 0;
          topDict._nominalWidthX = 0;
          var privateSize = topDict.private[0];
          var privateOffset = topDict.private[1];
          if (privateSize !== 0 && privateOffset !== 0) {
              var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
              topDict._defaultWidthX = privateDict.defaultWidthX;
              topDict._nominalWidthX = privateDict.nominalWidthX;
              if (privateDict.subrs !== 0) {
                  var subrOffset = privateOffset + privateDict.subrs;
                  var subrIndex = parseCFFIndex(data, subrOffset + start);
                  topDict._subrs = subrIndex.objects;
                  topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
              }
              topDict._privateDict = privateDict;
          }
          topDictArray.push(topDict);
      }
      return topDictArray;
  }

  // Parse the CFF charset table, which contains internal names for all the glyphs.
  // This function will return a list of glyph names.
  // See Adobe TN #5176 chapter 13, "Charsets".
  function parseCFFCharset$1(data, start, nGlyphs, strings) {
      var sid;
      var count;
      var parser = new parse$2.Parser(data, start);

      // The .notdef glyph is not included, so subtract 1.
      nGlyphs -= 1;
      var charset = ['.notdef'];

      var format = parser.parseCard8();
      if (format === 0) {
          for (var i = 0; i < nGlyphs; i += 1) {
              sid = parser.parseSID();
              charset.push(getCFFString$1(strings, sid));
          }
      } else if (format === 1) {
          while (charset.length <= nGlyphs) {
              sid = parser.parseSID();
              count = parser.parseCard8();
              for (var i$1 = 0; i$1 <= count; i$1 += 1) {
                  charset.push(getCFFString$1(strings, sid));
                  sid += 1;
              }
          }
      } else if (format === 2) {
          while (charset.length <= nGlyphs) {
              sid = parser.parseSID();
              count = parser.parseCard16();
              for (var i$2 = 0; i$2 <= count; i$2 += 1) {
                  charset.push(getCFFString$1(strings, sid));
                  sid += 1;
              }
          }
      } else {
          throw new Error('Unknown charset format ' + format);
      }

      return charset;
  }

  // Parse the CFF encoding data. Only one encoding can be specified per font.
  // See Adobe TN #5176 chapter 12, "Encodings".
  function parseCFFEncoding$1(data, start, charset) {
      var code;
      var enc = {};
      var parser = new parse$2.Parser(data, start);
      var format = parser.parseCard8();
      if (format === 0) {
          var nCodes = parser.parseCard8();
          for (var i = 0; i < nCodes; i += 1) {
              code = parser.parseCard8();
              enc[code] = i;
          }
      } else if (format === 1) {
          var nRanges = parser.parseCard8();
          code = 1;
          for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
              var first = parser.parseCard8();
              var nLeft = parser.parseCard8();
              for (var j = first; j <= first + nLeft; j += 1) {
                  enc[j] = code;
                  code += 1;
              }
          }
      } else {
          throw new Error('Unknown encoding format ' + format);
      }

      return new CffEncoding(enc, charset);
  }

  // Take in charstring code and return a Glyph object.
  // The encoding is described in the Type 2 Charstring Format
  // https://www.microsoft.com/typography/OTSPEC/charstr2.htm
  function parseCFFCharstring(font, glyph, code) {
      var c1x;
      var c1y;
      var c2x;
      var c2y;
      var p = new Path();
      var stack = [];
      var nStems = 0;
      var haveWidth = false;
      var open = false;
      var x = 0;
      var y = 0;
      var subrs;
      var subrsBias;
      var defaultWidthX;
      var nominalWidthX;
      if (font.isCIDFont) {
          var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
          var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
          subrs = fdDict._subrs;
          subrsBias = fdDict._subrsBias;
          defaultWidthX = fdDict._defaultWidthX;
          nominalWidthX = fdDict._nominalWidthX;
      } else {
          subrs = font.tables.cff.topDict._subrs;
          subrsBias = font.tables.cff.topDict._subrsBias;
          defaultWidthX = font.tables.cff.topDict._defaultWidthX;
          nominalWidthX = font.tables.cff.topDict._nominalWidthX;
      }
      var width = defaultWidthX;

      function newContour(x, y) {
          if (open) {
              p.closePath();
          }

          p.moveTo(x, y);
          open = true;
      }

      function parseStems() {
          var hasWidthArg;

          // The number of stem operators on the stack is always even.
          // If the value is uneven, that means a width is specified.
          hasWidthArg = stack.length % 2 !== 0;
          if (hasWidthArg && !haveWidth) {
              width = stack.shift() + nominalWidthX;
          }

          nStems += stack.length >> 1;
          stack.length = 0;
          haveWidth = true;
      }

      function parse(code) {
          var b1;
          var b2;
          var b3;
          var b4;
          var codeIndex;
          var subrCode;
          var jpx;
          var jpy;
          var c3x;
          var c3y;
          var c4x;
          var c4y;

          var i = 0;
          while (i < code.length) {
              var v = code[i];
              i += 1;
              switch (v) {
                  case 1: // hstem
                      parseStems();
                      break;
                  case 3: // vstem
                      parseStems();
                      break;
                  case 4: // vmoveto
                      if (stack.length > 1 && !haveWidth) {
                          width = stack.shift() + nominalWidthX;
                          haveWidth = true;
                      }

                      y += stack.pop();
                      newContour(x, y);
                      break;
                  case 5: // rlineto
                      while (stack.length > 0) {
                          x += stack.shift();
                          y += stack.shift();
                          p.lineTo(x, y);
                      }

                      break;
                  case 6: // hlineto
                      while (stack.length > 0) {
                          x += stack.shift();
                          p.lineTo(x, y);
                          if (stack.length === 0) {
                              break;
                          }

                          y += stack.shift();
                          p.lineTo(x, y);
                      }

                      break;
                  case 7: // vlineto
                      while (stack.length > 0) {
                          y += stack.shift();
                          p.lineTo(x, y);
                          if (stack.length === 0) {
                              break;
                          }

                          x += stack.shift();
                          p.lineTo(x, y);
                      }

                      break;
                  case 8: // rrcurveto
                      while (stack.length > 0) {
                          c1x = x + stack.shift();
                          c1y = y + stack.shift();
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          x = c2x + stack.shift();
                          y = c2y + stack.shift();
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      }

                      break;
                  case 10: // callsubr
                      codeIndex = stack.pop() + subrsBias;
                      subrCode = subrs[codeIndex];
                      if (subrCode) {
                          parse(subrCode);
                      }

                      break;
                  case 11: // return
                      return;
                  case 12: // flex operators
                      v = code[i];
                      i += 1;
                      switch (v) {
                          case 35: // flex
                              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                              c1x = x   + stack.shift();    // dx1
                              c1y = y   + stack.shift();    // dy1
                              c2x = c1x + stack.shift();    // dx2
                              c2y = c1y + stack.shift();    // dy2
                              jpx = c2x + stack.shift();    // dx3
                              jpy = c2y + stack.shift();    // dy3
                              c3x = jpx + stack.shift();    // dx4
                              c3y = jpy + stack.shift();    // dy4
                              c4x = c3x + stack.shift();    // dx5
                              c4y = c3y + stack.shift();    // dy5
                              x = c4x   + stack.shift();    // dx6
                              y = c4y   + stack.shift();    // dy6
                              stack.shift();                // flex depth
                              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                              p.curveTo(c3x, c3y, c4x, c4y, x, y);
                              break;
                          case 34: // hflex
                              // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                              c1x = x   + stack.shift();    // dx1
                              c1y = y;                      // dy1
                              c2x = c1x + stack.shift();    // dx2
                              c2y = c1y + stack.shift();    // dy2
                              jpx = c2x + stack.shift();    // dx3
                              jpy = c2y;                    // dy3
                              c3x = jpx + stack.shift();    // dx4
                              c3y = c2y;                    // dy4
                              c4x = c3x + stack.shift();    // dx5
                              c4y = y;                      // dy5
                              x = c4x + stack.shift();      // dx6
                              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                              p.curveTo(c3x, c3y, c4x, c4y, x, y);
                              break;
                          case 36: // hflex1
                              // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                              c1x = x   + stack.shift();    // dx1
                              c1y = y   + stack.shift();    // dy1
                              c2x = c1x + stack.shift();    // dx2
                              c2y = c1y + stack.shift();    // dy2
                              jpx = c2x + stack.shift();    // dx3
                              jpy = c2y;                    // dy3
                              c3x = jpx + stack.shift();    // dx4
                              c3y = c2y;                    // dy4
                              c4x = c3x + stack.shift();    // dx5
                              c4y = c3y + stack.shift();    // dy5
                              x = c4x + stack.shift();      // dx6
                              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                              p.curveTo(c3x, c3y, c4x, c4y, x, y);
                              break;
                          case 37: // flex1
                              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                              c1x = x   + stack.shift();    // dx1
                              c1y = y   + stack.shift();    // dy1
                              c2x = c1x + stack.shift();    // dx2
                              c2y = c1y + stack.shift();    // dy2
                              jpx = c2x + stack.shift();    // dx3
                              jpy = c2y + stack.shift();    // dy3
                              c3x = jpx + stack.shift();    // dx4
                              c3y = jpy + stack.shift();    // dy4
                              c4x = c3x + stack.shift();    // dx5
                              c4y = c3y + stack.shift();    // dy5
                              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                  x = c4x + stack.shift();
                              } else {
                                  y = c4y + stack.shift();
                              }

                              p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                              p.curveTo(c3x, c3y, c4x, c4y, x, y);
                              break;
                          default:
                              console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                              stack.length = 0;
                      }
                      break;
                  case 14: // endchar
                      if (stack.length > 0 && !haveWidth) {
                          width = stack.shift() + nominalWidthX;
                          haveWidth = true;
                      }

                      if (open) {
                          p.closePath();
                          open = false;
                      }

                      break;
                  case 18: // hstemhm
                      parseStems();
                      break;
                  case 19: // hintmask
                  case 20: // cntrmask
                      parseStems();
                      i += (nStems + 7) >> 3;
                      break;
                  case 21: // rmoveto
                      if (stack.length > 2 && !haveWidth) {
                          width = stack.shift() + nominalWidthX;
                          haveWidth = true;
                      }

                      y += stack.pop();
                      x += stack.pop();
                      newContour(x, y);
                      break;
                  case 22: // hmoveto
                      if (stack.length > 1 && !haveWidth) {
                          width = stack.shift() + nominalWidthX;
                          haveWidth = true;
                      }

                      x += stack.pop();
                      newContour(x, y);
                      break;
                  case 23: // vstemhm
                      parseStems();
                      break;
                  case 24: // rcurveline
                      while (stack.length > 2) {
                          c1x = x + stack.shift();
                          c1y = y + stack.shift();
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          x = c2x + stack.shift();
                          y = c2y + stack.shift();
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      }

                      x += stack.shift();
                      y += stack.shift();
                      p.lineTo(x, y);
                      break;
                  case 25: // rlinecurve
                      while (stack.length > 6) {
                          x += stack.shift();
                          y += stack.shift();
                          p.lineTo(x, y);
                      }

                      c1x = x + stack.shift();
                      c1y = y + stack.shift();
                      c2x = c1x + stack.shift();
                      c2y = c1y + stack.shift();
                      x = c2x + stack.shift();
                      y = c2y + stack.shift();
                      p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      break;
                  case 26: // vvcurveto
                      if (stack.length % 2) {
                          x += stack.shift();
                      }

                      while (stack.length > 0) {
                          c1x = x;
                          c1y = y + stack.shift();
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          x = c2x;
                          y = c2y + stack.shift();
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      }

                      break;
                  case 27: // hhcurveto
                      if (stack.length % 2) {
                          y += stack.shift();
                      }

                      while (stack.length > 0) {
                          c1x = x + stack.shift();
                          c1y = y;
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          x = c2x + stack.shift();
                          y = c2y;
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      }

                      break;
                  case 28: // shortint
                      b1 = code[i];
                      b2 = code[i + 1];
                      stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                      i += 2;
                      break;
                  case 29: // callgsubr
                      codeIndex = stack.pop() + font.gsubrsBias;
                      subrCode = font.gsubrs[codeIndex];
                      if (subrCode) {
                          parse(subrCode);
                      }

                      break;
                  case 30: // vhcurveto
                      while (stack.length > 0) {
                          c1x = x;
                          c1y = y + stack.shift();
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          x = c2x + stack.shift();
                          y = c2y + (stack.length === 1 ? stack.shift() : 0);
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                          if (stack.length === 0) {
                              break;
                          }

                          c1x = x + stack.shift();
                          c1y = y;
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          y = c2y + stack.shift();
                          x = c2x + (stack.length === 1 ? stack.shift() : 0);
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      }

                      break;
                  case 31: // hvcurveto
                      while (stack.length > 0) {
                          c1x = x + stack.shift();
                          c1y = y;
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          y = c2y + stack.shift();
                          x = c2x + (stack.length === 1 ? stack.shift() : 0);
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                          if (stack.length === 0) {
                              break;
                          }

                          c1x = x;
                          c1y = y + stack.shift();
                          c2x = c1x + stack.shift();
                          c2y = c1y + stack.shift();
                          x = c2x + stack.shift();
                          y = c2y + (stack.length === 1 ? stack.shift() : 0);
                          p.curveTo(c1x, c1y, c2x, c2y, x, y);
                      }

                      break;
                  default:
                      if (v < 32) {
                          console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                      } else if (v < 247) {
                          stack.push(v - 139);
                      } else if (v < 251) {
                          b1 = code[i];
                          i += 1;
                          stack.push((v - 247) * 256 + b1 + 108);
                      } else if (v < 255) {
                          b1 = code[i];
                          i += 1;
                          stack.push(-(v - 251) * 256 - b1 - 108);
                      } else {
                          b1 = code[i];
                          b2 = code[i + 1];
                          b3 = code[i + 2];
                          b4 = code[i + 3];
                          i += 4;
                          stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                      }
              }
          }
      }

      parse(code);

      glyph.advanceWidth = width;
      return p;
  }

  function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
      var fdSelect = [];
      var fdIndex;
      var parser = new parse$2.Parser(data, start);
      var format = parser.parseCard8();
      if (format === 0) {
          // Simple list of nGlyphs elements
          for (var iGid = 0; iGid < nGlyphs; iGid++) {
              fdIndex = parser.parseCard8();
              if (fdIndex >= fdArrayCount) {
                  throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
              }
              fdSelect.push(fdIndex);
          }
      } else if (format === 3) {
          // Ranges
          var nRanges = parser.parseCard16();
          var first = parser.parseCard16();
          if (first !== 0) {
              throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
          }
          var next;
          for (var iRange = 0; iRange < nRanges; iRange++) {
              fdIndex = parser.parseCard8();
              next = parser.parseCard16();
              if (fdIndex >= fdArrayCount) {
                  throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
              }
              if (next > nGlyphs) {
                  throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
              }
              for (; first < next; first++) {
                  fdSelect.push(fdIndex);
              }
              first = next;
          }
          if (next !== nGlyphs) {
              throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
          }
      } else {
          throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
      }
      return fdSelect;
  }

  // Parse the `CFF` table, which contains the glyph outlines in PostScript format.
  function parseCFFTable(data, start, font, opt) {
      font.tables.cff = {};
      var header = parseCFFHeader(data, start);
      var nameIndex = parseCFFIndex(data, header.endOffset, parse$2.bytesToString);
      var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
      var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse$2.bytesToString);
      var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
      font.gsubrs = globalSubrIndex.objects;
      font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

      var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
      if (topDictArray.length !== 1) {
          throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
      }

      var topDict = topDictArray[0];
      font.tables.cff.topDict = topDict;

      if (topDict._privateDict) {
          font.defaultWidthX = topDict._privateDict.defaultWidthX;
          font.nominalWidthX = topDict._privateDict.nominalWidthX;
      }

      if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
          font.isCIDFont = true;
      }

      if (font.isCIDFont) {
          var fdArrayOffset = topDict.fdArray;
          var fdSelectOffset = topDict.fdSelect;
          if (fdArrayOffset === 0 || fdSelectOffset === 0) {
              throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
          }
          fdArrayOffset += start;
          var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
          var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
          topDict._fdArray = fdArray;
          fdSelectOffset += start;
          topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
      }

      var privateDictOffset = start + topDict.private[1];
      var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
      font.defaultWidthX = privateDict.defaultWidthX;
      font.nominalWidthX = privateDict.nominalWidthX;

      if (privateDict.subrs !== 0) {
          var subrOffset = privateDictOffset + privateDict.subrs;
          var subrIndex = parseCFFIndex(data, subrOffset);
          font.subrs = subrIndex.objects;
          font.subrsBias = calcCFFSubroutineBias(font.subrs);
      } else {
          font.subrs = [];
          font.subrsBias = 0;
      }

      // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
      var charStringsIndex;
      if (opt.lowMemory) {
          charStringsIndex = parseCFFIndexLowMemory(data, start + topDict.charStrings);
          font.nGlyphs = charStringsIndex.offsets.length;
      } else {
          charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
          font.nGlyphs = charStringsIndex.objects.length;
      }

      var charset = parseCFFCharset$1(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
      if (topDict.encoding === 0) {
          // Standard encoding
          font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
      } else if (topDict.encoding === 1) {
          // Expert encoding
          font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
      } else {
          font.cffEncoding = parseCFFEncoding$1(data, start + topDict.encoding, charset);
      }

      // Prefer the CMAP encoding to the CFF encoding.
      font.encoding = font.encoding || font.cffEncoding;

      font.glyphs = new glyphset.GlyphSet(font);
      if (opt.lowMemory) {
          font._push = function(i) {
              var charString = getCffIndexObject(i, charStringsIndex.offsets, data, start + topDict.charStrings);
              font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
          };
      } else {
          for (var i = 0; i < font.nGlyphs; i += 1) {
              var charString = charStringsIndex.objects[i];
              font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
          }
      }
  }

  // Convert a string to a String ID (SID).
  // The list of strings is modified in place.
  function encodeString(s, strings) {
      var sid;

      // Is the string in the CFF standard strings?
      var i = cffStandardStrings$1.indexOf(s);
      if (i >= 0) {
          sid = i;
      }

      // Is the string already in the string index?
      i = strings.indexOf(s);
      if (i >= 0) {
          sid = i + cffStandardStrings$1.length;
      } else {
          sid = cffStandardStrings$1.length + strings.length;
          strings.push(s);
      }

      return sid;
  }

  function makeHeader() {
      return new table$1.Record('Header', [
          {name: 'major', type: 'Card8', value: 1},
          {name: 'minor', type: 'Card8', value: 0},
          {name: 'hdrSize', type: 'Card8', value: 4},
          {name: 'major', type: 'Card8', value: 1}
      ]);
  }

  function makeNameIndex(fontNames) {
      var t = new table$1.Record('Name INDEX', [
          {name: 'names', type: 'INDEX', value: []}
      ]);
      t.names = [];
      for (var i = 0; i < fontNames.length; i += 1) {
          t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
      }

      return t;
  }

  // Given a dictionary's metadata, create a DICT structure.
  function makeDict(meta, attrs, strings) {
      var m = {};
      for (var i = 0; i < meta.length; i += 1) {
          var entry = meta[i];
          var value = attrs[entry.name];
          if (value !== undefined && !equals(value, entry.value)) {
              if (entry.type === 'SID') {
                  value = encodeString(value, strings);
              }

              m[entry.op] = {name: entry.name, type: entry.type, value: value};
          }
      }

      return m;
  }

  // The Top DICT houses the global font attributes.
  function makeTopDict(attrs, strings) {
      var t = new table$1.Record('Top DICT', [
          {name: 'dict', type: 'DICT', value: {}}
      ]);
      t.dict = makeDict(TOP_DICT_META, attrs, strings);
      return t;
  }

  function makeTopDictIndex(topDict) {
      var t = new table$1.Record('Top DICT INDEX', [
          {name: 'topDicts', type: 'INDEX', value: []}
      ]);
      t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
      return t;
  }

  function makeStringIndex(strings) {
      var t = new table$1.Record('String INDEX', [
          {name: 'strings', type: 'INDEX', value: []}
      ]);
      t.strings = [];
      for (var i = 0; i < strings.length; i += 1) {
          t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
      }

      return t;
  }

  function makeGlobalSubrIndex() {
      // Currently we don't use subroutines.
      return new table$1.Record('Global Subr INDEX', [
          {name: 'subrs', type: 'INDEX', value: []}
      ]);
  }

  function makeCharsets(glyphNames, strings) {
      var t = new table$1.Record('Charsets', [
          {name: 'format', type: 'Card8', value: 0}
      ]);
      for (var i = 0; i < glyphNames.length; i += 1) {
          var glyphName = glyphNames[i];
          var glyphSID = encodeString(glyphName, strings);
          t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
      }

      return t;
  }

  function glyphToOps(glyph) {
      var ops = [];
      var path = glyph.path;
      ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
      var x = 0;
      var y = 0;
      for (var i = 0; i < path.commands.length; i += 1) {
          var dx = (void 0);
          var dy = (void 0);
          var cmd = path.commands[i];
          if (cmd.type === 'Q') {
              // CFF only supports bzier curves, so convert the quad to a bzier.
              var _13 = 1 / 3;
              var _23 = 2 / 3;

              // We're going to create a new command so we don't change the original path.
              // Since all coordinates are relative, we round() them ASAP to avoid propagating errors.
              cmd = {
                  type: 'C',
                  x: cmd.x,
                  y: cmd.y,
                  x1: Math.round(_13 * x + _23 * cmd.x1),
                  y1: Math.round(_13 * y + _23 * cmd.y1),
                  x2: Math.round(_13 * cmd.x + _23 * cmd.x1),
                  y2: Math.round(_13 * cmd.y + _23 * cmd.y1)
              };
          }

          if (cmd.type === 'M') {
              dx = Math.round(cmd.x - x);
              dy = Math.round(cmd.y - y);
              ops.push({name: 'dx', type: 'NUMBER', value: dx});
              ops.push({name: 'dy', type: 'NUMBER', value: dy});
              ops.push({name: 'rmoveto', type: 'OP', value: 21});
              x = Math.round(cmd.x);
              y = Math.round(cmd.y);
          } else if (cmd.type === 'L') {
              dx = Math.round(cmd.x - x);
              dy = Math.round(cmd.y - y);
              ops.push({name: 'dx', type: 'NUMBER', value: dx});
              ops.push({name: 'dy', type: 'NUMBER', value: dy});
              ops.push({name: 'rlineto', type: 'OP', value: 5});
              x = Math.round(cmd.x);
              y = Math.round(cmd.y);
          } else if (cmd.type === 'C') {
              var dx1 = Math.round(cmd.x1 - x);
              var dy1 = Math.round(cmd.y1 - y);
              var dx2 = Math.round(cmd.x2 - cmd.x1);
              var dy2 = Math.round(cmd.y2 - cmd.y1);
              dx = Math.round(cmd.x - cmd.x2);
              dy = Math.round(cmd.y - cmd.y2);
              ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
              ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
              ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
              ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
              ops.push({name: 'dx', type: 'NUMBER', value: dx});
              ops.push({name: 'dy', type: 'NUMBER', value: dy});
              ops.push({name: 'rrcurveto', type: 'OP', value: 8});
              x = Math.round(cmd.x);
              y = Math.round(cmd.y);
          }

          // Contours are closed automatically.
      }

      ops.push({name: 'endchar', type: 'OP', value: 14});
      return ops;
  }

  function makeCharStringsIndex(glyphs) {
      var t = new table$1.Record('CharStrings INDEX', [
          {name: 'charStrings', type: 'INDEX', value: []}
      ]);

      for (var i = 0; i < glyphs.length; i += 1) {
          var glyph = glyphs.get(i);
          var ops = glyphToOps(glyph);
          t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
      }

      return t;
  }

  function makePrivateDict(attrs, strings) {
      var t = new table$1.Record('Private DICT', [
          {name: 'dict', type: 'DICT', value: {}}
      ]);
      t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
      return t;
  }

  function makeCFFTable(glyphs, options) {
      var t = new table$1.Table('CFF ', [
          {name: 'header', type: 'RECORD'},
          {name: 'nameIndex', type: 'RECORD'},
          {name: 'topDictIndex', type: 'RECORD'},
          {name: 'stringIndex', type: 'RECORD'},
          {name: 'globalSubrIndex', type: 'RECORD'},
          {name: 'charsets', type: 'RECORD'},
          {name: 'charStringsIndex', type: 'RECORD'},
          {name: 'privateDict', type: 'RECORD'}
      ]);

      var fontScale = 1 / options.unitsPerEm;
      // We use non-zero values for the offsets so that the DICT encodes them.
      // This is important because the size of the Top DICT plays a role in offset calculation,
      // and the size shouldn't change after we've written correct offsets.
      var attrs = {
          version: options.version,
          fullName: options.fullName,
          familyName: options.familyName,
          weight: options.weightName,
          fontBBox: options.fontBBox || [0, 0, 0, 0],
          fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
          charset: 999,
          encoding: 0,
          charStrings: 999,
          private: [0, 999]
      };

      var privateAttrs = {};

      var glyphNames = [];
      var glyph;

      // Skip first glyph (.notdef)
      for (var i = 1; i < glyphs.length; i += 1) {
          glyph = glyphs.get(i);
          glyphNames.push(glyph.name);
      }

      var strings = [];

      t.header = makeHeader();
      t.nameIndex = makeNameIndex([options.postScriptName]);
      var topDict = makeTopDict(attrs, strings);
      t.topDictIndex = makeTopDictIndex(topDict);
      t.globalSubrIndex = makeGlobalSubrIndex();
      t.charsets = makeCharsets(glyphNames, strings);
      t.charStringsIndex = makeCharStringsIndex(glyphs);
      t.privateDict = makePrivateDict(privateAttrs, strings);

      // Needs to come at the end, to encode all custom strings used in the font.
      t.stringIndex = makeStringIndex(strings);

      var startOffset = t.header.sizeOf() +
          t.nameIndex.sizeOf() +
          t.topDictIndex.sizeOf() +
          t.stringIndex.sizeOf() +
          t.globalSubrIndex.sizeOf();
      attrs.charset = startOffset;

      // We use the CFF standard encoding; proper encoding will be handled in cmap.
      attrs.encoding = 0;
      attrs.charStrings = attrs.charset + t.charsets.sizeOf();
      attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

      // Recreate the Top DICT INDEX with the correct offsets.
      topDict = makeTopDict(attrs, strings);
      t.topDictIndex = makeTopDictIndex(topDict);

      return t;
  }

  var cff = { parse: parseCFFTable, make: makeCFFTable };

  // The `head` table contains global information about the font.

  // Parse the header `head` table
  function parseHeadTable(data, start) {
      var head = {};
      var p = new parse$2.Parser(data, start);
      head.version = p.parseVersion();
      head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
      head.checkSumAdjustment = p.parseULong();
      head.magicNumber = p.parseULong();
      check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
      head.flags = p.parseUShort();
      head.unitsPerEm = p.parseUShort();
      head.created = p.parseLongDateTime();
      head.modified = p.parseLongDateTime();
      head.xMin = p.parseShort();
      head.yMin = p.parseShort();
      head.xMax = p.parseShort();
      head.yMax = p.parseShort();
      head.macStyle = p.parseUShort();
      head.lowestRecPPEM = p.parseUShort();
      head.fontDirectionHint = p.parseShort();
      head.indexToLocFormat = p.parseShort();
      head.glyphDataFormat = p.parseShort();
      return head;
  }

  function makeHeadTable(options) {
      // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
      var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
      var createdTimestamp = timestamp;

      if (options.createdTimestamp) {
          createdTimestamp = options.createdTimestamp + 2082844800;
      }

      return new table$1.Table('head', [
          {name: 'version', type: 'FIXED', value: 0x00010000},
          {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
          {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
          {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
          {name: 'flags', type: 'USHORT', value: 0},
          {name: 'unitsPerEm', type: 'USHORT', value: 1000},
          {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
          {name: 'modified', type: 'LONGDATETIME', value: timestamp},
          {name: 'xMin', type: 'SHORT', value: 0},
          {name: 'yMin', type: 'SHORT', value: 0},
          {name: 'xMax', type: 'SHORT', value: 0},
          {name: 'yMax', type: 'SHORT', value: 0},
          {name: 'macStyle', type: 'USHORT', value: 0},
          {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
          {name: 'fontDirectionHint', type: 'SHORT', value: 2},
          {name: 'indexToLocFormat', type: 'SHORT', value: 0},
          {name: 'glyphDataFormat', type: 'SHORT', value: 0}
      ], options);
  }

  var head$1 = { parse: parseHeadTable, make: makeHeadTable };

  // The `hhea` table contains information for horizontal layout.

  // Parse the horizontal header `hhea` table
  function parseHheaTable(data, start) {
      var hhea = {};
      var p = new parse$2.Parser(data, start);
      hhea.version = p.parseVersion();
      hhea.ascender = p.parseShort();
      hhea.descender = p.parseShort();
      hhea.lineGap = p.parseShort();
      hhea.advanceWidthMax = p.parseUShort();
      hhea.minLeftSideBearing = p.parseShort();
      hhea.minRightSideBearing = p.parseShort();
      hhea.xMaxExtent = p.parseShort();
      hhea.caretSlopeRise = p.parseShort();
      hhea.caretSlopeRun = p.parseShort();
      hhea.caretOffset = p.parseShort();
      p.relativeOffset += 8;
      hhea.metricDataFormat = p.parseShort();
      hhea.numberOfHMetrics = p.parseUShort();
      return hhea;
  }

  function makeHheaTable(options) {
      return new table$1.Table('hhea', [
          {name: 'version', type: 'FIXED', value: 0x00010000},
          {name: 'ascender', type: 'FWORD', value: 0},
          {name: 'descender', type: 'FWORD', value: 0},
          {name: 'lineGap', type: 'FWORD', value: 0},
          {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
          {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
          {name: 'minRightSideBearing', type: 'FWORD', value: 0},
          {name: 'xMaxExtent', type: 'FWORD', value: 0},
          {name: 'caretSlopeRise', type: 'SHORT', value: 1},
          {name: 'caretSlopeRun', type: 'SHORT', value: 0},
          {name: 'caretOffset', type: 'SHORT', value: 0},
          {name: 'reserved1', type: 'SHORT', value: 0},
          {name: 'reserved2', type: 'SHORT', value: 0},
          {name: 'reserved3', type: 'SHORT', value: 0},
          {name: 'reserved4', type: 'SHORT', value: 0},
          {name: 'metricDataFormat', type: 'SHORT', value: 0},
          {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
      ], options);
  }

  var hhea$1 = { parse: parseHheaTable, make: makeHheaTable };

  // The `hmtx` table contains the horizontal metrics for all glyphs.

  function parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs) {
      var advanceWidth;
      var leftSideBearing;
      var p = new parse$2.Parser(data, start);
      for (var i = 0; i < numGlyphs; i += 1) {
          // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
          if (i < numMetrics) {
              advanceWidth = p.parseUShort();
              leftSideBearing = p.parseShort();
          }

          var glyph = glyphs.get(i);
          glyph.advanceWidth = advanceWidth;
          glyph.leftSideBearing = leftSideBearing;
      }
  }

  function parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs) {
      font._hmtxTableData = {};

      var advanceWidth;
      var leftSideBearing;
      var p = new parse$2.Parser(data, start);
      for (var i = 0; i < numGlyphs; i += 1) {
          // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
          if (i < numMetrics) {
              advanceWidth = p.parseUShort();
              leftSideBearing = p.parseShort();
          }

          font._hmtxTableData[i] = {
              advanceWidth: advanceWidth,
              leftSideBearing: leftSideBearing
          };
      }
  }

  // Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
  // This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
  function parseHmtxTable(font, data, start, numMetrics, numGlyphs, glyphs, opt) {
      if (opt.lowMemory)
          { parseHmtxTableOnLowMemory(font, data, start, numMetrics, numGlyphs); }
      else
          { parseHmtxTableAll(data, start, numMetrics, numGlyphs, glyphs); }
  }

  function makeHmtxTable(glyphs) {
      var t = new table$1.Table('hmtx', []);
      for (var i = 0; i < glyphs.length; i += 1) {
          var glyph = glyphs.get(i);
          var advanceWidth = glyph.advanceWidth || 0;
          var leftSideBearing = glyph.leftSideBearing || 0;
          t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
          t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
      }

      return t;
  }

  var hmtx$1 = { parse: parseHmtxTable, make: makeHmtxTable };

  // The `ltag` table stores IETF BCP-47 language tags. It allows supporting

  function makeLtagTable(tags) {
      var result = new table$1.Table('ltag', [
          {name: 'version', type: 'ULONG', value: 1},
          {name: 'flags', type: 'ULONG', value: 0},
          {name: 'numTags', type: 'ULONG', value: tags.length}
      ]);

      var stringPool = '';
      var stringPoolOffset = 12 + tags.length * 4;
      for (var i = 0; i < tags.length; ++i) {
          var pos = stringPool.indexOf(tags[i]);
          if (pos < 0) {
              pos = stringPool.length;
              stringPool += tags[i];
          }

          result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
          result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
      }

      result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
      return result;
  }

  function parseLtagTable(data, start) {
      var p = new parse$2.Parser(data, start);
      var tableVersion = p.parseULong();
      check.argument(tableVersion === 1, 'Unsupported ltag table version.');
      // The 'ltag' specification does not define any flags; skip the field.
      p.skip('uLong', 1);
      var numTags = p.parseULong();

      var tags = [];
      for (var i = 0; i < numTags; i++) {
          var tag = '';
          var offset = start + p.parseUShort();
          var length = p.parseUShort();
          for (var j = offset; j < offset + length; ++j) {
              tag += String.fromCharCode(data.getInt8(j));
          }

          tags.push(tag);
      }

      return tags;
  }

  var ltag = { make: makeLtagTable, parse: parseLtagTable };

  // The `maxp` table establishes the memory requirements for the font.

  // Parse the maximum profile `maxp` table.
  function parseMaxpTable(data, start) {
      var maxp = {};
      var p = new parse$2.Parser(data, start);
      maxp.version = p.parseVersion();
      maxp.numGlyphs = p.parseUShort();
      if (maxp.version === 1.0) {
          maxp.maxPoints = p.parseUShort();
          maxp.maxContours = p.parseUShort();
          maxp.maxCompositePoints = p.parseUShort();
          maxp.maxCompositeContours = p.parseUShort();
          maxp.maxZones = p.parseUShort();
          maxp.maxTwilightPoints = p.parseUShort();
          maxp.maxStorage = p.parseUShort();
          maxp.maxFunctionDefs = p.parseUShort();
          maxp.maxInstructionDefs = p.parseUShort();
          maxp.maxStackElements = p.parseUShort();
          maxp.maxSizeOfInstructions = p.parseUShort();
          maxp.maxComponentElements = p.parseUShort();
          maxp.maxComponentDepth = p.parseUShort();
      }

      return maxp;
  }

  function makeMaxpTable(numGlyphs) {
      return new table$1.Table('maxp', [
          {name: 'version', type: 'FIXED', value: 0x00005000},
          {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
      ]);
  }

  var maxp$1 = { parse: parseMaxpTable, make: makeMaxpTable };

  // The `name` naming table.

  // NameIDs for the name table.
  var nameTableNames = [
      'copyright',              // 0
      'fontFamily',             // 1
      'fontSubfamily',          // 2
      'uniqueID',               // 3
      'fullName',               // 4
      'version',                // 5
      'postScriptName',         // 6
      'trademark',              // 7
      'manufacturer',           // 8
      'designer',               // 9
      'description',            // 10
      'manufacturerURL',        // 11
      'designerURL',            // 12
      'license',                // 13
      'licenseURL',             // 14
      'reserved',               // 15
      'preferredFamily',        // 16
      'preferredSubfamily',     // 17
      'compatibleFullName',     // 18
      'sampleText',             // 19
      'postScriptFindFontName', // 20
      'wwsFamily',              // 21
      'wwsSubfamily'            // 22
  ];

  var macLanguages = {
      0: 'en',
      1: 'fr',
      2: 'de',
      3: 'it',
      4: 'nl',
      5: 'sv',
      6: 'es',
      7: 'da',
      8: 'pt',
      9: 'no',
      10: 'he',
      11: 'ja',
      12: 'ar',
      13: 'fi',
      14: 'el',
      15: 'is',
      16: 'mt',
      17: 'tr',
      18: 'hr',
      19: 'zh-Hant',
      20: 'ur',
      21: 'hi',
      22: 'th',
      23: 'ko',
      24: 'lt',
      25: 'pl',
      26: 'hu',
      27: 'es',
      28: 'lv',
      29: 'se',
      30: 'fo',
      31: 'fa',
      32: 'ru',
      33: 'zh',
      34: 'nl-BE',
      35: 'ga',
      36: 'sq',
      37: 'ro',
      38: 'cz',
      39: 'sk',
      40: 'si',
      41: 'yi',
      42: 'sr',
      43: 'mk',
      44: 'bg',
      45: 'uk',
      46: 'be',
      47: 'uz',
      48: 'kk',
      49: 'az-Cyrl',
      50: 'az-Arab',
      51: 'hy',
      52: 'ka',
      53: 'mo',
      54: 'ky',
      55: 'tg',
      56: 'tk',
      57: 'mn-CN',
      58: 'mn',
      59: 'ps',
      60: 'ks',
      61: 'ku',
      62: 'sd',
      63: 'bo',
      64: 'ne',
      65: 'sa',
      66: 'mr',
      67: 'bn',
      68: 'as',
      69: 'gu',
      70: 'pa',
      71: 'or',
      72: 'ml',
      73: 'kn',
      74: 'ta',
      75: 'te',
      76: 'si',
      77: 'my',
      78: 'km',
      79: 'lo',
      80: 'vi',
      81: 'id',
      82: 'tl',
      83: 'ms',
      84: 'ms-Arab',
      85: 'am',
      86: 'ti',
      87: 'om',
      88: 'so',
      89: 'sw',
      90: 'rw',
      91: 'rn',
      92: 'ny',
      93: 'mg',
      94: 'eo',
      128: 'cy',
      129: 'eu',
      130: 'ca',
      131: 'la',
      132: 'qu',
      133: 'gn',
      134: 'ay',
      135: 'tt',
      136: 'ug',
      137: 'dz',
      138: 'jv',
      139: 'su',
      140: 'gl',
      141: 'af',
      142: 'br',
      143: 'iu',
      144: 'gd',
      145: 'gv',
      146: 'ga',
      147: 'to',
      148: 'el-polyton',
      149: 'kl',
      150: 'az',
      151: 'nn'
  };

  // MacOS language ID  MacOS script ID
  //
  // Note that the script ID is not sufficient to determine what encoding
  // to use in TrueType files. For some languages, MacOS used a modification
  // of a mainstream script. For example, an Icelandic name would be stored
  // with smRoman in the TrueType naming table, but the actual encoding
  // is a special Icelandic version of the normal Macintosh Roman encoding.
  // As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
  // Syllables but MacOS had run out of available script codes, so this was
  // done as a (pretty radical) "modification" of Ethiopic.
  //
  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
  var macLanguageToScript = {
      0: 0,  // langEnglish  smRoman
      1: 0,  // langFrench  smRoman
      2: 0,  // langGerman  smRoman
      3: 0,  // langItalian  smRoman
      4: 0,  // langDutch  smRoman
      5: 0,  // langSwedish  smRoman
      6: 0,  // langSpanish  smRoman
      7: 0,  // langDanish  smRoman
      8: 0,  // langPortuguese  smRoman
      9: 0,  // langNorwegian  smRoman
      10: 5,  // langHebrew  smHebrew
      11: 1,  // langJapanese  smJapanese
      12: 4,  // langArabic  smArabic
      13: 0,  // langFinnish  smRoman
      14: 6,  // langGreek  smGreek
      15: 0,  // langIcelandic  smRoman (modified)
      16: 0,  // langMaltese  smRoman
      17: 0,  // langTurkish  smRoman (modified)
      18: 0,  // langCroatian  smRoman (modified)
      19: 2,  // langTradChinese  smTradChinese
      20: 4,  // langUrdu  smArabic
      21: 9,  // langHindi  smDevanagari
      22: 21,  // langThai  smThai
      23: 3,  // langKorean  smKorean
      24: 29,  // langLithuanian  smCentralEuroRoman
      25: 29,  // langPolish  smCentralEuroRoman
      26: 29,  // langHungarian  smCentralEuroRoman
      27: 29,  // langEstonian  smCentralEuroRoman
      28: 29,  // langLatvian  smCentralEuroRoman
      29: 0,  // langSami  smRoman
      30: 0,  // langFaroese  smRoman (modified)
      31: 4,  // langFarsi  smArabic (modified)
      32: 7,  // langRussian  smCyrillic
      33: 25,  // langSimpChinese  smSimpChinese
      34: 0,  // langFlemish  smRoman
      35: 0,  // langIrishGaelic  smRoman (modified)
      36: 0,  // langAlbanian  smRoman
      37: 0,  // langRomanian  smRoman (modified)
      38: 29,  // langCzech  smCentralEuroRoman
      39: 29,  // langSlovak  smCentralEuroRoman
      40: 0,  // langSlovenian  smRoman (modified)
      41: 5,  // langYiddish  smHebrew
      42: 7,  // langSerbian  smCyrillic
      43: 7,  // langMacedonian  smCyrillic
      44: 7,  // langBulgarian  smCyrillic
      45: 7,  // langUkrainian  smCyrillic (modified)
      46: 7,  // langByelorussian  smCyrillic
      47: 7,  // langUzbek  smCyrillic
      48: 7,  // langKazakh  smCyrillic
      49: 7,  // langAzerbaijani  smCyrillic
      50: 4,  // langAzerbaijanAr  smArabic
      51: 24,  // langArmenian  smArmenian
      52: 23,  // langGeorgian  smGeorgian
      53: 7,  // langMoldavian  smCyrillic
      54: 7,  // langKirghiz  smCyrillic
      55: 7,  // langTajiki  smCyrillic
      56: 7,  // langTurkmen  smCyrillic
      57: 27,  // langMongolian  smMongolian
      58: 7,  // langMongolianCyr  smCyrillic
      59: 4,  // langPashto  smArabic
      60: 4,  // langKurdish  smArabic
      61: 4,  // langKashmiri  smArabic
      62: 4,  // langSindhi  smArabic
      63: 26,  // langTibetan  smTibetan
      64: 9,  // langNepali  smDevanagari
      65: 9,  // langSanskrit  smDevanagari
      66: 9,  // langMarathi  smDevanagari
      67: 13,  // langBengali  smBengali
      68: 13,  // langAssamese  smBengali
      69: 11,  // langGujarati  smGujarati
      70: 10,  // langPunjabi  smGurmukhi
      71: 12,  // langOriya  smOriya
      72: 17,  // langMalayalam  smMalayalam
      73: 16,  // langKannada  smKannada
      74: 14,  // langTamil  smTamil
      75: 15,  // langTelugu  smTelugu
      76: 18,  // langSinhalese  smSinhalese
      77: 19,  // langBurmese  smBurmese
      78: 20,  // langKhmer  smKhmer
      79: 22,  // langLao  smLao
      80: 30,  // langVietnamese  smVietnamese
      81: 0,  // langIndonesian  smRoman
      82: 0,  // langTagalog  smRoman
      83: 0,  // langMalayRoman  smRoman
      84: 4,  // langMalayArabic  smArabic
      85: 28,  // langAmharic  smEthiopic
      86: 28,  // langTigrinya  smEthiopic
      87: 28,  // langOromo  smEthiopic
      88: 0,  // langSomali  smRoman
      89: 0,  // langSwahili  smRoman
      90: 0,  // langKinyarwanda  smRoman
      91: 0,  // langRundi  smRoman
      92: 0,  // langNyanja  smRoman
      93: 0,  // langMalagasy  smRoman
      94: 0,  // langEsperanto  smRoman
      128: 0,  // langWelsh  smRoman (modified)
      129: 0,  // langBasque  smRoman
      130: 0,  // langCatalan  smRoman
      131: 0,  // langLatin  smRoman
      132: 0,  // langQuechua  smRoman
      133: 0,  // langGuarani  smRoman
      134: 0,  // langAymara  smRoman
      135: 7,  // langTatar  smCyrillic
      136: 4,  // langUighur  smArabic
      137: 26,  // langDzongkha  smTibetan
      138: 0,  // langJavaneseRom  smRoman
      139: 0,  // langSundaneseRom  smRoman
      140: 0,  // langGalician  smRoman
      141: 0,  // langAfrikaans  smRoman
      142: 0,  // langBreton  smRoman (modified)
      143: 28,  // langInuktitut  smEthiopic (modified)
      144: 0,  // langScottishGaelic  smRoman (modified)
      145: 0,  // langManxGaelic  smRoman (modified)
      146: 0,  // langIrishGaelicScript  smRoman (modified)
      147: 0,  // langTongan  smRoman
      148: 6,  // langGreekAncient  smRoman
      149: 0,  // langGreenlandic  smRoman
      150: 0,  // langAzerbaijanRoman  smRoman
      151: 0   // langNynorsk  smRoman
  };

  // While Microsoft indicates a region/country for all its language
  // IDs, we omit the region code if it's equal to the "most likely
  // region subtag" according to Unicode CLDR. For scripts, we omit
  // the subtag if it is equal to the Suppress-Script entry in the
  // IANA language subtag registry for IETF BCP 47.
  //
  // For example, Microsoft states that its language code 0x041A is
  // Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
  // and not 'hr-HR' because Croatia is the default country for Croatian,
  // according to Unicode CLDR. As another example, Microsoft states
  // that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
  // this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
  // for the Croatian language, according to IANA.
  //
  // http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
  // http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
  var windowsLanguages = {
      0x0436: 'af',
      0x041C: 'sq',
      0x0484: 'gsw',
      0x045E: 'am',
      0x1401: 'ar-DZ',
      0x3C01: 'ar-BH',
      0x0C01: 'ar',
      0x0801: 'ar-IQ',
      0x2C01: 'ar-JO',
      0x3401: 'ar-KW',
      0x3001: 'ar-LB',
      0x1001: 'ar-LY',
      0x1801: 'ary',
      0x2001: 'ar-OM',
      0x4001: 'ar-QA',
      0x0401: 'ar-SA',
      0x2801: 'ar-SY',
      0x1C01: 'aeb',
      0x3801: 'ar-AE',
      0x2401: 'ar-YE',
      0x042B: 'hy',
      0x044D: 'as',
      0x082C: 'az-Cyrl',
      0x042C: 'az',
      0x046D: 'ba',
      0x042D: 'eu',
      0x0423: 'be',
      0x0845: 'bn',
      0x0445: 'bn-IN',
      0x201A: 'bs-Cyrl',
      0x141A: 'bs',
      0x047E: 'br',
      0x0402: 'bg',
      0x0403: 'ca',
      0x0C04: 'zh-HK',
      0x1404: 'zh-MO',
      0x0804: 'zh',
      0x1004: 'zh-SG',
      0x0404: 'zh-TW',
      0x0483: 'co',
      0x041A: 'hr',
      0x101A: 'hr-BA',
      0x0405: 'cs',
      0x0406: 'da',
      0x048C: 'prs',
      0x0465: 'dv',
      0x0813: 'nl-BE',
      0x0413: 'nl',
      0x0C09: 'en-AU',
      0x2809: 'en-BZ',
      0x1009: 'en-CA',
      0x2409: 'en-029',
      0x4009: 'en-IN',
      0x1809: 'en-IE',
      0x2009: 'en-JM',
      0x4409: 'en-MY',
      0x1409: 'en-NZ',
      0x3409: 'en-PH',
      0x4809: 'en-SG',
      0x1C09: 'en-ZA',
      0x2C09: 'en-TT',
      0x0809: 'en-GB',
      0x0409: 'en',
      0x3009: 'en-ZW',
      0x0425: 'et',
      0x0438: 'fo',
      0x0464: 'fil',
      0x040B: 'fi',
      0x080C: 'fr-BE',
      0x0C0C: 'fr-CA',
      0x040C: 'fr',
      0x140C: 'fr-LU',
      0x180C: 'fr-MC',
      0x100C: 'fr-CH',
      0x0462: 'fy',
      0x0456: 'gl',
      0x0437: 'ka',
      0x0C07: 'de-AT',
      0x0407: 'de',
      0x1407: 'de-LI',
      0x1007: 'de-LU',
      0x0807: 'de-CH',
      0x0408: 'el',
      0x046F: 'kl',
      0x0447: 'gu',
      0x0468: 'ha',
      0x040D: 'he',
      0x0439: 'hi',
      0x040E: 'hu',
      0x040F: 'is',
      0x0470: 'ig',
      0x0421: 'id',
      0x045D: 'iu',
      0x085D: 'iu-Latn',
      0x083C: 'ga',
      0x0434: 'xh',
      0x0435: 'zu',
      0x0410: 'it',
      0x0810: 'it-CH',
      0x0411: 'ja',
      0x044B: 'kn',
      0x043F: 'kk',
      0x0453: 'km',
      0x0486: 'quc',
      0x0487: 'rw',
      0x0441: 'sw',
      0x0457: 'kok',
      0x0412: 'ko',
      0x0440: 'ky',
      0x0454: 'lo',
      0x0426: 'lv',
      0x0427: 'lt',
      0x082E: 'dsb',
      0x046E: 'lb',
      0x042F: 'mk',
      0x083E: 'ms-BN',
      0x043E: 'ms',
      0x044C: 'ml',
      0x043A: 'mt',
      0x0481: 'mi',
      0x047A: 'arn',
      0x044E: 'mr',
      0x047C: 'moh',
      0x0450: 'mn',
      0x0850: 'mn-CN',
      0x0461: 'ne',
      0x0414: 'nb',
      0x0814: 'nn',
      0x0482: 'oc',
      0x0448: 'or',
      0x0463: 'ps',
      0x0415: 'pl',
      0x0416: 'pt',
      0x0816: 'pt-PT',
      0x0446: 'pa',
      0x046B: 'qu-BO',
      0x086B: 'qu-EC',
      0x0C6B: 'qu',
      0x0418: 'ro',
      0x0417: 'rm',
      0x0419: 'ru',
      0x243B: 'smn',
      0x103B: 'smj-NO',
      0x143B: 'smj',
      0x0C3B: 'se-FI',
      0x043B: 'se',
      0x083B: 'se-SE',
      0x203B: 'sms',
      0x183B: 'sma-NO',
      0x1C3B: 'sms',
      0x044F: 'sa',
      0x1C1A: 'sr-Cyrl-BA',
      0x0C1A: 'sr',
      0x181A: 'sr-Latn-BA',
      0x081A: 'sr-Latn',
      0x046C: 'nso',
      0x0432: 'tn',
      0x045B: 'si',
      0x041B: 'sk',
      0x0424: 'sl',
      0x2C0A: 'es-AR',
      0x400A: 'es-BO',
      0x340A: 'es-CL',
      0x240A: 'es-CO',
      0x140A: 'es-CR',
      0x1C0A: 'es-DO',
      0x300A: 'es-EC',
      0x440A: 'es-SV',
      0x100A: 'es-GT',
      0x480A: 'es-HN',
      0x080A: 'es-MX',
      0x4C0A: 'es-NI',
      0x180A: 'es-PA',
      0x3C0A: 'es-PY',
      0x280A: 'es-PE',
      0x500A: 'es-PR',

      // Microsoft has defined two different language codes for
      // Spanish with modern sorting and Spanish with traditional
      // sorting. This makes sense for collation APIs, and it would be
      // possible to express this in BCP 47 language tags via Unicode
      // extensions (eg., es-u-co-trad is Spanish with traditional
      // sorting). However, for storing names in fonts, the distinction
      // does not make sense, so we give es in both cases.
      0x0C0A: 'es',
      0x040A: 'es',

      0x540A: 'es-US',
      0x380A: 'es-UY',
      0x200A: 'es-VE',
      0x081D: 'sv-FI',
      0x041D: 'sv',
      0x045A: 'syr',
      0x0428: 'tg',
      0x085F: 'tzm',
      0x0449: 'ta',
      0x0444: 'tt',
      0x044A: 'te',
      0x041E: 'th',
      0x0451: 'bo',
      0x041F: 'tr',
      0x0442: 'tk',
      0x0480: 'ug',
      0x0422: 'uk',
      0x042E: 'hsb',
      0x0420: 'ur',
      0x0843: 'uz-Cyrl',
      0x0443: 'uz',
      0x042A: 'vi',
      0x0452: 'cy',
      0x0488: 'wo',
      0x0485: 'sah',
      0x0478: 'ii',
      0x046A: 'yo'
  };

  // Returns a IETF BCP 47 language code, for example 'zh-Hant'
  // for 'Chinese in the traditional script'.
  function getLanguageCode(platformID, languageID, ltag) {
      switch (platformID) {
          case 0:  // Unicode
              if (languageID === 0xFFFF) {
                  return 'und';
              } else if (ltag) {
                  return ltag[languageID];
              }

              break;

          case 1:  // Macintosh
              return macLanguages[languageID];

          case 3:  // Windows
              return windowsLanguages[languageID];
      }

      return undefined;
  }

  var utf16 = 'utf-16';

  // MacOS script ID  encoding. This table stores the default case,
  // which can be overridden by macLanguageEncodings.
  var macScriptEncodings = {
      0: 'macintosh',           // smRoman
      1: 'x-mac-japanese',      // smJapanese
      2: 'x-mac-chinesetrad',   // smTradChinese
      3: 'x-mac-korean',        // smKorean
      6: 'x-mac-greek',         // smGreek
      7: 'x-mac-cyrillic',      // smCyrillic
      9: 'x-mac-devanagai',     // smDevanagari
      10: 'x-mac-gurmukhi',     // smGurmukhi
      11: 'x-mac-gujarati',     // smGujarati
      12: 'x-mac-oriya',        // smOriya
      13: 'x-mac-bengali',      // smBengali
      14: 'x-mac-tamil',        // smTamil
      15: 'x-mac-telugu',       // smTelugu
      16: 'x-mac-kannada',      // smKannada
      17: 'x-mac-malayalam',    // smMalayalam
      18: 'x-mac-sinhalese',    // smSinhalese
      19: 'x-mac-burmese',      // smBurmese
      20: 'x-mac-khmer',        // smKhmer
      21: 'x-mac-thai',         // smThai
      22: 'x-mac-lao',          // smLao
      23: 'x-mac-georgian',     // smGeorgian
      24: 'x-mac-armenian',     // smArmenian
      25: 'x-mac-chinesesimp',  // smSimpChinese
      26: 'x-mac-tibetan',      // smTibetan
      27: 'x-mac-mongolian',    // smMongolian
      28: 'x-mac-ethiopic',     // smEthiopic
      29: 'x-mac-ce',           // smCentralEuroRoman
      30: 'x-mac-vietnamese',   // smVietnamese
      31: 'x-mac-extarabic'     // smExtArabic
  };

  // MacOS language ID  encoding. This table stores the exceptional
  // cases, which override macScriptEncodings. For writing MacOS naming
  // tables, we need to emit a MacOS script ID. Therefore, we cannot
  // merge macScriptEncodings into macLanguageEncodings.
  //
  // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
  var macLanguageEncodings = {
      15: 'x-mac-icelandic',    // langIcelandic
      17: 'x-mac-turkish',      // langTurkish
      18: 'x-mac-croatian',     // langCroatian
      24: 'x-mac-ce',           // langLithuanian
      25: 'x-mac-ce',           // langPolish
      26: 'x-mac-ce',           // langHungarian
      27: 'x-mac-ce',           // langEstonian
      28: 'x-mac-ce',           // langLatvian
      30: 'x-mac-icelandic',    // langFaroese
      37: 'x-mac-romanian',     // langRomanian
      38: 'x-mac-ce',           // langCzech
      39: 'x-mac-ce',           // langSlovak
      40: 'x-mac-ce',           // langSlovenian
      143: 'x-mac-inuit',       // langInuktitut
      146: 'x-mac-gaelic'       // langIrishGaelicScript
  };

  function getEncoding(platformID, encodingID, languageID) {
      switch (platformID) {
          case 0:  // Unicode
              return utf16;

          case 1:  // Apple Macintosh
              return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

          case 3:  // Microsoft Windows
              if (encodingID === 1 || encodingID === 10) {
                  return utf16;
              }

              break;
      }

      return undefined;
  }

  // Parse the naming `name` table.
  // FIXME: Format 1 additional fields are not supported yet.
  // ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
  function parseNameTable(data, start, ltag) {
      var name = {};
      var p = new parse$2.Parser(data, start);
      var format = p.parseUShort();
      var count = p.parseUShort();
      var stringOffset = p.offset + p.parseUShort();
      for (var i = 0; i < count; i++) {
          var platformID = p.parseUShort();
          var encodingID = p.parseUShort();
          var languageID = p.parseUShort();
          var nameID = p.parseUShort();
          var property = nameTableNames[nameID] || nameID;
          var byteLength = p.parseUShort();
          var offset = p.parseUShort();
          var language = getLanguageCode(platformID, languageID, ltag);
          var encoding = getEncoding(platformID, encodingID, languageID);
          if (encoding !== undefined && language !== undefined) {
              var text = (void 0);
              if (encoding === utf16) {
                  text = decode.UTF16(data, stringOffset + offset, byteLength);
              } else {
                  text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
              }

              if (text) {
                  var translations = name[property];
                  if (translations === undefined) {
                      translations = name[property] = {};
                  }

                  translations[language] = text;
              }
          }
      }
      if (format === 1) {
          // FIXME: Also handle Microsoft's 'name' table 1.
          p.parseUShort();
      }

      return name;
  }

  // {23: 'foo'}  {'foo': 23}
  // ['bar', 'baz']  {'bar': 0, 'baz': 1}
  function reverseDict(dict) {
      var result = {};
      for (var key in dict) {
          result[dict[key]] = parseInt(key);
      }

      return result;
  }

  function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
      return new table$1.Record('NameRecord', [
          {name: 'platformID', type: 'USHORT', value: platformID},
          {name: 'encodingID', type: 'USHORT', value: encodingID},
          {name: 'languageID', type: 'USHORT', value: languageID},
          {name: 'nameID', type: 'USHORT', value: nameID},
          {name: 'length', type: 'USHORT', value: length},
          {name: 'offset', type: 'USHORT', value: offset}
      ]);
  }

  // Finds the position of needle in haystack, or -1 if not there.
  // Like String.indexOf(), but for arrays.
  function findSubArray(needle, haystack) {
      var needleLength = needle.length;
      var limit = haystack.length - needleLength + 1;

      loop:
      for (var pos = 0; pos < limit; pos++) {
          for (; pos < limit; pos++) {
              for (var k = 0; k < needleLength; k++) {
                  if (haystack[pos + k] !== needle[k]) {
                      continue loop;
                  }
              }

              return pos;
          }
      }

      return -1;
  }

  function addStringToPool(s, pool) {
      var offset = findSubArray(s, pool);
      if (offset < 0) {
          offset = pool.length;
          var i = 0;
          var len = s.length;
          for (; i < len; ++i) {
              pool.push(s[i]);
          }

      }

      return offset;
  }

  function makeNameTable(names, ltag) {
      var nameID;
      var nameIDs = [];

      var namesWithNumericKeys = {};
      var nameTableIds = reverseDict(nameTableNames);
      for (var key in names) {
          var id = nameTableIds[key];
          if (id === undefined) {
              id = key;
          }

          nameID = parseInt(id);

          if (isNaN(nameID)) {
              throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
          }

          namesWithNumericKeys[nameID] = names[key];
          nameIDs.push(nameID);
      }

      var macLanguageIds = reverseDict(macLanguages);
      var windowsLanguageIds = reverseDict(windowsLanguages);

      var nameRecords = [];
      var stringPool = [];

      for (var i = 0; i < nameIDs.length; i++) {
          nameID = nameIDs[i];
          var translations = namesWithNumericKeys[nameID];
          for (var lang in translations) {
              var text = translations[lang];

              // For MacOS, we try to emit the name in the form that was introduced
              // in the initial version of the TrueType spec (in the late 1980s).
              // However, this can fail for various reasons: the requested BCP 47
              // language code might not have an old-style Mac equivalent;
              // we might not have a codec for the needed character encoding;
              // or the name might contain characters that cannot be expressed
              // in the old-style Macintosh encoding. In case of failure, we emit
              // the name in a more modern fashion (Unicode encoding with BCP 47
              // language tags) that is recognized by MacOS 10.5, released in 2009.
              // If fonts were only read by operating systems, we could simply
              // emit all names in the modern form; this would be much easier.
              // However, there are many applications and libraries that read
              // 'name' tables directly, and these will usually only recognize
              // the ancient form (silently skipping the unrecognized names).
              var macPlatform = 1;  // Macintosh
              var macLanguage = macLanguageIds[lang];
              var macScript = macLanguageToScript[macLanguage];
              var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
              var macName = encode.MACSTRING(text, macEncoding);
              if (macName === undefined) {
                  macPlatform = 0;  // Unicode
                  macLanguage = ltag.indexOf(lang);
                  if (macLanguage < 0) {
                      macLanguage = ltag.length;
                      ltag.push(lang);
                  }

                  macScript = 4;  // Unicode 2.0 and later
                  macName = encode.UTF16(text);
              }

              var macNameOffset = addStringToPool(macName, stringPool);
              nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                                              nameID, macName.length, macNameOffset));

              var winLanguage = windowsLanguageIds[lang];
              if (winLanguage !== undefined) {
                  var winName = encode.UTF16(text);
                  var winNameOffset = addStringToPool(winName, stringPool);
                  nameRecords.push(makeNameRecord(3, 1, winLanguage,
                                                  nameID, winName.length, winNameOffset));
              }
          }
      }

      nameRecords.sort(function(a, b) {
          return ((a.platformID - b.platformID) ||
                  (a.encodingID - b.encodingID) ||
                  (a.languageID - b.languageID) ||
                  (a.nameID - b.nameID));
      });

      var t = new table$1.Table('name', [
          {name: 'format', type: 'USHORT', value: 0},
          {name: 'count', type: 'USHORT', value: nameRecords.length},
          {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
      ]);

      for (var r = 0; r < nameRecords.length; r++) {
          t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
      }

      t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
      return t;
  }

  var _name = { parse: parseNameTable, make: makeNameTable };

  // The `OS/2` table contains metrics required in OpenType fonts.

  var unicodeRanges = [
      {begin: 0x0000, end: 0x007F}, // Basic Latin
      {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
      {begin: 0x0100, end: 0x017F}, // Latin Extended-A
      {begin: 0x0180, end: 0x024F}, // Latin Extended-B
      {begin: 0x0250, end: 0x02AF}, // IPA Extensions
      {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
      {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
      {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
      {begin: 0x2C80, end: 0x2CFF}, // Coptic
      {begin: 0x0400, end: 0x04FF}, // Cyrillic
      {begin: 0x0530, end: 0x058F}, // Armenian
      {begin: 0x0590, end: 0x05FF}, // Hebrew
      {begin: 0xA500, end: 0xA63F}, // Vai
      {begin: 0x0600, end: 0x06FF}, // Arabic
      {begin: 0x07C0, end: 0x07FF}, // NKo
      {begin: 0x0900, end: 0x097F}, // Devanagari
      {begin: 0x0980, end: 0x09FF}, // Bengali
      {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
      {begin: 0x0A80, end: 0x0AFF}, // Gujarati
      {begin: 0x0B00, end: 0x0B7F}, // Oriya
      {begin: 0x0B80, end: 0x0BFF}, // Tamil
      {begin: 0x0C00, end: 0x0C7F}, // Telugu
      {begin: 0x0C80, end: 0x0CFF}, // Kannada
      {begin: 0x0D00, end: 0x0D7F}, // Malayalam
      {begin: 0x0E00, end: 0x0E7F}, // Thai
      {begin: 0x0E80, end: 0x0EFF}, // Lao
      {begin: 0x10A0, end: 0x10FF}, // Georgian
      {begin: 0x1B00, end: 0x1B7F}, // Balinese
      {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
      {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
      {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
      {begin: 0x2000, end: 0x206F}, // General Punctuation
      {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
      {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
      {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
      {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
      {begin: 0x2150, end: 0x218F}, // Number Forms
      {begin: 0x2190, end: 0x21FF}, // Arrows
      {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
      {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
      {begin: 0x2400, end: 0x243F}, // Control Pictures
      {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
      {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
      {begin: 0x2500, end: 0x257F}, // Box Drawing
      {begin: 0x2580, end: 0x259F}, // Block Elements
      {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
      {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
      {begin: 0x2700, end: 0x27BF}, // Dingbats
      {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
      {begin: 0x3040, end: 0x309F}, // Hiragana
      {begin: 0x30A0, end: 0x30FF}, // Katakana
      {begin: 0x3100, end: 0x312F}, // Bopomofo
      {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
      {begin: 0xA840, end: 0xA87F}, // Phags-pa
      {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
      {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
      {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
      {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
      {begin: 0x10900, end: 0x1091F}, // Phoenicia
      {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
      {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
      {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
      {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
      {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
      {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
      {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
      {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
      {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
      {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
      {begin: 0xFFF0, end: 0xFFFF}, // Specials
      {begin: 0x0F00, end: 0x0FFF}, // Tibetan
      {begin: 0x0700, end: 0x074F}, // Syriac
      {begin: 0x0780, end: 0x07BF}, // Thaana
      {begin: 0x0D80, end: 0x0DFF}, // Sinhala
      {begin: 0x1000, end: 0x109F}, // Myanmar
      {begin: 0x1200, end: 0x137F}, // Ethiopic
      {begin: 0x13A0, end: 0x13FF}, // Cherokee
      {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
      {begin: 0x1680, end: 0x169F}, // Ogham
      {begin: 0x16A0, end: 0x16FF}, // Runic
      {begin: 0x1780, end: 0x17FF}, // Khmer
      {begin: 0x1800, end: 0x18AF}, // Mongolian
      {begin: 0x2800, end: 0x28FF}, // Braille Patterns
      {begin: 0xA000, end: 0xA48F}, // Yi Syllables
      {begin: 0x1700, end: 0x171F}, // Tagalog
      {begin: 0x10300, end: 0x1032F}, // Old Italic
      {begin: 0x10330, end: 0x1034F}, // Gothic
      {begin: 0x10400, end: 0x1044F}, // Deseret
      {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
      {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
      {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
      {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
      {begin: 0xE0000, end: 0xE007F}, // Tags
      {begin: 0x1900, end: 0x194F}, // Limbu
      {begin: 0x1950, end: 0x197F}, // Tai Le
      {begin: 0x1980, end: 0x19DF}, // New Tai Lue
      {begin: 0x1A00, end: 0x1A1F}, // Buginese
      {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
      {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
      {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
      {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
      {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
      {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
      {begin: 0x10380, end: 0x1039F}, // Ugaritic
      {begin: 0x103A0, end: 0x103DF}, // Old Persian
      {begin: 0x10450, end: 0x1047F}, // Shavian
      {begin: 0x10480, end: 0x104AF}, // Osmanya
      {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
      {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
      {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
      {begin: 0x12000, end: 0x123FF}, // Cuneiform
      {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
      {begin: 0x1B80, end: 0x1BBF}, // Sundanese
      {begin: 0x1C00, end: 0x1C4F}, // Lepcha
      {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
      {begin: 0xA880, end: 0xA8DF}, // Saurashtra
      {begin: 0xA900, end: 0xA92F}, // Kayah Li
      {begin: 0xA930, end: 0xA95F}, // Rejang
      {begin: 0xAA00, end: 0xAA5F}, // Cham
      {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
      {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
      {begin: 0x102A0, end: 0x102DF}, // Carian
      {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
  ];

  function getUnicodeRange(unicode) {
      for (var i = 0; i < unicodeRanges.length; i += 1) {
          var range = unicodeRanges[i];
          if (unicode >= range.begin && unicode < range.end) {
              return i;
          }
      }

      return -1;
  }

  // Parse the OS/2 and Windows metrics `OS/2` table
  function parseOS2Table(data, start) {
      var os2 = {};
      var p = new parse$2.Parser(data, start);
      os2.version = p.parseUShort();
      os2.xAvgCharWidth = p.parseShort();
      os2.usWeightClass = p.parseUShort();
      os2.usWidthClass = p.parseUShort();
      os2.fsType = p.parseUShort();
      os2.ySubscriptXSize = p.parseShort();
      os2.ySubscriptYSize = p.parseShort();
      os2.ySubscriptXOffset = p.parseShort();
      os2.ySubscriptYOffset = p.parseShort();
      os2.ySuperscriptXSize = p.parseShort();
      os2.ySuperscriptYSize = p.parseShort();
      os2.ySuperscriptXOffset = p.parseShort();
      os2.ySuperscriptYOffset = p.parseShort();
      os2.yStrikeoutSize = p.parseShort();
      os2.yStrikeoutPosition = p.parseShort();
      os2.sFamilyClass = p.parseShort();
      os2.panose = [];
      for (var i = 0; i < 10; i++) {
          os2.panose[i] = p.parseByte();
      }

      os2.ulUnicodeRange1 = p.parseULong();
      os2.ulUnicodeRange2 = p.parseULong();
      os2.ulUnicodeRange3 = p.parseULong();
      os2.ulUnicodeRange4 = p.parseULong();
      os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
      os2.fsSelection = p.parseUShort();
      os2.usFirstCharIndex = p.parseUShort();
      os2.usLastCharIndex = p.parseUShort();
      os2.sTypoAscender = p.parseShort();
      os2.sTypoDescender = p.parseShort();
      os2.sTypoLineGap = p.parseShort();
      os2.usWinAscent = p.parseUShort();
      os2.usWinDescent = p.parseUShort();
      if (os2.version >= 1) {
          os2.ulCodePageRange1 = p.parseULong();
          os2.ulCodePageRange2 = p.parseULong();
      }

      if (os2.version >= 2) {
          os2.sxHeight = p.parseShort();
          os2.sCapHeight = p.parseShort();
          os2.usDefaultChar = p.parseUShort();
          os2.usBreakChar = p.parseUShort();
          os2.usMaxContent = p.parseUShort();
      }

      return os2;
  }

  function makeOS2Table(options) {
      return new table$1.Table('OS/2', [
          {name: 'version', type: 'USHORT', value: 0x0003},
          {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
          {name: 'usWeightClass', type: 'USHORT', value: 0},
          {name: 'usWidthClass', type: 'USHORT', value: 0},
          {name: 'fsType', type: 'USHORT', value: 0},
          {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
          {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
          {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
          {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
          {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
          {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
          {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
          {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
          {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
          {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
          {name: 'sFamilyClass', type: 'SHORT', value: 0},
          {name: 'bFamilyType', type: 'BYTE', value: 0},
          {name: 'bSerifStyle', type: 'BYTE', value: 0},
          {name: 'bWeight', type: 'BYTE', value: 0},
          {name: 'bProportion', type: 'BYTE', value: 0},
          {name: 'bContrast', type: 'BYTE', value: 0},
          {name: 'bStrokeVariation', type: 'BYTE', value: 0},
          {name: 'bArmStyle', type: 'BYTE', value: 0},
          {name: 'bLetterform', type: 'BYTE', value: 0},
          {name: 'bMidline', type: 'BYTE', value: 0},
          {name: 'bXHeight', type: 'BYTE', value: 0},
          {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
          {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
          {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
          {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
          {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
          {name: 'fsSelection', type: 'USHORT', value: 0},
          {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
          {name: 'usLastCharIndex', type: 'USHORT', value: 0},
          {name: 'sTypoAscender', type: 'SHORT', value: 0},
          {name: 'sTypoDescender', type: 'SHORT', value: 0},
          {name: 'sTypoLineGap', type: 'SHORT', value: 0},
          {name: 'usWinAscent', type: 'USHORT', value: 0},
          {name: 'usWinDescent', type: 'USHORT', value: 0},
          {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
          {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
          {name: 'sxHeight', type: 'SHORT', value: 0},
          {name: 'sCapHeight', type: 'SHORT', value: 0},
          {name: 'usDefaultChar', type: 'USHORT', value: 0},
          {name: 'usBreakChar', type: 'USHORT', value: 0},
          {name: 'usMaxContext', type: 'USHORT', value: 0}
      ], options);
  }

  var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

  // The `post` table stores additional PostScript information, such as glyph names.

  // Parse the PostScript `post` table
  function parsePostTable(data, start) {
      var post = {};
      var p = new parse$2.Parser(data, start);
      post.version = p.parseVersion();
      post.italicAngle = p.parseFixed();
      post.underlinePosition = p.parseShort();
      post.underlineThickness = p.parseShort();
      post.isFixedPitch = p.parseULong();
      post.minMemType42 = p.parseULong();
      post.maxMemType42 = p.parseULong();
      post.minMemType1 = p.parseULong();
      post.maxMemType1 = p.parseULong();
      switch (post.version) {
          case 1:
              post.names = standardNames.slice();
              break;
          case 2:
              post.numberOfGlyphs = p.parseUShort();
              post.glyphNameIndex = new Array(post.numberOfGlyphs);
              for (var i = 0; i < post.numberOfGlyphs; i++) {
                  post.glyphNameIndex[i] = p.parseUShort();
              }

              post.names = [];
              for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                  if (post.glyphNameIndex[i$1] >= standardNames.length) {
                      var nameLength = p.parseChar();
                      post.names.push(p.parseString(nameLength));
                  }
              }

              break;
          case 2.5:
              post.numberOfGlyphs = p.parseUShort();
              post.offset = new Array(post.numberOfGlyphs);
              for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
                  post.offset[i$2] = p.parseChar();
              }

              break;
      }
      return post;
  }

  function makePostTable() {
      return new table$1.Table('post', [
          {name: 'version', type: 'FIXED', value: 0x00030000},
          {name: 'italicAngle', type: 'FIXED', value: 0},
          {name: 'underlinePosition', type: 'FWORD', value: 0},
          {name: 'underlineThickness', type: 'FWORD', value: 0},
          {name: 'isFixedPitch', type: 'ULONG', value: 0},
          {name: 'minMemType42', type: 'ULONG', value: 0},
          {name: 'maxMemType42', type: 'ULONG', value: 0},
          {name: 'minMemType1', type: 'ULONG', value: 0},
          {name: 'maxMemType1', type: 'ULONG', value: 0}
      ]);
  }

  var post$1 = { parse: parsePostTable, make: makePostTable };

  // The `GSUB` table contains ligatures, among other things.

  var subtableParsers = new Array(9);         // subtableParsers[0] is unused

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
  subtableParsers[1] = function parseLookup1() {
      var start = this.offset + this.relativeOffset;
      var substFormat = this.parseUShort();
      if (substFormat === 1) {
          return {
              substFormat: 1,
              coverage: this.parsePointer(Parser.coverage),
              deltaGlyphId: this.parseUShort()
          };
      } else if (substFormat === 2) {
          return {
              substFormat: 2,
              coverage: this.parsePointer(Parser.coverage),
              substitute: this.parseOffset16List()
          };
      }
      check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
  subtableParsers[2] = function parseLookup2() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
      return {
          substFormat: substFormat,
          coverage: this.parsePointer(Parser.coverage),
          sequences: this.parseListOfLists()
      };
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
  subtableParsers[3] = function parseLookup3() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
      return {
          substFormat: substFormat,
          coverage: this.parsePointer(Parser.coverage),
          alternateSets: this.parseListOfLists()
      };
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
  subtableParsers[4] = function parseLookup4() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
      return {
          substFormat: substFormat,
          coverage: this.parsePointer(Parser.coverage),
          ligatureSets: this.parseListOfLists(function() {
              return {
                  ligGlyph: this.parseUShort(),
                  components: this.parseUShortList(this.parseUShort() - 1)
              };
          })
      };
  };

  var lookupRecordDesc = {
      sequenceIndex: Parser.uShort,
      lookupListIndex: Parser.uShort
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
  subtableParsers[5] = function parseLookup5() {
      var start = this.offset + this.relativeOffset;
      var substFormat = this.parseUShort();

      if (substFormat === 1) {
          return {
              substFormat: substFormat,
              coverage: this.parsePointer(Parser.coverage),
              ruleSets: this.parseListOfLists(function() {
                  var glyphCount = this.parseUShort();
                  var substCount = this.parseUShort();
                  return {
                      input: this.parseUShortList(glyphCount - 1),
                      lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                  };
              })
          };
      } else if (substFormat === 2) {
          return {
              substFormat: substFormat,
              coverage: this.parsePointer(Parser.coverage),
              classDef: this.parsePointer(Parser.classDef),
              classSets: this.parseListOfLists(function() {
                  var glyphCount = this.parseUShort();
                  var substCount = this.parseUShort();
                  return {
                      classes: this.parseUShortList(glyphCount - 1),
                      lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                  };
              })
          };
      } else if (substFormat === 3) {
          var glyphCount = this.parseUShort();
          var substCount = this.parseUShort();
          return {
              substFormat: substFormat,
              coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
              lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
          };
      }
      check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
  subtableParsers[6] = function parseLookup6() {
      var start = this.offset + this.relativeOffset;
      var substFormat = this.parseUShort();
      if (substFormat === 1) {
          return {
              substFormat: 1,
              coverage: this.parsePointer(Parser.coverage),
              chainRuleSets: this.parseListOfLists(function() {
                  return {
                      backtrack: this.parseUShortList(),
                      input: this.parseUShortList(this.parseShort() - 1),
                      lookahead: this.parseUShortList(),
                      lookupRecords: this.parseRecordList(lookupRecordDesc)
                  };
              })
          };
      } else if (substFormat === 2) {
          return {
              substFormat: 2,
              coverage: this.parsePointer(Parser.coverage),
              backtrackClassDef: this.parsePointer(Parser.classDef),
              inputClassDef: this.parsePointer(Parser.classDef),
              lookaheadClassDef: this.parsePointer(Parser.classDef),
              chainClassSet: this.parseListOfLists(function() {
                  return {
                      backtrack: this.parseUShortList(),
                      input: this.parseUShortList(this.parseShort() - 1),
                      lookahead: this.parseUShortList(),
                      lookupRecords: this.parseRecordList(lookupRecordDesc)
                  };
              })
          };
      } else if (substFormat === 3) {
          return {
              substFormat: 3,
              backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
              inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
              lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
              lookupRecords: this.parseRecordList(lookupRecordDesc)
          };
      }
      check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
  subtableParsers[7] = function parseLookup7() {
      // Extension Substitution subtable
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
      var extensionLookupType = this.parseUShort();
      var extensionParser = new Parser(this.data, this.offset + this.parseULong());
      return {
          substFormat: 1,
          lookupType: extensionLookupType,
          extension: subtableParsers[extensionLookupType].call(extensionParser)
      };
  };

  // https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
  subtableParsers[8] = function parseLookup8() {
      var substFormat = this.parseUShort();
      check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
      return {
          substFormat: substFormat,
          coverage: this.parsePointer(Parser.coverage),
          backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
          lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
          substitutes: this.parseUShortList()
      };
  };

  // https://www.microsoft.com/typography/OTSPEC/gsub.htm
  function parseGsubTable(data, start) {
      start = start || 0;
      var p = new Parser(data, start);
      var tableVersion = p.parseVersion(1);
      check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
      if (tableVersion === 1) {
          return {
              version: tableVersion,
              scripts: p.parseScriptList(),
              features: p.parseFeatureList(),
              lookups: p.parseLookupList(subtableParsers)
          };
      } else {
          return {
              version: tableVersion,
              scripts: p.parseScriptList(),
              features: p.parseFeatureList(),
              lookups: p.parseLookupList(subtableParsers),
              variations: p.parseFeatureVariationsList()
          };
      }

  }

  // GSUB Writing //////////////////////////////////////////////
  var subtableMakers = new Array(9);

  subtableMakers[1] = function makeLookup1(subtable) {
      if (subtable.substFormat === 1) {
          return new table$1.Table('substitutionTable', [
              {name: 'substFormat', type: 'USHORT', value: 1},
              {name: 'coverage', type: 'TABLE', value: new table$1.Coverage(subtable.coverage)},
              {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
          ]);
      } else {
          return new table$1.Table('substitutionTable', [
              {name: 'substFormat', type: 'USHORT', value: 2},
              {name: 'coverage', type: 'TABLE', value: new table$1.Coverage(subtable.coverage)}
          ].concat(table$1.ushortList('substitute', subtable.substitute)));
      }
  };

  subtableMakers[2] = function makeLookup2(subtable) {
      check.assert(subtable.substFormat === 1, 'Lookup type 2 substFormat must be 1.');
      return new table$1.Table('substitutionTable', [
          {name: 'substFormat', type: 'USHORT', value: 1},
          {name: 'coverage', type: 'TABLE', value: new table$1.Coverage(subtable.coverage)}
      ].concat(table$1.tableList('seqSet', subtable.sequences, function(sequenceSet) {
          return new table$1.Table('sequenceSetTable', table$1.ushortList('sequence', sequenceSet));
      })));
  };

  subtableMakers[3] = function makeLookup3(subtable) {
      check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
      return new table$1.Table('substitutionTable', [
          {name: 'substFormat', type: 'USHORT', value: 1},
          {name: 'coverage', type: 'TABLE', value: new table$1.Coverage(subtable.coverage)}
      ].concat(table$1.tableList('altSet', subtable.alternateSets, function(alternateSet) {
          return new table$1.Table('alternateSetTable', table$1.ushortList('alternate', alternateSet));
      })));
  };

  subtableMakers[4] = function makeLookup4(subtable) {
      check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
      return new table$1.Table('substitutionTable', [
          {name: 'substFormat', type: 'USHORT', value: 1},
          {name: 'coverage', type: 'TABLE', value: new table$1.Coverage(subtable.coverage)}
      ].concat(table$1.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
          return new table$1.Table('ligatureSetTable', table$1.tableList('ligature', ligatureSet, function(ligature) {
              return new table$1.Table('ligatureTable',
                  [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                  .concat(table$1.ushortList('component', ligature.components, ligature.components.length + 1))
              );
          }));
      })));
  };

  subtableMakers[6] = function makeLookup6(subtable) {
      if (subtable.substFormat === 1) {
          var returnTable = new table$1.Table('chainContextTable', [
              {name: 'substFormat', type: 'USHORT', value: subtable.substFormat},
              {name: 'coverage', type: 'TABLE', value: new table$1.Coverage(subtable.coverage)}
          ].concat(table$1.tableList('chainRuleSet', subtable.chainRuleSets, function(chainRuleSet) {
              return new table$1.Table('chainRuleSetTable', table$1.tableList('chainRule', chainRuleSet, function(chainRule) {
                  var tableData = table$1.ushortList('backtrackGlyph', chainRule.backtrack, chainRule.backtrack.length)
                      .concat(table$1.ushortList('inputGlyph', chainRule.input, chainRule.input.length + 1))
                      .concat(table$1.ushortList('lookaheadGlyph', chainRule.lookahead, chainRule.lookahead.length))
                      .concat(table$1.ushortList('substitution', [], chainRule.lookupRecords.length));

                  chainRule.lookupRecords.forEach(function (record, i) {
                      tableData = tableData
                          .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
                          .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
                  });
                  return new table$1.Table('chainRuleTable', tableData);
              }));
          })));
          return returnTable;
      } else if (subtable.substFormat === 2) {
          check.assert(false, 'lookup type 6 format 2 is not yet supported.');
      } else if (subtable.substFormat === 3) {
          var tableData = [
              {name: 'substFormat', type: 'USHORT', value: subtable.substFormat} ];

          tableData.push({name: 'backtrackGlyphCount', type: 'USHORT', value: subtable.backtrackCoverage.length});
          subtable.backtrackCoverage.forEach(function (coverage, i) {
              tableData.push({name: 'backtrackCoverage' + i, type: 'TABLE', value: new table$1.Coverage(coverage)});
          });
          tableData.push({name: 'inputGlyphCount', type: 'USHORT', value: subtable.inputCoverage.length});
          subtable.inputCoverage.forEach(function (coverage, i) {
              tableData.push({name: 'inputCoverage' + i, type: 'TABLE', value: new table$1.Coverage(coverage)});
          });
          tableData.push({name: 'lookaheadGlyphCount', type: 'USHORT', value: subtable.lookaheadCoverage.length});
          subtable.lookaheadCoverage.forEach(function (coverage, i) {
              tableData.push({name: 'lookaheadCoverage' + i, type: 'TABLE', value: new table$1.Coverage(coverage)});
          });

          tableData.push({name: 'substitutionCount', type: 'USHORT', value: subtable.lookupRecords.length});
          subtable.lookupRecords.forEach(function (record, i) {
              tableData = tableData
                  .concat({name: 'sequenceIndex' + i, type: 'USHORT', value: record.sequenceIndex})
                  .concat({name: 'lookupListIndex' + i, type: 'USHORT', value: record.lookupListIndex});
          });

          var returnTable$1 = new table$1.Table('chainContextTable', tableData);

          return returnTable$1;
      }

      check.assert(false, 'lookup type 6 format must be 1, 2 or 3.');
  };

  function makeGsubTable(gsub) {
      return new table$1.Table('GSUB', [
          {name: 'version', type: 'ULONG', value: 0x10000},
          {name: 'scripts', type: 'TABLE', value: new table$1.ScriptList(gsub.scripts)},
          {name: 'features', type: 'TABLE', value: new table$1.FeatureList(gsub.features)},
          {name: 'lookups', type: 'TABLE', value: new table$1.LookupList(gsub.lookups, subtableMakers)}
      ]);
  }

  var gsub = { parse: parseGsubTable, make: makeGsubTable };

  // The `GPOS` table contains kerning pairs, among other things.

  // Parse the metadata `meta` table.
  // https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
  function parseMetaTable(data, start) {
      var p = new parse$2.Parser(data, start);
      var tableVersion = p.parseULong();
      check.argument(tableVersion === 1, 'Unsupported META table version.');
      p.parseULong(); // flags - currently unused and set to 0
      p.parseULong(); // tableOffset
      var numDataMaps = p.parseULong();

      var tags = {};
      for (var i = 0; i < numDataMaps; i++) {
          var tag = p.parseTag();
          var dataOffset = p.parseULong();
          var dataLength = p.parseULong();
          var text = decode.UTF8(data, start + dataOffset, dataLength);

          tags[tag] = text;
      }
      return tags;
  }

  function makeMetaTable(tags) {
      var numTags = Object.keys(tags).length;
      var stringPool = '';
      var stringPoolOffset = 16 + numTags * 12;

      var result = new table$1.Table('meta', [
          {name: 'version', type: 'ULONG', value: 1},
          {name: 'flags', type: 'ULONG', value: 0},
          {name: 'offset', type: 'ULONG', value: stringPoolOffset},
          {name: 'numTags', type: 'ULONG', value: numTags}
      ]);

      for (var tag in tags) {
          var pos = stringPool.length;
          stringPool += tags[tag];

          result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
          result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
          result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
      }

      result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

      return result;
  }

  var meta = { parse: parseMetaTable, make: makeMetaTable };

  // The `sfnt` wrapper provides organization for the tables in the font.

  function log2(v) {
      return Math.log(v) / Math.log(2) | 0;
  }

  function computeCheckSum(bytes) {
      while (bytes.length % 4 !== 0) {
          bytes.push(0);
      }

      var sum = 0;
      for (var i = 0; i < bytes.length; i += 4) {
          sum += (bytes[i] << 24) +
              (bytes[i + 1] << 16) +
              (bytes[i + 2] << 8) +
              (bytes[i + 3]);
      }

      sum %= Math.pow(2, 32);
      return sum;
  }

  function makeTableRecord(tag, checkSum, offset, length) {
      return new table$1.Record('Table Record', [
          {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
          {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
          {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
          {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
      ]);
  }

  function makeSfntTable(tables) {
      var sfnt = new table$1.Table('sfnt', [
          {name: 'version', type: 'TAG', value: 'OTTO'},
          {name: 'numTables', type: 'USHORT', value: 0},
          {name: 'searchRange', type: 'USHORT', value: 0},
          {name: 'entrySelector', type: 'USHORT', value: 0},
          {name: 'rangeShift', type: 'USHORT', value: 0}
      ]);
      sfnt.tables = tables;
      sfnt.numTables = tables.length;
      var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
      sfnt.searchRange = 16 * highestPowerOf2;
      sfnt.entrySelector = log2(highestPowerOf2);
      sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

      var recordFields = [];
      var tableFields = [];

      var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
      while (offset % 4 !== 0) {
          offset += 1;
          tableFields.push({name: 'padding', type: 'BYTE', value: 0});
      }

      for (var i = 0; i < tables.length; i += 1) {
          var t = tables[i];
          check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
          var tableLength = t.sizeOf();
          var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
          recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
          tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
          offset += tableLength;
          check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
          while (offset % 4 !== 0) {
              offset += 1;
              tableFields.push({name: 'padding', type: 'BYTE', value: 0});
          }
      }

      // Table records need to be sorted alphabetically.
      recordFields.sort(function(r1, r2) {
          if (r1.value.tag > r2.value.tag) {
              return 1;
          } else {
              return -1;
          }
      });

      sfnt.fields = sfnt.fields.concat(recordFields);
      sfnt.fields = sfnt.fields.concat(tableFields);
      return sfnt;
  }

  // Get the metrics for a character. If the string has more than one character
  // this function returns metrics for the first available character.
  // You can provide optional fallback metrics if no characters are available.
  function metricsForChar(font, chars, notFoundMetrics) {
      for (var i = 0; i < chars.length; i += 1) {
          var glyphIndex = font.charToGlyphIndex(chars[i]);
          if (glyphIndex > 0) {
              var glyph = font.glyphs.get(glyphIndex);
              return glyph.getMetrics();
          }
      }

      return notFoundMetrics;
  }

  function average(vs) {
      var sum = 0;
      for (var i = 0; i < vs.length; i += 1) {
          sum += vs[i];
      }

      return sum / vs.length;
  }

  // Convert the font object to a SFNT data structure.
  // This structure contains all the necessary tables and metadata to create a binary OTF file.
  function fontToSfntTable(font) {
      var xMins = [];
      var yMins = [];
      var xMaxs = [];
      var yMaxs = [];
      var advanceWidths = [];
      var leftSideBearings = [];
      var rightSideBearings = [];
      var firstCharIndex;
      var lastCharIndex = 0;
      var ulUnicodeRange1 = 0;
      var ulUnicodeRange2 = 0;
      var ulUnicodeRange3 = 0;
      var ulUnicodeRange4 = 0;

      for (var i = 0; i < font.glyphs.length; i += 1) {
          var glyph = font.glyphs.get(i);
          var unicode = glyph.unicode | 0;

          if (isNaN(glyph.advanceWidth)) {
              throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
          }

          if (firstCharIndex > unicode || firstCharIndex === undefined) {
              // ignore .notdef char
              if (unicode > 0) {
                  firstCharIndex = unicode;
              }
          }

          if (lastCharIndex < unicode) {
              lastCharIndex = unicode;
          }

          var position = os2.getUnicodeRange(unicode);
          if (position < 32) {
              ulUnicodeRange1 |= 1 << position;
          } else if (position < 64) {
              ulUnicodeRange2 |= 1 << position - 32;
          } else if (position < 96) {
              ulUnicodeRange3 |= 1 << position - 64;
          } else if (position < 123) {
              ulUnicodeRange4 |= 1 << position - 96;
          } else {
              throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
          }
          // Skip non-important characters.
          if (glyph.name === '.notdef') { continue; }
          var metrics = glyph.getMetrics();
          xMins.push(metrics.xMin);
          yMins.push(metrics.yMin);
          xMaxs.push(metrics.xMax);
          yMaxs.push(metrics.yMax);
          leftSideBearings.push(metrics.leftSideBearing);
          rightSideBearings.push(metrics.rightSideBearing);
          advanceWidths.push(glyph.advanceWidth);
      }

      var globals = {
          xMin: Math.min.apply(null, xMins),
          yMin: Math.min.apply(null, yMins),
          xMax: Math.max.apply(null, xMaxs),
          yMax: Math.max.apply(null, yMaxs),
          advanceWidthMax: Math.max.apply(null, advanceWidths),
          advanceWidthAvg: average(advanceWidths),
          minLeftSideBearing: Math.min.apply(null, leftSideBearings),
          maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
          minRightSideBearing: Math.min.apply(null, rightSideBearings)
      };
      globals.ascender = font.ascender;
      globals.descender = font.descender;

      var headTable = head$1.make({
          flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
          unitsPerEm: font.unitsPerEm,
          xMin: globals.xMin,
          yMin: globals.yMin,
          xMax: globals.xMax,
          yMax: globals.yMax,
          lowestRecPPEM: 3,
          createdTimestamp: font.createdTimestamp
      });

      var hheaTable = hhea$1.make({
          ascender: globals.ascender,
          descender: globals.descender,
          advanceWidthMax: globals.advanceWidthMax,
          minLeftSideBearing: globals.minLeftSideBearing,
          minRightSideBearing: globals.minRightSideBearing,
          xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
          numberOfHMetrics: font.glyphs.length
      });

      var maxpTable = maxp$1.make(font.glyphs.length);

      var os2Table = os2.make(Object.assign({
          xAvgCharWidth: Math.round(globals.advanceWidthAvg),
          usFirstCharIndex: firstCharIndex,
          usLastCharIndex: lastCharIndex,
          ulUnicodeRange1: ulUnicodeRange1,
          ulUnicodeRange2: ulUnicodeRange2,
          ulUnicodeRange3: ulUnicodeRange3,
          ulUnicodeRange4: ulUnicodeRange4,
          // See http://typophile.com/node/13081 for more info on vertical metrics.
          // We get metrics for typical characters (such as "x" for xHeight).
          // We provide some fallback characters if characters are unavailable: their
          // ordering was chosen experimentally.
          sTypoAscender: globals.ascender,
          sTypoDescender: globals.descender,
          sTypoLineGap: 0,
          usWinAscent: globals.yMax,
          usWinDescent: Math.abs(globals.yMin),
          ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
          sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
          sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
          usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
          usBreakChar: font.hasChar(' ') ? 32 : 0, // Use space as the break character, if available.
      }, font.tables.os2));

      var hmtxTable = hmtx$1.make(font.glyphs);
      var cmapTable = cmap$1.make(font.glyphs);

      var englishFamilyName = font.getEnglishName('fontFamily');
      var englishStyleName = font.getEnglishName('fontSubfamily');
      var englishFullName = englishFamilyName + ' ' + englishStyleName;
      var postScriptName = font.getEnglishName('postScriptName');
      if (!postScriptName) {
          postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
      }

      var names = {};
      for (var n in font.names) {
          names[n] = font.names[n];
      }

      if (!names.uniqueID) {
          names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
      }

      if (!names.postScriptName) {
          names.postScriptName = {en: postScriptName};
      }

      if (!names.preferredFamily) {
          names.preferredFamily = font.names.fontFamily;
      }

      if (!names.preferredSubfamily) {
          names.preferredSubfamily = font.names.fontSubfamily;
      }

      var languageTags = [];
      var nameTable = _name.make(names, languageTags);
      var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

      var postTable = post$1.make();
      var cffTable = cff.make(font.glyphs, {
          version: font.getEnglishName('version'),
          fullName: englishFullName,
          familyName: englishFamilyName,
          weightName: englishStyleName,
          postScriptName: postScriptName,
          unitsPerEm: font.unitsPerEm,
          fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
      });

      var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

      // The order does not matter because makeSfntTable() will sort them.
      var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
      if (ltagTable) {
          tables.push(ltagTable);
      }
      // Optional tables
      if (font.tables.gsub) {
          tables.push(gsub.make(font.tables.gsub));
      }
      if (metaTable) {
          tables.push(metaTable);
      }

      var sfntTable = makeSfntTable(tables);

      // Compute the font's checkSum and store it in head.checkSumAdjustment.
      var bytes = sfntTable.encode();
      var checkSum = computeCheckSum(bytes);
      var tableFields = sfntTable.fields;
      var checkSumAdjusted = false;
      for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
          if (tableFields[i$1].name === 'head table') {
              tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
              checkSumAdjusted = true;
              break;
          }
      }

      if (!checkSumAdjusted) {
          throw new Error('Could not find head table with checkSum to adjust.');
      }

      return sfntTable;
  }

  var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

  // The Layout object is the prototype of Substitution objects, and provides

  function searchTag(arr, tag) {
      /* jshint bitwise: false */
      var imin = 0;
      var imax = arr.length - 1;
      while (imin <= imax) {
          var imid = (imin + imax) >>> 1;
          var val = arr[imid].tag;
          if (val === tag) {
              return imid;
          } else if (val < tag) {
              imin = imid + 1;
          } else { imax = imid - 1; }
      }
      // Not found: return -1-insertion point
      return -imin - 1;
  }

  function binSearch(arr, value) {
      /* jshint bitwise: false */
      var imin = 0;
      var imax = arr.length - 1;
      while (imin <= imax) {
          var imid = (imin + imax) >>> 1;
          var val = arr[imid];
          if (val === value) {
              return imid;
          } else if (val < value) {
              imin = imid + 1;
          } else { imax = imid - 1; }
      }
      // Not found: return -1-insertion point
      return -imin - 1;
  }

  // binary search in a list of ranges (coverage, class definition)
  function searchRange(ranges, value) {
      // jshint bitwise: false
      var range;
      var imin = 0;
      var imax = ranges.length - 1;
      while (imin <= imax) {
          var imid = (imin + imax) >>> 1;
          range = ranges[imid];
          var start = range.start;
          if (start === value) {
              return range;
          } else if (start < value) {
              imin = imid + 1;
          } else { imax = imid - 1; }
      }
      if (imin > 0) {
          range = ranges[imin - 1];
          if (value > range.end) { return 0; }
          return range;
      }
  }

  /**
   * @exports opentype.Layout
   * @class
   */
  function Layout(font, tableName) {
      this.font = font;
      this.tableName = tableName;
  }

  Layout.prototype = {

      /**
       * Binary search an object by "tag" property
       * @instance
       * @function searchTag
       * @memberof opentype.Layout
       * @param  {Array} arr
       * @param  {string} tag
       * @return {number}
       */
      searchTag: searchTag,

      /**
       * Binary search in a list of numbers
       * @instance
       * @function binSearch
       * @memberof opentype.Layout
       * @param  {Array} arr
       * @param  {number} value
       * @return {number}
       */
      binSearch: binSearch,

      /**
       * Get or create the Layout table (GSUB, GPOS etc).
       * @param  {boolean} create - Whether to create a new one.
       * @return {Object} The GSUB or GPOS table.
       */
      getTable: function(create) {
          var layout = this.font.tables[this.tableName];
          if (!layout && create) {
              layout = this.font.tables[this.tableName] = this.createDefaultTable();
          }
          return layout;
      },

      /**
       * Returns all scripts in the substitution table.
       * @instance
       * @return {Array}
       */
      getScriptNames: function() {
          var layout = this.getTable();
          if (!layout) { return []; }
          return layout.scripts.map(function(script) {
              return script.tag;
          });
      },

      /**
       * Returns the best bet for a script name.
       * Returns 'DFLT' if it exists.
       * If not, returns 'latn' if it exists.
       * If neither exist, returns undefined.
       */
      getDefaultScriptName: function() {
          var layout = this.getTable();
          if (!layout) { return; }
          var hasLatn = false;
          for (var i = 0; i < layout.scripts.length; i++) {
              var name = layout.scripts[i].tag;
              if (name === 'DFLT') { return name; }
              if (name === 'latn') { hasLatn = true; }
          }
          if (hasLatn) { return 'latn'; }
      },

      /**
       * Returns all LangSysRecords in the given script.
       * @instance
       * @param {string} [script='DFLT']
       * @param {boolean} create - forces the creation of this script table if it doesn't exist.
       * @return {Object} An object with tag and script properties.
       */
      getScriptTable: function(script, create) {
          var layout = this.getTable(create);
          if (layout) {
              script = script || 'DFLT';
              var scripts = layout.scripts;
              var pos = searchTag(layout.scripts, script);
              if (pos >= 0) {
                  return scripts[pos].script;
              } else if (create) {
                  var scr = {
                      tag: script,
                      script: {
                          defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
                          langSysRecords: []
                      }
                  };
                  scripts.splice(-1 - pos, 0, scr);
                  return scr.script;
              }
          }
      },

      /**
       * Returns a language system table
       * @instance
       * @param {string} [script='DFLT']
       * @param {string} [language='dlft']
       * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
       * @return {Object}
       */
      getLangSysTable: function(script, language, create) {
          var scriptTable = this.getScriptTable(script, create);
          if (scriptTable) {
              if (!language || language === 'dflt' || language === 'DFLT') {
                  return scriptTable.defaultLangSys;
              }
              var pos = searchTag(scriptTable.langSysRecords, language);
              if (pos >= 0) {
                  return scriptTable.langSysRecords[pos].langSys;
              } else if (create) {
                  var langSysRecord = {
                      tag: language,
                      langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
                  };
                  scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                  return langSysRecord.langSys;
              }
          }
      },

      /**
       * Get a specific feature table.
       * @instance
       * @param {string} [script='DFLT']
       * @param {string} [language='dlft']
       * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
       * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
       * @return {Object}
       */
      getFeatureTable: function(script, language, feature, create) {
          var langSysTable = this.getLangSysTable(script, language, create);
          if (langSysTable) {
              var featureRecord;
              var featIndexes = langSysTable.featureIndexes;
              var allFeatures = this.font.tables[this.tableName].features;
              // The FeatureIndex array of indices is in arbitrary order,
              // even if allFeatures is sorted alphabetically by feature tag.
              for (var i = 0; i < featIndexes.length; i++) {
                  featureRecord = allFeatures[featIndexes[i]];
                  if (featureRecord.tag === feature) {
                      return featureRecord.feature;
                  }
              }
              if (create) {
                  var index = allFeatures.length;
                  // Automatic ordering of features would require to shift feature indexes in the script list.
                  check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                  featureRecord = {
                      tag: feature,
                      feature: { params: 0, lookupListIndexes: [] }
                  };
                  allFeatures.push(featureRecord);
                  featIndexes.push(index);
                  return featureRecord.feature;
              }
          }
      },

      /**
       * Get the lookup tables of a given type for a script/language/feature.
       * @instance
       * @param {string} [script='DFLT']
       * @param {string} [language='dlft']
       * @param {string} feature - 4-letter feature code
       * @param {number} lookupType - 1 to 9
       * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
       * @return {Object[]}
       */
      getLookupTables: function(script, language, feature, lookupType, create) {
          var featureTable = this.getFeatureTable(script, language, feature, create);
          var tables = [];
          if (featureTable) {
              var lookupTable;
              var lookupListIndexes = featureTable.lookupListIndexes;
              var allLookups = this.font.tables[this.tableName].lookups;
              // lookupListIndexes are in no particular order, so use naive search.
              for (var i = 0; i < lookupListIndexes.length; i++) {
                  lookupTable = allLookups[lookupListIndexes[i]];
                  if (lookupTable.lookupType === lookupType) {
                      tables.push(lookupTable);
                  }
              }
              if (tables.length === 0 && create) {
                  lookupTable = {
                      lookupType: lookupType,
                      lookupFlag: 0,
                      subtables: [],
                      markFilteringSet: undefined
                  };
                  var index = allLookups.length;
                  allLookups.push(lookupTable);
                  lookupListIndexes.push(index);
                  return [lookupTable];
              }
          }
          return tables;
      },

      /**
       * Find a glyph in a class definition table
       * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
       * @param {object} classDefTable - an OpenType Layout class definition table
       * @param {number} glyphIndex - the index of the glyph to find
       * @returns {number} -1 if not found
       */
      getGlyphClass: function(classDefTable, glyphIndex) {
          switch (classDefTable.format) {
              case 1:
                  if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
                      return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
                  }
                  return 0;
              case 2:
                  var range = searchRange(classDefTable.ranges, glyphIndex);
                  return range ? range.classId : 0;
          }
      },

      /**
       * Find a glyph in a coverage table
       * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
       * @param {object} coverageTable - an OpenType Layout coverage table
       * @param {number} glyphIndex - the index of the glyph to find
       * @returns {number} -1 if not found
       */
      getCoverageIndex: function(coverageTable, glyphIndex) {
          switch (coverageTable.format) {
              case 1:
                  var index = binSearch(coverageTable.glyphs, glyphIndex);
                  return index >= 0 ? index : -1;
              case 2:
                  var range = searchRange(coverageTable.ranges, glyphIndex);
                  return range ? range.index + glyphIndex - range.start : -1;
          }
      },

      /**
       * Returns the list of glyph indexes of a coverage table.
       * Format 1: the list is stored raw
       * Format 2: compact list as range records.
       * @instance
       * @param  {Object} coverageTable
       * @return {Array}
       */
      expandCoverage: function(coverageTable) {
          if (coverageTable.format === 1) {
              return coverageTable.glyphs;
          } else {
              var glyphs = [];
              var ranges = coverageTable.ranges;
              for (var i = 0; i < ranges.length; i++) {
                  var range = ranges[i];
                  var start = range.start;
                  var end = range.end;
                  for (var j = start; j <= end; j++) {
                      glyphs.push(j);
                  }
              }
              return glyphs;
          }
      }

  };

  // The Position object provides utility methods to manipulate

  /**
   * @exports opentype.Position
   * @class
   * @extends opentype.Layout
   * @param {opentype.Font}
   * @constructor
   */
  function Position(font) {
      Layout.call(this, font, 'gpos');
  }

  Position.prototype = Layout.prototype;

  /**
   * Init some data for faster and easier access later.
   */
  Position.prototype.init = function() {
      var script = this.getDefaultScriptName();
      this.defaultKerningTables = this.getKerningTables(script);
  };

  /**
   * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
   *
   * @param {integer} leftIndex - left glyph index
   * @param {integer} rightIndex - right glyph index
   * @returns {integer}
   */
  Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
      for (var i = 0; i < kerningLookups.length; i++) {
          var subtables = kerningLookups[i].subtables;
          for (var j = 0; j < subtables.length; j++) {
              var subtable = subtables[j];
              var covIndex = this.getCoverageIndex(subtable.coverage, leftIndex);
              if (covIndex < 0) { continue; }
              switch (subtable.posFormat) {
                  case 1:
                      // Search Pair Adjustment Positioning Format 1
                      var pairSet = subtable.pairSets[covIndex];
                      for (var k = 0; k < pairSet.length; k++) {
                          var pair = pairSet[k];
                          if (pair.secondGlyph === rightIndex) {
                              return pair.value1 && pair.value1.xAdvance || 0;
                          }
                      }
                      break;      // left glyph found, not right glyph - try next subtable
                  case 2:
                      // Search Pair Adjustment Positioning Format 2
                      var class1 = this.getGlyphClass(subtable.classDef1, leftIndex);
                      var class2 = this.getGlyphClass(subtable.classDef2, rightIndex);
                      var pair$1 = subtable.classRecords[class1][class2];
                      return pair$1.value1 && pair$1.value1.xAdvance || 0;
              }
          }
      }
      return 0;
  };

  /**
   * List all kerning lookup tables.
   *
   * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
   * @param {string} [language='dflt']
   * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
   */
  Position.prototype.getKerningTables = function(script, language) {
      if (this.font.tables.gpos) {
          return this.getLookupTables(script, language, 'kern', 2);
      }
  };

  // The Substitution object provides utility methods to manipulate

  /**
   * @exports opentype.Substitution
   * @class
   * @extends opentype.Layout
   * @param {opentype.Font}
   * @constructor
   */
  function Substitution(font) {
      Layout.call(this, font, 'gsub');
  }

  // Check if 2 arrays of primitives are equal.
  function arraysEqual(ar1, ar2) {
      var n = ar1.length;
      if (n !== ar2.length) { return false; }
      for (var i = 0; i < n; i++) {
          if (ar1[i] !== ar2[i]) { return false; }
      }
      return true;
  }

  // Find the first subtable of a lookup table in a particular format.
  function getSubstFormat(lookupTable, format, defaultSubtable) {
      var subtables = lookupTable.subtables;
      for (var i = 0; i < subtables.length; i++) {
          var subtable = subtables[i];
          if (subtable.substFormat === format) {
              return subtable;
          }
      }
      if (defaultSubtable) {
          subtables.push(defaultSubtable);
          return defaultSubtable;
      }
      return undefined;
  }

  Substitution.prototype = Layout.prototype;

  /**
   * Create a default GSUB table.
   * @return {Object} gsub - The GSUB table.
   */
  Substitution.prototype.createDefaultTable = function() {
      // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
      return {
          version: 1,
          scripts: [{
              tag: 'DFLT',
              script: {
                  defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                  langSysRecords: []
              }
          }],
          features: [],
          lookups: []
      };
  };

  /**
   * List all single substitutions (lookup type 1) for a given script, language, and feature.
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
   * @return {Array} substitutions - The list of substitutions.
   */
  Substitution.prototype.getSingle = function(feature, script, language) {
      var substitutions = [];
      var lookupTables = this.getLookupTables(script, language, feature, 1);
      for (var idx = 0; idx < lookupTables.length; idx++) {
          var subtables = lookupTables[idx].subtables;
          for (var i = 0; i < subtables.length; i++) {
              var subtable = subtables[i];
              var glyphs = this.expandCoverage(subtable.coverage);
              var j = (void 0);
              if (subtable.substFormat === 1) {
                  var delta = subtable.deltaGlyphId;
                  for (j = 0; j < glyphs.length; j++) {
                      var glyph = glyphs[j];
                      substitutions.push({ sub: glyph, by: glyph + delta });
                  }
              } else {
                  var substitute = subtable.substitute;
                  for (j = 0; j < glyphs.length; j++) {
                      substitutions.push({ sub: glyphs[j], by: substitute[j] });
                  }
              }
          }
      }
      return substitutions;
  };

  /**
   * List all multiple substitutions (lookup type 2) for a given script, language, and feature.
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   * @param {string} feature - 4-character feature name ('ccmp', 'stch')
   * @return {Array} substitutions - The list of substitutions.
   */
  Substitution.prototype.getMultiple = function(feature, script, language) {
      var substitutions = [];
      var lookupTables = this.getLookupTables(script, language, feature, 2);
      for (var idx = 0; idx < lookupTables.length; idx++) {
          var subtables = lookupTables[idx].subtables;
          for (var i = 0; i < subtables.length; i++) {
              var subtable = subtables[i];
              var glyphs = this.expandCoverage(subtable.coverage);
              var j = (void 0);

              for (j = 0; j < glyphs.length; j++) {
                  var glyph = glyphs[j];
                  var replacements = subtable.sequences[j];
                  substitutions.push({ sub: glyph, by: replacements });
              }
          }
      }
      return substitutions;
  };

  /**
   * List all alternates (lookup type 3) for a given script, language, and feature.
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
   * @return {Array} alternates - The list of alternates
   */
  Substitution.prototype.getAlternates = function(feature, script, language) {
      var alternates = [];
      var lookupTables = this.getLookupTables(script, language, feature, 3);
      for (var idx = 0; idx < lookupTables.length; idx++) {
          var subtables = lookupTables[idx].subtables;
          for (var i = 0; i < subtables.length; i++) {
              var subtable = subtables[i];
              var glyphs = this.expandCoverage(subtable.coverage);
              var alternateSets = subtable.alternateSets;
              for (var j = 0; j < glyphs.length; j++) {
                  alternates.push({ sub: glyphs[j], by: alternateSets[j] });
              }
          }
      }
      return alternates;
  };

  /**
   * List all ligatures (lookup type 4) for a given script, language, and feature.
   * The result is an array of ligature objects like { sub: [ids], by: id }
   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   * @return {Array} ligatures - The list of ligatures.
   */
  Substitution.prototype.getLigatures = function(feature, script, language) {
      var ligatures = [];
      var lookupTables = this.getLookupTables(script, language, feature, 4);
      for (var idx = 0; idx < lookupTables.length; idx++) {
          var subtables = lookupTables[idx].subtables;
          for (var i = 0; i < subtables.length; i++) {
              var subtable = subtables[i];
              var glyphs = this.expandCoverage(subtable.coverage);
              var ligatureSets = subtable.ligatureSets;
              for (var j = 0; j < glyphs.length; j++) {
                  var startGlyph = glyphs[j];
                  var ligSet = ligatureSets[j];
                  for (var k = 0; k < ligSet.length; k++) {
                      var lig = ligSet[k];
                      ligatures.push({
                          sub: [startGlyph].concat(lig.components),
                          by: lig.ligGlyph
                      });
                  }
              }
          }
      }
      return ligatures;
  };

  /**
   * Add or modify a single substitution (lookup type 1)
   * Format 2, more flexible, is always used.
   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
   * @param {Object} substitution - { sub: id, by: id } (format 1 is not supported)
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   */
  Substitution.prototype.addSingle = function(feature, substitution, script, language) {
      var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
      var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
          substFormat: 2,
          coverage: {format: 1, glyphs: []},
          substitute: []
      });
      check.assert(subtable.coverage.format === 1, 'Single: unable to modify coverage table format ' + subtable.coverage.format);
      var coverageGlyph = substitution.sub;
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos < 0) {
          pos = -1 - pos;
          subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
          subtable.substitute.splice(pos, 0, 0);
      }
      subtable.substitute[pos] = substitution.by;
  };

  /**
   * Add or modify a multiple substitution (lookup type 2)
   * @param {string} feature - 4-letter feature name ('ccmp', 'stch')
   * @param {Object} substitution - { sub: id, by: [id] } for format 2.
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   */
  Substitution.prototype.addMultiple = function(feature, substitution, script, language) {
      check.assert(substitution.by instanceof Array && substitution.by.length > 1, 'Multiple: "by" must be an array of two or more ids');
      var lookupTable = this.getLookupTables(script, language, feature, 2, true)[0];
      var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 2 subtable, format 1, coverage format 1
          substFormat: 1,
          coverage: {format: 1, glyphs: []},
          sequences: []
      });
      check.assert(subtable.coverage.format === 1, 'Multiple: unable to modify coverage table format ' + subtable.coverage.format);
      var coverageGlyph = substitution.sub;
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos < 0) {
          pos = -1 - pos;
          subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
          subtable.sequences.splice(pos, 0, 0);
      }
      subtable.sequences[pos] = substitution.by;
  };

  /**
   * Add or modify an alternate substitution (lookup type 3)
   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
   * @param {Object} substitution - { sub: id, by: [ids] }
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   */
  Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
      var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
      var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
          substFormat: 1,
          coverage: {format: 1, glyphs: []},
          alternateSets: []
      });
      check.assert(subtable.coverage.format === 1, 'Alternate: unable to modify coverage table format ' + subtable.coverage.format);
      var coverageGlyph = substitution.sub;
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos < 0) {
          pos = -1 - pos;
          subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
          subtable.alternateSets.splice(pos, 0, 0);
      }
      subtable.alternateSets[pos] = substitution.by;
  };

  /**
   * Add a ligature (lookup type 4)
   * Ligatures with more components must be stored ahead of those with fewer components in order to be found
   * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
   * @param {Object} ligature - { sub: [ids], by: id }
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   */
  Substitution.prototype.addLigature = function(feature, ligature, script, language) {
      var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
      var subtable = lookupTable.subtables[0];
      if (!subtable) {
          subtable = {                // lookup type 4 subtable, format 1, coverage format 1
              substFormat: 1,
              coverage: { format: 1, glyphs: [] },
              ligatureSets: []
          };
          lookupTable.subtables[0] = subtable;
      }
      check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
      var coverageGlyph = ligature.sub[0];
      var ligComponents = ligature.sub.slice(1);
      var ligatureTable = {
          ligGlyph: ligature.by,
          components: ligComponents
      };
      var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
      if (pos >= 0) {
          // ligatureSet already exists
          var ligatureSet = subtable.ligatureSets[pos];
          for (var i = 0; i < ligatureSet.length; i++) {
              // If ligature already exists, return.
              if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                  return;
              }
          }
          // ligature does not exist: add it.
          ligatureSet.push(ligatureTable);
      } else {
          // Create a new ligatureSet and add coverage for the first glyph.
          pos = -1 - pos;
          subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
          subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
      }
  };

  /**
   * List all feature data for a given script and language.
   * @param {string} feature - 4-letter feature name
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   * @return {Array} substitutions - The list of substitutions.
   */
  Substitution.prototype.getFeature = function(feature, script, language) {
      if (/ss\d\d/.test(feature)) {
          // ss01 - ss20
          return this.getSingle(feature, script, language);
      }
      switch (feature) {
          case 'aalt':
          case 'salt':
              return this.getSingle(feature, script, language)
                      .concat(this.getAlternates(feature, script, language));
          case 'dlig':
          case 'liga':
          case 'rlig':
              return this.getLigatures(feature, script, language);
          case 'ccmp':
              return this.getMultiple(feature, script, language)
                  .concat(this.getLigatures(feature, script, language));
          case 'stch':
              return this.getMultiple(feature, script, language);
      }
      return undefined;
  };

  /**
   * Add a substitution to a feature for a given script and language.
   * @param {string} feature - 4-letter feature name
   * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
   * @param {string} [script='DFLT']
   * @param {string} [language='dflt']
   */
  Substitution.prototype.add = function(feature, sub, script, language) {
      if (/ss\d\d/.test(feature)) {
          // ss01 - ss20
          return this.addSingle(feature, sub, script, language);
      }
      switch (feature) {
          case 'aalt':
          case 'salt':
              if (typeof sub.by === 'number') {
                  return this.addSingle(feature, sub, script, language);
              }
              return this.addAlternate(feature, sub, script, language);
          case 'dlig':
          case 'liga':
          case 'rlig':
              return this.addLigature(feature, sub, script, language);
          case 'ccmp':
              if (sub.by instanceof Array) {
                  return this.addMultiple(feature, sub, script, language);
              }
              return this.addLigature(feature, sub, script, language);
      }
      return undefined;
  };

  function isBrowser() {
      return typeof window !== 'undefined';
  }

  function nodeBufferToArrayBuffer(buffer) {
      var ab = new ArrayBuffer(buffer.length);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
          view[i] = buffer[i];
      }

      return ab;
  }

  function arrayBufferToNodeBuffer(ab) {
      var buffer = new Buffer(ab.byteLength);
      var view = new Uint8Array(ab);
      for (var i = 0; i < buffer.length; ++i) {
          buffer[i] = view[i];
      }

      return buffer;
  }

  function checkArgument(expression, message) {
      if (!expression) {
          throw message;
      }
  }

  // The `glyf` table describes the glyphs in TrueType outline format.

  // Parse the coordinate data for a glyph.
  function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
      var v;
      if ((flag & shortVectorBitMask) > 0) {
          // The coordinate is 1 byte long.
          v = p.parseByte();
          // The `same` bit is re-used for short values to signify the sign of the value.
          if ((flag & sameBitMask) === 0) {
              v = -v;
          }

          v = previousValue + v;
      } else {
          //  The coordinate is 2 bytes long.
          // If the `same` bit is set, the coordinate is the same as the previous coordinate.
          if ((flag & sameBitMask) > 0) {
              v = previousValue;
          } else {
              // Parse the coordinate as a signed 16-bit delta value.
              v = previousValue + p.parseShort();
          }
      }

      return v;
  }

  // Parse a TrueType glyph.
  function parseGlyph(glyph, data, start) {
      var p = new parse$2.Parser(data, start);
      glyph.numberOfContours = p.parseShort();
      glyph._xMin = p.parseShort();
      glyph._yMin = p.parseShort();
      glyph._xMax = p.parseShort();
      glyph._yMax = p.parseShort();
      var flags;
      var flag;

      if (glyph.numberOfContours > 0) {
          // This glyph is not a composite.
          var endPointIndices = glyph.endPointIndices = [];
          for (var i = 0; i < glyph.numberOfContours; i += 1) {
              endPointIndices.push(p.parseUShort());
          }

          glyph.instructionLength = p.parseUShort();
          glyph.instructions = [];
          for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
              glyph.instructions.push(p.parseByte());
          }

          var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
          flags = [];
          for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
              flag = p.parseByte();
              flags.push(flag);
              // If bit 3 is set, we repeat this flag n times, where n is the next byte.
              if ((flag & 8) > 0) {
                  var repeatCount = p.parseByte();
                  for (var j = 0; j < repeatCount; j += 1) {
                      flags.push(flag);
                      i$2 += 1;
                  }
              }
          }

          check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

          if (endPointIndices.length > 0) {
              var points = [];
              var point;
              // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
              if (numberOfCoordinates > 0) {
                  for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
                      flag = flags[i$3];
                      point = {};
                      point.onCurve = !!(flag & 1);
                      point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
                      points.push(point);
                  }

                  var px = 0;
                  for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
                      flag = flags[i$4];
                      point = points[i$4];
                      point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                      px = point.x;
                  }

                  var py = 0;
                  for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
                      flag = flags[i$5];
                      point = points[i$5];
                      point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                      py = point.y;
                  }
              }

              glyph.points = points;
          } else {
              glyph.points = [];
          }
      } else if (glyph.numberOfContours === 0) {
          glyph.points = [];
      } else {
          glyph.isComposite = true;
          glyph.points = [];
          glyph.components = [];
          var moreComponents = true;
          while (moreComponents) {
              flags = p.parseUShort();
              var component = {
                  glyphIndex: p.parseUShort(),
                  xScale: 1,
                  scale01: 0,
                  scale10: 0,
                  yScale: 1,
                  dx: 0,
                  dy: 0
              };
              if ((flags & 1) > 0) {
                  // The arguments are words
                  if ((flags & 2) > 0) {
                      // values are offset
                      component.dx = p.parseShort();
                      component.dy = p.parseShort();
                  } else {
                      // values are matched points
                      component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                  }

              } else {
                  // The arguments are bytes
                  if ((flags & 2) > 0) {
                      // values are offset
                      component.dx = p.parseChar();
                      component.dy = p.parseChar();
                  } else {
                      // values are matched points
                      component.matchedPoints = [p.parseByte(), p.parseByte()];
                  }
              }

              if ((flags & 8) > 0) {
                  // We have a scale
                  component.xScale = component.yScale = p.parseF2Dot14();
              } else if ((flags & 64) > 0) {
                  // We have an X / Y scale
                  component.xScale = p.parseF2Dot14();
                  component.yScale = p.parseF2Dot14();
              } else if ((flags & 128) > 0) {
                  // We have a 2x2 transformation
                  component.xScale = p.parseF2Dot14();
                  component.scale01 = p.parseF2Dot14();
                  component.scale10 = p.parseF2Dot14();
                  component.yScale = p.parseF2Dot14();
              }

              glyph.components.push(component);
              moreComponents = !!(flags & 32);
          }
          if (flags & 0x100) {
              // We have instructions
              glyph.instructionLength = p.parseUShort();
              glyph.instructions = [];
              for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
                  glyph.instructions.push(p.parseByte());
              }
          }
      }
  }

  // Transform an array of points and return a new array.
  function transformPoints(points, transform) {
      var newPoints = [];
      for (var i = 0; i < points.length; i += 1) {
          var pt = points[i];
          var newPt = {
              x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
              y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
              onCurve: pt.onCurve,
              lastPointOfContour: pt.lastPointOfContour
          };
          newPoints.push(newPt);
      }

      return newPoints;
  }

  function getContours(points) {
      var contours = [];
      var currentContour = [];
      for (var i = 0; i < points.length; i += 1) {
          var pt = points[i];
          currentContour.push(pt);
          if (pt.lastPointOfContour) {
              contours.push(currentContour);
              currentContour = [];
          }
      }

      check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
      return contours;
  }

  // Convert the TrueType glyph outline to a Path.
  function getPath(points) {
      var p = new Path();
      if (!points) {
          return p;
      }

      var contours = getContours(points);

      for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
          var contour = contours[contourIndex];

          var prev = null;
          var curr = contour[contour.length - 1];
          var next = contour[0];

          if (curr.onCurve) {
              p.moveTo(curr.x, curr.y);
          } else {
              if (next.onCurve) {
                  p.moveTo(next.x, next.y);
              } else {
                  // If both first and last points are off-curve, start at their middle.
                  var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
                  p.moveTo(start.x, start.y);
              }
          }

          for (var i = 0; i < contour.length; ++i) {
              prev = curr;
              curr = next;
              next = contour[(i + 1) % contour.length];

              if (curr.onCurve) {
                  // This is a straight line.
                  p.lineTo(curr.x, curr.y);
              } else {
                  var next2 = next;

                  if (!prev.onCurve) {
                      ({ x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 });
                  }

                  if (!next.onCurve) {
                      next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                  }

                  p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
              }
          }

          p.closePath();
      }
      return p;
  }

  function buildPath(glyphs, glyph) {
      if (glyph.isComposite) {
          for (var j = 0; j < glyph.components.length; j += 1) {
              var component = glyph.components[j];
              var componentGlyph = glyphs.get(component.glyphIndex);
              // Force the ttfGlyphLoader to parse the glyph.
              componentGlyph.getPath();
              if (componentGlyph.points) {
                  var transformedPoints = (void 0);
                  if (component.matchedPoints === undefined) {
                      // component positioned by offset
                      transformedPoints = transformPoints(componentGlyph.points, component);
                  } else {
                      // component positioned by matched points
                      if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                          (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                          throw Error('Matched points out of range in ' + glyph.name);
                      }
                      var firstPt = glyph.points[component.matchedPoints[0]];
                      var secondPt = componentGlyph.points[component.matchedPoints[1]];
                      var transform = {
                          xScale: component.xScale, scale01: component.scale01,
                          scale10: component.scale10, yScale: component.yScale,
                          dx: 0, dy: 0
                      };
                      secondPt = transformPoints([secondPt], transform)[0];
                      transform.dx = firstPt.x - secondPt.x;
                      transform.dy = firstPt.y - secondPt.y;
                      transformedPoints = transformPoints(componentGlyph.points, transform);
                  }
                  glyph.points = glyph.points.concat(transformedPoints);
              }
          }
      }

      return getPath(glyph.points);
  }

  function parseGlyfTableAll(data, start, loca, font) {
      var glyphs = new glyphset.GlyphSet(font);

      // The last element of the loca table is invalid.
      for (var i = 0; i < loca.length - 1; i += 1) {
          var offset = loca[i];
          var nextOffset = loca[i + 1];
          if (offset !== nextOffset) {
              glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
          } else {
              glyphs.push(i, glyphset.glyphLoader(font, i));
          }
      }

      return glyphs;
  }

  function parseGlyfTableOnLowMemory(data, start, loca, font) {
      var glyphs = new glyphset.GlyphSet(font);

      font._push = function(i) {
          var offset = loca[i];
          var nextOffset = loca[i + 1];
          if (offset !== nextOffset) {
              glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
          } else {
              glyphs.push(i, glyphset.glyphLoader(font, i));
          }
      };

      return glyphs;
  }

  // Parse all the glyphs according to the offsets from the `loca` table.
  function parseGlyfTable(data, start, loca, font, opt) {
      if (opt.lowMemory)
          { return parseGlyfTableOnLowMemory(data, start, loca, font); }
      else
          { return parseGlyfTableAll(data, start, loca, font); }
  }

  var glyf$1 = { getPath: getPath, parse: parseGlyfTable};

  /* A TrueType font hinting interpreter.
  *
  * (c) 2017 Axel Kittenberger
  *
  * This interpreter has been implemented according to this documentation:
  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
  *
  * According to the documentation F24DOT6 values are used for pixels.
  * That means calculation is 1/64 pixel accurate and uses integer operations.
  * However, Javascript has floating point operations by default and only
  * those are available. One could make a case to simulate the 1/64 accuracy
  * exactly by truncating after every division operation
  * (for example with << 0) to get pixel exactly results as other TrueType
  * implementations. It may make sense since some fonts are pixel optimized
  * by hand using DELTAP instructions. The current implementation doesn't
  * and rather uses full floating point precision.
  *
  * xScale, yScale and rotation is currently ignored.
  *
  * A few non-trivial instructions are missing as I didn't encounter yet
  * a font that used them to test a possible implementation.
  *
  * Some fonts seem to use undocumented features regarding the twilight zone.
  * Only some of them are implemented as they were encountered.
  *
  * The exports.DEBUG statements are removed on the minified distribution file.
  */

  var instructionTable;
  var exec;
  var execGlyph;
  var execComponent;

  /*
  * Creates a hinting object.
  *
  * There ought to be exactly one
  * for each truetype font that is used for hinting.
  */
  function Hinting(font) {
      // the font this hinting object is for
      this.font = font;

      this.getCommands = function (hPoints) {
          return glyf$1.getPath(hPoints).commands;
      };

      // cached states
      this._fpgmState  =
      this._prepState  =
          undefined;

      // errorState
      // 0 ... all okay
      // 1 ... had an error in a glyf,
      //       continue working but stop spamming
      //       the console
      // 2 ... error at prep, stop hinting at this ppem
      // 3 ... error at fpeg, stop hinting for this font at all
      this._errorState = 0;
  }

  /*
  * Not rounding.
  */
  function roundOff(v) {
      return v;
  }

  /*
  * Rounding to grid.
  */
  function roundToGrid(v) {
      //Rounding in TT is supposed to "symmetrical around zero"
      return Math.sign(v) * Math.round(Math.abs(v));
  }

  /*
  * Rounding to double grid.
  */
  function roundToDoubleGrid(v) {
      return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
  }

  /*
  * Rounding to half grid.
  */
  function roundToHalfGrid(v) {
      return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
  }

  /*
  * Rounding to up to grid.
  */
  function roundUpToGrid(v) {
      return Math.sign(v) * Math.ceil(Math.abs(v));
  }

  /*
  * Rounding to down to grid.
  */
  function roundDownToGrid(v) {
      return Math.sign(v) * Math.floor(Math.abs(v));
  }

  /*
  * Super rounding.
  */
  var roundSuper = function (v) {
      var period = this.srPeriod;
      var phase = this.srPhase;
      var threshold = this.srThreshold;
      var sign = 1;

      if (v < 0) {
          v = -v;
          sign = -1;
      }

      v += threshold - phase;

      v = Math.trunc(v / period) * period;

      v += phase;

      // according to http://xgridfit.sourceforge.net/round.html
      if (v < 0) { return phase * sign; }

      return v * sign;
  };

  /*
  * Unit vector of x-axis.
  */
  var xUnitVector = {
      x: 1,

      y: 0,

      axis: 'x',

      // Gets the projected distance between two points.
      // o1/o2 ... if true, respective original position is used.
      distance: function (p1, p2, o1, o2) {
          return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
      },

      // Moves point p so the moved position has the same relative
      // position to the moved positions of rp1 and rp2 than the
      // original positions had.
      //
      // See APPENDIX on INTERPOLATE at the bottom of this file.
      interpolate: function (p, rp1, rp2, pv) {
          var do1;
          var do2;
          var doa1;
          var doa2;
          var dm1;
          var dm2;
          var dt;

          if (!pv || pv === this) {
              do1 = p.xo - rp1.xo;
              do2 = p.xo - rp2.xo;
              dm1 = rp1.x - rp1.xo;
              dm2 = rp2.x - rp2.xo;
              doa1 = Math.abs(do1);
              doa2 = Math.abs(do2);
              dt = doa1 + doa2;

              if (dt === 0) {
                  p.x = p.xo + (dm1 + dm2) / 2;
                  return;
              }

              p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
              return;
          }

          do1 = pv.distance(p, rp1, true, true);
          do2 = pv.distance(p, rp2, true, true);
          dm1 = pv.distance(rp1, rp1, false, true);
          dm2 = pv.distance(rp2, rp2, false, true);
          doa1 = Math.abs(do1);
          doa2 = Math.abs(do2);
          dt = doa1 + doa2;

          if (dt === 0) {
              xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
              return;
          }

          xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
      },

      // Slope of line normal to this
      normalSlope: Number.NEGATIVE_INFINITY,

      // Sets the point 'p' relative to point 'rp'
      // by the distance 'd'.
      //
      // See APPENDIX on SETRELATIVE at the bottom of this file.
      //
      // p   ... point to set
      // rp  ... reference point
      // d   ... distance on projection vector
      // pv  ... projection vector (undefined = this)
      // org ... if true, uses the original position of rp as reference.
      setRelative: function (p, rp, d, pv, org) {
          if (!pv || pv === this) {
              p.x = (org ? rp.xo : rp.x) + d;
              return;
          }

          var rpx = org ? rp.xo : rp.x;
          var rpy = org ? rp.yo : rp.y;
          var rpdx = rpx + d * pv.x;
          var rpdy = rpy + d * pv.y;

          p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
      },

      // Slope of vector line.
      slope: 0,

      // Touches the point p.
      touch: function (p) {
          p.xTouched = true;
      },

      // Tests if a point p is touched.
      touched: function (p) {
          return p.xTouched;
      },

      // Untouches the point p.
      untouch: function (p) {
          p.xTouched = false;
      }
  };

  /*
  * Unit vector of y-axis.
  */
  var yUnitVector = {
      x: 0,

      y: 1,

      axis: 'y',

      // Gets the projected distance between two points.
      // o1/o2 ... if true, respective original position is used.
      distance: function (p1, p2, o1, o2) {
          return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
      },

      // Moves point p so the moved position has the same relative
      // position to the moved positions of rp1 and rp2 than the
      // original positions had.
      //
      // See APPENDIX on INTERPOLATE at the bottom of this file.
      interpolate: function (p, rp1, rp2, pv) {
          var do1;
          var do2;
          var doa1;
          var doa2;
          var dm1;
          var dm2;
          var dt;

          if (!pv || pv === this) {
              do1 = p.yo - rp1.yo;
              do2 = p.yo - rp2.yo;
              dm1 = rp1.y - rp1.yo;
              dm2 = rp2.y - rp2.yo;
              doa1 = Math.abs(do1);
              doa2 = Math.abs(do2);
              dt = doa1 + doa2;

              if (dt === 0) {
                  p.y = p.yo + (dm1 + dm2) / 2;
                  return;
              }

              p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
              return;
          }

          do1 = pv.distance(p, rp1, true, true);
          do2 = pv.distance(p, rp2, true, true);
          dm1 = pv.distance(rp1, rp1, false, true);
          dm2 = pv.distance(rp2, rp2, false, true);
          doa1 = Math.abs(do1);
          doa2 = Math.abs(do2);
          dt = doa1 + doa2;

          if (dt === 0) {
              yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
              return;
          }

          yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
      },

      // Slope of line normal to this.
      normalSlope: 0,

      // Sets the point 'p' relative to point 'rp'
      // by the distance 'd'
      //
      // See APPENDIX on SETRELATIVE at the bottom of this file.
      //
      // p   ... point to set
      // rp  ... reference point
      // d   ... distance on projection vector
      // pv  ... projection vector (undefined = this)
      // org ... if true, uses the original position of rp as reference.
      setRelative: function (p, rp, d, pv, org) {
          if (!pv || pv === this) {
              p.y = (org ? rp.yo : rp.y) + d;
              return;
          }

          var rpx = org ? rp.xo : rp.x;
          var rpy = org ? rp.yo : rp.y;
          var rpdx = rpx + d * pv.x;
          var rpdy = rpy + d * pv.y;

          p.y = rpdy + pv.normalSlope * (p.x - rpdx);
      },

      // Slope of vector line.
      slope: Number.POSITIVE_INFINITY,

      // Touches the point p.
      touch: function (p) {
          p.yTouched = true;
      },

      // Tests if a point p is touched.
      touched: function (p) {
          return p.yTouched;
      },

      // Untouches the point p.
      untouch: function (p) {
          p.yTouched = false;
      }
  };

  Object.freeze(xUnitVector);
  Object.freeze(yUnitVector);

  /*
  * Creates a unit vector that is not x- or y-axis.
  */
  function UnitVector(x, y) {
      this.x = x;
      this.y = y;
      this.axis = undefined;
      this.slope = y / x;
      this.normalSlope = -x / y;
      Object.freeze(this);
  }

  /*
  * Gets the projected distance between two points.
  * o1/o2 ... if true, respective original position is used.
  */
  UnitVector.prototype.distance = function(p1, p2, o1, o2) {
      return (
          this.x * xUnitVector.distance(p1, p2, o1, o2) +
          this.y * yUnitVector.distance(p1, p2, o1, o2)
      );
  };

  /*
  * Moves point p so the moved position has the same relative
  * position to the moved positions of rp1 and rp2 than the
  * original positions had.
  *
  * See APPENDIX on INTERPOLATE at the bottom of this file.
  */
  UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
      var dm1;
      var dm2;
      var do1;
      var do2;
      var doa1;
      var doa2;
      var dt;

      do1 = pv.distance(p, rp1, true, true);
      do2 = pv.distance(p, rp2, true, true);
      dm1 = pv.distance(rp1, rp1, false, true);
      dm2 = pv.distance(rp2, rp2, false, true);
      doa1 = Math.abs(do1);
      doa2 = Math.abs(do2);
      dt = doa1 + doa2;

      if (dt === 0) {
          this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
          return;
      }

      this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
  };

  /*
  * Sets the point 'p' relative to point 'rp'
  * by the distance 'd'
  *
  * See APPENDIX on SETRELATIVE at the bottom of this file.
  *
  * p   ...  point to set
  * rp  ... reference point
  * d   ... distance on projection vector
  * pv  ... projection vector (undefined = this)
  * org ... if true, uses the original position of rp as reference.
  */
  UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
      pv = pv || this;

      var rpx = org ? rp.xo : rp.x;
      var rpy = org ? rp.yo : rp.y;
      var rpdx = rpx + d * pv.x;
      var rpdy = rpy + d * pv.y;

      var pvns = pv.normalSlope;
      var fvs = this.slope;

      var px = p.x;
      var py = p.y;

      p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
      p.y = fvs * (p.x - px) + py;
  };

  /*
  * Touches the point p.
  */
  UnitVector.prototype.touch = function(p) {
      p.xTouched = true;
      p.yTouched = true;
  };

  /*
  * Returns a unit vector with x/y coordinates.
  */
  function getUnitVector(x, y) {
      var d = Math.sqrt(x * x + y * y);

      x /= d;
      y /= d;

      if (x === 1 && y === 0) { return xUnitVector; }
      else if (x === 0 && y === 1) { return yUnitVector; }
      else { return new UnitVector(x, y); }
  }

  /*
  * Creates a point in the hinting engine.
  */
  function HPoint(
      x,
      y,
      lastPointOfContour,
      onCurve
  ) {
      this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
      this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

      this.lastPointOfContour = lastPointOfContour;
      this.onCurve = onCurve;
      this.prevPointOnContour = undefined;
      this.nextPointOnContour = undefined;
      this.xTouched = false;
      this.yTouched = false;

      Object.preventExtensions(this);
  }

  /*
  * Returns the next touched point on the contour.
  *
  * v  ... unit vector to test touch axis.
  */
  HPoint.prototype.nextTouched = function(v) {
      var p = this.nextPointOnContour;

      while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

      return p;
  };

  /*
  * Returns the previous touched point on the contour
  *
  * v  ... unit vector to test touch axis.
  */
  HPoint.prototype.prevTouched = function(v) {
      var p = this.prevPointOnContour;

      while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

      return p;
  };

  /*
  * The zero point.
  */
  var HPZero = Object.freeze(new HPoint(0, 0));

  /*
  * The default state of the interpreter.
  *
  * Note: Freezing the defaultState and then deriving from it
  * makes the V8 Javascript engine going awkward,
  * so this is avoided, albeit the defaultState shouldn't
  * ever change.
  */
  var defaultState = {
      cvCutIn: 17 / 16,    // control value cut in
      deltaBase: 9,
      deltaShift: 0.125,
      loop: 1,             // loops some instructions
      minDis: 1,           // minimum distance
      autoFlip: true
  };

  /*
  * The current state of the interpreter.
  *
  * env  ... 'fpgm' or 'prep' or 'glyf'
  * prog ... the program
  */
  function State(env, prog) {
      this.env = env;
      this.stack = [];
      this.prog = prog;

      switch (env) {
          case 'glyf' :
              this.zp0 = this.zp1 = this.zp2 = 1;
              this.rp0 = this.rp1 = this.rp2 = 0;
              /* fall through */
          case 'prep' :
              this.fv = this.pv = this.dpv = xUnitVector;
              this.round = roundToGrid;
      }
  }

  /*
  * Executes a glyph program.
  *
  * This does the hinting for each glyph.
  *
  * Returns an array of moved points.
  *
  * glyph: the glyph to hint
  * ppem: the size the glyph is rendered for
  */
  Hinting.prototype.exec = function(glyph, ppem) {
      if (typeof ppem !== 'number') {
          throw new Error('Point size is not a number!');
      }

      // Received a fatal error, don't do any hinting anymore.
      if (this._errorState > 2) { return; }

      var font = this.font;
      var prepState = this._prepState;

      if (!prepState || prepState.ppem !== ppem) {
          var fpgmState = this._fpgmState;

          if (!fpgmState) {
              // Executes the fpgm state.
              // This is used by fonts to define functions.
              State.prototype = defaultState;

              fpgmState =
              this._fpgmState =
                  new State('fpgm', font.tables.fpgm);

              fpgmState.funcs = [ ];
              fpgmState.font = font;

              if (exports.DEBUG) {
                  console.log('---EXEC FPGM---');
                  fpgmState.step = -1;
              }

              try {
                  exec(fpgmState);
              } catch (e) {
                  console.log('Hinting error in FPGM:' + e);
                  this._errorState = 3;
                  return;
              }
          }

          // Executes the prep program for this ppem setting.
          // This is used by fonts to set cvt values
          // depending on to be rendered font size.

          State.prototype = fpgmState;
          prepState =
          this._prepState =
              new State('prep', font.tables.prep);

          prepState.ppem = ppem;

          // Creates a copy of the cvt table
          // and scales it to the current ppem setting.
          var oCvt = font.tables.cvt;
          if (oCvt) {
              var cvt = prepState.cvt = new Array(oCvt.length);
              var scale = ppem / font.unitsPerEm;
              for (var c = 0; c < oCvt.length; c++) {
                  cvt[c] = oCvt[c] * scale;
              }
          } else {
              prepState.cvt = [];
          }

          if (exports.DEBUG) {
              console.log('---EXEC PREP---');
              prepState.step = -1;
          }

          try {
              exec(prepState);
          } catch (e) {
              if (this._errorState < 2) {
                  console.log('Hinting error in PREP:' + e);
              }
              this._errorState = 2;
          }
      }

      if (this._errorState > 1) { return; }

      try {
          return execGlyph(glyph, prepState);
      } catch (e) {
          if (this._errorState < 1) {
              console.log('Hinting error:' + e);
              console.log('Note: further hinting errors are silenced');
          }
          this._errorState = 1;
          return undefined;
      }
  };

  /*
  * Executes the hinting program for a glyph.
  */
  execGlyph = function(glyph, prepState) {
      // original point positions
      var xScale = prepState.ppem / prepState.font.unitsPerEm;
      var yScale = xScale;
      var components = glyph.components;
      var contours;
      var gZone;
      var state;

      State.prototype = prepState;
      if (!components) {
          state = new State('glyf', glyph.instructions);
          if (exports.DEBUG) {
              console.log('---EXEC GLYPH---');
              state.step = -1;
          }
          execComponent(glyph, state, xScale, yScale);
          gZone = state.gZone;
      } else {
          var font = prepState.font;
          gZone = [];
          contours = [];
          for (var i = 0; i < components.length; i++) {
              var c = components[i];
              var cg = font.glyphs.get(c.glyphIndex);

              state = new State('glyf', cg.instructions);

              if (exports.DEBUG) {
                  console.log('---EXEC COMP ' + i + '---');
                  state.step = -1;
              }

              execComponent(cg, state, xScale, yScale);
              // appends the computed points to the result array
              // post processes the component points
              var dx = Math.round(c.dx * xScale);
              var dy = Math.round(c.dy * yScale);
              var gz = state.gZone;
              var cc = state.contours;
              for (var pi = 0; pi < gz.length; pi++) {
                  var p = gz[pi];
                  p.xTouched = p.yTouched = false;
                  p.xo = p.x = p.x + dx;
                  p.yo = p.y = p.y + dy;
              }

              var gLen = gZone.length;
              gZone.push.apply(gZone, gz);
              for (var j = 0; j < cc.length; j++) {
                  contours.push(cc[j] + gLen);
              }
          }

          if (glyph.instructions && !state.inhibitGridFit) {
              // the composite has instructions on its own
              state = new State('glyf', glyph.instructions);

              state.gZone = state.z0 = state.z1 = state.z2 = gZone;

              state.contours = contours;

              // note: HPZero cannot be used here, since
              //       the point might be modified
              gZone.push(
                  new HPoint(0, 0),
                  new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
              );

              if (exports.DEBUG) {
                  console.log('---EXEC COMPOSITE---');
                  state.step = -1;
              }

              exec(state);

              gZone.length -= 2;
          }
      }

      return gZone;
  };

  /*
  * Executes the hinting program for a component of a multi-component glyph
  * or of the glyph itself for a non-component glyph.
  */
  execComponent = function(glyph, state, xScale, yScale)
  {
      var points = glyph.points || [];
      var pLen = points.length;
      var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
      var contours = state.contours = [];

      // Scales the original points and
      // makes copies for the hinted points.
      var cp; // current point
      for (var i = 0; i < pLen; i++) {
          cp = points[i];

          gZone[i] = new HPoint(
              cp.x * xScale,
              cp.y * yScale,
              cp.lastPointOfContour,
              cp.onCurve
          );
      }

      // Chain links the contours.
      var sp; // start point
      var np; // next point

      for (var i$1 = 0; i$1 < pLen; i$1++) {
          cp = gZone[i$1];

          if (!sp) {
              sp = cp;
              contours.push(i$1);
          }

          if (cp.lastPointOfContour) {
              cp.nextPointOnContour = sp;
              sp.prevPointOnContour = cp;
              sp = undefined;
          } else {
              np = gZone[i$1 + 1];
              cp.nextPointOnContour = np;
              np.prevPointOnContour = cp;
          }
      }

      if (state.inhibitGridFit) { return; }

      if (exports.DEBUG) {
          console.log('PROCESSING GLYPH', state.stack);
          for (var i$2 = 0; i$2 < pLen; i$2++) {
              console.log(i$2, gZone[i$2].x, gZone[i$2].y);
          }
      }

      gZone.push(
          new HPoint(0, 0),
          new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
      );

      exec(state);

      // Removes the extra points.
      gZone.length -= 2;

      if (exports.DEBUG) {
          console.log('FINISHED GLYPH', state.stack);
          for (var i$3 = 0; i$3 < pLen; i$3++) {
              console.log(i$3, gZone[i$3].x, gZone[i$3].y);
          }
      }
  };

  /*
  * Executes the program loaded in state.
  */
  exec = function(state) {
      var prog = state.prog;

      if (!prog) { return; }

      var pLen = prog.length;
      var ins;

      for (state.ip = 0; state.ip < pLen; state.ip++) {
          if (exports.DEBUG) { state.step++; }
          ins = instructionTable[prog[state.ip]];

          if (!ins) {
              throw new Error(
                  'unknown instruction: 0x' +
                  Number(prog[state.ip]).toString(16)
              );
          }

          ins(state);

          // very extensive debugging for each step
          /*
          if (exports.DEBUG) {
              var da;
              if (state.gZone) {
                  da = [];
                  for (let i = 0; i < state.gZone.length; i++)
                  {
                      da.push(i + ' ' +
                          state.gZone[i].x * 64 + ' ' +
                          state.gZone[i].y * 64 + ' ' +
                          (state.gZone[i].xTouched ? 'x' : '') +
                          (state.gZone[i].yTouched ? 'y' : '')
                      );
                  }
                  console.log('GZ', da);
              }

              if (state.tZone) {
                  da = [];
                  for (let i = 0; i < state.tZone.length; i++) {
                      da.push(i + ' ' +
                          state.tZone[i].x * 64 + ' ' +
                          state.tZone[i].y * 64 + ' ' +
                          (state.tZone[i].xTouched ? 'x' : '') +
                          (state.tZone[i].yTouched ? 'y' : '')
                      );
                  }
                  console.log('TZ', da);
              }

              if (state.stack.length > 10) {
                  console.log(
                      state.stack.length,
                      '...', state.stack.slice(state.stack.length - 10)
                  );
              } else {
                  console.log(state.stack.length, state.stack);
              }
          }
          */
      }
  };

  /*
  * Initializes the twilight zone.
  *
  * This is only done if a SZPx instruction
  * refers to the twilight zone.
  */
  function initTZone(state)
  {
      var tZone = state.tZone = new Array(state.gZone.length);

      // no idea if this is actually correct...
      for (var i = 0; i < tZone.length; i++)
      {
          tZone[i] = new HPoint(0, 0);
      }
  }

  /*
  * Skips the instruction pointer ahead over an IF/ELSE block.
  * handleElse .. if true breaks on matching ELSE
  */
  function skip(state, handleElse)
  {
      var prog = state.prog;
      var ip = state.ip;
      var nesting = 1;
      var ins;

      do {
          ins = prog[++ip];
          if (ins === 0x58) // IF
              { nesting++; }
          else if (ins === 0x59) // EIF
              { nesting--; }
          else if (ins === 0x40) // NPUSHB
              { ip += prog[ip + 1] + 1; }
          else if (ins === 0x41) // NPUSHW
              { ip += 2 * prog[ip + 1] + 1; }
          else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
              { ip += ins - 0xB0 + 1; }
          else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
              { ip += (ins - 0xB8 + 1) * 2; }
          else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
              { break; }
      } while (nesting > 0);

      state.ip = ip;
  }

  /*----------------------------------------------------------*
  *          And then a lot of instructions...                *
  *----------------------------------------------------------*/

  // SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
  // 0x00-0x01
  function SVTCA(v, state) {
      if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

      state.fv = state.pv = state.dpv = v;
  }

  // SPVTCA[a] Set Projection Vector to Coordinate Axis
  // 0x02-0x03
  function SPVTCA(v, state) {
      if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

      state.pv = state.dpv = v;
  }

  // SFVTCA[a] Set Freedom Vector to Coordinate Axis
  // 0x04-0x05
  function SFVTCA(v, state) {
      if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

      state.fv = v;
  }

  // SPVTL[a] Set Projection Vector To Line
  // 0x06-0x07
  function SPVTL(a, state) {
      var stack = state.stack;
      var p2i = stack.pop();
      var p1i = stack.pop();
      var p2 = state.z2[p2i];
      var p1 = state.z1[p1i];

      if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

      var dx;
      var dy;

      if (!a) {
          dx = p1.x - p2.x;
          dy = p1.y - p2.y;
      } else {
          dx = p2.y - p1.y;
          dy = p1.x - p2.x;
      }

      state.pv = state.dpv = getUnitVector(dx, dy);
  }

  // SFVTL[a] Set Freedom Vector To Line
  // 0x08-0x09
  function SFVTL(a, state) {
      var stack = state.stack;
      var p2i = stack.pop();
      var p1i = stack.pop();
      var p2 = state.z2[p2i];
      var p1 = state.z1[p1i];

      if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

      var dx;
      var dy;

      if (!a) {
          dx = p1.x - p2.x;
          dy = p1.y - p2.y;
      } else {
          dx = p2.y - p1.y;
          dy = p1.x - p2.x;
      }

      state.fv = getUnitVector(dx, dy);
  }

  // SPVFS[] Set Projection Vector From Stack
  // 0x0A
  function SPVFS(state) {
      var stack = state.stack;
      var y = stack.pop();
      var x = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

      state.pv = state.dpv = getUnitVector(x, y);
  }

  // SFVFS[] Set Freedom Vector From Stack
  // 0x0B
  function SFVFS(state) {
      var stack = state.stack;
      var y = stack.pop();
      var x = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

      state.fv = getUnitVector(x, y);
  }

  // GPV[] Get Projection Vector
  // 0x0C
  function GPV(state) {
      var stack = state.stack;
      var pv = state.pv;

      if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

      stack.push(pv.x * 0x4000);
      stack.push(pv.y * 0x4000);
  }

  // GFV[] Get Freedom Vector
  // 0x0C
  function GFV(state) {
      var stack = state.stack;
      var fv = state.fv;

      if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

      stack.push(fv.x * 0x4000);
      stack.push(fv.y * 0x4000);
  }

  // SFVTPV[] Set Freedom Vector To Projection Vector
  // 0x0E
  function SFVTPV(state) {
      state.fv = state.pv;

      if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
  }

  // ISECT[] moves point p to the InterSECTion of two lines
  // 0x0F
  function ISECT(state)
  {
      var stack = state.stack;
      var pa0i = stack.pop();
      var pa1i = stack.pop();
      var pb0i = stack.pop();
      var pb1i = stack.pop();
      var pi = stack.pop();
      var z0 = state.z0;
      var z1 = state.z1;
      var pa0 = z0[pa0i];
      var pa1 = z0[pa1i];
      var pb0 = z1[pb0i];
      var pb1 = z1[pb1i];
      var p = state.z2[pi];

      if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

      // math from
      // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

      var x1 = pa0.x;
      var y1 = pa0.y;
      var x2 = pa1.x;
      var y2 = pa1.y;
      var x3 = pb0.x;
      var y3 = pb0.y;
      var x4 = pb1.x;
      var y4 = pb1.y;

      var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
      var f1 = x1 * y2 - y1 * x2;
      var f2 = x3 * y4 - y3 * x4;

      p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
      p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
  }

  // SRP0[] Set Reference Point 0
  // 0x10
  function SRP0(state) {
      state.rp0 = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
  }

  // SRP1[] Set Reference Point 1
  // 0x11
  function SRP1(state) {
      state.rp1 = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
  }

  // SRP1[] Set Reference Point 2
  // 0x12
  function SRP2(state) {
      state.rp2 = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
  }

  // SZP0[] Set Zone Pointer 0
  // 0x13
  function SZP0(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

      state.zp0 = n;

      switch (n) {
          case 0:
              if (!state.tZone) { initTZone(state); }
              state.z0 = state.tZone;
              break;
          case 1 :
              state.z0 = state.gZone;
              break;
          default :
              throw new Error('Invalid zone pointer');
      }
  }

  // SZP1[] Set Zone Pointer 1
  // 0x14
  function SZP1(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

      state.zp1 = n;

      switch (n) {
          case 0:
              if (!state.tZone) { initTZone(state); }
              state.z1 = state.tZone;
              break;
          case 1 :
              state.z1 = state.gZone;
              break;
          default :
              throw new Error('Invalid zone pointer');
      }
  }

  // SZP2[] Set Zone Pointer 2
  // 0x15
  function SZP2(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

      state.zp2 = n;

      switch (n) {
          case 0:
              if (!state.tZone) { initTZone(state); }
              state.z2 = state.tZone;
              break;
          case 1 :
              state.z2 = state.gZone;
              break;
          default :
              throw new Error('Invalid zone pointer');
      }
  }

  // SZPS[] Set Zone PointerS
  // 0x16
  function SZPS(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

      state.zp0 = state.zp1 = state.zp2 = n;

      switch (n) {
          case 0:
              if (!state.tZone) { initTZone(state); }
              state.z0 = state.z1 = state.z2 = state.tZone;
              break;
          case 1 :
              state.z0 = state.z1 = state.z2 = state.gZone;
              break;
          default :
              throw new Error('Invalid zone pointer');
      }
  }

  // SLOOP[] Set LOOP variable
  // 0x17
  function SLOOP(state) {
      state.loop = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
  }

  // RTG[] Round To Grid
  // 0x18
  function RTG(state) {
      if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

      state.round = roundToGrid;
  }

  // RTHG[] Round To Half Grid
  // 0x19
  function RTHG(state) {
      if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

      state.round = roundToHalfGrid;
  }

  // SMD[] Set Minimum Distance
  // 0x1A
  function SMD(state) {
      var d = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

      state.minDis = d / 0x40;
  }

  // ELSE[] ELSE clause
  // 0x1B
  function ELSE(state) {
      // This instruction has been reached by executing a then branch
      // so it just skips ahead until matching EIF.
      //
      // In case the IF was negative the IF[] instruction already
      // skipped forward over the ELSE[]

      if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

      skip(state, false);
  }

  // JMPR[] JuMP Relative
  // 0x1C
  function JMPR(state) {
      var o = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

      // A jump by 1 would do nothing.
      state.ip += o - 1;
  }

  // SCVTCI[] Set Control Value Table Cut-In
  // 0x1D
  function SCVTCI(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

      state.cvCutIn = n / 0x40;
  }

  // DUP[] DUPlicate top stack element
  // 0x20
  function DUP(state) {
      var stack = state.stack;

      if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

      stack.push(stack[stack.length - 1]);
  }

  // POP[] POP top stack element
  // 0x21
  function POP(state) {
      if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

      state.stack.pop();
  }

  // CLEAR[] CLEAR the stack
  // 0x22
  function CLEAR(state) {
      if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

      state.stack.length = 0;
  }

  // SWAP[] SWAP the top two elements on the stack
  // 0x23
  function SWAP(state) {
      var stack = state.stack;

      var a = stack.pop();
      var b = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

      stack.push(a);
      stack.push(b);
  }

  // DEPTH[] DEPTH of the stack
  // 0x24
  function DEPTH(state) {
      var stack = state.stack;

      if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

      stack.push(stack.length);
  }

  // LOOPCALL[] LOOPCALL function
  // 0x2A
  function LOOPCALL(state) {
      var stack = state.stack;
      var fn = stack.pop();
      var c = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

      // saves callers program
      var cip = state.ip;
      var cprog = state.prog;

      state.prog = state.funcs[fn];

      // executes the function
      for (var i = 0; i < c; i++) {
          exec(state);

          if (exports.DEBUG) { console.log(
              ++state.step,
              i + 1 < c ? 'next loopcall' : 'done loopcall',
              i
          ); }
      }

      // restores the callers program
      state.ip = cip;
      state.prog = cprog;
  }

  // CALL[] CALL function
  // 0x2B
  function CALL(state) {
      var fn = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

      // saves callers program
      var cip = state.ip;
      var cprog = state.prog;

      state.prog = state.funcs[fn];

      // executes the function
      exec(state);

      // restores the callers program
      state.ip = cip;
      state.prog = cprog;

      if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
  }

  // CINDEX[] Copy the INDEXed element to the top of the stack
  // 0x25
  function CINDEX(state) {
      var stack = state.stack;
      var k = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

      // In case of k == 1, it copies the last element after popping
      // thus stack.length - k.
      stack.push(stack[stack.length - k]);
  }

  // MINDEX[] Move the INDEXed element to the top of the stack
  // 0x26
  function MINDEX(state) {
      var stack = state.stack;
      var k = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

      stack.push(stack.splice(stack.length - k, 1)[0]);
  }

  // FDEF[] Function DEFinition
  // 0x2C
  function FDEF(state) {
      if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
      var stack = state.stack;
      var prog = state.prog;
      var ip = state.ip;

      var fn = stack.pop();
      var ipBegin = ip;

      if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

      while (prog[++ip] !== 0x2D){ }

      state.ip = ip;
      state.funcs[fn] = prog.slice(ipBegin + 1, ip);
  }

  // MDAP[a] Move Direct Absolute Point
  // 0x2E-0x2F
  function MDAP(round, state) {
      var pi = state.stack.pop();
      var p = state.z0[pi];
      var fv = state.fv;
      var pv = state.pv;

      if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

      var d = pv.distance(p, HPZero);

      if (round) { d = state.round(d); }

      fv.setRelative(p, HPZero, d, pv);
      fv.touch(p);

      state.rp0 = state.rp1 = pi;
  }

  // IUP[a] Interpolate Untouched Points through the outline
  // 0x30
  function IUP(v, state) {
      var z2 = state.z2;
      var pLen = z2.length - 2;
      var cp;
      var pp;
      var np;

      if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

      for (var i = 0; i < pLen; i++) {
          cp = z2[i]; // current point

          // if this point has been touched go on
          if (v.touched(cp)) { continue; }

          pp = cp.prevTouched(v);

          // no point on the contour has been touched?
          if (pp === cp) { continue; }

          np = cp.nextTouched(v);

          if (pp === np) {
              // only one point on the contour has been touched
              // so simply moves the point like that

              v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
          }

          v.interpolate(cp, pp, np, v);
      }
  }

  // SHP[] SHift Point using reference point
  // 0x32-0x33
  function SHP(a, state) {
      var stack = state.stack;
      var rpi = a ? state.rp1 : state.rp2;
      var rp = (a ? state.z0 : state.z1)[rpi];
      var fv = state.fv;
      var pv = state.pv;
      var loop = state.loop;
      var z2 = state.z2;

      while (loop--)
      {
          var pi = stack.pop();
          var p = z2[pi];

          var d = pv.distance(rp, rp, false, true);
          fv.setRelative(p, p, d, pv);
          fv.touch(p);

          if (exports.DEBUG) {
              console.log(
                  state.step,
                  (state.loop > 1 ?
                     'loop ' + (state.loop - loop) + ': ' :
                     ''
                  ) +
                  'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
              );
          }
      }

      state.loop = 1;
  }

  // SHC[] SHift Contour using reference point
  // 0x36-0x37
  function SHC(a, state) {
      var stack = state.stack;
      var rpi = a ? state.rp1 : state.rp2;
      var rp = (a ? state.z0 : state.z1)[rpi];
      var fv = state.fv;
      var pv = state.pv;
      var ci = stack.pop();
      var sp = state.z2[state.contours[ci]];
      var p = sp;

      if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

      var d = pv.distance(rp, rp, false, true);

      do {
          if (p !== rp) { fv.setRelative(p, p, d, pv); }
          p = p.nextPointOnContour;
      } while (p !== sp);
  }

  // SHZ[] SHift Zone using reference point
  // 0x36-0x37
  function SHZ(a, state) {
      var stack = state.stack;
      var rpi = a ? state.rp1 : state.rp2;
      var rp = (a ? state.z0 : state.z1)[rpi];
      var fv = state.fv;
      var pv = state.pv;

      var e = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

      var z;
      switch (e) {
          case 0 : z = state.tZone; break;
          case 1 : z = state.gZone; break;
          default : throw new Error('Invalid zone');
      }

      var p;
      var d = pv.distance(rp, rp, false, true);
      var pLen = z.length - 2;
      for (var i = 0; i < pLen; i++)
      {
          p = z[i];
          fv.setRelative(p, p, d, pv);
          //if (p !== rp) fv.setRelative(p, p, d, pv);
      }
  }

  // SHPIX[] SHift point by a PIXel amount
  // 0x38
  function SHPIX(state) {
      var stack = state.stack;
      var loop = state.loop;
      var fv = state.fv;
      var d = stack.pop() / 0x40;
      var z2 = state.z2;

      while (loop--) {
          var pi = stack.pop();
          var p = z2[pi];

          if (exports.DEBUG) {
              console.log(
                  state.step,
                  (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                  'SHPIX[]', pi, d
              );
          }

          fv.setRelative(p, p, d);
          fv.touch(p);
      }

      state.loop = 1;
  }

  // IP[] Interpolate Point
  // 0x39
  function IP(state) {
      var stack = state.stack;
      var rp1i = state.rp1;
      var rp2i = state.rp2;
      var loop = state.loop;
      var rp1 = state.z0[rp1i];
      var rp2 = state.z1[rp2i];
      var fv = state.fv;
      var pv = state.dpv;
      var z2 = state.z2;

      while (loop--) {
          var pi = stack.pop();
          var p = z2[pi];

          if (exports.DEBUG) {
              console.log(
                  state.step,
                  (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                  'IP[]', pi, rp1i, '<->', rp2i
              );
          }

          fv.interpolate(p, rp1, rp2, pv);

          fv.touch(p);
      }

      state.loop = 1;
  }

  // MSIRP[a] Move Stack Indirect Relative Point
  // 0x3A-0x3B
  function MSIRP(a, state) {
      var stack = state.stack;
      var d = stack.pop() / 64;
      var pi = stack.pop();
      var p = state.z1[pi];
      var rp0 = state.z0[state.rp0];
      var fv = state.fv;
      var pv = state.pv;

      fv.setRelative(p, rp0, d, pv);
      fv.touch(p);

      if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

      state.rp1 = state.rp0;
      state.rp2 = pi;
      if (a) { state.rp0 = pi; }
  }

  // ALIGNRP[] Align to reference point.
  // 0x3C
  function ALIGNRP(state) {
      var stack = state.stack;
      var rp0i = state.rp0;
      var rp0 = state.z0[rp0i];
      var loop = state.loop;
      var fv = state.fv;
      var pv = state.pv;
      var z1 = state.z1;

      while (loop--) {
          var pi = stack.pop();
          var p = z1[pi];

          if (exports.DEBUG) {
              console.log(
                  state.step,
                  (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                  'ALIGNRP[]', pi
              );
          }

          fv.setRelative(p, rp0, 0, pv);
          fv.touch(p);
      }

      state.loop = 1;
  }

  // RTG[] Round To Double Grid
  // 0x3D
  function RTDG(state) {
      if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

      state.round = roundToDoubleGrid;
  }

  // MIAP[a] Move Indirect Absolute Point
  // 0x3E-0x3F
  function MIAP(round, state) {
      var stack = state.stack;
      var n = stack.pop();
      var pi = stack.pop();
      var p = state.z0[pi];
      var fv = state.fv;
      var pv = state.pv;
      var cv = state.cvt[n];

      if (exports.DEBUG) {
          console.log(
              state.step,
              'MIAP[' + round + ']',
              n, '(', cv, ')', pi
          );
      }

      var d = pv.distance(p, HPZero);

      if (round) {
          if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

          d = state.round(d);
      }

      fv.setRelative(p, HPZero, d, pv);

      if (state.zp0 === 0) {
          p.xo = p.x;
          p.yo = p.y;
      }

      fv.touch(p);

      state.rp0 = state.rp1 = pi;
  }

  // NPUSB[] PUSH N Bytes
  // 0x40
  function NPUSHB(state) {
      var prog = state.prog;
      var ip = state.ip;
      var stack = state.stack;

      var n = prog[++ip];

      if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

      for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

      state.ip = ip;
  }

  // NPUSHW[] PUSH N Words
  // 0x41
  function NPUSHW(state) {
      var ip = state.ip;
      var prog = state.prog;
      var stack = state.stack;
      var n = prog[++ip];

      if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

      for (var i = 0; i < n; i++) {
          var w = (prog[++ip] << 8) | prog[++ip];
          if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
          stack.push(w);
      }

      state.ip = ip;
  }

  // WS[] Write Store
  // 0x42
  function WS(state) {
      var stack = state.stack;
      var store = state.store;

      if (!store) { store = state.store = []; }

      var v = stack.pop();
      var l = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

      store[l] = v;
  }

  // RS[] Read Store
  // 0x43
  function RS(state) {
      var stack = state.stack;
      var store = state.store;

      var l = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'RS', l); }

      var v = (store && store[l]) || 0;

      stack.push(v);
  }

  // WCVTP[] Write Control Value Table in Pixel units
  // 0x44
  function WCVTP(state) {
      var stack = state.stack;

      var v = stack.pop();
      var l = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

      state.cvt[l] = v / 0x40;
  }

  // RCVT[] Read Control Value Table entry
  // 0x45
  function RCVT(state) {
      var stack = state.stack;
      var cvte = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

      stack.push(state.cvt[cvte] * 0x40);
  }

  // GC[] Get Coordinate projected onto the projection vector
  // 0x46-0x47
  function GC(a, state) {
      var stack = state.stack;
      var pi = stack.pop();
      var p = state.z2[pi];

      if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

      stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
  }

  // MD[a] Measure Distance
  // 0x49-0x4A
  function MD(a, state) {
      var stack = state.stack;
      var pi2 = stack.pop();
      var pi1 = stack.pop();
      var p2 = state.z1[pi2];
      var p1 = state.z0[pi1];
      var d = state.dpv.distance(p1, p2, a, a);

      if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

      state.stack.push(Math.round(d * 64));
  }

  // MPPEM[] Measure Pixels Per EM
  // 0x4B
  function MPPEM(state) {
      if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
      state.stack.push(state.ppem);
  }

  // FLIPON[] set the auto FLIP Boolean to ON
  // 0x4D
  function FLIPON(state) {
      if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
      state.autoFlip = true;
  }

  // LT[] Less Than
  // 0x50
  function LT(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

      stack.push(e1 < e2 ? 1 : 0);
  }

  // LTEQ[] Less Than or EQual
  // 0x53
  function LTEQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

      stack.push(e1 <= e2 ? 1 : 0);
  }

  // GTEQ[] Greater Than
  // 0x52
  function GT(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

      stack.push(e1 > e2 ? 1 : 0);
  }

  // GTEQ[] Greater Than or EQual
  // 0x53
  function GTEQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

      stack.push(e1 >= e2 ? 1 : 0);
  }

  // EQ[] EQual
  // 0x54
  function EQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

      stack.push(e2 === e1 ? 1 : 0);
  }

  // NEQ[] Not EQual
  // 0x55
  function NEQ(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

      stack.push(e2 !== e1 ? 1 : 0);
  }

  // ODD[] ODD
  // 0x56
  function ODD(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

      stack.push(Math.trunc(n) % 2 ? 1 : 0);
  }

  // EVEN[] EVEN
  // 0x57
  function EVEN(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

      stack.push(Math.trunc(n) % 2 ? 0 : 1);
  }

  // IF[] IF test
  // 0x58
  function IF(state) {
      var test = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

      // if test is true it just continues
      // if not the ip is skipped until matching ELSE or EIF
      if (!test) {
          skip(state, true);

          if (exports.DEBUG) { console.log(state.step,  'EIF[]'); }
      }
  }

  // EIF[] End IF
  // 0x59
  function EIF(state) {
      // this can be reached normally when
      // executing an else branch.
      // -> just ignore it

      if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
  }

  // AND[] logical AND
  // 0x5A
  function AND(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

      stack.push(e2 && e1 ? 1 : 0);
  }

  // OR[] logical OR
  // 0x5B
  function OR(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

      stack.push(e2 || e1 ? 1 : 0);
  }

  // NOT[] logical NOT
  // 0x5C
  function NOT(state) {
      var stack = state.stack;
      var e = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

      stack.push(e ? 0 : 1);
  }

  // DELTAP1[] DELTA exception P1
  // DELTAP2[] DELTA exception P2
  // DELTAP3[] DELTA exception P3
  // 0x5D, 0x71, 0x72
  function DELTAP123(b, state) {
      var stack = state.stack;
      var n = stack.pop();
      var fv = state.fv;
      var pv = state.pv;
      var ppem = state.ppem;
      var base = state.deltaBase + (b - 1) * 16;
      var ds = state.deltaShift;
      var z0 = state.z0;

      if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

      for (var i = 0; i < n; i++) {
          var pi = stack.pop();
          var arg = stack.pop();
          var appem = base + ((arg & 0xF0) >> 4);
          if (appem !== ppem) { continue; }

          var mag = (arg & 0x0F) - 8;
          if (mag >= 0) { mag++; }
          if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

          var p = z0[pi];
          fv.setRelative(p, p, mag * ds, pv);
      }
  }

  // SDB[] Set Delta Base in the graphics state
  // 0x5E
  function SDB(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

      state.deltaBase = n;
  }

  // SDS[] Set Delta Shift in the graphics state
  // 0x5F
  function SDS(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

      state.deltaShift = Math.pow(0.5, n);
  }

  // ADD[] ADD
  // 0x60
  function ADD(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

      stack.push(n1 + n2);
  }

  // SUB[] SUB
  // 0x61
  function SUB(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

      stack.push(n1 - n2);
  }

  // DIV[] DIV
  // 0x62
  function DIV(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

      stack.push(n1 * 64 / n2);
  }

  // MUL[] MUL
  // 0x63
  function MUL(state) {
      var stack = state.stack;
      var n2 = stack.pop();
      var n1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

      stack.push(n1 * n2 / 64);
  }

  // ABS[] ABSolute value
  // 0x64
  function ABS(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

      stack.push(Math.abs(n));
  }

  // NEG[] NEGate
  // 0x65
  function NEG(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

      stack.push(-n);
  }

  // FLOOR[] FLOOR
  // 0x66
  function FLOOR(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

      stack.push(Math.floor(n / 0x40) * 0x40);
  }

  // CEILING[] CEILING
  // 0x67
  function CEILING(state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

      stack.push(Math.ceil(n / 0x40) * 0x40);
  }

  // ROUND[ab] ROUND value
  // 0x68-0x6B
  function ROUND(dt, state) {
      var stack = state.stack;
      var n = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

      stack.push(state.round(n / 0x40) * 0x40);
  }

  // WCVTF[] Write Control Value Table in Funits
  // 0x70
  function WCVTF(state) {
      var stack = state.stack;
      var v = stack.pop();
      var l = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

      state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
  }

  // DELTAC1[] DELTA exception C1
  // DELTAC2[] DELTA exception C2
  // DELTAC3[] DELTA exception C3
  // 0x73, 0x74, 0x75
  function DELTAC123(b, state) {
      var stack = state.stack;
      var n = stack.pop();
      var ppem = state.ppem;
      var base = state.deltaBase + (b - 1) * 16;
      var ds = state.deltaShift;

      if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

      for (var i = 0; i < n; i++) {
          var c = stack.pop();
          var arg = stack.pop();
          var appem = base + ((arg & 0xF0) >> 4);
          if (appem !== ppem) { continue; }

          var mag = (arg & 0x0F) - 8;
          if (mag >= 0) { mag++; }

          var delta = mag * ds;

          if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

          state.cvt[c] += delta;
      }
  }

  // SROUND[] Super ROUND
  // 0x76
  function SROUND(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

      state.round = roundSuper;

      var period;

      switch (n & 0xC0) {
          case 0x00:
              period = 0.5;
              break;
          case 0x40:
              period = 1;
              break;
          case 0x80:
              period = 2;
              break;
          default:
              throw new Error('invalid SROUND value');
      }

      state.srPeriod = period;

      switch (n & 0x30) {
          case 0x00:
              state.srPhase = 0;
              break;
          case 0x10:
              state.srPhase = 0.25 * period;
              break;
          case 0x20:
              state.srPhase = 0.5  * period;
              break;
          case 0x30:
              state.srPhase = 0.75 * period;
              break;
          default: throw new Error('invalid SROUND value');
      }

      n &= 0x0F;

      if (n === 0) { state.srThreshold = 0; }
      else { state.srThreshold = (n / 8 - 0.5) * period; }
  }

  // S45ROUND[] Super ROUND 45 degrees
  // 0x77
  function S45ROUND(state) {
      var n = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

      state.round = roundSuper;

      var period;

      switch (n & 0xC0) {
          case 0x00:
              period = Math.sqrt(2) / 2;
              break;
          case 0x40:
              period = Math.sqrt(2);
              break;
          case 0x80:
              period = 2 * Math.sqrt(2);
              break;
          default:
              throw new Error('invalid S45ROUND value');
      }

      state.srPeriod = period;

      switch (n & 0x30) {
          case 0x00:
              state.srPhase = 0;
              break;
          case 0x10:
              state.srPhase = 0.25 * period;
              break;
          case 0x20:
              state.srPhase = 0.5  * period;
              break;
          case 0x30:
              state.srPhase = 0.75 * period;
              break;
          default:
              throw new Error('invalid S45ROUND value');
      }

      n &= 0x0F;

      if (n === 0) { state.srThreshold = 0; }
      else { state.srThreshold = (n / 8 - 0.5) * period; }
  }

  // ROFF[] Round Off
  // 0x7A
  function ROFF(state) {
      if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

      state.round = roundOff;
  }

  // RUTG[] Round Up To Grid
  // 0x7C
  function RUTG(state) {
      if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

      state.round = roundUpToGrid;
  }

  // RDTG[] Round Down To Grid
  // 0x7D
  function RDTG(state) {
      if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

      state.round = roundDownToGrid;
  }

  // SCANCTRL[] SCAN conversion ConTRoL
  // 0x85
  function SCANCTRL(state) {
      var n = state.stack.pop();

      // ignored by opentype.js

      if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
  }

  // SDPVTL[a] Set Dual Projection Vector To Line
  // 0x86-0x87
  function SDPVTL(a, state) {
      var stack = state.stack;
      var p2i = stack.pop();
      var p1i = stack.pop();
      var p2 = state.z2[p2i];
      var p1 = state.z1[p1i];

      if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

      var dx;
      var dy;

      if (!a) {
          dx = p1.x - p2.x;
          dy = p1.y - p2.y;
      } else {
          dx = p2.y - p1.y;
          dy = p1.x - p2.x;
      }

      state.dpv = getUnitVector(dx, dy);
  }

  // GETINFO[] GET INFOrmation
  // 0x88
  function GETINFO(state) {
      var stack = state.stack;
      var sel = stack.pop();
      var r = 0;

      if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

      // v35 as in no subpixel hinting
      if (sel & 0x01) { r = 35; }

      // TODO rotation and stretch currently not supported
      // and thus those GETINFO are always 0.

      // opentype.js is always gray scaling
      if (sel & 0x20) { r |= 0x1000; }

      stack.push(r);
  }

  // ROLL[] ROLL the top three stack elements
  // 0x8A
  function ROLL(state) {
      var stack = state.stack;
      var a = stack.pop();
      var b = stack.pop();
      var c = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

      stack.push(b);
      stack.push(a);
      stack.push(c);
  }

  // MAX[] MAXimum of top two stack elements
  // 0x8B
  function MAX(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

      stack.push(Math.max(e1, e2));
  }

  // MIN[] MINimum of top two stack elements
  // 0x8C
  function MIN(state) {
      var stack = state.stack;
      var e2 = stack.pop();
      var e1 = stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

      stack.push(Math.min(e1, e2));
  }

  // SCANTYPE[] SCANTYPE
  // 0x8D
  function SCANTYPE(state) {
      var n = state.stack.pop();
      // ignored by opentype.js
      if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
  }

  // INSTCTRL[] INSTCTRL
  // 0x8D
  function INSTCTRL(state) {
      var s = state.stack.pop();
      var v = state.stack.pop();

      if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

      switch (s) {
          case 1 : state.inhibitGridFit = !!v; return;
          case 2 : state.ignoreCvt = !!v; return;
          default: throw new Error('invalid INSTCTRL[] selector');
      }
  }

  // PUSHB[abc] PUSH Bytes
  // 0xB0-0xB7
  function PUSHB(n, state) {
      var stack = state.stack;
      var prog = state.prog;
      var ip = state.ip;

      if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

      for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

      state.ip = ip;
  }

  // PUSHW[abc] PUSH Words
  // 0xB8-0xBF
  function PUSHW(n, state) {
      var ip = state.ip;
      var prog = state.prog;
      var stack = state.stack;

      if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

      for (var i = 0; i < n; i++) {
          var w = (prog[++ip] << 8) | prog[++ip];
          if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
          stack.push(w);
      }

      state.ip = ip;
  }

  // MDRP[abcde] Move Direct Relative Point
  // 0xD0-0xEF
  // (if indirect is 0)
  //
  // and
  //
  // MIRP[abcde] Move Indirect Relative Point
  // 0xE0-0xFF
  // (if indirect is 1)

  function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
      var stack = state.stack;
      var cvte = indirect && stack.pop();
      var pi = stack.pop();
      var rp0i = state.rp0;
      var rp = state.z0[rp0i];
      var p = state.z1[pi];

      var md = state.minDis;
      var fv = state.fv;
      var pv = state.dpv;
      var od; // original distance
      var d; // moving distance
      var sign; // sign of distance
      var cv;

      d = od = pv.distance(p, rp, true, true);
      sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

      // TODO consider autoFlip
      d = Math.abs(d);

      if (indirect) {
          cv = state.cvt[cvte];

          if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
      }

      if (keepD && d < md) { d = md; }

      if (ro) { d = state.round(d); }

      fv.setRelative(p, rp, sign * d, pv);
      fv.touch(p);

      if (exports.DEBUG) {
          console.log(
              state.step,
              (indirect ? 'MIRP[' : 'MDRP[') +
              (setRp0 ? 'M' : 'm') +
              (keepD ? '>' : '_') +
              (ro ? 'R' : '_') +
              (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
              ']',
              indirect ?
                  cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
                  '',
              pi,
              '(d =', od, '->', sign * d, ')'
          );
      }

      state.rp1 = state.rp0;
      state.rp2 = pi;
      if (setRp0) { state.rp0 = pi; }
  }

  /*
  * The instruction table.
  */
  instructionTable = [
      /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
      /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
      /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
      /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
      /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
      /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
      /* 0x06 */ SPVTL.bind(undefined, 0),
      /* 0x07 */ SPVTL.bind(undefined, 1),
      /* 0x08 */ SFVTL.bind(undefined, 0),
      /* 0x09 */ SFVTL.bind(undefined, 1),
      /* 0x0A */ SPVFS,
      /* 0x0B */ SFVFS,
      /* 0x0C */ GPV,
      /* 0x0D */ GFV,
      /* 0x0E */ SFVTPV,
      /* 0x0F */ ISECT,
      /* 0x10 */ SRP0,
      /* 0x11 */ SRP1,
      /* 0x12 */ SRP2,
      /* 0x13 */ SZP0,
      /* 0x14 */ SZP1,
      /* 0x15 */ SZP2,
      /* 0x16 */ SZPS,
      /* 0x17 */ SLOOP,
      /* 0x18 */ RTG,
      /* 0x19 */ RTHG,
      /* 0x1A */ SMD,
      /* 0x1B */ ELSE,
      /* 0x1C */ JMPR,
      /* 0x1D */ SCVTCI,
      /* 0x1E */ undefined,   // TODO SSWCI
      /* 0x1F */ undefined,   // TODO SSW
      /* 0x20 */ DUP,
      /* 0x21 */ POP,
      /* 0x22 */ CLEAR,
      /* 0x23 */ SWAP,
      /* 0x24 */ DEPTH,
      /* 0x25 */ CINDEX,
      /* 0x26 */ MINDEX,
      /* 0x27 */ undefined,   // TODO ALIGNPTS
      /* 0x28 */ undefined,
      /* 0x29 */ undefined,   // TODO UTP
      /* 0x2A */ LOOPCALL,
      /* 0x2B */ CALL,
      /* 0x2C */ FDEF,
      /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
      /* 0x2E */ MDAP.bind(undefined, 0),
      /* 0x2F */ MDAP.bind(undefined, 1),
      /* 0x30 */ IUP.bind(undefined, yUnitVector),
      /* 0x31 */ IUP.bind(undefined, xUnitVector),
      /* 0x32 */ SHP.bind(undefined, 0),
      /* 0x33 */ SHP.bind(undefined, 1),
      /* 0x34 */ SHC.bind(undefined, 0),
      /* 0x35 */ SHC.bind(undefined, 1),
      /* 0x36 */ SHZ.bind(undefined, 0),
      /* 0x37 */ SHZ.bind(undefined, 1),
      /* 0x38 */ SHPIX,
      /* 0x39 */ IP,
      /* 0x3A */ MSIRP.bind(undefined, 0),
      /* 0x3B */ MSIRP.bind(undefined, 1),
      /* 0x3C */ ALIGNRP,
      /* 0x3D */ RTDG,
      /* 0x3E */ MIAP.bind(undefined, 0),
      /* 0x3F */ MIAP.bind(undefined, 1),
      /* 0x40 */ NPUSHB,
      /* 0x41 */ NPUSHW,
      /* 0x42 */ WS,
      /* 0x43 */ RS,
      /* 0x44 */ WCVTP,
      /* 0x45 */ RCVT,
      /* 0x46 */ GC.bind(undefined, 0),
      /* 0x47 */ GC.bind(undefined, 1),
      /* 0x48 */ undefined,   // TODO SCFS
      /* 0x49 */ MD.bind(undefined, 0),
      /* 0x4A */ MD.bind(undefined, 1),
      /* 0x4B */ MPPEM,
      /* 0x4C */ undefined,   // TODO MPS
      /* 0x4D */ FLIPON,
      /* 0x4E */ undefined,   // TODO FLIPOFF
      /* 0x4F */ undefined,   // TODO DEBUG
      /* 0x50 */ LT,
      /* 0x51 */ LTEQ,
      /* 0x52 */ GT,
      /* 0x53 */ GTEQ,
      /* 0x54 */ EQ,
      /* 0x55 */ NEQ,
      /* 0x56 */ ODD,
      /* 0x57 */ EVEN,
      /* 0x58 */ IF,
      /* 0x59 */ EIF,
      /* 0x5A */ AND,
      /* 0x5B */ OR,
      /* 0x5C */ NOT,
      /* 0x5D */ DELTAP123.bind(undefined, 1),
      /* 0x5E */ SDB,
      /* 0x5F */ SDS,
      /* 0x60 */ ADD,
      /* 0x61 */ SUB,
      /* 0x62 */ DIV,
      /* 0x63 */ MUL,
      /* 0x64 */ ABS,
      /* 0x65 */ NEG,
      /* 0x66 */ FLOOR,
      /* 0x67 */ CEILING,
      /* 0x68 */ ROUND.bind(undefined, 0),
      /* 0x69 */ ROUND.bind(undefined, 1),
      /* 0x6A */ ROUND.bind(undefined, 2),
      /* 0x6B */ ROUND.bind(undefined, 3),
      /* 0x6C */ undefined,   // TODO NROUND[ab]
      /* 0x6D */ undefined,   // TODO NROUND[ab]
      /* 0x6E */ undefined,   // TODO NROUND[ab]
      /* 0x6F */ undefined,   // TODO NROUND[ab]
      /* 0x70 */ WCVTF,
      /* 0x71 */ DELTAP123.bind(undefined, 2),
      /* 0x72 */ DELTAP123.bind(undefined, 3),
      /* 0x73 */ DELTAC123.bind(undefined, 1),
      /* 0x74 */ DELTAC123.bind(undefined, 2),
      /* 0x75 */ DELTAC123.bind(undefined, 3),
      /* 0x76 */ SROUND,
      /* 0x77 */ S45ROUND,
      /* 0x78 */ undefined,   // TODO JROT[]
      /* 0x79 */ undefined,   // TODO JROF[]
      /* 0x7A */ ROFF,
      /* 0x7B */ undefined,
      /* 0x7C */ RUTG,
      /* 0x7D */ RDTG,
      /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
      /* 0x7F */ POP, // actually AA, supposed to do only a pop though
      /* 0x80 */ undefined,   // TODO FLIPPT
      /* 0x81 */ undefined,   // TODO FLIPRGON
      /* 0x82 */ undefined,   // TODO FLIPRGOFF
      /* 0x83 */ undefined,
      /* 0x84 */ undefined,
      /* 0x85 */ SCANCTRL,
      /* 0x86 */ SDPVTL.bind(undefined, 0),
      /* 0x87 */ SDPVTL.bind(undefined, 1),
      /* 0x88 */ GETINFO,
      /* 0x89 */ undefined,   // TODO IDEF
      /* 0x8A */ ROLL,
      /* 0x8B */ MAX,
      /* 0x8C */ MIN,
      /* 0x8D */ SCANTYPE,
      /* 0x8E */ INSTCTRL,
      /* 0x8F */ undefined,
      /* 0x90 */ undefined,
      /* 0x91 */ undefined,
      /* 0x92 */ undefined,
      /* 0x93 */ undefined,
      /* 0x94 */ undefined,
      /* 0x95 */ undefined,
      /* 0x96 */ undefined,
      /* 0x97 */ undefined,
      /* 0x98 */ undefined,
      /* 0x99 */ undefined,
      /* 0x9A */ undefined,
      /* 0x9B */ undefined,
      /* 0x9C */ undefined,
      /* 0x9D */ undefined,
      /* 0x9E */ undefined,
      /* 0x9F */ undefined,
      /* 0xA0 */ undefined,
      /* 0xA1 */ undefined,
      /* 0xA2 */ undefined,
      /* 0xA3 */ undefined,
      /* 0xA4 */ undefined,
      /* 0xA5 */ undefined,
      /* 0xA6 */ undefined,
      /* 0xA7 */ undefined,
      /* 0xA8 */ undefined,
      /* 0xA9 */ undefined,
      /* 0xAA */ undefined,
      /* 0xAB */ undefined,
      /* 0xAC */ undefined,
      /* 0xAD */ undefined,
      /* 0xAE */ undefined,
      /* 0xAF */ undefined,
      /* 0xB0 */ PUSHB.bind(undefined, 1),
      /* 0xB1 */ PUSHB.bind(undefined, 2),
      /* 0xB2 */ PUSHB.bind(undefined, 3),
      /* 0xB3 */ PUSHB.bind(undefined, 4),
      /* 0xB4 */ PUSHB.bind(undefined, 5),
      /* 0xB5 */ PUSHB.bind(undefined, 6),
      /* 0xB6 */ PUSHB.bind(undefined, 7),
      /* 0xB7 */ PUSHB.bind(undefined, 8),
      /* 0xB8 */ PUSHW.bind(undefined, 1),
      /* 0xB9 */ PUSHW.bind(undefined, 2),
      /* 0xBA */ PUSHW.bind(undefined, 3),
      /* 0xBB */ PUSHW.bind(undefined, 4),
      /* 0xBC */ PUSHW.bind(undefined, 5),
      /* 0xBD */ PUSHW.bind(undefined, 6),
      /* 0xBE */ PUSHW.bind(undefined, 7),
      /* 0xBF */ PUSHW.bind(undefined, 8),
      /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
      /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
      /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
      /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
      /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
      /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
      /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
      /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
      /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
      /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
      /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
      /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
      /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
      /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
      /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
      /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
      /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
      /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
      /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
      /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
      /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
      /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
      /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
      /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
      /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
      /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
      /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
      /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
      /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
      /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
      /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
      /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
      /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
      /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
      /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
      /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
      /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
      /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
      /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
      /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
      /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
      /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
      /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
      /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
      /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
      /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
      /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
      /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
      /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
      /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
      /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
      /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
      /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
      /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
      /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
      /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
      /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
      /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
      /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
      /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
      /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
      /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
      /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
      /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
  ];

  /*****************************
    Mathematical Considerations
  ******************************

  fv ... refers to freedom vector
  pv ... refers to projection vector
  rp ... refers to reference point
  p  ... refers to to point being operated on
  d  ... refers to distance

  SETRELATIVE:
  ============

  case freedom vector == x-axis:
  ------------------------------

                          (pv)
                       .-'
                rpd .-'
                 .-*
            d .-'90'
           .-'       '
        .-'           '
     *-'               ' b
    rp                  '
                         '
                          '
              p *----------*-------------- (fv)
                            pm

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

    equation of line b

     y - rpdy = pvns * (x- rpdx)

     y = p.y

     x = rpdx + ( p.y - rpdy ) / pvns


  case freedom vector == y-axis:
  ------------------------------

      * pm
      |\
      | \
      |  \
      |   \
      |    \
      |     \
      |      \
      |       \
      |        \
      |         \ b
      |          \
      |           \
      |            \    .-' (pv)
      |         90 \.-'
      |           .-'* rpd
      |        .-'
      *     *-'  d
      p     rp

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

    equation of line b:
             pvns ... normal slope to pv

     y - rpdy = pvns * (x - rpdx)

     x = p.x

     y = rpdy +  pvns * (p.x - rpdx)



  generic case:
  -------------


                                .'(fv)
                              .'
                            .* pm
                          .' !
                        .'    .
                      .'      !
                    .'         . b
                  .'           !
                 *              .
                p               !
                           90   .    ... (pv)
                             ...-*-'''
                    ...---'''    rpd
           ...---'''   d
     *--'''
    rp

      rpdx = rpx + d * pv.x
      rpdy = rpy + d * pv.y

   equation of line b:
      pvns... normal slope to pv

      y - rpdy = pvns * (x - rpdx)

   equation of freedom vector line:
      fvs ... slope of freedom vector (=fy/fx)

      y - py = fvs * (x - px)


    on pm both equations are true for same x/y

      y - rpdy = pvns * (x - rpdx)

      y - py = fvs * (x - px)

    form to y and set equal:

      pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

    expand:

      pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

    switch:

      fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

    solve for x:

      fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



            fvs * px - pvns * rpdx + rpdy - py
      x =  -----------------------------------
                   fvs - pvns

    and:

      y = fvs * (x - px) + py



  INTERPOLATE:
  ============

  Examples of point interpolation.

  The weight of the movement of the reference point gets bigger
  the further the other reference point is away, thus the safest
  option (that is avoiding 0/0 divisions) is to weight the
  original distance of the other point by the sum of both distances.

  If the sum of both distances is 0, then move the point by the
  arithmetic average of the movement of both reference points.




             (+6)
      rp1o *---->*rp1
           .     .                          (+12)
           .     .                  rp2o *---------->* rp2
           .     .                       .           .
           .     .                       .           .
           .    10          20           .           .
           |.........|...................|           .
                 .   .                               .
                 .   . (+8)                          .
                  po *------>*p                      .
                 .           .                       .
                 .    12     .          24           .
                 |...........|.......................|
                                    36


  -------



             (+10)
      rp1o *-------->*rp1
           .         .                      (-10)
           .         .              rp2 *<---------* rpo2
           .         .                   .         .
           .         .                   .         .
           .    10   .          30       .         .
           |.........|.............................|
                     .                   .
                     . (+5)              .
                  po *--->* p            .
                     .    .              .
                     .    .   20         .
                     |....|..............|
                       5        15


  -------


             (+10)
      rp1o *-------->*rp1
           .         .
           .         .
      rp2o *-------->*rp2


                                 (+10)
                            po *-------->* p

  -------


             (+10)
      rp1o *-------->*rp1
           .         .
           .         .(+30)
      rp2o *---------------------------->*rp2


                                          (+25)
                            po *----------------------->* p



  vim: set ts=4 sw=4 expandtab:
  *****/

  /**
   * Converts a string into a list of tokens.
   */

  /**
   * Create a new token
   * @param {string} char a single char
   */
  function Token(char) {
      this.char = char;
      this.state = {};
      this.activeState = null;
  }

  /**
   * Create a new context range
   * @param {number} startIndex range start index
   * @param {number} endOffset range end index offset
   * @param {string} contextName owner context name
   */
  function ContextRange(startIndex, endOffset, contextName) {
      this.contextName = contextName;
      this.startIndex = startIndex;
      this.endOffset = endOffset;
  }

  /**
   * Check context start and end
   * @param {string} contextName a unique context name
   * @param {function} checkStart a predicate function the indicates a context's start
   * @param {function} checkEnd a predicate function the indicates a context's end
   */
  function ContextChecker(contextName, checkStart, checkEnd) {
      this.contextName = contextName;
      this.openRange = null;
      this.ranges = [];
      this.checkStart = checkStart;
      this.checkEnd = checkEnd;
  }

  /**
   * @typedef ContextParams
   * @type Object
   * @property {array} context context items
   * @property {number} currentIndex current item index
   */

  /**
   * Create a context params
   * @param {array} context a list of items
   * @param {number} currentIndex current item index
   */
  function ContextParams(context, currentIndex) {
      this.context = context;
      this.index = currentIndex;
      this.length = context.length;
      this.current = context[currentIndex];
      this.backtrack = context.slice(0, currentIndex);
      this.lookahead = context.slice(currentIndex + 1);
  }

  /**
   * Create an event instance
   * @param {string} eventId event unique id
   */
  function Event(eventId) {
      this.eventId = eventId;
      this.subscribers = [];
  }

  /**
   * Initialize a core events and auto subscribe required event handlers
   * @param {any} events an object that enlists core events handlers
   */
  function initializeCoreEvents(events) {
      var this$1$1 = this;

      var coreEvents = [
          'start', 'end', 'next', 'newToken', 'contextStart',
          'contextEnd', 'insertToken', 'removeToken', 'removeRange',
          'replaceToken', 'replaceRange', 'composeRUD', 'updateContextsRanges'
      ];

      coreEvents.forEach(function (eventId) {
          Object.defineProperty(this$1$1.events, eventId, {
              value: new Event(eventId)
          });
      });

      if (!!events) {
          coreEvents.forEach(function (eventId) {
              var event = events[eventId];
              if (typeof event === 'function') {
                  this$1$1.events[eventId].subscribe(event);
              }
          });
      }
      var requiresContextUpdate = [
          'insertToken', 'removeToken', 'removeRange',
          'replaceToken', 'replaceRange', 'composeRUD'
      ];
      requiresContextUpdate.forEach(function (eventId) {
          this$1$1.events[eventId].subscribe(
              this$1$1.updateContextsRanges
          );
      });
  }

  /**
   * Converts a string into a list of tokens
   * @param {any} events tokenizer core events
   */
  function Tokenizer(events) {
      this.tokens = [];
      this.registeredContexts = {};
      this.contextCheckers = [];
      this.events = {};
      this.registeredModifiers = [];

      initializeCoreEvents.call(this, events);
  }

  /**
   * Sets the state of a token, usually called by a state modifier.
   * @param {string} key state item key
   * @param {any} value state item value
   */
  Token.prototype.setState = function(key, value) {
      this.state[key] = value;
      this.activeState = { key: key, value: this.state[key] };
      return this.activeState;
  };

  Token.prototype.getState = function (stateId) {
      return this.state[stateId] || null;
  };

  /**
   * Checks if an index exists in the tokens list.
   * @param {number} index token index
   */
  Tokenizer.prototype.inboundIndex = function(index) {
      return index >= 0 && index < this.tokens.length;
  };

  /**
   * Compose and apply a list of operations (replace, update, delete)
   * @param {array} RUDs replace, update and delete operations
   * TODO: Perf. Optimization (lengthBefore === lengthAfter ? dispatch once)
   */
  Tokenizer.prototype.composeRUD = function (RUDs) {
      var this$1$1 = this;

      var silent = true;
      var state = RUDs.map(function (RUD) { return (
          this$1$1[RUD[0]].apply(this$1$1, RUD.slice(1).concat(silent))
      ); });
      var hasFAILObject = function (obj) { return (
          typeof obj === 'object' &&
          obj.hasOwnProperty('FAIL')
      ); };
      if (state.every(hasFAILObject)) {
          return {
              FAIL: "composeRUD: one or more operations hasn't completed successfully",
              report: state.filter(hasFAILObject)
          };
      }
      this.dispatch('composeRUD', [state.filter(function (op) { return !hasFAILObject(op); })]);
  };

  /**
   * Replace a range of tokens with a list of tokens
   * @param {number} startIndex range start index
   * @param {number} offset range offset
   * @param {token} tokens a list of tokens to replace
   * @param {boolean} silent dispatch events and update context ranges
   */
  Tokenizer.prototype.replaceRange = function (startIndex, offset, tokens, silent) {
      offset = offset !== null ? offset : this.tokens.length;
      var isTokenType = tokens.every(function (token) { return token instanceof Token; });
      if (!isNaN(startIndex) && this.inboundIndex(startIndex) && isTokenType) {
          var replaced = this.tokens.splice.apply(
              this.tokens, [startIndex, offset].concat(tokens)
          );
          if (!silent) { this.dispatch('replaceToken', [startIndex, offset, tokens]); }
          return [replaced, tokens];
      } else {
          return { FAIL: 'replaceRange: invalid tokens or startIndex.' };
      }
  };

  /**
   * Replace a token with another token
   * @param {number} index token index
   * @param {token} token a token to replace
   * @param {boolean} silent dispatch events and update context ranges
   */
  Tokenizer.prototype.replaceToken = function (index, token, silent) {
      if (!isNaN(index) && this.inboundIndex(index) && token instanceof Token) {
          var replaced = this.tokens.splice(index, 1, token);
          if (!silent) { this.dispatch('replaceToken', [index, token]); }
          return [replaced[0], token];
      } else {
          return { FAIL: 'replaceToken: invalid token or index.' };
      }
  };

  /**
   * Removes a range of tokens
   * @param {number} startIndex range start index
   * @param {number} offset range offset
   * @param {boolean} silent dispatch events and update context ranges
   */
  Tokenizer.prototype.removeRange = function(startIndex, offset, silent) {
      offset = !isNaN(offset) ? offset : this.tokens.length;
      var tokens = this.tokens.splice(startIndex, offset);
      if (!silent) { this.dispatch('removeRange', [tokens, startIndex, offset]); }
      return tokens;
  };

  /**
   * Remove a token at a certain index
   * @param {number} index token index
   * @param {boolean} silent dispatch events and update context ranges
   */
  Tokenizer.prototype.removeToken = function(index, silent) {
      if (!isNaN(index) && this.inboundIndex(index)) {
          var token = this.tokens.splice(index, 1);
          if (!silent) { this.dispatch('removeToken', [token, index]); }
          return token;
      } else {
          return { FAIL: 'removeToken: invalid token index.' };
      }
  };

  /**
   * Insert a list of tokens at a certain index
   * @param {array} tokens a list of tokens to insert
   * @param {number} index insert the list of tokens at index
   * @param {boolean} silent dispatch events and update context ranges
   */
  Tokenizer.prototype.insertToken = function (tokens, index, silent) {
      var tokenType = tokens.every(
          function (token) { return token instanceof Token; }
      );
      if (tokenType) {
          this.tokens.splice.apply(
              this.tokens, [index, 0].concat(tokens)
          );
          if (!silent) { this.dispatch('insertToken', [tokens, index]); }
          return tokens;
      } else {
          return { FAIL: 'insertToken: invalid token(s).' };
      }
  };

  /**
   * A state modifier that is called on 'newToken' event
   * @param {string} modifierId state modifier id
   * @param {function} condition a predicate function that returns true or false
   * @param {function} modifier a function to update token state
   */
  Tokenizer.prototype.registerModifier = function(modifierId, condition, modifier) {
      this.events.newToken.subscribe(function(token, contextParams) {
          var conditionParams = [token, contextParams];
          var canApplyModifier = (
              condition === null ||
              condition.apply(this, conditionParams) === true
          );
          var modifierParams = [token, contextParams];
          if (canApplyModifier) {
              var newStateValue = modifier.apply(this, modifierParams);
              token.setState(modifierId, newStateValue);
          }
      });
      this.registeredModifiers.push(modifierId);
  };

  /**
   * Subscribe a handler to an event
   * @param {function} eventHandler an event handler function
   */
  Event.prototype.subscribe = function (eventHandler) {
      if (typeof eventHandler === 'function') {
          return ((this.subscribers.push(eventHandler)) - 1);
      } else {
          return { FAIL: ("invalid '" + (this.eventId) + "' event handler")};
      }
  };

  /**
   * Unsubscribe an event handler
   * @param {string} subsId subscription id
   */
  Event.prototype.unsubscribe = function (subsId) {
      this.subscribers.splice(subsId, 1);
  };

  /**
   * Sets context params current value index
   * @param {number} index context params current value index
   */
  ContextParams.prototype.setCurrentIndex = function(index) {
      this.index = index;
      this.current = this.context[index];
      this.backtrack = this.context.slice(0, index);
      this.lookahead = this.context.slice(index + 1);
  };

  /**
   * Get an item at an offset from the current value
   * example (current value is 3):
   *  1    2   [3]   4    5   |   items values
   * -2   -1    0    1    2   |   offset values
   * @param {number} offset an offset from current value index
   */
  ContextParams.prototype.get = function (offset) {
      switch (true) {
          case (offset === 0):
              return this.current;
          case (offset < 0 && Math.abs(offset) <= this.backtrack.length):
              return this.backtrack.slice(offset)[0];
          case (offset > 0 && offset <= this.lookahead.length):
              return this.lookahead[offset - 1];
          default:
              return null;
      }
  };

  /**
   * Converts a context range into a string value
   * @param {contextRange} range a context range
   */
  Tokenizer.prototype.rangeToText = function (range) {
      if (range instanceof ContextRange) {
          return (
              this.getRangeTokens(range)
                  .map(function (token) { return token.char; }).join('')
          );
      }
  };

  /**
   * Converts all tokens into a string
   */
  Tokenizer.prototype.getText = function () {
      return this.tokens.map(function (token) { return token.char; }).join('');
  };

  /**
   * Get a context by name
   * @param {string} contextName context name to get
   */
  Tokenizer.prototype.getContext = function (contextName) {
      var context = this.registeredContexts[contextName];
      return !!context ? context : null;
  };

  /**
   * Subscribes a new event handler to an event
   * @param {string} eventName event name to subscribe to
   * @param {function} eventHandler a function to be invoked on event
   */
  Tokenizer.prototype.on = function(eventName, eventHandler) {
      var event = this.events[eventName];
      if (!!event) {
          return event.subscribe(eventHandler);
      } else {
          return null;
      }
  };

  /**
   * Dispatches an event
   * @param {string} eventName event name
   * @param {any} args event handler arguments
   */
  Tokenizer.prototype.dispatch = function(eventName, args) {
      var this$1$1 = this;

      var event = this.events[eventName];
      if (event instanceof Event) {
          event.subscribers.forEach(function (subscriber) {
              subscriber.apply(this$1$1, args || []);
          });
      }
  };

  /**
   * Register a new context checker
   * @param {string} contextName a unique context name
   * @param {function} contextStartCheck a predicate function that returns true on context start
   * @param {function} contextEndCheck  a predicate function that returns true on context end
   * TODO: call tokenize on registration to update context ranges with the new context.
   */
  Tokenizer.prototype.registerContextChecker = function(contextName, contextStartCheck, contextEndCheck) {
      if (!!this.getContext(contextName)) { return {
          FAIL:
          ("context name '" + contextName + "' is already registered.")
      }; }
      if (typeof contextStartCheck !== 'function') { return {
          FAIL:
          "missing context start check."
      }; }
      if (typeof contextEndCheck !== 'function') { return {
          FAIL:
          "missing context end check."
      }; }
      var contextCheckers = new ContextChecker(
          contextName, contextStartCheck, contextEndCheck
      );
      this.registeredContexts[contextName] = contextCheckers;
      this.contextCheckers.push(contextCheckers);
      return contextCheckers;
  };

  /**
   * Gets a context range tokens
   * @param {contextRange} range a context range
   */
  Tokenizer.prototype.getRangeTokens = function(range) {
      var endIndex = range.startIndex + range.endOffset;
      return [].concat(
          this.tokens
              .slice(range.startIndex, endIndex)
      );
  };

  /**
   * Gets the ranges of a context
   * @param {string} contextName context name
   */
  Tokenizer.prototype.getContextRanges = function(contextName) {
      var context = this.getContext(contextName);
      if (!!context) {
          return context.ranges;
      } else {
          return { FAIL: ("context checker '" + contextName + "' is not registered.") };
      }
  };

  /**
   * Resets context ranges to run context update
   */
  Tokenizer.prototype.resetContextsRanges = function () {
      var registeredContexts = this.registeredContexts;
      for (var contextName in registeredContexts) {
          if (registeredContexts.hasOwnProperty(contextName)) {
              var context = registeredContexts[contextName];
              context.ranges = [];
          }
      }
  };

  /**
   * Updates context ranges
   */
  Tokenizer.prototype.updateContextsRanges = function () {
      this.resetContextsRanges();
      var chars = this.tokens.map(function (token) { return token.char; });
      for (var i = 0; i < chars.length; i++) {
          var contextParams = new ContextParams(chars, i);
          this.runContextCheck(contextParams);
      }
      this.dispatch('updateContextsRanges', [this.registeredContexts]);
  };

  /**
   * Sets the end offset of an open range
   * @param {number} offset range end offset
   * @param {string} contextName context name
   */
  Tokenizer.prototype.setEndOffset = function (offset, contextName) {
      var startIndex = this.getContext(contextName).openRange.startIndex;
      var range = new ContextRange(startIndex, offset, contextName);
      var ranges = this.getContext(contextName).ranges;
      range.rangeId = contextName + "." + (ranges.length);
      ranges.push(range);
      this.getContext(contextName).openRange = null;
      return range;
  };

  /**
   * Runs a context check on the current context
   * @param {contextParams} contextParams current context params
   */
  Tokenizer.prototype.runContextCheck = function(contextParams) {
      var this$1$1 = this;

      var index = contextParams.index;
      this.contextCheckers.forEach(function (contextChecker) {
          var contextName = contextChecker.contextName;
          var openRange = this$1$1.getContext(contextName).openRange;
          if (!openRange && contextChecker.checkStart(contextParams)) {
              openRange = new ContextRange(index, null, contextName);
              this$1$1.getContext(contextName).openRange = openRange;
              this$1$1.dispatch('contextStart', [contextName, index]);
          }
          if (!!openRange && contextChecker.checkEnd(contextParams)) {
              var offset = (index - openRange.startIndex) + 1;
              var range = this$1$1.setEndOffset(offset, contextName);
              this$1$1.dispatch('contextEnd', [contextName, range]);
          }
      });
  };

  /**
   * Converts a text into a list of tokens
   * @param {string} text a text to tokenize
   */
  Tokenizer.prototype.tokenize = function (text) {
      this.tokens = [];
      this.resetContextsRanges();
      var chars = Array.from(text);
      this.dispatch('start');
      for (var i = 0; i < chars.length; i++) {
          var char = chars[i];
          var contextParams = new ContextParams(chars, i);
          this.dispatch('next', [contextParams]);
          this.runContextCheck(contextParams);
          var token = new Token(char);
          this.tokens.push(token);
          this.dispatch('newToken', [token, contextParams]);
      }
      this.dispatch('end', [this.tokens]);
      return this.tokens;
  };

  // 
  //  Character Class Assertions  Checks if a char belongs to a certain class 
  // 
  // jscs:disable maximumLineLength
  /**
   * Check if a char is Arabic
   * @param {string} c a single char
   */
  function isArabicChar(c) {
      return /[\u0600-\u065F\u066A-\u06D2\u06FA-\u06FF]/.test(c);
  }

  /**
   * Check if a char is an isolated arabic char
   * @param {string} c a single char
   */
  function isIsolatedArabicChar(char) {
      return /[\u0630\u0690\u0621\u0631\u0661\u0671\u0622\u0632\u0672\u0692\u06C2\u0623\u0673\u0693\u06C3\u0624\u0694\u06C4\u0625\u0675\u0695\u06C5\u06E5\u0676\u0696\u06C6\u0627\u0677\u0697\u06C7\u0648\u0688\u0698\u06C8\u0689\u0699\u06C9\u068A\u06CA\u066B\u068B\u06CB\u068C\u068D\u06CD\u06FD\u068E\u06EE\u06FE\u062F\u068F\u06CF\u06EF]/.test(char);
  }

  /**
   * Check if a char is an Arabic Tashkeel char
   * @param {string} c a single char
   */
  function isTashkeelArabicChar(char) {
      return /[\u0600-\u0605\u060C-\u060E\u0610-\u061B\u061E\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED]/.test(char);
  }

  /**
   * Check if a char is Latin
   * @param {string} c a single char
   */
  function isLatinChar(c) {
      return /[A-z]/.test(c);
  }

  /**
   * Check if a char is whitespace char
   * @param {string} c a single char
   */
  function isWhiteSpace(c) {
      return /\s/.test(c);
  }

  /**
   * Query a feature by some of it's properties to lookup a glyph substitution.
   */

  /**
   * Create feature query instance
   * @param {Font} font opentype font instance
   */
  function FeatureQuery(font) {
      this.font = font;
      this.features = {};
  }

  /**
   * @typedef SubstitutionAction
   * @type Object
   * @property {number} id substitution type
   * @property {string} tag feature tag
   * @property {any} substitution substitution value(s)
   */

  /**
   * Create a substitution action instance
   * @param {SubstitutionAction} action
   */
  function SubstitutionAction(action) {
      this.id = action.id;
      this.tag = action.tag;
      this.substitution = action.substitution;
  }

  /**
   * Lookup a coverage table
   * @param {number} glyphIndex glyph index
   * @param {CoverageTable} coverage coverage table
   */
  function lookupCoverage(glyphIndex, coverage) {
      if (!glyphIndex) { return -1; }
      switch (coverage.format) {
          case 1:
              return coverage.glyphs.indexOf(glyphIndex);

          case 2:
              var ranges = coverage.ranges;
              for (var i = 0; i < ranges.length; i++) {
                  var range = ranges[i];
                  if (glyphIndex >= range.start && glyphIndex <= range.end) {
                      var offset = glyphIndex - range.start;
                      return range.index + offset;
                  }
              }
              break;
          default:
              return -1; // not found
      }
      return -1;
  }

  /**
   * Handle a single substitution - format 1
   * @param {ContextParams} contextParams context params to lookup
   */
  function singleSubstitutionFormat1(glyphIndex, subtable) {
      var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
      if (substituteIndex === -1) { return null; }
      return glyphIndex + subtable.deltaGlyphId;
  }

  /**
   * Handle a single substitution - format 2
   * @param {ContextParams} contextParams context params to lookup
   */
  function singleSubstitutionFormat2(glyphIndex, subtable) {
      var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
      if (substituteIndex === -1) { return null; }
      return subtable.substitute[substituteIndex];
  }

  /**
   * Lookup a list of coverage tables
   * @param {any} coverageList a list of coverage tables
   * @param {ContextParams} contextParams context params to lookup
   */
  function lookupCoverageList(coverageList, contextParams) {
      var lookupList = [];
      for (var i = 0; i < coverageList.length; i++) {
          var coverage = coverageList[i];
          var glyphIndex = contextParams.current;
          glyphIndex = Array.isArray(glyphIndex) ? glyphIndex[0] : glyphIndex;
          var lookupIndex = lookupCoverage(glyphIndex, coverage);
          if (lookupIndex !== -1) {
              lookupList.push(lookupIndex);
          }
      }
      if (lookupList.length !== coverageList.length) { return -1; }
      return lookupList;
  }

  /**
   * Handle chaining context substitution - format 3
   * @param {ContextParams} contextParams context params to lookup
   */
  function chainingSubstitutionFormat3(contextParams, subtable) {
      var lookupsCount = (
          subtable.inputCoverage.length +
          subtable.lookaheadCoverage.length +
          subtable.backtrackCoverage.length
      );
      if (contextParams.context.length < lookupsCount) { return []; }
      // INPUT LOOKUP //
      var inputLookups = lookupCoverageList(
          subtable.inputCoverage, contextParams
      );
      if (inputLookups === -1) { return []; }
      // LOOKAHEAD LOOKUP //
      var lookaheadOffset = subtable.inputCoverage.length - 1;
      if (contextParams.lookahead.length < subtable.lookaheadCoverage.length) { return []; }
      var lookaheadContext = contextParams.lookahead.slice(lookaheadOffset);
      while (lookaheadContext.length && isTashkeelArabicChar(lookaheadContext[0].char)) {
          lookaheadContext.shift();
      }
      var lookaheadParams = new ContextParams(lookaheadContext, 0);
      var lookaheadLookups = lookupCoverageList(
          subtable.lookaheadCoverage, lookaheadParams
      );
      // BACKTRACK LOOKUP //
      var backtrackContext = [].concat(contextParams.backtrack);
      backtrackContext.reverse();
      while (backtrackContext.length && isTashkeelArabicChar(backtrackContext[0].char)) {
          backtrackContext.shift();
      }
      if (backtrackContext.length < subtable.backtrackCoverage.length) { return []; }
      var backtrackParams = new ContextParams(backtrackContext, 0);
      var backtrackLookups = lookupCoverageList(
          subtable.backtrackCoverage, backtrackParams
      );
      var contextRulesMatch = (
          inputLookups.length === subtable.inputCoverage.length &&
          lookaheadLookups.length === subtable.lookaheadCoverage.length &&
          backtrackLookups.length === subtable.backtrackCoverage.length
      );
      var substitutions = [];
      if (contextRulesMatch) {
          for (var i = 0; i < subtable.lookupRecords.length; i++) {
              var lookupRecord = subtable.lookupRecords[i];
              var lookupListIndex = lookupRecord.lookupListIndex;
              var lookupTable = this.getLookupByIndex(lookupListIndex);
              for (var s = 0; s < lookupTable.subtables.length; s++) {
                  var subtable$1 = lookupTable.subtables[s];
                  var lookup = this.getLookupMethod(lookupTable, subtable$1);
                  var substitutionType = this.getSubstitutionType(lookupTable, subtable$1);
                  if (substitutionType === '12') {
                      for (var n = 0; n < inputLookups.length; n++) {
                          var glyphIndex = contextParams.get(n);
                          var substitution = lookup(glyphIndex);
                          if (substitution) { substitutions.push(substitution); }
                      }
                  }
              }
          }
      }
      return substitutions;
  }

  /**
   * Handle ligature substitution - format 1
   * @param {ContextParams} contextParams context params to lookup
   */
  function ligatureSubstitutionFormat1(contextParams, subtable) {
      // COVERAGE LOOKUP //
      var glyphIndex = contextParams.current;
      var ligSetIndex = lookupCoverage(glyphIndex, subtable.coverage);
      if (ligSetIndex === -1) { return null; }
      // COMPONENTS LOOKUP
      // (!) note, components are ordered in the written direction.
      var ligature;
      var ligatureSet = subtable.ligatureSets[ligSetIndex];
      for (var s = 0; s < ligatureSet.length; s++) {
          ligature = ligatureSet[s];
          for (var l = 0; l < ligature.components.length; l++) {
              var lookaheadItem = contextParams.lookahead[l];
              var component = ligature.components[l];
              if (lookaheadItem !== component) { break; }
              if (l === ligature.components.length - 1) { return ligature; }
          }
      }
      return null;
  }

  /**
   * Handle decomposition substitution - format 1
   * @param {number} glyphIndex glyph index
   * @param {any} subtable subtable
   */
  function decompositionSubstitutionFormat1(glyphIndex, subtable) {
      var substituteIndex = lookupCoverage(glyphIndex, subtable.coverage);
      if (substituteIndex === -1) { return null; }
      return subtable.sequences[substituteIndex];
  }

  /**
   * Get default script features indexes
   */
  FeatureQuery.prototype.getDefaultScriptFeaturesIndexes = function () {
      var scripts = this.font.tables.gsub.scripts;
      for (var s = 0; s < scripts.length; s++) {
          var script = scripts[s];
          if (script.tag === 'DFLT') { return (
              script.script.defaultLangSys.featureIndexes
          ); }
      }
      return [];
  };

  /**
   * Get feature indexes of a specific script
   * @param {string} scriptTag script tag
   */
  FeatureQuery.prototype.getScriptFeaturesIndexes = function(scriptTag) {
      var tables = this.font.tables;
      if (!tables.gsub) { return []; }
      if (!scriptTag) { return this.getDefaultScriptFeaturesIndexes(); }
      var scripts = this.font.tables.gsub.scripts;
      for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          if (script.tag === scriptTag && script.script.defaultLangSys) {
              return script.script.defaultLangSys.featureIndexes;
          } else {
              var langSysRecords = script.langSysRecords;
              if (!!langSysRecords) {
                  for (var j = 0; j < langSysRecords.length; j++) {
                      var langSysRecord = langSysRecords[j];
                      if (langSysRecord.tag === scriptTag) {
                          var langSys = langSysRecord.langSys;
                          return langSys.featureIndexes;
                      }
                  }
              }
          }
      }
      return this.getDefaultScriptFeaturesIndexes();
  };

  /**
   * Map a feature tag to a gsub feature
   * @param {any} features gsub features
   * @param {string} scriptTag script tag
   */
  FeatureQuery.prototype.mapTagsToFeatures = function (features, scriptTag) {
      var tags = {};
      for (var i = 0; i < features.length; i++) {
          var tag = features[i].tag;
          var feature = features[i].feature;
          tags[tag] = feature;
      }
      this.features[scriptTag].tags = tags;
  };

  /**
   * Get features of a specific script
   * @param {string} scriptTag script tag
   */
  FeatureQuery.prototype.getScriptFeatures = function (scriptTag) {
      var features = this.features[scriptTag];
      if (this.features.hasOwnProperty(scriptTag)) { return features; }
      var featuresIndexes = this.getScriptFeaturesIndexes(scriptTag);
      if (!featuresIndexes) { return null; }
      var gsub = this.font.tables.gsub;
      features = featuresIndexes.map(function (index) { return gsub.features[index]; });
      this.features[scriptTag] = features;
      this.mapTagsToFeatures(features, scriptTag);
      return features;
  };

  /**
   * Get substitution type
   * @param {any} lookupTable lookup table
   * @param {any} subtable subtable
   */
  FeatureQuery.prototype.getSubstitutionType = function(lookupTable, subtable) {
      var lookupType = lookupTable.lookupType.toString();
      var substFormat = subtable.substFormat.toString();
      return lookupType + substFormat;
  };

  /**
   * Get lookup method
   * @param {any} lookupTable lookup table
   * @param {any} subtable subtable
   */
  FeatureQuery.prototype.getLookupMethod = function(lookupTable, subtable) {
      var this$1$1 = this;

      var substitutionType = this.getSubstitutionType(lookupTable, subtable);
      switch (substitutionType) {
          case '11':
              return function (glyphIndex) { return singleSubstitutionFormat1.apply(
                  this$1$1, [glyphIndex, subtable]
              ); };
          case '12':
              return function (glyphIndex) { return singleSubstitutionFormat2.apply(
                  this$1$1, [glyphIndex, subtable]
              ); };
          case '63':
              return function (contextParams) { return chainingSubstitutionFormat3.apply(
                  this$1$1, [contextParams, subtable]
              ); };
          case '41':
              return function (contextParams) { return ligatureSubstitutionFormat1.apply(
                  this$1$1, [contextParams, subtable]
              ); };
          case '21':
              return function (glyphIndex) { return decompositionSubstitutionFormat1.apply(
                  this$1$1, [glyphIndex, subtable]
              ); };
          default:
              throw new Error(
                  "lookupType: " + (lookupTable.lookupType) + " - " +
                  "substFormat: " + (subtable.substFormat) + " " +
                  "is not yet supported"
              );
      }
  };

  /**
   * [ LOOKUP TYPES ]
   * -------------------------------
   * Single                        1;
   * Multiple                      2;
   * Alternate                     3;
   * Ligature                      4;
   * Context                       5;
   * ChainingContext               6;
   * ExtensionSubstitution         7;
   * ReverseChainingContext        8;
   * -------------------------------
   *
   */

  /**
   * @typedef FQuery
   * @type Object
   * @param {string} tag feature tag
   * @param {string} script feature script
   * @param {ContextParams} contextParams context params
   */

  /**
   * Lookup a feature using a query parameters
   * @param {FQuery} query feature query
   */
  FeatureQuery.prototype.lookupFeature = function (query) {
      var contextParams = query.contextParams;
      var currentIndex = contextParams.index;
      var feature = this.getFeature({
          tag: query.tag, script: query.script
      });
      if (!feature) { return new Error(
          "font '" + (this.font.names.fullName.en) + "' " +
          "doesn't support feature '" + (query.tag) + "' " +
          "for script '" + (query.script) + "'."
      ); }
      var lookups = this.getFeatureLookups(feature);
      var substitutions = [].concat(contextParams.context);
      for (var l = 0; l < lookups.length; l++) {
          var lookupTable = lookups[l];
          var subtables = this.getLookupSubtables(lookupTable);
          for (var s = 0; s < subtables.length; s++) {
              var subtable = subtables[s];
              var substType = this.getSubstitutionType(lookupTable, subtable);
              var lookup = this.getLookupMethod(lookupTable, subtable);
              var substitution = (void 0);
              switch (substType) {
                  case '11':
                      substitution = lookup(contextParams.current);
                      if (substitution) {
                          substitutions.splice(currentIndex, 1, new SubstitutionAction({
                              id: 11, tag: query.tag, substitution: substitution
                          }));
                      }
                      break;
                  case '12':
                      substitution = lookup(contextParams.current);
                      if (substitution) {
                          substitutions.splice(currentIndex, 1, new SubstitutionAction({
                              id: 12, tag: query.tag, substitution: substitution
                          }));
                      }
                      break;
                  case '63':
                      substitution = lookup(contextParams);
                      if (Array.isArray(substitution) && substitution.length) {
                          substitutions.splice(currentIndex, 1, new SubstitutionAction({
                              id: 63, tag: query.tag, substitution: substitution
                          }));
                      }
                      break;
                  case '41':
                      substitution = lookup(contextParams);
                      if (substitution) {
                          substitutions.splice(currentIndex, 1, new SubstitutionAction({
                              id: 41, tag: query.tag, substitution: substitution
                          }));
                      }
                      break;
                  case '21':
                      substitution = lookup(contextParams.current);
                      if (substitution) {
                          substitutions.splice(currentIndex, 1, new SubstitutionAction({
                              id: 21, tag: query.tag, substitution: substitution
                          }));
                      }
                      break;
              }
              contextParams = new ContextParams(substitutions, currentIndex);
              if (Array.isArray(substitution) && !substitution.length) { continue; }
              substitution = null;
          }
      }
      return substitutions.length ? substitutions : null;
  };

  /**
   * Checks if a font supports a specific features
   * @param {FQuery} query feature query object
   */
  FeatureQuery.prototype.supports = function (query) {
      if (!query.script) { return false; }
      this.getScriptFeatures(query.script);
      var supportedScript = this.features.hasOwnProperty(query.script);
      if (!query.tag) { return supportedScript; }
      var supportedFeature = (
          this.features[query.script].some(function (feature) { return feature.tag === query.tag; })
      );
      return supportedScript && supportedFeature;
  };

  /**
   * Get lookup table subtables
   * @param {any} lookupTable lookup table
   */
  FeatureQuery.prototype.getLookupSubtables = function (lookupTable) {
      return lookupTable.subtables || null;
  };

  /**
   * Get lookup table by index
   * @param {number} index lookup table index
   */
  FeatureQuery.prototype.getLookupByIndex = function (index) {
      var lookups = this.font.tables.gsub.lookups;
      return lookups[index] || null;
  };

  /**
   * Get lookup tables for a feature
   * @param {string} feature
   */
  FeatureQuery.prototype.getFeatureLookups = function (feature) {
      // TODO: memoize
      return feature.lookupListIndexes.map(this.getLookupByIndex.bind(this));
  };

  /**
   * Query a feature by it's properties
   * @param {any} query an object that describes the properties of a query
   */
  FeatureQuery.prototype.getFeature = function getFeature(query) {
      if (!this.font) { return { FAIL: "No font was found"}; }
      if (!this.features.hasOwnProperty(query.script)) {
          this.getScriptFeatures(query.script);
      }
      var scriptFeatures = this.features[query.script];
      if (!scriptFeatures) { return (
          { FAIL: ("No feature for script " + (query.script))}
      ); }
      if (!scriptFeatures.tags[query.tag]) { return null; }
      return this.features[query.script].tags[query.tag];
  };

  /**
   * Arabic word context checkers
   */

  function arabicWordStartCheck(contextParams) {
      var char = contextParams.current;
      var prevChar = contextParams.get(-1);
      return (
          // ? arabic first char
          (prevChar === null && isArabicChar(char)) ||
          // ? arabic char preceded with a non arabic char
          (!isArabicChar(prevChar) && isArabicChar(char))
      );
  }

  function arabicWordEndCheck(contextParams) {
      var nextChar = contextParams.get(1);
      return (
          // ? last arabic char
          (nextChar === null) ||
          // ? next char is not arabic
          (!isArabicChar(nextChar))
      );
  }

  var arabicWordCheck = {
      startCheck: arabicWordStartCheck,
      endCheck: arabicWordEndCheck
  };

  /**
   * Arabic sentence context checkers
   */

  function arabicSentenceStartCheck(contextParams) {
      var char = contextParams.current;
      var prevChar = contextParams.get(-1);
      return (
          // ? an arabic char preceded with a non arabic char
          (isArabicChar(char) || isTashkeelArabicChar(char)) &&
          !isArabicChar(prevChar)
      );
  }

  function arabicSentenceEndCheck(contextParams) {
      var nextChar = contextParams.get(1);
      switch (true) {
          case nextChar === null:
              return true;
          case (!isArabicChar(nextChar) && !isTashkeelArabicChar(nextChar)):
              var nextIsWhitespace = isWhiteSpace(nextChar);
              if (!nextIsWhitespace) { return true; }
              if (nextIsWhitespace) {
                  var arabicCharAhead = false;
                  arabicCharAhead = (
                      contextParams.lookahead.some(
                          function (c) { return isArabicChar(c) || isTashkeelArabicChar(c); }
                      )
                  );
                  if (!arabicCharAhead) { return true; }
              }
              break;
          default:
              return false;
      }
  }

  var arabicSentenceCheck = {
      startCheck: arabicSentenceStartCheck,
      endCheck: arabicSentenceEndCheck
  };

  /**
   * Apply single substitution format 1
   * @param {Array} substitutions substitutions
   * @param {any} tokens a list of tokens
   * @param {number} index token index
   */
  function singleSubstitutionFormat1$1(action, tokens, index) {
      tokens[index].setState(action.tag, action.substitution);
  }

  /**
   * Apply single substitution format 2
   * @param {Array} substitutions substitutions
   * @param {any} tokens a list of tokens
   * @param {number} index token index
   */
  function singleSubstitutionFormat2$1(action, tokens, index) {
      tokens[index].setState(action.tag, action.substitution);
  }

  /**
   * Apply chaining context substitution format 3
   * @param {Array} substitutions substitutions
   * @param {any} tokens a list of tokens
   * @param {number} index token index
   */
  function chainingSubstitutionFormat3$1(action, tokens, index) {
      action.substitution.forEach(function (subst, offset) {
          var token = tokens[index + offset];
          token.setState(action.tag, subst);
      });
  }

  /**
   * Apply ligature substitution format 1
   * @param {Array} substitutions substitutions
   * @param {any} tokens a list of tokens
   * @param {number} index token index
   */
  function ligatureSubstitutionFormat1$1(action, tokens, index) {
      var token = tokens[index];
      token.setState(action.tag, action.substitution.ligGlyph);
      var compsCount = action.substitution.components.length;
      for (var i = 0; i < compsCount; i++) {
          token = tokens[index + i + 1];
          token.setState('deleted', true);
      }
  }

  /**
   * Supported substitutions
   */
  var SUBSTITUTIONS = {
      11: singleSubstitutionFormat1$1,
      12: singleSubstitutionFormat2$1,
      63: chainingSubstitutionFormat3$1,
      41: ligatureSubstitutionFormat1$1
  };

  /**
   * Apply substitutions to a list of tokens
   * @param {Array} substitutions substitutions
   * @param {any} tokens a list of tokens
   * @param {number} index token index
   */
  function applySubstitution(action, tokens, index) {
      if (action instanceof SubstitutionAction && SUBSTITUTIONS[action.id]) {
          SUBSTITUTIONS[action.id](action, tokens, index);
      }
  }

  /**
   * Apply Arabic presentation forms to a range of tokens
   */

  /**
   * Check if a char can be connected to it's preceding char
   * @param {ContextParams} charContextParams context params of a char
   */
  function willConnectPrev(charContextParams) {
      var backtrack = [].concat(charContextParams.backtrack);
      for (var i = backtrack.length - 1; i >= 0; i--) {
          var prevChar = backtrack[i];
          var isolated = isIsolatedArabicChar(prevChar);
          var tashkeel = isTashkeelArabicChar(prevChar);
          if (!isolated && !tashkeel) { return true; }
          if (isolated) { return false; }
      }
      return false;
  }

  /**
   * Check if a char can be connected to it's proceeding char
   * @param {ContextParams} charContextParams context params of a char
   */
  function willConnectNext(charContextParams) {
      if (isIsolatedArabicChar(charContextParams.current)) { return false; }
      for (var i = 0; i < charContextParams.lookahead.length; i++) {
          var nextChar = charContextParams.lookahead[i];
          var tashkeel = isTashkeelArabicChar(nextChar);
          if (!tashkeel) { return true; }
      }
      return false;
  }

  /**
   * Apply arabic presentation forms to a list of tokens
   * @param {ContextRange} range a range of tokens
   */
  function arabicPresentationForms(range) {
      var this$1$1 = this;

      var script = 'arab';
      var tags = this.featuresTags[script];
      var tokens = this.tokenizer.getRangeTokens(range);
      if (tokens.length === 1) { return; }
      var contextParams = new ContextParams(
          tokens.map(function (token) { return token.getState('glyphIndex'); }
      ), 0);
      var charContextParams = new ContextParams(
          tokens.map(function (token) { return token.char; }
      ), 0);
      tokens.forEach(function (token, index) {
          if (isTashkeelArabicChar(token.char)) { return; }
          contextParams.setCurrentIndex(index);
          charContextParams.setCurrentIndex(index);
          var CONNECT = 0; // 2 bits 00 (10: can connect next) (01: can connect prev)
          if (willConnectPrev(charContextParams)) { CONNECT |= 1; }
          if (willConnectNext(charContextParams)) { CONNECT |= 2; }
          var tag;
          switch (CONNECT) {
              case 1: (tag = 'fina'); break;
              case 2: (tag = 'init'); break;
              case 3: (tag = 'medi'); break;
          }
          if (tags.indexOf(tag) === -1) { return; }
          var substitutions = this$1$1.query.lookupFeature({
              tag: tag, script: script, contextParams: contextParams
          });
          if (substitutions instanceof Error) { return console.info(substitutions.message); }
          substitutions.forEach(function (action, index) {
              if (action instanceof SubstitutionAction) {
                  applySubstitution(action, tokens, index);
                  contextParams.context[index] = action.substitution;
              }
          });
      });
  }

  /**
   * Apply Arabic required ligatures feature to a range of tokens
   */

  /**
   * Update context params
   * @param {any} tokens a list of tokens
   * @param {number} index current item index
   */
  function getContextParams(tokens, index) {
      var context = tokens.map(function (token) { return token.activeState.value; });
      return new ContextParams(context, index || 0);
  }

  /**
   * Apply Arabic required ligatures to a context range
   * @param {ContextRange} range a range of tokens
   */
  function arabicRequiredLigatures(range) {
      var this$1$1 = this;

      var script = 'arab';
      var tokens = this.tokenizer.getRangeTokens(range);
      var contextParams = getContextParams(tokens);
      contextParams.context.forEach(function (glyphIndex, index) {
          contextParams.setCurrentIndex(index);
          var substitutions = this$1$1.query.lookupFeature({
              tag: 'rlig', script: script, contextParams: contextParams
          });
          if (substitutions.length) {
              substitutions.forEach(
                  function (action) { return applySubstitution(action, tokens, index); }
              );
              contextParams = getContextParams(tokens);
          }
      });
  }

  /**
   * Latin word context checkers
   */

  function latinWordStartCheck(contextParams) {
      var char = contextParams.current;
      var prevChar = contextParams.get(-1);
      return (
          // ? latin first char
          (prevChar === null && isLatinChar(char)) ||
          // ? latin char preceded with a non latin char
          (!isLatinChar(prevChar) && isLatinChar(char))
      );
  }

  function latinWordEndCheck(contextParams) {
      var nextChar = contextParams.get(1);
      return (
          // ? last latin char
          (nextChar === null) ||
          // ? next char is not latin
          (!isLatinChar(nextChar))
      );
  }

  var latinWordCheck = {
      startCheck: latinWordStartCheck,
      endCheck: latinWordEndCheck
  };

  /**
   * Apply Latin ligature feature to a range of tokens
   */

  /**
   * Update context params
   * @param {any} tokens a list of tokens
   * @param {number} index current item index
   */
  function getContextParams$1(tokens, index) {
      var context = tokens.map(function (token) { return token.activeState.value; });
      return new ContextParams(context, index || 0);
  }

  /**
   * Apply Arabic required ligatures to a context range
   * @param {ContextRange} range a range of tokens
   */
  function latinLigature(range) {
      var this$1$1 = this;

      var script = 'latn';
      var tokens = this.tokenizer.getRangeTokens(range);
      var contextParams = getContextParams$1(tokens);
      contextParams.context.forEach(function (glyphIndex, index) {
          contextParams.setCurrentIndex(index);
          var substitutions = this$1$1.query.lookupFeature({
              tag: 'liga', script: script, contextParams: contextParams
          });
          if (substitutions.length) {
              substitutions.forEach(
                  function (action) { return applySubstitution(action, tokens, index); }
              );
              contextParams = getContextParams$1(tokens);
          }
      });
  }

  /**
   * Infer bidirectional properties for a given text and apply
   * the corresponding layout rules.
   */

  /**
   * Create Bidi. features
   * @param {string} baseDir text base direction. value either 'ltr' or 'rtl'
   */
  function Bidi(baseDir) {
      this.baseDir = baseDir || 'ltr';
      this.tokenizer = new Tokenizer();
      this.featuresTags = {};
  }

  /**
   * Sets Bidi text
   * @param {string} text a text input
   */
  Bidi.prototype.setText = function (text) {
      this.text = text;
  };

  /**
   * Store essential context checks:
   * arabic word check for applying gsub features
   * arabic sentence check for adjusting arabic layout
   */
  Bidi.prototype.contextChecks = ({
      latinWordCheck: latinWordCheck,
      arabicWordCheck: arabicWordCheck,
      arabicSentenceCheck: arabicSentenceCheck
  });

  /**
   * Register arabic word check
   */
  function registerContextChecker(checkId) {
      var check = this.contextChecks[(checkId + "Check")];
      return this.tokenizer.registerContextChecker(
          checkId, check.startCheck, check.endCheck
      );
  }

  /**
   * Perform pre tokenization procedure then
   * tokenize text input
   */
  function tokenizeText() {
      registerContextChecker.call(this, 'latinWord');
      registerContextChecker.call(this, 'arabicWord');
      registerContextChecker.call(this, 'arabicSentence');
      return this.tokenizer.tokenize(this.text);
  }

  /**
   * Reverse arabic sentence layout
   * TODO: check base dir before applying adjustments - priority low
   */
  function reverseArabicSentences() {
      var this$1$1 = this;

      var ranges = this.tokenizer.getContextRanges('arabicSentence');
      ranges.forEach(function (range) {
          var rangeTokens = this$1$1.tokenizer.getRangeTokens(range);
          this$1$1.tokenizer.replaceRange(
              range.startIndex,
              range.endOffset,
              rangeTokens.reverse()
          );
      });
  }

  /**
   * Register supported features tags
   * @param {script} script script tag
   * @param {Array} tags features tags list
   */
  Bidi.prototype.registerFeatures = function (script, tags) {
      var this$1$1 = this;

      var supportedTags = tags.filter(
          function (tag) { return this$1$1.query.supports({script: script, tag: tag}); }
      );
      if (!this.featuresTags.hasOwnProperty(script)) {
          this.featuresTags[script] = supportedTags;
      } else {
          this.featuresTags[script] =
          this.featuresTags[script].concat(supportedTags);
      }
  };

  /**
   * Apply GSUB features
   * @param {Array} tagsList a list of features tags
   * @param {string} script a script tag
   * @param {Font} font opentype font instance
   */
  Bidi.prototype.applyFeatures = function (font, features) {
      if (!font) { throw new Error(
          'No valid font was provided to apply features'
      ); }
      if (!this.query) { this.query = new FeatureQuery(font); }
      for (var f = 0; f < features.length; f++) {
          var feature = features[f];
          if (!this.query.supports({script: feature.script})) { continue; }
          this.registerFeatures(feature.script, feature.tags);
      }
  };

  /**
   * Register a state modifier
   * @param {string} modifierId state modifier id
   * @param {function} condition a predicate function that returns true or false
   * @param {function} modifier a modifier function to set token state
   */
  Bidi.prototype.registerModifier = function (modifierId, condition, modifier) {
      this.tokenizer.registerModifier(modifierId, condition, modifier);
  };

  /**
   * Check if 'glyphIndex' is registered
   */
  function checkGlyphIndexStatus() {
      if (this.tokenizer.registeredModifiers.indexOf('glyphIndex') === -1) {
          throw new Error(
              'glyphIndex modifier is required to apply ' +
              'arabic presentation features.'
          );
      }
  }

  /**
   * Apply arabic presentation forms features
   */
  function applyArabicPresentationForms() {
      var this$1$1 = this;

      var script = 'arab';
      if (!this.featuresTags.hasOwnProperty(script)) { return; }
      checkGlyphIndexStatus.call(this);
      var ranges = this.tokenizer.getContextRanges('arabicWord');
      ranges.forEach(function (range) {
          arabicPresentationForms.call(this$1$1, range);
      });
  }

  /**
   * Apply required arabic ligatures
   */
  function applyArabicRequireLigatures() {
      var this$1$1 = this;

      var script = 'arab';
      if (!this.featuresTags.hasOwnProperty(script)) { return; }
      var tags = this.featuresTags[script];
      if (tags.indexOf('rlig') === -1) { return; }
      checkGlyphIndexStatus.call(this);
      var ranges = this.tokenizer.getContextRanges('arabicWord');
      ranges.forEach(function (range) {
          arabicRequiredLigatures.call(this$1$1, range);
      });
  }

  /**
   * Apply required arabic ligatures
   */
  function applyLatinLigatures() {
      var this$1$1 = this;

      var script = 'latn';
      if (!this.featuresTags.hasOwnProperty(script)) { return; }
      var tags = this.featuresTags[script];
      if (tags.indexOf('liga') === -1) { return; }
      checkGlyphIndexStatus.call(this);
      var ranges = this.tokenizer.getContextRanges('latinWord');
      ranges.forEach(function (range) {
          latinLigature.call(this$1$1, range);
      });
  }

  /**
   * Check if a context is registered
   * @param {string} contextId context id
   */
  Bidi.prototype.checkContextReady = function (contextId) {
      return !!this.tokenizer.getContext(contextId);
  };

  /**
   * Apply features to registered contexts
   */
  Bidi.prototype.applyFeaturesToContexts = function () {
      if (this.checkContextReady('arabicWord')) {
          applyArabicPresentationForms.call(this);
          applyArabicRequireLigatures.call(this);
      }
      if (this.checkContextReady('latinWord')) {
          applyLatinLigatures.call(this);
      }
      if (this.checkContextReady('arabicSentence')) {
          reverseArabicSentences.call(this);
      }
  };

  /**
   * process text input
   * @param {string} text an input text
   */
  Bidi.prototype.processText = function(text) {
      if (!this.text || this.text !== text) {
          this.setText(text);
          tokenizeText.call(this);
          this.applyFeaturesToContexts();
      }
  };

  /**
   * Process a string of text to identify and adjust
   * bidirectional text entities.
   * @param {string} text input text
   */
  Bidi.prototype.getBidiText = function (text) {
      this.processText(text);
      return this.tokenizer.getText();
  };

  /**
   * Get the current state index of each token
   * @param {text} text an input text
   */
  Bidi.prototype.getTextGlyphs = function (text) {
      this.processText(text);
      var indexes = [];
      for (var i = 0; i < this.tokenizer.tokens.length; i++) {
          var token = this.tokenizer.tokens[i];
          if (token.state.deleted) { continue; }
          var index = token.activeState.value;
          indexes.push(Array.isArray(index) ? index[0] : index);
      }
      return indexes;
  };

  // The Font object

  /**
   * @typedef FontOptions
   * @type Object
   * @property {Boolean} empty - whether to create a new empty font
   * @property {string} familyName
   * @property {string} styleName
   * @property {string=} fullName
   * @property {string=} postScriptName
   * @property {string=} designer
   * @property {string=} designerURL
   * @property {string=} manufacturer
   * @property {string=} manufacturerURL
   * @property {string=} license
   * @property {string=} licenseURL
   * @property {string=} version
   * @property {string=} description
   * @property {string=} copyright
   * @property {string=} trademark
   * @property {Number} unitsPerEm
   * @property {Number} ascender
   * @property {Number} descender
   * @property {Number} createdTimestamp
   * @property {string=} weightClass
   * @property {string=} widthClass
   * @property {string=} fsSelection
   */

  /**
   * A Font represents a loaded OpenType font file.
   * It contains a set of glyphs and methods to draw text on a drawing context,
   * or to get a path representing the text.
   * @exports opentype.Font
   * @class
   * @param {FontOptions}
   * @constructor
   */
  function Font(options) {
      options = options || {};
      options.tables = options.tables || {};

      if (!options.empty) {
          // Check that we've provided the minimum set of names.
          checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
          checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
          checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
          checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
          checkArgument(options.descender <= 0, 'When creating a new Font object, negative descender value is required.');

          // OS X will complain if the names are empty, so we put a single space everywhere by default.
          this.names = {
              fontFamily: {en: options.familyName || ' '},
              fontSubfamily: {en: options.styleName || ' '},
              fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
              // postScriptName may not contain any whitespace
              postScriptName: {en: options.postScriptName || (options.familyName + options.styleName).replace(/\s/g, '')},
              designer: {en: options.designer || ' '},
              designerURL: {en: options.designerURL || ' '},
              manufacturer: {en: options.manufacturer || ' '},
              manufacturerURL: {en: options.manufacturerURL || ' '},
              license: {en: options.license || ' '},
              licenseURL: {en: options.licenseURL || ' '},
              version: {en: options.version || 'Version 0.1'},
              description: {en: options.description || ' '},
              copyright: {en: options.copyright || ' '},
              trademark: {en: options.trademark || ' '}
          };
          this.unitsPerEm = options.unitsPerEm || 1000;
          this.ascender = options.ascender;
          this.descender = options.descender;
          this.createdTimestamp = options.createdTimestamp;
          this.tables = Object.assign(options.tables, {
              os2: Object.assign({
                  usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
                  usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
                  fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR,
              }, options.tables.os2)
          });
      }

      this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
      this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
      this.encoding = new DefaultEncoding(this);
      this.position = new Position(this);
      this.substitution = new Substitution(this);
      this.tables = this.tables || {};

      // needed for low memory mode only.
      this._push = null;
      this._hmtxTableData = {};

      Object.defineProperty(this, 'hinting', {
          get: function() {
              if (this._hinting) { return this._hinting; }
              if (this.outlinesFormat === 'truetype') {
                  return (this._hinting = new Hinting(this));
              }
          }
      });
  }

  /**
   * Check if the font has a glyph for the given character.
   * @param  {string}
   * @return {Boolean}
   */
  Font.prototype.hasChar = function(c) {
      return this.encoding.charToGlyphIndex(c) !== null;
  };

  /**
   * Convert the given character to a single glyph index.
   * Note that this function assumes that there is a one-to-one mapping between
   * the given character and a glyph; for complex scripts this might not be the case.
   * @param  {string}
   * @return {Number}
   */
  Font.prototype.charToGlyphIndex = function(s) {
      return this.encoding.charToGlyphIndex(s);
  };

  /**
   * Convert the given character to a single Glyph object.
   * Note that this function assumes that there is a one-to-one mapping between
   * the given character and a glyph; for complex scripts this might not be the case.
   * @param  {string}
   * @return {opentype.Glyph}
   */
  Font.prototype.charToGlyph = function(c) {
      var glyphIndex = this.charToGlyphIndex(c);
      var glyph = this.glyphs.get(glyphIndex);
      if (!glyph) {
          // .notdef
          glyph = this.glyphs.get(0);
      }

      return glyph;
  };

  /**
   * Update features
   * @param {any} options features options
   */
  Font.prototype.updateFeatures = function (options) {
      // TODO: update all features options not only 'latn'.
      return this.defaultRenderOptions.features.map(function (feature) {
          if (feature.script === 'latn') {
              return {
                  script: 'latn',
                  tags: feature.tags.filter(function (tag) { return options[tag]; })
              };
          } else {
              return feature;
          }
      });
  };

  /**
   * Convert the given text to a list of Glyph objects.
   * Note that there is no strict one-to-one mapping between characters and
   * glyphs, so the list of returned glyphs can be larger or smaller than the
   * length of the given string.
   * @param  {string}
   * @param  {GlyphRenderOptions} [options]
   * @return {opentype.Glyph[]}
   */
  Font.prototype.stringToGlyphs = function(s, options) {
      var this$1$1 = this;


      var bidi = new Bidi();

      // Create and register 'glyphIndex' state modifier
      var charToGlyphIndexMod = function (token) { return this$1$1.charToGlyphIndex(token.char); };
      bidi.registerModifier('glyphIndex', null, charToGlyphIndexMod);

      // roll-back to default features
      var features = options ?
      this.updateFeatures(options.features) :
      this.defaultRenderOptions.features;

      bidi.applyFeatures(this, features);

      var indexes = bidi.getTextGlyphs(s);

      var length = indexes.length;

      // convert glyph indexes to glyph objects
      var glyphs = new Array(length);
      var notdef = this.glyphs.get(0);
      for (var i = 0; i < length; i += 1) {
          glyphs[i] = this.glyphs.get(indexes[i]) || notdef;
      }
      return glyphs;
  };

  /**
   * @param  {string}
   * @return {Number}
   */
  Font.prototype.nameToGlyphIndex = function(name) {
      return this.glyphNames.nameToGlyphIndex(name);
  };

  /**
   * @param  {string}
   * @return {opentype.Glyph}
   */
  Font.prototype.nameToGlyph = function(name) {
      var glyphIndex = this.nameToGlyphIndex(name);
      var glyph = this.glyphs.get(glyphIndex);
      if (!glyph) {
          // .notdef
          glyph = this.glyphs.get(0);
      }

      return glyph;
  };

  /**
   * @param  {Number}
   * @return {String}
   */
  Font.prototype.glyphIndexToName = function(gid) {
      if (!this.glyphNames.glyphIndexToName) {
          return '';
      }

      return this.glyphNames.glyphIndexToName(gid);
  };

  /**
   * Retrieve the value of the kerning pair between the left glyph (or its index)
   * and the right glyph (or its index). If no kerning pair is found, return 0.
   * The kerning value gets added to the advance width when calculating the spacing
   * between glyphs.
   * For GPOS kerning, this method uses the default script and language, which covers
   * most use cases. To have greater control, use font.position.getKerningValue .
   * @param  {opentype.Glyph} leftGlyph
   * @param  {opentype.Glyph} rightGlyph
   * @return {Number}
   */
  Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
      leftGlyph = leftGlyph.index || leftGlyph;
      rightGlyph = rightGlyph.index || rightGlyph;
      var gposKerning = this.position.defaultKerningTables;
      if (gposKerning) {
          return this.position.getKerningValue(gposKerning, leftGlyph, rightGlyph);
      }
      // "kern" table
      return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
  };

  /**
   * @typedef GlyphRenderOptions
   * @type Object
   * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
   *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
   * @property {string} [language='dflt'] - language system used to determine which features to apply.
   *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
   * @property {boolean} [kerning=true] - whether to include kerning values
   * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
   *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
   */
  Font.prototype.defaultRenderOptions = {
      kerning: true,
      features: [
          /**
           * these 4 features are required to render Arabic text properly
           * and shouldn't be turned off when rendering arabic text.
           */
          { script: 'arab', tags: ['init', 'medi', 'fina', 'rlig'] },
          { script: 'latn', tags: ['liga', 'rlig'] }
      ]
  };

  /**
   * Helper function that invokes the given callback for each glyph in the given text.
   * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
   * @param {string} text - The text to apply.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {GlyphRenderOptions=} options
   * @param  {Function} callback
   */
  Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
      x = x !== undefined ? x : 0;
      y = y !== undefined ? y : 0;
      fontSize = fontSize !== undefined ? fontSize : 72;
      options = Object.assign({}, this.defaultRenderOptions, options);
      var fontScale = 1 / this.unitsPerEm * fontSize;
      var glyphs = this.stringToGlyphs(text, options);
      var kerningLookups;
      if (options.kerning) {
          var script = options.script || this.position.getDefaultScriptName();
          kerningLookups = this.position.getKerningTables(script, options.language);
      }
      for (var i = 0; i < glyphs.length; i += 1) {
          var glyph = glyphs[i];
          callback.call(this, glyph, x, y, fontSize, options);
          if (glyph.advanceWidth) {
              x += glyph.advanceWidth * fontScale;
          }

          if (options.kerning && i < glyphs.length - 1) {
              // We should apply position adjustment lookups in a more generic way.
              // Here we only use the xAdvance value.
              var kerningValue = kerningLookups ?
                    this.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
                    this.getKerningValue(glyph, glyphs[i + 1]);
              x += kerningValue * fontScale;
          }

          if (options.letterSpacing) {
              x += options.letterSpacing * fontSize;
          } else if (options.tracking) {
              x += (options.tracking / 1000) * fontSize;
          }
      }
      return x;
  };

  /**
   * Create a Path object that represents the given text.
   * @param  {string} text - The text to create.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {GlyphRenderOptions=} options
   * @return {opentype.Path}
   */
  Font.prototype.getPath = function(text, x, y, fontSize, options) {
      var fullPath = new Path();
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
          var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
          fullPath.extend(glyphPath);
      });
      return fullPath;
  };

  /**
   * Create an array of Path objects that represent the glyphs of a given text.
   * @param  {string} text - The text to create.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {GlyphRenderOptions=} options
   * @return {opentype.Path[]}
   */
  Font.prototype.getPaths = function(text, x, y, fontSize, options) {
      var glyphPaths = [];
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
          var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
          glyphPaths.push(glyphPath);
      });

      return glyphPaths;
  };

  /**
   * Returns the advance width of a text.
   *
   * This is something different than Path.getBoundingBox() as for example a
   * suffixed whitespace increases the advanceWidth but not the bounding box
   * or an overhanging letter like a calligraphic 'f' might have a quite larger
   * bounding box than its advance width.
   *
   * This corresponds to canvas2dContext.measureText(text).width
   *
   * @param  {string} text - The text to create.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {GlyphRenderOptions=} options
   * @return advance width
   */
  Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
      return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
  };

  /**
   * Draw the text on the given drawing context.
   * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
   * @param  {string} text - The text to create.
   * @param  {number} [x=0] - Horizontal position of the beginning of the text.
   * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param  {GlyphRenderOptions=} options
   */
  Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
      this.getPath(text, x, y, fontSize, options).draw(ctx);
  };

  /**
   * Draw the points of all glyphs in the text.
   * On-curve points will be drawn in blue, off-curve points will be drawn in red.
   * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
   * @param {string} text - The text to create.
   * @param {number} [x=0] - Horizontal position of the beginning of the text.
   * @param {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param {GlyphRenderOptions=} options
   */
  Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
          glyph.drawPoints(ctx, gX, gY, gFontSize);
      });
  };

  /**
   * Draw lines indicating important font measurements for all glyphs in the text.
   * Black lines indicate the origin of the coordinate system (point 0,0).
   * Blue lines indicate the glyph bounding box.
   * Green line indicates the advance width of the glyph.
   * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
   * @param {string} text - The text to create.
   * @param {number} [x=0] - Horizontal position of the beginning of the text.
   * @param {number} [y=0] - Vertical position of the *baseline* of the text.
   * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
   * @param {GlyphRenderOptions=} options
   */
  Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
      this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
          glyph.drawMetrics(ctx, gX, gY, gFontSize);
      });
  };

  /**
   * @param  {string}
   * @return {string}
   */
  Font.prototype.getEnglishName = function(name) {
      var translations = this.names[name];
      if (translations) {
          return translations.en;
      }
  };

  /**
   * Validate
   */
  Font.prototype.validate = function() {
      var _this = this;

      function assert(predicate, message) {
      }

      function assertNamePresent(name) {
          var englishName = _this.getEnglishName(name);
          assert(englishName && englishName.trim().length > 0);
      }

      // Identification information
      assertNamePresent('fontFamily');
      assertNamePresent('weightName');
      assertNamePresent('manufacturer');
      assertNamePresent('copyright');
      assertNamePresent('version');

      // Dimension information
      assert(this.unitsPerEm > 0);
  };

  /**
   * Convert the font object to a SFNT data structure.
   * This structure contains all the necessary tables and metadata to create a binary OTF file.
   * @return {opentype.Table}
   */
  Font.prototype.toTables = function() {
      return sfnt.fontToTable(this);
  };
  /**
   * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
   */
  Font.prototype.toBuffer = function() {
      console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
      return this.toArrayBuffer();
  };
  /**
   * Converts a `opentype.Font` into an `ArrayBuffer`
   * @return {ArrayBuffer}
   */
  Font.prototype.toArrayBuffer = function() {
      var sfntTable = this.toTables();
      var bytes = sfntTable.encode();
      var buffer = new ArrayBuffer(bytes.length);
      var intArray = new Uint8Array(buffer);
      for (var i = 0; i < bytes.length; i++) {
          intArray[i] = bytes[i];
      }

      return buffer;
  };

  /**
   * Initiate a download of the OpenType font.
   */
  Font.prototype.download = function(fileName) {
      var familyName = this.getEnglishName('fontFamily');
      var styleName = this.getEnglishName('fontSubfamily');
      fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
      var arrayBuffer = this.toArrayBuffer();

      if (isBrowser()) {
          window.URL = window.URL || window.webkitURL;

          if (window.URL) {
              var dataView = new DataView(arrayBuffer);
              var blob = new Blob([dataView], {type: 'font/opentype'});

              var link = document.createElement('a');
              link.href = window.URL.createObjectURL(blob);
              link.download = fileName;

              var event = document.createEvent('MouseEvents');
              event.initEvent('click', true, false);
              link.dispatchEvent(event);
          } else {
              console.warn('Font file could not be downloaded. Try using a different browser.');
          }
      } else {
          var fs = require$$0;
          var buffer = arrayBufferToNodeBuffer(arrayBuffer);
          fs.writeFileSync(fileName, buffer);
      }
  };
  /**
   * @private
   */
  Font.prototype.fsSelectionValues = {
      ITALIC:              0x001, //1
      UNDERSCORE:          0x002, //2
      NEGATIVE:            0x004, //4
      OUTLINED:            0x008, //8
      STRIKEOUT:           0x010, //16
      BOLD:                0x020, //32
      REGULAR:             0x040, //64
      USER_TYPO_METRICS:   0x080, //128
      WWS:                 0x100, //256
      OBLIQUE:             0x200  //512
  };

  /**
   * @private
   */
  Font.prototype.usWidthClasses = {
      ULTRA_CONDENSED: 1,
      EXTRA_CONDENSED: 2,
      CONDENSED: 3,
      SEMI_CONDENSED: 4,
      MEDIUM: 5,
      SEMI_EXPANDED: 6,
      EXPANDED: 7,
      EXTRA_EXPANDED: 8,
      ULTRA_EXPANDED: 9
  };

  /**
   * @private
   */
  Font.prototype.usWeightClasses = {
      THIN: 100,
      EXTRA_LIGHT: 200,
      LIGHT: 300,
      NORMAL: 400,
      MEDIUM: 500,
      SEMI_BOLD: 600,
      BOLD: 700,
      EXTRA_BOLD: 800,
      BLACK:    900
  };

  // The `fvar` table stores font variation axes and instances.

  function addName(name, names) {
      var nameString = JSON.stringify(name);
      var nameID = 256;
      for (var nameKey in names) {
          var n = parseInt(nameKey);
          if (!n || n < 256) {
              continue;
          }

          if (JSON.stringify(names[nameKey]) === nameString) {
              return n;
          }

          if (nameID <= n) {
              nameID = n + 1;
          }
      }

      names[nameID] = name;
      return nameID;
  }

  function makeFvarAxis(n, axis, names) {
      var nameID = addName(axis.name, names);
      return [
          {name: 'tag_' + n, type: 'TAG', value: axis.tag},
          {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
          {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
          {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
          {name: 'flags_' + n, type: 'USHORT', value: 0},
          {name: 'nameID_' + n, type: 'USHORT', value: nameID}
      ];
  }

  function parseFvarAxis(data, start, names) {
      var axis = {};
      var p = new parse$2.Parser(data, start);
      axis.tag = p.parseTag();
      axis.minValue = p.parseFixed();
      axis.defaultValue = p.parseFixed();
      axis.maxValue = p.parseFixed();
      p.skip('uShort', 1);  // reserved for flags; no values defined
      axis.name = names[p.parseUShort()] || {};
      return axis;
  }

  function makeFvarInstance(n, inst, axes, names) {
      var nameID = addName(inst.name, names);
      var fields = [
          {name: 'nameID_' + n, type: 'USHORT', value: nameID},
          {name: 'flags_' + n, type: 'USHORT', value: 0}
      ];

      for (var i = 0; i < axes.length; ++i) {
          var axisTag = axes[i].tag;
          fields.push({
              name: 'axis_' + n + ' ' + axisTag,
              type: 'FIXED',
              value: inst.coordinates[axisTag] << 16
          });
      }

      return fields;
  }

  function parseFvarInstance(data, start, axes, names) {
      var inst = {};
      var p = new parse$2.Parser(data, start);
      inst.name = names[p.parseUShort()] || {};
      p.skip('uShort', 1);  // reserved for flags; no values defined

      inst.coordinates = {};
      for (var i = 0; i < axes.length; ++i) {
          inst.coordinates[axes[i].tag] = p.parseFixed();
      }

      return inst;
  }

  function makeFvarTable(fvar, names) {
      var result = new table$1.Table('fvar', [
          {name: 'version', type: 'ULONG', value: 0x10000},
          {name: 'offsetToData', type: 'USHORT', value: 0},
          {name: 'countSizePairs', type: 'USHORT', value: 2},
          {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
          {name: 'axisSize', type: 'USHORT', value: 20},
          {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
          {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
      ]);
      result.offsetToData = result.sizeOf();

      for (var i = 0; i < fvar.axes.length; i++) {
          result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
      }

      for (var j = 0; j < fvar.instances.length; j++) {
          result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
      }

      return result;
  }

  function parseFvarTable(data, start, names) {
      var p = new parse$2.Parser(data, start);
      var tableVersion = p.parseULong();
      check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
      var offsetToData = p.parseOffset16();
      // Skip countSizePairs.
      p.skip('uShort', 1);
      var axisCount = p.parseUShort();
      var axisSize = p.parseUShort();
      var instanceCount = p.parseUShort();
      var instanceSize = p.parseUShort();

      var axes = [];
      for (var i = 0; i < axisCount; i++) {
          axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
      }

      var instances = [];
      var instanceStart = start + offsetToData + axisCount * axisSize;
      for (var j = 0; j < instanceCount; j++) {
          instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
      }

      return {axes: axes, instances: instances};
  }

  var fvar = { make: makeFvarTable, parse: parseFvarTable };

  // The `GDEF` table contains various glyph properties

  var attachList = function() {
      return {
          coverage: this.parsePointer(Parser.coverage),
          attachPoints: this.parseList(Parser.pointer(Parser.uShortList))
      };
  };

  var caretValue = function() {
      var format = this.parseUShort();
      check.argument(format === 1 || format === 2 || format === 3,
          'Unsupported CaretValue table version.');
      if (format === 1) {
          return { coordinate: this.parseShort() };
      } else if (format === 2) {
          return { pointindex: this.parseShort() };
      } else if (format === 3) {
          // Device / Variation Index tables unsupported
          return { coordinate: this.parseShort() };
      }
  };

  var ligGlyph = function() {
      return this.parseList(Parser.pointer(caretValue));
  };

  var ligCaretList = function() {
      return {
          coverage: this.parsePointer(Parser.coverage),
          ligGlyphs: this.parseList(Parser.pointer(ligGlyph))
      };
  };

  var markGlyphSets = function() {
      this.parseUShort(); // Version
      return this.parseList(Parser.pointer(Parser.coverage));
  };

  function parseGDEFTable(data, start) {
      start = start || 0;
      var p = new Parser(data, start);
      var tableVersion = p.parseVersion(1);
      check.argument(tableVersion === 1 || tableVersion === 1.2 || tableVersion === 1.3,
          'Unsupported GDEF table version.');
      var gdef = {
          version: tableVersion,
          classDef: p.parsePointer(Parser.classDef),
          attachList: p.parsePointer(attachList),
          ligCaretList: p.parsePointer(ligCaretList),
          markAttachClassDef: p.parsePointer(Parser.classDef)
      };
      if (tableVersion >= 1.2) {
          gdef.markGlyphSets = p.parsePointer(markGlyphSets);
      }
      return gdef;
  }
  var gdef = { parse: parseGDEFTable };

  // The `GPOS` table contains kerning pairs, among other things.

  var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

  // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
  // this = Parser instance
  subtableParsers$1[1] = function parseLookup1() {
      var start = this.offset + this.relativeOffset;
      var posformat = this.parseUShort();
      if (posformat === 1) {
          return {
              posFormat: 1,
              coverage: this.parsePointer(Parser.coverage),
              value: this.parseValueRecord()
          };
      } else if (posformat === 2) {
          return {
              posFormat: 2,
              coverage: this.parsePointer(Parser.coverage),
              values: this.parseValueRecordList()
          };
      }
      check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
  };

  // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
  subtableParsers$1[2] = function parseLookup2() {
      var start = this.offset + this.relativeOffset;
      var posFormat = this.parseUShort();
      check.assert(posFormat === 1 || posFormat === 2, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
      var coverage = this.parsePointer(Parser.coverage);
      var valueFormat1 = this.parseUShort();
      var valueFormat2 = this.parseUShort();
      if (posFormat === 1) {
          // Adjustments for Glyph Pairs
          return {
              posFormat: posFormat,
              coverage: coverage,
              valueFormat1: valueFormat1,
              valueFormat2: valueFormat2,
              pairSets: this.parseList(Parser.pointer(Parser.list(function() {
                  return {        // pairValueRecord
                      secondGlyph: this.parseUShort(),
                      value1: this.parseValueRecord(valueFormat1),
                      value2: this.parseValueRecord(valueFormat2)
                  };
              })))
          };
      } else if (posFormat === 2) {
          var classDef1 = this.parsePointer(Parser.classDef);
          var classDef2 = this.parsePointer(Parser.classDef);
          var class1Count = this.parseUShort();
          var class2Count = this.parseUShort();
          return {
              // Class Pair Adjustment
              posFormat: posFormat,
              coverage: coverage,
              valueFormat1: valueFormat1,
              valueFormat2: valueFormat2,
              classDef1: classDef1,
              classDef2: classDef2,
              class1Count: class1Count,
              class2Count: class2Count,
              classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
                  return {
                      value1: this.parseValueRecord(valueFormat1),
                      value2: this.parseValueRecord(valueFormat2)
                  };
              }))
          };
      }
  };

  subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
  subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
  subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
  subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
  subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
  subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
  subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

  // https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
  function parseGposTable(data, start) {
      start = start || 0;
      var p = new Parser(data, start);
      var tableVersion = p.parseVersion(1);
      check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

      if (tableVersion === 1) {
          return {
              version: tableVersion,
              scripts: p.parseScriptList(),
              features: p.parseFeatureList(),
              lookups: p.parseLookupList(subtableParsers$1)
          };
      } else {
          return {
              version: tableVersion,
              scripts: p.parseScriptList(),
              features: p.parseFeatureList(),
              lookups: p.parseLookupList(subtableParsers$1),
              variations: p.parseFeatureVariationsList()
          };
      }

  }

  // GPOS Writing //////////////////////////////////////////////
  // NOT SUPPORTED
  var subtableMakers$1 = new Array(10);

  function makeGposTable(gpos) {
      return new table$1.Table('GPOS', [
          {name: 'version', type: 'ULONG', value: 0x10000},
          {name: 'scripts', type: 'TABLE', value: new table$1.ScriptList(gpos.scripts)},
          {name: 'features', type: 'TABLE', value: new table$1.FeatureList(gpos.features)},
          {name: 'lookups', type: 'TABLE', value: new table$1.LookupList(gpos.lookups, subtableMakers$1)}
      ]);
  }

  var gpos = { parse: parseGposTable, make: makeGposTable };

  // The `kern` table contains kerning pairs.

  function parseWindowsKernTable(p) {
      var pairs = {};
      // Skip nTables.
      p.skip('uShort');
      var subtableVersion = p.parseUShort();
      check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
      // Skip subtableLength, subtableCoverage
      p.skip('uShort', 2);
      var nPairs = p.parseUShort();
      // Skip searchRange, entrySelector, rangeShift.
      p.skip('uShort', 3);
      for (var i = 0; i < nPairs; i += 1) {
          var leftIndex = p.parseUShort();
          var rightIndex = p.parseUShort();
          var value = p.parseShort();
          pairs[leftIndex + ',' + rightIndex] = value;
      }
      return pairs;
  }

  function parseMacKernTable(p) {
      var pairs = {};
      // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
      // Skip the rest.
      p.skip('uShort');
      var nTables = p.parseULong();
      //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
      if (nTables > 1) {
          console.warn('Only the first kern subtable is supported.');
      }
      p.skip('uLong');
      var coverage = p.parseUShort();
      var subtableVersion = coverage & 0xFF;
      p.skip('uShort');
      if (subtableVersion === 0) {
          var nPairs = p.parseUShort();
          // Skip searchRange, entrySelector, rangeShift.
          p.skip('uShort', 3);
          for (var i = 0; i < nPairs; i += 1) {
              var leftIndex = p.parseUShort();
              var rightIndex = p.parseUShort();
              var value = p.parseShort();
              pairs[leftIndex + ',' + rightIndex] = value;
          }
      }
      return pairs;
  }

  // Parse the `kern` table which contains kerning pairs.
  function parseKernTable(data, start) {
      var p = new parse$2.Parser(data, start);
      var tableVersion = p.parseUShort();
      if (tableVersion === 0) {
          return parseWindowsKernTable(p);
      } else if (tableVersion === 1) {
          return parseMacKernTable(p);
      } else {
          throw new Error('Unsupported kern table version (' + tableVersion + ').');
      }
  }

  var kern$1 = { parse: parseKernTable };

  // The `loca` table stores the offsets to the locations of the glyphs in the font.

  // Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
  // relative to the beginning of the glyphData table.
  // The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
  // The loca table has two versions: a short version where offsets are stored as uShorts, and a long
  // version where offsets are stored as uLongs. The `head` table specifies which version to use
  // (under indexToLocFormat).
  function parseLocaTable(data, start, numGlyphs, shortVersion) {
      var p = new parse$2.Parser(data, start);
      var parseFn = shortVersion ? p.parseUShort : p.parseULong;
      // There is an extra entry after the last index element to compute the length of the last glyph.
      // That's why we use numGlyphs + 1.
      var glyphOffsets = [];
      for (var i = 0; i < numGlyphs + 1; i += 1) {
          var glyphOffset = parseFn.call(p);
          if (shortVersion) {
              // The short table version stores the actual offset divided by 2.
              glyphOffset *= 2;
          }

          glyphOffsets.push(glyphOffset);
      }

      return glyphOffsets;
  }

  var loca$1 = { parse: parseLocaTable };

  // opentype.js

  /**
   * The opentype library.
   * @namespace opentype
   */

  // File loaders /////////////////////////////////////////////////////////
  /**
   * Loads a font from a file. The callback throws an error message as the first parameter if it fails
   * and the font as an ArrayBuffer in the second parameter if it succeeds.
   * @param  {string} path - The path of the file
   * @param  {Function} callback - The function to call when the font load completes
   */
  function loadFromFile(path, callback) {
      var fs = require$$0;
      fs.readFile(path, function(err, buffer) {
          if (err) {
              return callback(err.message);
          }

          callback(null, nodeBufferToArrayBuffer(buffer));
      });
  }
  /**
   * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
   * and the font as an ArrayBuffer in the second parameter if it succeeds.
   * @param  {string} url - The URL of the font file.
   * @param  {Function} callback - The function to call when the font load completes
   */
  function loadFromUrl(url, callback) {
      var request = new XMLHttpRequest();
      request.open('get', url, true);
      request.responseType = 'arraybuffer';
      request.onload = function() {
          if (request.response) {
              return callback(null, request.response);
          } else {
              return callback('Font could not be loaded: ' + request.statusText);
          }
      };

      request.onerror = function () {
          callback('Font could not be loaded');
      };

      request.send();
  }

  // Table Directory Entries //////////////////////////////////////////////
  /**
   * Parses OpenType table entries.
   * @param  {DataView}
   * @param  {Number}
   * @return {Object[]}
   */
  function parseOpenTypeTableEntries(data, numTables) {
      var tableEntries = [];
      var p = 12;
      for (var i = 0; i < numTables; i += 1) {
          var tag = parse$2.getTag(data, p);
          var checksum = parse$2.getULong(data, p + 4);
          var offset = parse$2.getULong(data, p + 8);
          var length = parse$2.getULong(data, p + 12);
          tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
          p += 16;
      }

      return tableEntries;
  }

  /**
   * Parses WOFF table entries.
   * @param  {DataView}
   * @param  {Number}
   * @return {Object[]}
   */
  function parseWOFFTableEntries(data, numTables) {
      var tableEntries = [];
      var p = 44; // offset to the first table directory entry.
      for (var i = 0; i < numTables; i += 1) {
          var tag = parse$2.getTag(data, p);
          var offset = parse$2.getULong(data, p + 4);
          var compLength = parse$2.getULong(data, p + 8);
          var origLength = parse$2.getULong(data, p + 12);
          var compression = (void 0);
          if (compLength < origLength) {
              compression = 'WOFF';
          } else {
              compression = false;
          }

          tableEntries.push({tag: tag, offset: offset, compression: compression,
              compressedLength: compLength, length: origLength});
          p += 20;
      }

      return tableEntries;
  }

  /**
   * @typedef TableData
   * @type Object
   * @property {DataView} data - The DataView
   * @property {number} offset - The data offset.
   */

  /**
   * @param  {DataView}
   * @param  {Object}
   * @return {TableData}
   */
  function uncompressTable(data, tableEntry) {
      if (tableEntry.compression === 'WOFF') {
          var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
          var outBuffer = new Uint8Array(tableEntry.length);
          tinyInflate(inBuffer, outBuffer);
          if (outBuffer.byteLength !== tableEntry.length) {
              throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
          }

          var view = new DataView(outBuffer.buffer, 0);
          return {data: view, offset: 0};
      } else {
          return {data: data, offset: tableEntry.offset};
      }
  }

  // Public API ///////////////////////////////////////////////////////////

  /**
   * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
   * Throws an error if the font could not be parsed.
   * @param  {ArrayBuffer}
   * @param  {Object} opt - options for parsing
   * @return {opentype.Font}
   */
  function parseBuffer(buffer, opt) {
      opt = (opt === undefined || opt === null) ?  {} : opt;

      var indexToLocFormat;
      var ltagTable;

      // Since the constructor can also be called to create new fonts from scratch, we indicate this
      // should be an empty font that we'll fill with our own data.
      var font = new Font({empty: true});

      // OpenType fonts use big endian byte ordering.
      // We can't rely on typed array view types, because they operate with the endianness of the host computer.
      // Instead we use DataViews where we can specify endianness.
      var data = new DataView(buffer, 0);
      var numTables;
      var tableEntries = [];
      var signature = parse$2.getTag(data, 0);
      if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
          font.outlinesFormat = 'truetype';
          numTables = parse$2.getUShort(data, 4);
          tableEntries = parseOpenTypeTableEntries(data, numTables);
      } else if (signature === 'OTTO') {
          font.outlinesFormat = 'cff';
          numTables = parse$2.getUShort(data, 4);
          tableEntries = parseOpenTypeTableEntries(data, numTables);
      } else if (signature === 'wOFF') {
          var flavor = parse$2.getTag(data, 4);
          if (flavor === String.fromCharCode(0, 1, 0, 0)) {
              font.outlinesFormat = 'truetype';
          } else if (flavor === 'OTTO') {
              font.outlinesFormat = 'cff';
          } else {
              throw new Error('Unsupported OpenType flavor ' + signature);
          }

          numTables = parse$2.getUShort(data, 12);
          tableEntries = parseWOFFTableEntries(data, numTables);
      } else {
          throw new Error('Unsupported OpenType signature ' + signature);
      }

      var cffTableEntry;
      var fvarTableEntry;
      var glyfTableEntry;
      var gdefTableEntry;
      var gposTableEntry;
      var gsubTableEntry;
      var hmtxTableEntry;
      var kernTableEntry;
      var locaTableEntry;
      var nameTableEntry;
      var metaTableEntry;
      var p;

      for (var i = 0; i < numTables; i += 1) {
          var tableEntry = tableEntries[i];
          var table = (void 0);
          switch (tableEntry.tag) {
              case 'cmap':
                  table = uncompressTable(data, tableEntry);
                  font.tables.cmap = cmap$1.parse(table.data, table.offset);
                  font.encoding = new CmapEncoding(font.tables.cmap);
                  break;
              case 'cvt ' :
                  table = uncompressTable(data, tableEntry);
                  p = new parse$2.Parser(table.data, table.offset);
                  font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                  break;
              case 'fvar':
                  fvarTableEntry = tableEntry;
                  break;
              case 'fpgm' :
                  table = uncompressTable(data, tableEntry);
                  p = new parse$2.Parser(table.data, table.offset);
                  font.tables.fpgm = p.parseByteList(tableEntry.length);
                  break;
              case 'head':
                  table = uncompressTable(data, tableEntry);
                  font.tables.head = head$1.parse(table.data, table.offset);
                  font.unitsPerEm = font.tables.head.unitsPerEm;
                  indexToLocFormat = font.tables.head.indexToLocFormat;
                  break;
              case 'hhea':
                  table = uncompressTable(data, tableEntry);
                  font.tables.hhea = hhea$1.parse(table.data, table.offset);
                  font.ascender = font.tables.hhea.ascender;
                  font.descender = font.tables.hhea.descender;
                  font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                  break;
              case 'hmtx':
                  hmtxTableEntry = tableEntry;
                  break;
              case 'ltag':
                  table = uncompressTable(data, tableEntry);
                  ltagTable = ltag.parse(table.data, table.offset);
                  break;
              case 'maxp':
                  table = uncompressTable(data, tableEntry);
                  font.tables.maxp = maxp$1.parse(table.data, table.offset);
                  font.numGlyphs = font.tables.maxp.numGlyphs;
                  break;
              case 'name':
                  nameTableEntry = tableEntry;
                  break;
              case 'OS/2':
                  table = uncompressTable(data, tableEntry);
                  font.tables.os2 = os2.parse(table.data, table.offset);
                  break;
              case 'post':
                  table = uncompressTable(data, tableEntry);
                  font.tables.post = post$1.parse(table.data, table.offset);
                  font.glyphNames = new GlyphNames(font.tables.post);
                  break;
              case 'prep' :
                  table = uncompressTable(data, tableEntry);
                  p = new parse$2.Parser(table.data, table.offset);
                  font.tables.prep = p.parseByteList(tableEntry.length);
                  break;
              case 'glyf':
                  glyfTableEntry = tableEntry;
                  break;
              case 'loca':
                  locaTableEntry = tableEntry;
                  break;
              case 'CFF ':
                  cffTableEntry = tableEntry;
                  break;
              case 'kern':
                  kernTableEntry = tableEntry;
                  break;
              case 'GDEF':
                  gdefTableEntry = tableEntry;
                  break;
              case 'GPOS':
                  gposTableEntry = tableEntry;
                  break;
              case 'GSUB':
                  gsubTableEntry = tableEntry;
                  break;
              case 'meta':
                  metaTableEntry = tableEntry;
                  break;
          }
      }

      var nameTable = uncompressTable(data, nameTableEntry);
      font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
      font.names = font.tables.name;

      if (glyfTableEntry && locaTableEntry) {
          var shortVersion = indexToLocFormat === 0;
          var locaTable = uncompressTable(data, locaTableEntry);
          var locaOffsets = loca$1.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
          var glyfTable = uncompressTable(data, glyfTableEntry);
          font.glyphs = glyf$1.parse(glyfTable.data, glyfTable.offset, locaOffsets, font, opt);
      } else if (cffTableEntry) {
          var cffTable = uncompressTable(data, cffTableEntry);
          cff.parse(cffTable.data, cffTable.offset, font, opt);
      } else {
          throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
      }

      var hmtxTable = uncompressTable(data, hmtxTableEntry);
      hmtx$1.parse(font, hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs, opt);
      addGlyphNames(font, opt);

      if (kernTableEntry) {
          var kernTable = uncompressTable(data, kernTableEntry);
          font.kerningPairs = kern$1.parse(kernTable.data, kernTable.offset);
      } else {
          font.kerningPairs = {};
      }

      if (gdefTableEntry) {
          var gdefTable = uncompressTable(data, gdefTableEntry);
          font.tables.gdef = gdef.parse(gdefTable.data, gdefTable.offset);
      }

      if (gposTableEntry) {
          var gposTable = uncompressTable(data, gposTableEntry);
          font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
          font.position.init();
      }

      if (gsubTableEntry) {
          var gsubTable = uncompressTable(data, gsubTableEntry);
          font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
      }

      if (fvarTableEntry) {
          var fvarTable = uncompressTable(data, fvarTableEntry);
          font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
      }

      if (metaTableEntry) {
          var metaTable = uncompressTable(data, metaTableEntry);
          font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
          font.metas = font.tables.meta;
      }

      return font;
  }

  /**
   * Asynchronously load the font from a URL or a filesystem. When done, call the callback
   * with two arguments `(err, font)`. The `err` will be null on success,
   * the `font` is a Font object.
   * We use the node.js callback convention so that
   * opentype.js can integrate with frameworks like async.js.
   * @alias opentype.load
   * @param  {string} url - The URL of the font to load.
   * @param  {Function} callback - The callback.
   */
  function load(url, callback, opt) {
      opt = (opt === undefined || opt === null) ?  {} : opt;
      var isNode = typeof window === 'undefined';
      var loadFn = isNode && !opt.isUrl ? loadFromFile : loadFromUrl;

      return new Promise(function (resolve, reject) {
          loadFn(url, function(err, arrayBuffer) {
              if (err) {
                  if (callback) {
                      return callback(err);
                  } else {
                      reject(err);
                  }
              }
              var font;
              try {
                  font = parseBuffer(arrayBuffer, opt);
              } catch (e) {
                  if (callback) {
                      return callback(e, null);
                  } else {
                      reject(e);
                  }
              }
              if (callback) {
                  return callback(null, font);
              } else {
                  resolve(font);
              }
          });
      });
  }

  /**
   * Synchronously load the font from a URL or file.
   * When done, returns the font object or throws an error.
   * @alias opentype.loadSync
   * @param  {string} url - The URL of the font to load.
   * @param  {Object} opt - opt.lowMemory
   * @return {opentype.Font}
   */
  function loadSync(url, opt) {
      var fs = require$$0;
      var buffer = fs.readFileSync(url);
      return parseBuffer(nodeBufferToArrayBuffer(buffer), opt);
  }

  var opentype = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	Font: Font,
  	Glyph: Glyph,
  	Path: Path,
  	BoundingBox: BoundingBox,
  	_parse: parse$2,
  	parse: parseBuffer,
  	load: load,
  	loadSync: loadSync
  });

  var main_esm = {};

  var font = {};

  var buffer = {};

  var hasRequiredBuffer;

  function requireBuffer () {
  	if (hasRequiredBuffer) return buffer;
  	hasRequiredBuffer = 1;

  	Object.defineProperty(buffer, "__esModule", {
  	  value: true
  	});
  	buffer.default = void 0;
  	/**
  	 * @file BufferArrayBuffer
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/* eslint-disable no-undef */
  	buffer.default = {
  	  /**
  	   * BufferArrayBuffer
  	   *
  	   * @param {Buffer} buffer 
  	   * @return {ArrayBuffer}
  	   */
  	  toArrayBuffer: function toArrayBuffer(buffer) {
  	    var length = buffer.length;
  	    var view = new DataView(new ArrayBuffer(length), 0, length);
  	    for (var i = 0, l = length; i < l; i++) {
  	      view.setUint8(i, buffer[i], false);
  	    }
  	    return view.buffer;
  	  },
  	  /**
  	   * ArrayBufferBuffer
  	   *
  	   * @param {ArrayBuffer} arrayBuffer 
  	   * @return {Buffer}
  	   */
  	  toBuffer: function toBuffer(arrayBuffer) {
  	    if (Array.isArray(arrayBuffer)) {
  	      return Buffer.from(arrayBuffer);
  	    }
  	    var length = arrayBuffer.byteLength;
  	    var view = new DataView(arrayBuffer, 0, length);
  	    var buffer = Buffer.alloc(length);
  	    for (var i = 0, l = length; i < l; i++) {
  	      buffer[i] = view.getUint8(i, false);
  	    }
  	    return buffer;
  	  }
  	};
  	return buffer;
  }

  var getEmptyttfObject = {};

  var lang = {};

  var hasRequiredLang;

  function requireLang () {
  	if (hasRequiredLang) return lang;
  	hasRequiredLang = 1;

  	Object.defineProperty(lang, "__esModule", {
  	  value: true
  	});
  	lang.clone = clone;
  	lang.curry = curry;
  	lang.debounce = debounce;
  	lang.equals = equals;
  	lang.generic = generic;
  	lang.isArray = isArray;
  	lang.isDate = isDate;
  	lang.isEmptyObject = isEmptyObject;
  	lang.isFunction = isFunction;
  	lang.isObject = isObject;
  	lang.isString = isString;
  	lang.overwrite = overwrite;
  	lang.throttle = throttle;
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	function isArray(obj) {
  	  return obj != null && toString.call(obj).slice(8, -1) === 'Array';
  	}
  	function isObject(obj) {
  	  return obj != null && toString.call(obj).slice(8, -1) === 'Object';
  	}
  	function isString(obj) {
  	  return obj != null && toString.call(obj).slice(8, -1) === 'String';
  	}
  	function isFunction(obj) {
  	  return obj != null && toString.call(obj).slice(8, -1) === 'Function';
  	}
  	function isDate(obj) {
  	  return obj != null && toString.call(obj).slice(8, -1) === 'Date';
  	}
  	function isEmptyObject(object) {
  	  for (var name in object) {
  	    // eslint-disable-next-line no-prototype-builtins
  	    if (object.hasOwnProperty(name)) {
  	      return false;
  	    }
  	  }
  	  return true;
  	}

  	/**
  	 * 
  	 *
  	 * @see http://en.wikipedia.org/wiki/Currying
  	 * @param {Function} fn 
  	 * @param {...Array} cargs cargs
  	 * @return {Function}
  	 */
  	function curry(fn) {
  	  for (var _len = arguments.length, cargs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  	    cargs[_key - 1] = arguments[_key];
  	  }
  	  return function () {
  	    for (var _len2 = arguments.length, rargs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
  	      rargs[_key2] = arguments[_key2];
  	    }
  	    var args = cargs.concat(rargs);
  	    // eslint-disable-next-line no-invalid-this
  	    return fn.apply(this, args);
  	  };
  	}

  	/**
  	 * , 
  	 *
  	 * @param {Function} method 
  	 * @return {Function} 
  	 */
  	function generic(method) {
  	  return function () {
  	    for (var _len3 = arguments.length, fargs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
  	      fargs[_key3] = arguments[_key3];
  	    }
  	    return Function.call.apply(method, fargs);
  	  };
  	}

  	/**
  	 * 
  	 *
  	 * @param {Object} thisObj 
  	 * @param {Object} thatObj 
  	 * @param {Array.<string>} fields 
  	 * @return {Object} thisObj
  	 */
  	function overwrite(thisObj, thatObj, fields) {
  	  if (!thatObj) {
  	    return thisObj;
  	  }

  	  // `fields`overwrite`fields`
  	  fields = fields || Object.keys(thatObj);
  	  fields.forEach(function (field) {
  	    // 
  	    if (thisObj[field] && _typeof(thisObj[field]) === 'object' && thatObj[field] && _typeof(thatObj[field]) === 'object') {
  	      overwrite(thisObj[field], thatObj[field]);
  	    } else {
  	      thisObj[field] = thatObj[field];
  	    }
  	  });
  	  return thisObj;
  	}

  	/**
  	 * 
  	 *
  	 * @param {Object} source 
  	 * @return {Object} 
  	 */
  	function clone(source) {
  	  if (!source || _typeof(source) !== 'object') {
  	    return source;
  	  }
  	  var cloned = source;
  	  if (isArray(source)) {
  	    cloned = source.slice().map(clone);
  	  } else if (isObject(source) && 'isPrototypeOf' in source) {
  	    cloned = {};
  	    for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
  	      var key = _Object$keys[_i];
  	      cloned[key] = clone(source[key]);
  	    }
  	  }
  	  return cloned;
  	}

  	// Returns a function, that, when invoked, will only be triggered at most once
  	// during a given window of time.
  	// @see underscore.js
  	function throttle(func, wait) {
  	  var context;
  	  var args;
  	  var timeout;
  	  var result;
  	  var previous = 0;
  	  var later = function later() {
  	    previous = new Date();
  	    timeout = null;
  	    result = func.apply(context, args);
  	  };
  	  return function () {
  	    var now = new Date();
  	    var remaining = wait - (now - previous);
  	    // eslint-disable-next-line no-invalid-this
  	    context = this;
  	    if (remaining <= 0) {
  	      clearTimeout(timeout);
  	      timeout = null;
  	      previous = now;
  	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
  	        args[_key4] = arguments[_key4];
  	      }
  	      result = func.apply(context, args);
  	    } else if (!timeout) {
  	      timeout = setTimeout(later, remaining);
  	    }
  	    return result;
  	  };
  	}

  	// Returns a function, that, as long as it continues to be invoked, will not
  	// be triggered. The function will be called after it stops being called for
  	// N milliseconds. If `immediate` is passed, trigger the function on the
  	// leading edge, instead of the trailing.
  	// @see underscore.js
  	function debounce(func, wait, immediate) {
  	  var timeout;
  	  var result;
  	  return function () {
  	    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
  	      args[_key5] = arguments[_key5];
  	    }
  	    // eslint-disable-next-line no-invalid-this
  	    var context = this;
  	    var later = function later() {
  	      timeout = null;
  	      if (!immediate) {
  	        result = func.apply(context, args);
  	      }
  	    };
  	    var callNow = immediate && !timeout;
  	    clearTimeout(timeout);
  	    timeout = setTimeout(later, wait);
  	    if (callNow) {
  	      result = func.apply(context, args);
  	    }
  	    return result;
  	  };
  	}

  	/**
  	 * 
  	 *
  	 * @param  {Object} thisObj 
  	 * @param  {Object} thatObj 
  	 * @param  {Array} fields 
  	 * @return {boolean}  
  	 */
  	function equals(thisObj, thatObj, fields) {
  	  if (thisObj === thatObj) {
  	    return true;
  	  }
  	  if (thisObj == null && thatObj == null) {
  	    return true;
  	  }
  	  if (thisObj == null && thatObj != null || thisObj != null && thatObj == null) {
  	    return false;
  	  }

  	  // `fields`overwrite`fields`
  	  fields = fields || (_typeof(thisObj) === 'object' ? Object.keys(thisObj) : []);
  	  if (!fields.length) {
  	    return thisObj === thatObj;
  	  }
  	  var equal = true;
  	  for (var i = 0, l = fields.length, field; equal && i < l; i++) {
  	    field = fields[i];
  	    if (thisObj[field] && _typeof(thisObj[field]) === 'object' && thatObj[field] && _typeof(thatObj[field]) === 'object') {
  	      equal = equal && equals(thisObj[field], thatObj[field]);
  	    } else {
  	      equal = equal && thisObj[field] === thatObj[field];
  	    }
  	  }
  	  return equal;
  	}
  	return lang;
  }

  var empty = {};

  var hasRequiredEmpty;

  function requireEmpty () {
  	if (hasRequiredEmpty) return empty;
  	hasRequiredEmpty = 1;

  	Object.defineProperty(empty, "__esModule", {
  	  value: true
  	});
  	empty.default = void 0;
  	/**
  	 * @file ttfjson
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/* eslint-disable  */
  	empty.default = {
  	  "version": 1,
  	  "numTables": 10,
  	  "searchRange": 128,
  	  "entrySelector": 3,
  	  "rangeShift": 64,
  	  "head": {
  	    "version": 1,
  	    "fontRevision": 1,
  	    "checkSumAdjustment": 0,
  	    "magickNumber": 1594834165,
  	    "flags": 11,
  	    "unitsPerEm": 1024,
  	    "created": 1428940800000,
  	    "modified": 1428940800000,
  	    "xMin": 34,
  	    "yMin": 0,
  	    "xMax": 306,
  	    "yMax": 682,
  	    "macStyle": 0,
  	    "lowestRecPPEM": 8,
  	    "fontDirectionHint": 2,
  	    "indexToLocFormat": 0,
  	    "glyphDataFormat": 0
  	  },
  	  "glyf": [{
  	    "contours": [[{
  	      "x": 34,
  	      "y": 0,
  	      "onCurve": true
  	    }, {
  	      "x": 34,
  	      "y": 682,
  	      "onCurve": true
  	    }, {
  	      "x": 306,
  	      "y": 682,
  	      "onCurve": true
  	    }, {
  	      "x": 306,
  	      "y": 0,
  	      "onCurve": true
  	    }], [{
  	      "x": 68,
  	      "y": 34,
  	      "onCurve": true
  	    }, {
  	      "x": 272,
  	      "y": 34,
  	      "onCurve": true
  	    }, {
  	      "x": 272,
  	      "y": 648,
  	      "onCurve": true
  	    }, {
  	      "x": 68,
  	      "y": 648,
  	      "onCurve": true
  	    }]],
  	    "xMin": 34,
  	    "yMin": 0,
  	    "xMax": 306,
  	    "yMax": 682,
  	    "advanceWidth": 374,
  	    "leftSideBearing": 34,
  	    "name": ".notdef"
  	  }],
  	  "cmap": {},
  	  "name": {
  	    "fontFamily": "fonteditor",
  	    "fontSubFamily": "Medium",
  	    "uniqueSubFamily": "FontEditor 1.0 : fonteditor",
  	    "version": "Version 1.0 ; FontEditor (v0.0.1)",
  	    "postScriptName": "fonteditor",
  	    "fullName": "fonteditor"
  	  },
  	  "hhea": {
  	    "version": 1,
  	    "ascent": 812,
  	    "descent": -212,
  	    "lineGap": 92,
  	    "advanceWidthMax": 374,
  	    "minLeftSideBearing": 34,
  	    "minRightSideBearing": 68,
  	    "xMaxExtent": 306,
  	    "caretSlopeRise": 1,
  	    "caretSlopeRun": 0,
  	    "caretOffset": 0,
  	    "reserved0": 0,
  	    "reserved1": 0,
  	    "reserved2": 0,
  	    "reserved3": 0,
  	    "metricDataFormat": 0,
  	    "numOfLongHorMetrics": 1
  	  },
  	  "post": {
  	    "italicAngle": 0,
  	    "postoints": 65411,
  	    "underlinePosition": 50,
  	    "underlineThickness": 0,
  	    "isFixedPitch": 0,
  	    "minMemType42": 0,
  	    "maxMemType42": 0,
  	    "minMemType1": 0,
  	    "maxMemType1": 1,
  	    "format": 2
  	  },
  	  "maxp": {
  	    "version": 1.0,
  	    "numGlyphs": 0,
  	    "maxPoints": 0,
  	    "maxContours": 0,
  	    "maxCompositePoints": 0,
  	    "maxCompositeContours": 0,
  	    "maxZones": 0,
  	    "maxTwilightPoints": 0,
  	    "maxStorage": 0,
  	    "maxFunctionDefs": 0,
  	    "maxStackElements": 0,
  	    "maxSizeOfInstructions": 0,
  	    "maxComponentElements": 0,
  	    "maxComponentDepth": 0
  	  },
  	  "OS/2": {
  	    "version": 4,
  	    "xAvgCharWidth": 1031,
  	    "usWeightClass": 400,
  	    "usWidthClass": 5,
  	    "fsType": 0,
  	    "ySubscriptXSize": 665,
  	    "ySubscriptYSize": 716,
  	    "ySubscriptXOffset": 0,
  	    "ySubscriptYOffset": 143,
  	    "ySuperscriptXSize": 665,
  	    "ySuperscriptYSize": 716,
  	    "ySuperscriptXOffset": 0,
  	    "ySuperscriptYOffset": 491,
  	    "yStrikeoutSize": 51,
  	    "yStrikeoutPosition": 265,
  	    "sFamilyClass": 0,
  	    "bFamilyType": 2,
  	    "bSerifStyle": 0,
  	    "bWeight": 6,
  	    "bProportion": 3,
  	    "bContrast": 0,
  	    "bStrokeVariation": 0,
  	    "bArmStyle": 0,
  	    "bLetterform": 0,
  	    "bMidline": 0,
  	    "bXHeight": 0,
  	    "ulUnicodeRange1": 1,
  	    "ulUnicodeRange2": 268435456,
  	    "ulUnicodeRange3": 0,
  	    "ulUnicodeRange4": 0,
  	    "achVendID": "PfEd",
  	    "fsSelection": 192,
  	    "usFirstCharIndex": 65535,
  	    "usLastCharIndex": -1,
  	    "sTypoAscender": 812,
  	    "sTypoDescender": -212,
  	    "sTypoLineGap": 92,
  	    "usWinAscent": 812,
  	    "usWinDescent": 212,
  	    "ulCodePageRange1": 1,
  	    "ulCodePageRange2": 0,
  	    "sxHeight": 792,
  	    "sCapHeight": 0,
  	    "usDefaultChar": 0,
  	    "usBreakChar": 32,
  	    "usMaxContext": 1
  	  }
  	};
  	return empty;
  }

  var _default = {};

  var hasRequired_default;

  function require_default () {
  	if (hasRequired_default) return _default;
  	hasRequired_default = 1;

  	Object.defineProperty(_default, "__esModule", {
  	  value: true
  	});
  	_default.default = void 0;
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	_default.default = {
  	  // 
  	  fontId: 'fonteditor',
  	  // 
  	  name: {
  	    // 
  	    fontFamily: 'fonteditor',
  	    fontSubFamily: 'Medium',
  	    uniqueSubFamily: 'FontEditor 1.0 : fonteditor',
  	    version: 'Version 1.0; FontEditor (v1.0)',
  	    postScriptName: 'fonteditor'
  	  }
  	};
  	return _default;
  }

  var hasRequiredGetEmptyttfObject;

  function requireGetEmptyttfObject () {
  	if (hasRequiredGetEmptyttfObject) return getEmptyttfObject;
  	hasRequiredGetEmptyttfObject = 1;

  	Object.defineProperty(getEmptyttfObject, "__esModule", {
  	  value: true
  	});
  	getEmptyttfObject.default = getEmpty;
  	var _lang = requireLang();
  	var _empty = _interopRequireDefault(requireEmpty());
  	var _default = _interopRequireDefault(require_default());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	function getEmpty() {
  	  var ttf = (0, _lang.clone)(_empty.default);
  	  Object.assign(ttf.name, _default.default.name);
  	  ttf.head.created = ttf.head.modified = Date.now();
  	  return ttf;
  	}
  	return getEmptyttfObject;
  }

  var ttf = {};

  var string$1 = {};

  var unicodeName = {};

  var hasRequiredUnicodeName;

  function requireUnicodeName () {
  	if (hasRequiredUnicodeName) return unicodeName;
  	hasRequiredUnicodeName = 1;

  	Object.defineProperty(unicodeName, "__esModule", {
  	  value: true
  	});
  	unicodeName.default = void 0;
  	/**
  	 * @file unicode postName
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * see:
  	 * http://www.microsoft.com/typography/otspec/WGL4.htm
  	 */
  	unicodeName.default = {
  	  0: 1,
  	  1: 1,
  	  2: 1,
  	  3: 1,
  	  4: 1,
  	  5: 1,
  	  6: 1,
  	  7: 1,
  	  8: 1,
  	  9: 2,
  	  10: 1,
  	  11: 1,
  	  12: 1,
  	  13: 2,
  	  14: 1,
  	  15: 1,
  	  16: 1,
  	  17: 1,
  	  18: 1,
  	  19: 1,
  	  20: 1,
  	  21: 1,
  	  22: 1,
  	  23: 1,
  	  24: 1,
  	  25: 1,
  	  26: 1,
  	  27: 1,
  	  28: 1,
  	  29: 1,
  	  30: 1,
  	  31: 1,
  	  32: 3,
  	  33: 4,
  	  34: 5,
  	  35: 6,
  	  36: 7,
  	  37: 8,
  	  38: 9,
  	  39: 10,
  	  40: 11,
  	  41: 12,
  	  42: 13,
  	  43: 14,
  	  44: 15,
  	  45: 16,
  	  46: 17,
  	  47: 18,
  	  48: 19,
  	  49: 20,
  	  50: 21,
  	  51: 22,
  	  52: 23,
  	  53: 24,
  	  54: 25,
  	  55: 26,
  	  56: 27,
  	  57: 28,
  	  58: 29,
  	  59: 30,
  	  60: 31,
  	  61: 32,
  	  62: 33,
  	  63: 34,
  	  64: 35,
  	  65: 36,
  	  66: 37,
  	  67: 38,
  	  68: 39,
  	  69: 40,
  	  70: 41,
  	  71: 42,
  	  72: 43,
  	  73: 44,
  	  74: 45,
  	  75: 46,
  	  76: 47,
  	  77: 48,
  	  78: 49,
  	  79: 50,
  	  80: 51,
  	  81: 52,
  	  82: 53,
  	  83: 54,
  	  84: 55,
  	  85: 56,
  	  86: 57,
  	  87: 58,
  	  88: 59,
  	  89: 60,
  	  90: 61,
  	  91: 62,
  	  92: 63,
  	  93: 64,
  	  94: 65,
  	  95: 66,
  	  96: 67,
  	  97: 68,
  	  98: 69,
  	  99: 70,
  	  100: 71,
  	  101: 72,
  	  102: 73,
  	  103: 74,
  	  104: 75,
  	  105: 76,
  	  106: 77,
  	  107: 78,
  	  108: 79,
  	  109: 80,
  	  110: 81,
  	  111: 82,
  	  112: 83,
  	  113: 84,
  	  114: 85,
  	  115: 86,
  	  116: 87,
  	  117: 88,
  	  118: 89,
  	  119: 90,
  	  120: 91,
  	  121: 92,
  	  122: 93,
  	  123: 94,
  	  124: 95,
  	  125: 96,
  	  126: 97,
  	  160: 172,
  	  161: 163,
  	  162: 132,
  	  163: 133,
  	  164: 189,
  	  165: 150,
  	  166: 232,
  	  167: 134,
  	  168: 142,
  	  169: 139,
  	  170: 157,
  	  171: 169,
  	  172: 164,
  	  174: 138,
  	  175: 218,
  	  176: 131,
  	  177: 147,
  	  178: 242,
  	  179: 243,
  	  180: 141,
  	  181: 151,
  	  182: 136,
  	  184: 222,
  	  185: 241,
  	  186: 158,
  	  187: 170,
  	  188: 245,
  	  189: 244,
  	  190: 246,
  	  191: 162,
  	  192: 173,
  	  193: 201,
  	  194: 199,
  	  195: 174,
  	  196: 98,
  	  197: 99,
  	  198: 144,
  	  199: 100,
  	  200: 203,
  	  201: 101,
  	  202: 200,
  	  203: 202,
  	  204: 207,
  	  205: 204,
  	  206: 205,
  	  207: 206,
  	  208: 233,
  	  209: 102,
  	  210: 211,
  	  211: 208,
  	  212: 209,
  	  213: 175,
  	  214: 103,
  	  215: 240,
  	  216: 145,
  	  217: 214,
  	  218: 212,
  	  219: 213,
  	  220: 104,
  	  221: 235,
  	  222: 237,
  	  223: 137,
  	  224: 106,
  	  225: 105,
  	  226: 107,
  	  227: 109,
  	  228: 108,
  	  229: 110,
  	  230: 160,
  	  231: 111,
  	  232: 113,
  	  233: 112,
  	  234: 114,
  	  235: 115,
  	  236: 117,
  	  237: 116,
  	  238: 118,
  	  239: 119,
  	  240: 234,
  	  241: 120,
  	  242: 122,
  	  243: 121,
  	  244: 123,
  	  245: 125,
  	  246: 124,
  	  247: 184,
  	  248: 161,
  	  249: 127,
  	  250: 126,
  	  251: 128,
  	  252: 129,
  	  253: 236,
  	  254: 238,
  	  255: 186,
  	  262: 253,
  	  263: 254,
  	  268: 255,
  	  269: 256,
  	  273: 257,
  	  286: 248,
  	  287: 249,
  	  304: 250,
  	  305: 215,
  	  321: 226,
  	  322: 227,
  	  338: 176,
  	  339: 177,
  	  350: 251,
  	  351: 252,
  	  352: 228,
  	  353: 229,
  	  376: 187,
  	  381: 230,
  	  382: 231,
  	  402: 166,
  	  710: 216,
  	  711: 225,
  	  728: 219,
  	  729: 220,
  	  730: 221,
  	  731: 224,
  	  733: 223,
  	  960: 155,
  	  8211: 178,
  	  8212: 179,
  	  8216: 182,
  	  8217: 183,
  	  8218: 196,
  	  8220: 180,
  	  8221: 181,
  	  8222: 197,
  	  8224: 130,
  	  8225: 194,
  	  8226: 135,
  	  8230: 171,
  	  8240: 198,
  	  8249: 190,
  	  8250: 191,
  	  8355: 247,
  	  8482: 140,
  	  8486: 159,
  	  8706: 152,
  	  8710: 168,
  	  8719: 154,
  	  8721: 153,
  	  8722: 239,
  	  8725: 188,
  	  8729: 195,
  	  8730: 165,
  	  8734: 146,
  	  8747: 156,
  	  8776: 167,
  	  8800: 143,
  	  8804: 148,
  	  8805: 149,
  	  9674: 185,
  	  61441: 192,
  	  61442: 193,
  	  64257: 192,
  	  64258: 193,
  	  65535: 0 // 0xFFFF.notdef
  	};
  	return unicodeName;
  }

  var postName = {};

  var hasRequiredPostName;

  function requirePostName () {
  	if (hasRequiredPostName) return postName;
  	hasRequiredPostName = 1;

  	Object.defineProperty(postName, "__esModule", {
  	  value: true
  	});
  	postName.default = void 0;
  	/**
  	 * @file Mac glyf
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * see:
  	 * http://www.microsoft.com/typography/otspec/WGL4.htm
  	 */
  	postName.default = {
  	  0: '.notdef',
  	  1: '.null',
  	  2: 'nonmarkingreturn',
  	  3: 'space',
  	  4: 'exclam',
  	  5: 'quotedbl',
  	  6: 'numbersign',
  	  7: 'dollar',
  	  8: 'percent',
  	  9: 'ampersand',
  	  10: 'quotesingle',
  	  11: 'parenleft',
  	  12: 'parenright',
  	  13: 'asterisk',
  	  14: 'plus',
  	  15: 'comma',
  	  16: 'hyphen',
  	  17: 'period',
  	  18: 'slash',
  	  19: 'zero',
  	  20: 'one',
  	  21: 'two',
  	  22: 'three',
  	  23: 'four',
  	  24: 'five',
  	  25: 'six',
  	  26: 'seven',
  	  27: 'eight',
  	  28: 'nine',
  	  29: 'colon',
  	  30: 'semicolon',
  	  31: 'less',
  	  32: 'equal',
  	  33: 'greater',
  	  34: 'question',
  	  35: 'at',
  	  36: 'A',
  	  37: 'B',
  	  38: 'C',
  	  39: 'D',
  	  40: 'E',
  	  41: 'F',
  	  42: 'G',
  	  43: 'H',
  	  44: 'I',
  	  45: 'J',
  	  46: 'K',
  	  47: 'L',
  	  48: 'M',
  	  49: 'N',
  	  50: 'O',
  	  51: 'P',
  	  52: 'Q',
  	  53: 'R',
  	  54: 'S',
  	  55: 'T',
  	  56: 'U',
  	  57: 'V',
  	  58: 'W',
  	  59: 'X',
  	  60: 'Y',
  	  61: 'Z',
  	  62: 'bracketleft',
  	  63: 'backslash',
  	  64: 'bracketright',
  	  65: 'asciicircum',
  	  66: 'underscore',
  	  67: 'grave',
  	  68: 'a',
  	  69: 'b',
  	  70: 'c',
  	  71: 'd',
  	  72: 'e',
  	  73: 'f',
  	  74: 'g',
  	  75: 'h',
  	  76: 'i',
  	  77: 'j',
  	  78: 'k',
  	  79: 'l',
  	  80: 'm',
  	  81: 'n',
  	  82: 'o',
  	  83: 'p',
  	  84: 'q',
  	  85: 'r',
  	  86: 's',
  	  87: 't',
  	  88: 'u',
  	  89: 'v',
  	  90: 'w',
  	  91: 'x',
  	  92: 'y',
  	  93: 'z',
  	  94: 'braceleft',
  	  95: 'bar',
  	  96: 'braceright',
  	  97: 'asciitilde',
  	  98: 'Adieresis',
  	  99: 'Aring',
  	  100: 'Ccedilla',
  	  101: 'Eacute',
  	  102: 'Ntilde',
  	  103: 'Odieresis',
  	  104: 'Udieresis',
  	  105: 'aacute',
  	  106: 'agrave',
  	  107: 'acircumflex',
  	  108: 'adieresis',
  	  109: 'atilde',
  	  110: 'aring',
  	  111: 'ccedilla',
  	  112: 'eacute',
  	  113: 'egrave',
  	  114: 'ecircumflex',
  	  115: 'edieresis',
  	  116: 'iacute',
  	  117: 'igrave',
  	  118: 'icircumflex',
  	  119: 'idieresis',
  	  120: 'ntilde',
  	  121: 'oacute',
  	  122: 'ograve',
  	  123: 'ocircumflex',
  	  124: 'odieresis',
  	  125: 'otilde',
  	  126: 'uacute',
  	  127: 'ugrave',
  	  128: 'ucircumflex',
  	  129: 'udieresis',
  	  130: 'dagger',
  	  131: 'degree',
  	  132: 'cent',
  	  133: 'sterling',
  	  134: 'section',
  	  135: 'bullet',
  	  136: 'paragraph',
  	  137: 'germandbls',
  	  138: 'registered',
  	  139: 'copyright',
  	  140: 'trademark',
  	  141: 'acute',
  	  142: 'dieresis',
  	  143: 'notequal',
  	  144: 'AE',
  	  145: 'Oslash',
  	  146: 'infinity',
  	  147: 'plusminus',
  	  148: 'lessequal',
  	  149: 'greaterequal',
  	  150: 'yen',
  	  151: 'mu',
  	  152: 'partialdiff',
  	  153: 'summation',
  	  154: 'product',
  	  155: 'pi',
  	  156: 'integral',
  	  157: 'ordfeminine',
  	  158: 'ordmasculine',
  	  159: 'Omega',
  	  160: 'ae',
  	  161: 'oslash',
  	  162: 'questiondown',
  	  163: 'exclamdown',
  	  164: 'logicalnot',
  	  165: 'radical',
  	  166: 'florin',
  	  167: 'approxequal',
  	  168: 'Delta',
  	  169: 'guillemotleft',
  	  170: 'guillemotright',
  	  171: 'ellipsis',
  	  172: 'nonbreakingspace',
  	  173: 'Agrave',
  	  174: 'Atilde',
  	  175: 'Otilde',
  	  176: 'OE',
  	  177: 'oe',
  	  178: 'endash',
  	  179: 'emdash',
  	  180: 'quotedblleft',
  	  181: 'quotedblright',
  	  182: 'quoteleft',
  	  183: 'quoteright',
  	  184: 'divide',
  	  185: 'lozenge',
  	  186: 'ydieresis',
  	  187: 'Ydieresis',
  	  188: 'fraction',
  	  189: 'currency',
  	  190: 'guilsinglleft',
  	  191: 'guilsinglright',
  	  192: 'fi',
  	  193: 'fl',
  	  194: 'daggerdbl',
  	  195: 'periodcentered',
  	  196: 'quotesinglbase',
  	  197: 'quotedblbase',
  	  198: 'perthousand',
  	  199: 'Acircumflex',
  	  200: 'Ecircumflex',
  	  201: 'Aacute',
  	  202: 'Edieresis',
  	  203: 'Egrave',
  	  204: 'Iacute',
  	  205: 'Icircumflex',
  	  206: 'Idieresis',
  	  207: 'Igrave',
  	  208: 'Oacute',
  	  209: 'Ocircumflex',
  	  210: 'apple',
  	  211: 'Ograve',
  	  212: 'Uacute',
  	  213: 'Ucircumflex',
  	  214: 'Ugrave',
  	  215: 'dotlessi',
  	  216: 'circumflex',
  	  217: 'tilde',
  	  218: 'macron',
  	  219: 'breve',
  	  220: 'dotaccent',
  	  221: 'ring',
  	  222: 'cedilla',
  	  223: 'hungarumlaut',
  	  224: 'ogonek',
  	  225: 'caron',
  	  226: 'Lslash',
  	  227: 'lslash',
  	  228: 'Scaron',
  	  229: 'scaron',
  	  230: 'Zcaron',
  	  231: 'zcaron',
  	  232: 'brokenbar',
  	  233: 'Eth',
  	  234: 'eth',
  	  235: 'Yacute',
  	  236: 'yacute',
  	  237: 'Thorn',
  	  238: 'thorn',
  	  239: 'minus',
  	  240: 'multiply',
  	  241: 'onesuperior',
  	  242: 'twosuperior',
  	  243: 'threesuperior',
  	  244: 'onehalf',
  	  245: 'onequarter',
  	  246: 'threequarters',
  	  247: 'franc',
  	  248: 'Gbreve',
  	  249: 'gbreve',
  	  250: 'Idotaccent',
  	  251: 'Scedilla',
  	  252: 'scedilla',
  	  253: 'Cacute',
  	  254: 'cacute',
  	  255: 'Ccaron',
  	  256: 'ccaron',
  	  257: 'dcroat'
  	};
  	return postName;
  }

  var hasRequiredString$1;

  function requireString$1 () {
  	if (hasRequiredString$1) return string$1;
  	hasRequiredString$1 = 1;

  	Object.defineProperty(string$1, "__esModule", {
  	  value: true
  	});
  	string$1.default = void 0;
  	var _unicodeName = _interopRequireDefault(requireUnicodeName());
  	var _postName = _interopRequireDefault(requirePostName());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * references:
  	 * 1. svg2ttf @ github
  	 */

  	/**
  	 * unicodejs
  	 * `\u0020`, 
  	 *
  	 * @param {string} str str
  	 * @return {string} 
  	 */
  	function stringify(str) {
  	  if (!str) {
  	    return str;
  	  }
  	  var newStr = '';
  	  for (var i = 0, l = str.length, ch; i < l; i++) {
  	    ch = str.charCodeAt(i);
  	    if (ch === 0) {
  	      continue;
  	    }
  	    newStr += String.fromCharCode(ch);
  	  }
  	  return newStr;
  	}
  	string$1.default = {
  	  stringify: stringify,
  	  /**
  	   * `\uxxxx`
  	   *
  	   * @param {string} str str
  	   * @return {string} 
  	   */
  	  escape: function (_escape) {
  	    function escape(_x) {
  	      return _escape.apply(this, arguments);
  	    }
  	    escape.toString = function () {
  	      return _escape.toString();
  	    };
  	    return escape;
  	  }(function (str) {
  	    if (!str) {
  	      return str;
  	    }
  	    return String(str).replace(/[\uff-\uffff]/g, function (c) {
  	      return escape(c).replace('%', '\\');
  	    });
  	  }),
  	  /**
  	   * bytes to string
  	   *
  	   * @param  {Array} bytes 
  	   * @return {string}       string
  	   */
  	  getString: function getString(bytes) {
  	    var s = '';
  	    for (var i = 0, l = bytes.length; i < l; i++) {
  	      s += String.fromCharCode(bytes[i]);
  	    }
  	    return s;
  	  },
  	  /**
  	   * unicode
  	   *
  	   * @param {number} unicode unicode
  	   * @return {string} 
  	   */
  	  getUnicodeName: function getUnicodeName(unicode) {
  	    var unicodeNameIndex = _unicodeName.default[unicode];
  	    if (undefined !== unicodeNameIndex) {
  	      return _postName.default[unicodeNameIndex];
  	    }
  	    return 'uni' + unicode.toString(16).toUpperCase();
  	  },
  	  /**
  	   * utf8
  	   *
  	   * @param {string} str 
  	   * @return {Array.<byte>} 
  	   */
  	  toUTF8Bytes: function toUTF8Bytes(str) {
  	    str = stringify(str);
  	    var byteArray = [];
  	    for (var i = 0, l = str.length; i < l; i++) {
  	      if (str.charCodeAt(i) <= 0x7F) {
  	        byteArray.push(str.charCodeAt(i));
  	      } else {
  	        var codePoint = str.codePointAt(i);
  	        if (codePoint > 0xffff) {
  	          i++;
  	        }
  	        var h = encodeURIComponent(String.fromCodePoint(codePoint)).slice(1).split('%');
  	        for (var j = 0; j < h.length; j++) {
  	          byteArray.push(parseInt(h[j], 16));
  	        }
  	      }
  	    }
  	    return byteArray;
  	  },
  	  /**
  	   * usc2
  	   *
  	   * @param {string} str 
  	   * @return {Array.<byte>} 
  	   */
  	  toUCS2Bytes: function toUCS2Bytes(str) {
  	    str = stringify(str);
  	    var byteArray = [];
  	    for (var i = 0, l = str.length, ch; i < l; i++) {
  	      ch = str.charCodeAt(i);
  	      byteArray.push(ch >> 8);
  	      byteArray.push(ch & 0xFF);
  	    }
  	    return byteArray;
  	  },
  	  /**
  	   * pascal string 
  	   *
  	   * @param {string} str 
  	   * @return {Array.<byte>} byteArray byte
  	   */
  	  toPascalStringBytes: function toPascalStringBytes(str) {
  	    var bytes = [];
  	    var length = str ? str.length < 256 ? str.length : 255 : 0;
  	    bytes.push(length);
  	    for (var i = 0, l = str.length; i < l; i++) {
  	      var c = str.charCodeAt(i);
  	      // non-ASCII characters are substituted with '*'
  	      bytes.push(c < 128 ? c : 42);
  	    }
  	    return bytes;
  	  },
  	  /**
  	   * utf8
  	   *
  	   * @param {Array} bytes 
  	   * @return {string} 
  	   */
  	  getUTF8String: function getUTF8String(bytes) {
  	    var str = '';
  	    for (var i = 0, l = bytes.length; i < l; i++) {
  	      if (bytes[i] < 0x7F) {
  	        str += String.fromCharCode(bytes[i]);
  	      } else {
  	        str += '%' + (256 + bytes[i]).toString(16).slice(1);
  	      }
  	    }
  	    return unescape(str);
  	  },
  	  /**
  	   * ucs2
  	   *
  	   * @param {Array} bytes 
  	   * @return {string} 
  	   */
  	  getUCS2String: function getUCS2String(bytes) {
  	    var str = '';
  	    for (var i = 0, l = bytes.length; i < l; i += 2) {
  	      str += String.fromCharCode((bytes[i] << 8) + bytes[i + 1]);
  	    }
  	    return str;
  	  },
  	  /**
  	   *  pascal string
  	   *
  	   * @param {Array.<byte>} byteArray byte
  	   * @return {Array.<string>} 
  	   */
  	  getPascalString: function getPascalString(byteArray) {
  	    var strArray = [];
  	    var i = 0;
  	    var l = byteArray.length;
  	    while (i < l) {
  	      var strLength = byteArray[i++];
  	      var str = '';
  	      while (strLength-- > 0 && i < l) {
  	        str += String.fromCharCode(byteArray[i++]);
  	      }
  	      // unicodejs
  	      str = stringify(str);
  	      strArray.push(str);
  	    }
  	    return strArray;
  	  }
  	};
  	return string$1;
  }

  var pathAdjust = {};

  var hasRequiredPathAdjust;

  function requirePathAdjust () {
  	if (hasRequiredPathAdjust) return pathAdjust;
  	hasRequiredPathAdjust = 1;

  	Object.defineProperty(pathAdjust, "__esModule", {
  	  value: true
  	});
  	pathAdjust.default = pathAdjust$1;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * path
  	 *
  	 * @param {Object} contour 
  	 * @param {number} scaleX x
  	 * @param {number} scaleY y
  	 * @param {number} offsetX x
  	 * @param {number} offsetY y
  	 *
  	 * @return {Object} contour 
  	 */
  	function pathAdjust$1(contour, scaleX, scaleY, offsetX, offsetY) {
  	  scaleX = scaleX === undefined ? 1 : scaleX;
  	  scaleY = scaleY === undefined ? 1 : scaleY;
  	  var x = offsetX || 0;
  	  var y = offsetY || 0;
  	  var p;
  	  for (var i = 0, l = contour.length; i < l; i++) {
  	    p = contour[i];
  	    p.x = scaleX * (p.x + x);
  	    p.y = scaleY * (p.y + y);
  	  }
  	  return contour;
  	}
  	return pathAdjust;
  }

  var pathCeil = {};

  var hasRequiredPathCeil;

  function requirePathCeil () {
  	if (hasRequiredPathCeil) return pathCeil;
  	hasRequiredPathCeil = 1;

  	Object.defineProperty(pathCeil, "__esModule", {
  	  value: true
  	});
  	pathCeil.default = pathCeil$1;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * path
  	 *
  	 * @param {Array} contour 
  	 * @param {number} point 
  	 * @return {Object} contour 
  	 */
  	function pathCeil$1(contour, point) {
  	  var p;
  	  for (var i = 0, l = contour.length; i < l; i++) {
  	    p = contour[i];
  	    if (!point) {
  	      p.x = Math.round(p.x);
  	      p.y = Math.round(p.y);
  	    } else {
  	      p.x = Number(p.x.toFixed(point));
  	      p.y = Number(p.y.toFixed(point));
  	    }
  	  }
  	  return contour;
  	}
  	return pathCeil;
  }

  var computeBoundingBox = {};

  var pathIterator = {};

  var hasRequiredPathIterator;

  function requirePathIterator () {
  	if (hasRequiredPathIterator) return pathIterator;
  	hasRequiredPathIterator = 1;

  	Object.defineProperty(pathIterator, "__esModule", {
  	  value: true
  	});
  	pathIterator.default = pathIterator$1;
  	/**
  	 * @file segment bezier curve
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Array} contour 
  	 * @param {Function} callBack command, p0, p1, p2, i
  	 * p0, p1, p2 
  	 * i 
  	 * command = L  Q
  	 */
  	function pathIterator$1(contour, callBack) {
  	  var curPoint;
  	  var prevPoint;
  	  var nextPoint;
  	  var cursorPoint; // cursorPoint 

  	  for (var i = 0, l = contour.length; i < l; i++) {
  	    curPoint = contour[i];
  	    prevPoint = i === 0 ? contour[l - 1] : contour[i - 1];
  	    nextPoint = i === l - 1 ? contour[0] : contour[i + 1];

  	    // 
  	    if (i === 0) {
  	      if (curPoint.onCurve) {
  	        cursorPoint = curPoint;
  	      } else if (prevPoint.onCurve) {
  	        cursorPoint = prevPoint;
  	      } else {
  	        cursorPoint = {
  	          x: (prevPoint.x + curPoint.x) / 2,
  	          y: (prevPoint.y + curPoint.y) / 2
  	        };
  	      }
  	    }

  	    // 
  	    if (curPoint.onCurve && nextPoint.onCurve) {
  	      if (false === callBack('L', curPoint, nextPoint, 0, i)) {
  	        break;
  	      }
  	      cursorPoint = nextPoint;
  	    } else if (!curPoint.onCurve) {
  	      if (nextPoint.onCurve) {
  	        if (false === callBack('Q', cursorPoint, curPoint, nextPoint, i)) {
  	          break;
  	        }
  	        cursorPoint = nextPoint;
  	      } else {
  	        var last = {
  	          x: (curPoint.x + nextPoint.x) / 2,
  	          y: (curPoint.y + nextPoint.y) / 2
  	        };
  	        if (false === callBack('Q', cursorPoint, curPoint, last, i)) {
  	          break;
  	        }
  	        cursorPoint = last;
  	      }
  	    }
  	  }
  	}
  	return pathIterator;
  }

  var hasRequiredComputeBoundingBox;

  function requireComputeBoundingBox () {
  	if (hasRequiredComputeBoundingBox) return computeBoundingBox;
  	hasRequiredComputeBoundingBox = 1;

  	Object.defineProperty(computeBoundingBox, "__esModule", {
  	  value: true
  	});
  	computeBoundingBox.computePath = computeBoundingBox.computeBounding = void 0;
  	computeBoundingBox.computePathBox = computePathBox;
  	computeBoundingBox.quadraticBezier = void 0;
  	var _pathIterator = _interopRequireDefault(requirePathIterator());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * modify from:
  	 * zrender
  	 * https://github.com/ecomfe/zrender/blob/master/src/tool/computeBoundingBox.js
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Array} points 
  	 * @return {Object} bounding box
  	 */
  	function computeBoundingBox$1(points) {
  	  if (points.length === 0) {
  	    return false;
  	  }
  	  var left = points[0].x;
  	  var right = points[0].x;
  	  var top = points[0].y;
  	  var bottom = points[0].y;
  	  for (var i = 1; i < points.length; i++) {
  	    var p = points[i];
  	    if (p.x < left) {
  	      left = p.x;
  	    }
  	    if (p.x > right) {
  	      right = p.x;
  	    }
  	    if (p.y < top) {
  	      top = p.y;
  	    }
  	    if (p.y > bottom) {
  	      bottom = p.y;
  	    }
  	  }
  	  return {
  	    x: left,
  	    y: top,
  	    width: right - left,
  	    height: bottom - top
  	  };
  	}

  	/**
  	 * 
  	 * http://pissang.net/blog/?p=91
  	 *
  	 * @param {Object} p0 p0
  	 * @param {Object} p1 p1
  	 * @param {Object} p2 p2
  	 * @return {Object} bound
  	 */
  	function computeQuadraticBezierBoundingBox(p0, p1, p2) {
  	  // Find extremities, where derivative in x dim or y dim is zero
  	  var tmp = p0.x + p2.x - 2 * p1.x;
  	  // p1 is center of p0 and p2 in x dim
  	  var t1;
  	  if (tmp === 0) {
  	    t1 = 0.5;
  	  } else {
  	    t1 = (p0.x - p1.x) / tmp;
  	  }
  	  tmp = p0.y + p2.y - 2 * p1.y;
  	  // p1 is center of p0 and p2 in y dim
  	  var t2;
  	  if (tmp === 0) {
  	    t2 = 0.5;
  	  } else {
  	    t2 = (p0.y - p1.y) / tmp;
  	  }
  	  t1 = Math.max(Math.min(t1, 1), 0);
  	  t2 = Math.max(Math.min(t2, 1), 0);
  	  var ct1 = 1 - t1;
  	  var ct2 = 1 - t2;
  	  var x1 = ct1 * ct1 * p0.x + 2 * ct1 * t1 * p1.x + t1 * t1 * p2.x;
  	  var y1 = ct1 * ct1 * p0.y + 2 * ct1 * t1 * p1.y + t1 * t1 * p2.y;
  	  var x2 = ct2 * ct2 * p0.x + 2 * ct2 * t2 * p1.x + t2 * t2 * p2.x;
  	  var y2 = ct2 * ct2 * p0.y + 2 * ct2 * t2 * p1.y + t2 * t2 * p2.y;
  	  return computeBoundingBox$1([p0, p2, {
  	    x: x1,
  	    y: y1
  	  }, {
  	    x: x2,
  	    y: y2
  	  }]);
  	}

  	/**
  	 * 
  	 *
  	 * @private
  	 * @param {...Array} args , path
  	 * @return {Object} {x, y, width, height}
  	 */
  	function computePathBoundingBox() {
  	  var points = [];
  	  var iterator = function iterator(c, p0, p1, p2) {
  	    if (c === 'L') {
  	      points.push(p0);
  	      points.push(p1);
  	    } else if (c === 'Q') {
  	      var bound = computeQuadraticBezierBoundingBox(p0, p1, p2);
  	      points.push(bound);
  	      points.push({
  	        x: bound.x + bound.width,
  	        y: bound.y + bound.height
  	      });
  	    }
  	  };
  	  if (arguments.length === 1) {
  	    (0, _pathIterator.default)(arguments.length <= 0 ? undefined : arguments[0], function (c, p0, p1, p2) {
  	      if (c === 'L') {
  	        points.push(p0);
  	        points.push(p1);
  	      } else if (c === 'Q') {
  	        var bound = computeQuadraticBezierBoundingBox(p0, p1, p2);
  	        points.push(bound);
  	        points.push({
  	          x: bound.x + bound.width,
  	          y: bound.y + bound.height
  	        });
  	      }
  	    });
  	  } else {
  	    for (var i = 0, l = arguments.length; i < l; i++) {
  	      (0, _pathIterator.default)(i < 0 || arguments.length <= i ? undefined : arguments[i], iterator);
  	    }
  	  }
  	  return computeBoundingBox$1(points);
  	}

  	/**
  	 * 
  	 *
  	 * @private
  	 * @param {...Array} args path, path
  	 * @return {Object} {x, y, width, height}
  	 */
  	function computePathBox() {
  	  var points = [];
  	  if (arguments.length === 1) {
  	    points = arguments.length <= 0 ? undefined : arguments[0];
  	  } else {
  	    for (var i = 0, l = arguments.length; i < l; i++) {
  	      Array.prototype.splice.apply(points, [points.length, 0].concat(i < 0 || arguments.length <= i ? undefined : arguments[i]));
  	    }
  	  }
  	  return computeBoundingBox$1(points);
  	}
  	computeBoundingBox.computeBounding = computeBoundingBox$1;
  	computeBoundingBox.quadraticBezier = computeQuadraticBezierBoundingBox;
  	computeBoundingBox.computePath = computePathBoundingBox;
  	return computeBoundingBox;
  }

  var compound2simpleglyf = {};

  var transformGlyfContours = {};

  var pathTransform = {};

  var hasRequiredPathTransform;

  function requirePathTransform () {
  	if (hasRequiredPathTransform) return pathTransform;
  	hasRequiredPathTransform = 1;

  	Object.defineProperty(pathTransform, "__esModule", {
  	  value: true
  	});
  	pathTransform.default = transform;
  	/**
  	 * @file transform
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * 
  	 * http://blog.csdn.net/henren555/article/details/9699449
  	 *
  	 *  |X|    |a      c       e|    |x|
  	 *  |Y| =  |b      d       f| *  |y|
  	 *  |1|    |0      0       1|    |1|
  	 *
  	 *  X = x * a + y * c + e
  	 *  Y = x * b + y * d + f
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Array.<Object>} contour 
  	 * @param {number} a m11
  	 * @param {number} b m12
  	 * @param {number} c m21
  	 * @param {number} d m22
  	 * @param {number} e dx
  	 * @param {number} f dy
  	 * @return {Array.<Object>} contour 
  	 */
  	function transform(contour, a, b, c, d, e, f) {
  	  var x;
  	  var y;
  	  var p;
  	  for (var i = 0, l = contour.length; i < l; i++) {
  	    p = contour[i];
  	    x = p.x;
  	    y = p.y;
  	    p.x = x * a + y * c + e;
  	    p.y = x * b + y * d + f;
  	  }
  	  return contour;
  	}
  	return pathTransform;
  }

  var hasRequiredTransformGlyfContours;

  function requireTransformGlyfContours () {
  	if (hasRequiredTransformGlyfContours) return transformGlyfContours;
  	hasRequiredTransformGlyfContours = 1;

  	Object.defineProperty(transformGlyfContours, "__esModule", {
  	  value: true
  	});
  	transformGlyfContours.default = transformGlyfContours$1;
  	var _pathCeil = _interopRequireDefault(requirePathCeil());
  	var _pathTransform = _interopRequireDefault(requirePathTransform());
  	var _lang = requireLang();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file contours
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * contoursListglyf
  	 *
  	 * @param  {Object} glyf glyf
  	 * @param  {Object} ttf ttfObject
  	 * @param  {Object=} contoursList contours
  	 * @param  {number} glyfIndex glyfindex
  	 * @return {Array} 
  	 */
  	function transformGlyfContours$1(glyf, ttf) {
  	  var contoursList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  	  var glyfIndex = arguments.length > 3 ? arguments[3] : undefined;
  	  if (!glyf.glyfs) {
  	    return glyf;
  	  }
  	  var compoundContours = [];
  	  glyf.glyfs.forEach(function (g) {
  	    var glyph = ttf.glyf[g.glyphIndex];
  	    if (!glyph || glyph === glyf) {
  	      return;
  	    }

  	    // contours
  	    if (glyph.compound && !contoursList[g.glyphIndex]) {
  	      transformGlyfContours$1(glyph, ttf, contoursList, g.glyphIndex);
  	    }

  	    // matrix
  	    var contours = (0, _lang.clone)(glyph.compound ? contoursList[g.glyphIndex] || [] : glyph.contours);
  	    var transform = g.transform;
  	    for (var i = 0, l = contours.length; i < l; i++) {
  	      (0, _pathTransform.default)(contours[i], transform.a, transform.b, transform.c, transform.d, transform.e, transform.f);
  	      compoundContours.push((0, _pathCeil.default)(contours[i]));
  	    }
  	  });

  	  // eslint-disable-next-line eqeqeq
  	  if (null != glyfIndex) {
  	    contoursList[glyfIndex] = compoundContours;
  	  }
  	  return compoundContours;
  	}
  	return transformGlyfContours;
  }

  var compound2simple = {};

  var hasRequiredCompound2simple;

  function requireCompound2simple () {
  	if (hasRequiredCompound2simple) return compound2simple;
  	hasRequiredCompound2simple = 1;

  	Object.defineProperty(compound2simple, "__esModule", {
  	  value: true
  	});
  	compound2simple.default = compound2simple$1;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param  {Object} glyf glyf
  	 * @param  {Array} contours 
  	 * @return {Object} 
  	 */
  	function compound2simple$1(glyf, contours) {
  	  glyf.contours = contours;
  	  delete glyf.compound;
  	  delete glyf.glyfs;
  	  // hintinghinting
  	  delete glyf.instructions;
  	  return glyf;
  	}
  	return compound2simple;
  }

  var hasRequiredCompound2simpleglyf;

  function requireCompound2simpleglyf () {
  	if (hasRequiredCompound2simpleglyf) return compound2simpleglyf;
  	hasRequiredCompound2simpleglyf = 1;

  	Object.defineProperty(compound2simpleglyf, "__esModule", {
  	  value: true
  	});
  	compound2simpleglyf.default = compound2simpleglyf$1;
  	var _transformGlyfContours = _interopRequireDefault(requireTransformGlyfContours());
  	var _compound2simple = _interopRequireDefault(requireCompound2simple());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * ttf
  	 *
  	 * @param  {Object|number} glyf glyfglyf
  	 * @param  {Object} ttf ttfObject
  	 * @param  {boolean} recrusive 
  	 * @return {Object} 
  	 */
  	function compound2simpleglyf$1(glyf, ttf, recrusive) {
  	  var glyfIndex;
  	  // 
  	  if (typeof glyf === 'number') {
  	    glyfIndex = glyf;
  	    glyf = ttf.glyf[glyfIndex];
  	  } else {
  	    glyfIndex = ttf.glyf.indexOf(glyf);
  	    if (-1 === glyfIndex) {
  	      return glyf;
  	    }
  	  }
  	  if (!glyf.compound || !glyf.glyfs) {
  	    return glyf;
  	  }
  	  var contoursList = {};
  	  (0, _transformGlyfContours.default)(glyf, ttf, contoursList, glyfIndex);
  	  if (recrusive) {
  	    Object.keys(contoursList).forEach(function (index) {
  	      (0, _compound2simple.default)(ttf.glyf[index], contoursList[index]);
  	    });
  	  } else {
  	    (0, _compound2simple.default)(glyf, contoursList[glyfIndex]);
  	  }
  	  return glyf;
  	}
  	return compound2simpleglyf;
  }

  var glyfAdjust = {};

  var hasRequiredGlyfAdjust;

  function requireGlyfAdjust () {
  	if (hasRequiredGlyfAdjust) return glyfAdjust;
  	hasRequiredGlyfAdjust = 1;

  	Object.defineProperty(glyfAdjust, "__esModule", {
  	  value: true
  	});
  	glyfAdjust.default = glyfAdjust$1;
  	var _pathAdjust = _interopRequireDefault(requirePathAdjust());
  	var _pathCeil = _interopRequireDefault(requirePathCeil());
  	var _computeBoundingBox = requireComputeBoundingBox();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file glyf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Object} g glyf
  	 * @param {number} scaleX x
  	 * @param {number} scaleY y
  	 * @param {number} offsetX x
  	 * @param {number} offsetY y
  	 * @param {boolan} useCeil 
  	 *
  	 * @return {Object} glyf
  	 */
  	function glyfAdjust$1(g) {
  	  var scaleX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  	  var scaleY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  	  var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  	  var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  	  var useCeil = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;
  	  if (g.contours && g.contours.length) {
  	    if (scaleX !== 1 || scaleY !== 1) {
  	      g.contours.forEach(function (contour) {
  	        (0, _pathAdjust.default)(contour, scaleX, scaleY);
  	      });
  	    }
  	    if (offsetX !== 0 || offsetY !== 0) {
  	      g.contours.forEach(function (contour) {
  	        (0, _pathAdjust.default)(contour, 1, 1, offsetX, offsetY);
  	      });
  	    }
  	    if (false !== useCeil) {
  	      g.contours.forEach(function (contour) {
  	        (0, _pathCeil.default)(contour);
  	      });
  	    }
  	  }

  	  // xminxmaxyminymax
  	  var advanceWidth = g.advanceWidth;
  	  if (undefined === g.xMin || undefined === g.yMax || undefined === g.leftSideBearing || undefined === g.advanceWidth) {
  	    // 
  	    var bound;
  	    if (g.contours && g.contours.length) {
  	      // eslint-disable-next-line no-invalid-this
  	      bound = _computeBoundingBox.computePathBox.apply(this, g.contours);
  	    } else {
  	      bound = {
  	        x: 0,
  	        y: 0,
  	        width: 0,
  	        height: 0
  	      };
  	    }
  	    g.xMin = bound.x;
  	    g.xMax = bound.x + bound.width;
  	    g.yMin = bound.y;
  	    g.yMax = bound.y + bound.height;
  	    g.leftSideBearing = g.xMin;

  	    // advanceWidthxMax + abs(xMin)
  	    if (undefined !== advanceWidth) {
  	      g.advanceWidth = Math.round(advanceWidth * scaleX + offsetX);
  	    } else {
  	      g.advanceWidth = g.xMax + Math.abs(g.xMin);
  	    }
  	  } else {
  	    g.xMin = Math.round(g.xMin * scaleX + offsetX);
  	    g.xMax = Math.round(g.xMax * scaleX + offsetX);
  	    g.yMin = Math.round(g.yMin * scaleY + offsetY);
  	    g.yMax = Math.round(g.yMax * scaleY + offsetY);
  	    g.leftSideBearing = Math.round(g.leftSideBearing * scaleX + offsetX);
  	    g.advanceWidth = Math.round(advanceWidth * scaleX + offsetX);
  	  }
  	  return g;
  	}
  	return glyfAdjust;
  }

  var optimizettf = {};

  var reduceGlyf = {};

  var reducePath = {};

  var hasRequiredReducePath;

  function requireReducePath () {
  	if (hasRequiredReducePath) return reducePath;
  	hasRequiredReducePath = 1;

  	Object.defineProperty(reducePath, "__esModule", {
  	  value: true
  	});
  	reducePath.default = reducePath$1;
  	/**
  	 * @file path
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Object} prev 
  	 * @param {Object} p 
  	 * @param {Object} next 
  	 * @return {boolean}
  	 */
  	function redundant(prev, p, next) {
  	  // , 
  	  if ((p.onCurve && next.onCurve || !p.onCurve && !next.onCurve) && Math.pow(p.x - next.x, 2) + Math.pow(p.y - next.y, 2) <= 1) {
  	    return true;
  	  }

  	  //  
  	  if (p.onCurve && prev.onCurve && next.onCurve && Math.abs((next.y - p.y) * (prev.x - p.x) - (prev.y - p.y) * (next.x - p.x)) <= 0.001) {
  	    return true;
  	  }

  	  //  
  	  if (!p.onCurve && prev.onCurve && next.onCurve && Math.abs((next.y - p.y) * (prev.x - p.x) - (prev.y - p.y) * (next.x - p.x)) <= 0.001) {
  	    return true;
  	  }
  	  return false;
  	}

  	/**
  	 * glyf
  	 *
  	 * @param {Array} contour 
  	 * @return {Array} 
  	 */
  	function reducePath$1(contour) {
  	  if (!contour.length) {
  	    return contour;
  	  }
  	  var prev;
  	  var next;
  	  var p;
  	  for (var i = contour.length - 1, last = i; i >= 0; i--) {
  	    // 
  	    p = contour[i];
  	    next = i === last ? contour[0] : contour[i + 1];
  	    prev = i === 0 ? contour[last] : contour[i - 1];
  	    if (redundant(prev, p, next)) {
  	      contour.splice(i, 1);
  	      last--;
  	      continue;
  	    }
  	  }
  	  return contour;
  	}
  	return reducePath;
  }

  var hasRequiredReduceGlyf;

  function requireReduceGlyf () {
  	if (hasRequiredReduceGlyf) return reduceGlyf;
  	hasRequiredReduceGlyf = 1;

  	Object.defineProperty(reduceGlyf, "__esModule", {
  	  value: true
  	});
  	reduceGlyf.default = reduceGlyf$1;
  	var _reducePath = _interopRequireDefault(requireReducePath());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file glyf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * glyf
  	 *
  	 * @param {Object} glyf glyf
  	 * @return {Object} glyf
  	 */
  	function reduceGlyf$1(glyf) {
  	  var contours = glyf.contours;
  	  var contour;
  	  for (var j = contours.length - 1; j >= 0; j--) {
  	    contour = (0, _reducePath.default)(contours[j]);

  	    // 
  	    if (contour.length <= 2) {
  	      contours.splice(j, 1);
  	      continue;
  	    }
  	  }
  	  if (0 === glyf.contours.length) {
  	    delete glyf.contours;
  	  }
  	  return glyf;
  	}
  	return reduceGlyf;
  }

  var hasRequiredOptimizettf;

  function requireOptimizettf () {
  	if (hasRequiredOptimizettf) return optimizettf;
  	hasRequiredOptimizettf = 1;

  	Object.defineProperty(optimizettf, "__esModule", {
  	  value: true
  	});
  	optimizettf.default = optimizettf$1;
  	var _reduceGlyf = _interopRequireDefault(requireReduceGlyf());
  	var _pathCeil = _interopRequireDefault(requirePathCeil());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * ttf
  	 *
  	 * @param  {Object} ttf ttf
  	 * @return {true|Object} 
  	 */
  	function optimizettf$1(ttf) {
  	  var checkUnicodeRepeat = {}; // 
  	  var repeatList = [];
  	  ttf.glyf.forEach(function (glyf, index) {
  	    if (glyf.unicode) {
  	      glyf.unicode = glyf.unicode.sort();

  	      // glyf
  	      glyf.unicode.sort(function (a, b) {
  	        return a - b;
  	      }).forEach(function (u) {
  	        if (checkUnicodeRepeat[u]) {
  	          repeatList.push(index);
  	        } else {
  	          checkUnicodeRepeat[u] = true;
  	        }
  	      });
  	    }
  	    if (!glyf.compound && glyf.contours) {
  	      // 
  	      glyf.contours.forEach(function (contour) {
  	        (0, _pathCeil.default)(contour);
  	      });
  	      // glyf
  	      (0, _reduceGlyf.default)(glyf);
  	    }

  	    // 
  	    glyf.xMin = Math.round(glyf.xMin || 0);
  	    glyf.xMax = Math.round(glyf.xMax || 0);
  	    glyf.yMin = Math.round(glyf.yMin || 0);
  	    glyf.yMax = Math.round(glyf.yMax || 0);
  	    glyf.leftSideBearing = Math.round(glyf.leftSideBearing || 0);
  	    glyf.advanceWidth = Math.round(glyf.advanceWidth || 0);
  	  });

  	  // 
  	  if (!ttf.glyf.some(function (a) {
  	    return a.compound;
  	  })) {
  	    ttf.glyf = ttf.glyf.filter(function (glyf, index) {
  	      return index === 0 || glyf.contours && glyf.contours.length;
  	    });
  	  }
  	  if (!repeatList.length) {
  	    return true;
  	  }
  	  return {
  	    repeat: repeatList
  	  };
  	}
  	return optimizettf;
  }

  var hasRequiredTtf;

  function requireTtf () {
  	if (hasRequiredTtf) return ttf;
  	hasRequiredTtf = 1;

  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	Object.defineProperty(ttf, "__esModule", {
  	  value: true
  	});
  	ttf.default = void 0;
  	var _lang = requireLang();
  	var _string = _interopRequireDefault(requireString$1());
  	var _pathAdjust = _interopRequireDefault(requirePathAdjust());
  	var _pathCeil = _interopRequireDefault(requirePathCeil());
  	var _computeBoundingBox = requireComputeBoundingBox();
  	var _compound2simpleglyf = _interopRequireDefault(requireCompound2simpleglyf());
  	var _glyfAdjust = _interopRequireDefault(requireGlyfAdjust());
  	var _optimizettf = _interopRequireDefault(requireOptimizettf());
  	var _default = _interopRequireDefault(require_default());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
  	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
  	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
  	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/**
  	 * EM
  	 *
  	 * @param {Array} glyfList glyf
  	 * @param {number} ascent 
  	 * @param {number} descent 
  	 * @param {number} adjustToEmPadding  
  	 * @return {Array} glyfList
  	 */
  	function adjustToEmBox(glyfList, ascent, descent, adjustToEmPadding) {
  	  glyfList.forEach(function (g) {
  	    if (g.contours && g.contours.length) {
  	      var rightSideBearing = g.advanceWidth - g.xMax;
  	      var bound = _computeBoundingBox.computePath.apply(void 0, _toConsumableArray(g.contours));
  	      var scale = (ascent - descent - adjustToEmPadding) / bound.height;
  	      var center = (ascent + descent) / 2;
  	      var yOffset = center - (bound.y + bound.height / 2) * scale;
  	      g.contours.forEach(function (contour) {
  	        if (scale !== 1) {
  	          (0, _pathAdjust.default)(contour, scale, scale);
  	        }
  	        (0, _pathAdjust.default)(contour, 1, 1, 0, yOffset);
  	        (0, _pathCeil.default)(contour);
  	      });
  	      var box = _computeBoundingBox.computePathBox.apply(void 0, _toConsumableArray(g.contours));
  	      g.xMin = box.x;
  	      g.xMax = box.x + box.width;
  	      g.yMin = box.y;
  	      g.yMax = box.y + box.height;
  	      g.leftSideBearing = g.xMin;
  	      g.advanceWidth = g.xMax + rightSideBearing;
  	    }
  	  });
  	  return glyfList;
  	}

  	/**
  	 * 
  	 *
  	 * @param {Array} glyfList 
  	 * @param {number=} leftSideBearing 
  	 * @param {number=} rightSideBearing 
  	 * @param {number=} verticalAlign 
  	 *
  	 * @return {Array} 
  	 */
  	function adjustPos(glyfList, leftSideBearing, rightSideBearing, verticalAlign) {
  	  var changed = false;

  	  // 
  	  if (null != leftSideBearing) {
  	    changed = true;
  	    glyfList.forEach(function (g) {
  	      if (g.leftSideBearing !== leftSideBearing) {
  	        (0, _glyfAdjust.default)(g, 1, 1, leftSideBearing - g.leftSideBearing);
  	      }
  	    });
  	  }

  	  // 
  	  if (null != rightSideBearing) {
  	    changed = true;
  	    glyfList.forEach(function (g) {
  	      g.advanceWidth = g.xMax + rightSideBearing;
  	    });
  	  }

  	  // 
  	  if (null != verticalAlign) {
  	    changed = true;
  	    glyfList.forEach(function (g) {
  	      if (g.contours && g.contours.length) {
  	        var bound = _computeBoundingBox.computePath.apply(void 0, _toConsumableArray(g.contours));
  	        var offset = verticalAlign - bound.y;
  	        (0, _glyfAdjust.default)(g, 1, 1, 0, offset);
  	      }
  	    });
  	  }
  	  return changed ? glyfList : [];
  	}

  	/**
  	 * ttfObject
  	 *
  	 * @param {Object} ttf ttfObject
  	 * @param {Object} imported ttfObject
  	 * @param {Object} options 
  	 * @param {boolean} options.scale true
  	 * @param {boolean} options.adjustGlyf 
  	 *                                     ( options.scale )
  	 *
  	 * @return {Object} ttfObject
  	 */
  	function merge(ttf, imported) {
  	  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
  	    scale: true
  	  };
  	  var list = imported.glyf.filter(function (g) {
  	    return (
  	      // 
  	      g.contours && g.contours.length
  	      // 
  	      && g.name !== '.notdef' && g.name !== '.null' && g.name !== 'nonmarkingreturn'
  	    );
  	  });

  	  // 
  	  if (options.adjustGlyf) {
  	    var ascent = ttf.hhea.ascent;
  	    var descent = ttf.hhea.descent;
  	    var adjustToEmPadding = 16;
  	    adjustPos(list, 16, 16);
  	    adjustToEmBox(list, ascent, descent, adjustToEmPadding);
  	    list.forEach(function (g) {
  	      ttf.glyf.push(g);
  	    });
  	  }
  	  // unitsPerEm 
  	  else if (options.scale) {
  	    var scale = 1;

  	    // glyf
  	    if (imported.head.unitsPerEm && imported.head.unitsPerEm !== ttf.head.unitsPerEm) {
  	      scale = ttf.head.unitsPerEm / imported.head.unitsPerEm;
  	    }
  	    list.forEach(function (g) {
  	      (0, _glyfAdjust.default)(g, scale, scale);
  	      ttf.glyf.push(g);
  	    });
  	  }
  	  return list;
  	}
  	ttf.default = /*#__PURE__*/function () {
  	  /**
  	   * ttf
  	   *
  	   * @constructor
  	   * @param {Object} ttf ttf
  	   */
  	  function TTF(ttf) {
  	    _classCallCheck(this, TTF);
  	    this.ttf = ttf;
  	  }

  	  /**
  	   * 
  	   *
  	   * @return {Object} 
  	   */
  	  return _createClass(TTF, [{
  	    key: "codes",
  	    value: function codes() {
  	      return Object.keys(this.ttf.cmap);
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {string} c 
  	     *
  	     * @return {?number} glyf
  	     */
  	  }, {
  	    key: "getGlyfIndexByCode",
  	    value: function getGlyfIndexByCode(c) {
  	      var charCode = typeof c === 'number' ? c : c.codePointAt(0);
  	      var glyfIndex = this.ttf.cmap[charCode] || -1;
  	      return glyfIndex;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number} glyfIndex glyf
  	     *
  	     * @return {?Object} glyf
  	     */
  	  }, {
  	    key: "getGlyfByIndex",
  	    value: function getGlyfByIndex(glyfIndex) {
  	      var glyfList = this.ttf.glyf;
  	      var glyf = glyfList[glyfIndex];
  	      return glyf;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {string} c 
  	     *
  	     * @return {?Object} glyf
  	     */
  	  }, {
  	    key: "getGlyfByCode",
  	    value: function getGlyfByCode(c) {
  	      var glyfIndex = this.getGlyfIndexByCode(c);
  	      return this.getGlyfByIndex(glyfIndex);
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @param {Object} ttf ttf
  	     * @return {this}
  	     */
  	  }, {
  	    key: "set",
  	    value: function set(ttf) {
  	      this.ttf = ttf;
  	      return this;
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @return {ttfObject} ttf ttf
  	     */
  	  }, {
  	    key: "get",
  	    value: function get() {
  	      return this.ttf;
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Object} glyf glyf
  	     *
  	     * @return {number} glyf
  	     */
  	  }, {
  	    key: "addGlyf",
  	    value: function addGlyf(glyf) {
  	      return this.insertGlyf(glyf);
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Object} glyf glyf
  	     * @param {Object} insertIndex 
  	     * @return {number} glyf
  	     */
  	  }, {
  	    key: "insertGlyf",
  	    value: function insertGlyf(glyf, insertIndex) {
  	      if (insertIndex >= 0 && insertIndex < this.ttf.glyf.length) {
  	        this.ttf.glyf.splice(insertIndex, 0, glyf);
  	      } else {
  	        this.ttf.glyf.push(glyf);
  	      }
  	      return [glyf];
  	    }

  	    /**
  	     * ttfObject
  	     *
  	     * @param {Object} imported ttfObject
  	     * @param {Object} options 
  	     * @param {boolean} options.scale 
  	     * @param {boolean} options.adjustGlyf 
  	     *                                     ( options.scale )
  	     *
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "mergeGlyf",
  	    value: function mergeGlyf(imported, options) {
  	      var list = merge(this.ttf, imported, options);
  	      return list;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Array} indexList 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "removeGlyf",
  	    value: function removeGlyf(indexList) {
  	      var glyf = this.ttf.glyf;
  	      var removed = [];
  	      for (var i = glyf.length - 1; i >= 0; i--) {
  	        if (indexList.indexOf(i) >= 0) {
  	          removed.push(glyf[i]);
  	          glyf.splice(i, 1);
  	        }
  	      }
  	      return removed;
  	    }

  	    /**
  	     * unicode
  	     *
  	     * @param {string} unicode unicode $E021, $22
  	     * @param {Array=} indexList 
  	     * @param {boolean} isGenerateName name
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "setUnicode",
  	    value: function setUnicode(unicode, indexList, isGenerateName) {
  	      var glyf = this.ttf.glyf;
  	      var list = [];
  	      if (indexList && indexList.length) {
  	        var first = indexList.indexOf(0);
  	        if (first >= 0) {
  	          indexList.splice(first, 1);
  	        }
  	        list = indexList.map(function (item) {
  	          return glyf[item];
  	        });
  	      } else {
  	        list = glyf.slice(1);
  	      }

  	      //  unicode >32 glyf
  	      if (list.length > 1) {
  	        var less32 = function less32(u) {
  	          return u < 33;
  	        };
  	        list = list.filter(function (g) {
  	          return !g.unicode || !g.unicode.some(less32);
  	        });
  	      }
  	      if (list.length) {
  	        unicode = Number('0x' + unicode.slice(1));
  	        list.forEach(function (g) {
  	          //  nonmarkingreturn 
  	          if (unicode === 0xA0 || unicode === 0x3000) {
  	            unicode++;
  	          }
  	          g.unicode = [unicode];
  	          if (isGenerateName) {
  	            g.name = _string.default.getUnicodeName(unicode);
  	          }
  	          unicode++;
  	        });
  	      }
  	      return list;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Array=} indexList 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "genGlyfName",
  	    value: function genGlyfName(indexList) {
  	      var glyf = this.ttf.glyf;
  	      var list = [];
  	      if (indexList && indexList.length) {
  	        list = indexList.map(function (item) {
  	          return glyf[item];
  	        });
  	      } else {
  	        list = glyf;
  	      }
  	      if (list.length) {
  	        var first = this.ttf.glyf[0];
  	        list.forEach(function (g) {
  	          if (g === first) {
  	            g.name = '.notdef';
  	          } else if (g.unicode && g.unicode.length) {
  	            g.name = _string.default.getUnicodeName(g.unicode[0]);
  	          } else {
  	            g.name = '.notdef';
  	          }
  	        });
  	      }
  	      return list;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Array=} indexList 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "clearGlyfName",
  	    value: function clearGlyfName(indexList) {
  	      var glyf = this.ttf.glyf;
  	      var list = [];
  	      if (indexList && indexList.length) {
  	        list = indexList.map(function (item) {
  	          return glyf[item];
  	        });
  	      } else {
  	        list = glyf;
  	      }
  	      if (list.length) {
  	        list.forEach(function (g) {
  	          delete g.name;
  	        });
  	      }
  	      return list;
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Array} glyfList 
  	     * @param {Array=} indexList 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "appendGlyf",
  	    value: function appendGlyf(glyfList, indexList) {
  	      var glyf = this.ttf.glyf;
  	      var result = glyfList.slice(0);
  	      if (indexList && indexList.length) {
  	        var l = Math.min(glyfList.length, indexList.length);
  	        for (var i = 0; i < l; i++) {
  	          glyf[indexList[i]] = glyfList[i];
  	        }
  	        glyfList = glyfList.slice(l);
  	      }
  	      if (glyfList.length) {
  	        Array.prototype.splice.apply(glyf, [glyf.length, 0].concat(_toConsumableArray(glyfList)));
  	      }
  	      return result;
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Array=} indexList 
  	     * @param {Object} setting 
  	     * @param {number=} setting.leftSideBearing 
  	     * @param {number=} setting.rightSideBearing 
  	     * @param {number=} setting.verticalAlign 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "adjustGlyfPos",
  	    value: function adjustGlyfPos(indexList, setting) {
  	      var glyfList = this.getGlyf(indexList);
  	      return adjustPos(glyfList, setting.leftSideBearing, setting.rightSideBearing, setting.verticalAlign);
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Array=} indexList 
  	     * @param {Object} setting 
  	     * @param {boolean=} setting.reverse 
  	     * @param {boolean=} setting.mirror 
  	     * @param {number=} setting.scale 
  	     * @param {boolean=} setting.adjustToEmBox   em 
  	     * @param {number=} setting.adjustToEmPadding  em 
  	     * @return {boolean}
  	     */
  	  }, {
  	    key: "adjustGlyf",
  	    value: function adjustGlyf(indexList, setting) {
  	      var glyfList = this.getGlyf(indexList);
  	      var changed = false;
  	      setting.adjustToEmBox = setting.ajdustToEmBox || setting.adjustToEmBox;
  	      setting.adjustToEmPadding = setting.ajdustToEmPadding || setting.adjustToEmPadding;
  	      if (setting.reverse || setting.mirror) {
  	        changed = true;
  	        glyfList.forEach(function (g) {
  	          if (g.contours && g.contours.length) {
  	            var offsetX = g.xMax + g.xMin;
  	            var offsetY = g.yMax + g.yMin;
  	            g.contours.forEach(function (contour) {
  	              (0, _pathAdjust.default)(contour, setting.mirror ? -1 : 1, setting.reverse ? -1 : 1);
  	              (0, _pathAdjust.default)(contour, 1, 1, setting.mirror ? offsetX : 0, setting.reverse ? offsetY : 0);
  	            });
  	          }
  	        });
  	      }
  	      if (setting.scale && setting.scale !== 1) {
  	        changed = true;
  	        var scale = setting.scale;
  	        glyfList.forEach(function (g) {
  	          if (g.contours && g.contours.length) {
  	            (0, _glyfAdjust.default)(g, scale, scale);
  	          }
  	        });
  	      }
  	      // embox
  	      else if (setting.adjustToEmBox) {
  	        changed = true;
  	        var ascent = this.ttf.hhea.ascent;
  	        var descent = this.ttf.hhea.descent;
  	        var adjustToEmPadding = 2 * (setting.adjustToEmPadding || 0);
  	        adjustToEmBox(glyfList, ascent, descent, adjustToEmPadding);
  	      }
  	      return changed ? glyfList : [];
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Array=} indexList 
  	     * @return {Array} glyflist
  	     */
  	  }, {
  	    key: "getGlyf",
  	    value: function getGlyf(indexList) {
  	      var glyf = this.ttf.glyf;
  	      if (indexList && indexList.length) {
  	        return indexList.map(function (item) {
  	          return glyf[item];
  	        });
  	      }
  	      return glyf;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param  {Object} condition 
  	     * @param  {Array|number} condition.unicode unicodeunicode
  	     * @param  {string} condition.name glyf`uniE001`, `uniE`
  	     * @param  {Function} condition.filter 
  	     * @example
  	     *     condition.filter = function (glyf) {
  	     *         return glyf.name === 'logo';
  	     *     }
  	     * @return {Array}  glyf
  	     */
  	  }, {
  	    key: "findGlyf",
  	    value: function findGlyf(condition) {
  	      if (!condition) {
  	        return [];
  	      }
  	      var filters = [];

  	      // unicode
  	      if (condition.unicode) {
  	        var unicodeList = Array.isArray(condition.unicode) ? condition.unicode : [condition.unicode];
  	        var unicodeHash = {};
  	        unicodeList.forEach(function (unicode) {
  	          if (typeof unicode === 'string') {
  	            unicode = Number('0x' + unicode.slice(1));
  	          }
  	          unicodeHash[unicode] = true;
  	        });
  	        filters.push(function (glyf) {
  	          if (!glyf.unicode || !glyf.unicode.length) {
  	            return false;
  	          }
  	          for (var i = 0, l = glyf.unicode.length; i < l; i++) {
  	            if (unicodeHash[glyf.unicode[i]]) {
  	              return true;
  	            }
  	          }
  	        });
  	      }

  	      // 
  	      if (condition.name) {
  	        var name = condition.name;
  	        filters.push(function (glyf) {
  	          return glyf.name && glyf.name.indexOf(name) === 0;
  	        });
  	      }

  	      // 
  	      if (typeof condition.filter === 'function') {
  	        filters.push(condition.filter);
  	      }
  	      var indexList = [];
  	      this.ttf.glyf.forEach(function (glyf, index) {
  	        for (var filterIndex = 0, filter; filter = filters[filterIndex++];) {
  	          if (true === filter(glyf)) {
  	            indexList.push(index);
  	            break;
  	          }
  	        }
  	      });
  	      return indexList;
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Object} glyf glyfobject
  	     * @param {string} index 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "replaceGlyf",
  	    value: function replaceGlyf(glyf, index) {
  	      if (index >= 0 && index < this.ttf.glyf.length) {
  	        this.ttf.glyf[index] = glyf;
  	        return [glyf];
  	      }
  	      return [];
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Array} glyfList glyf
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "setGlyf",
  	    value: function setGlyf(glyfList) {
  	      delete this.glyf;
  	      this.ttf.glyf = glyfList || [];
  	      return this.ttf.glyf;
  	    }

  	    /**
  	     * unicode, 
  	     *
  	     * @param {Array} glyfList glyf
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "sortGlyf",
  	    value: function sortGlyf() {
  	      var glyf = this.ttf.glyf;
  	      if (glyf.length > 1) {
  	        // 
  	        if (glyf.some(function (a) {
  	          return a.compound;
  	        })) {
  	          return -2;
  	        }
  	        var notdef = glyf.shift();
  	        // , unicode
  	        glyf.sort(function (a, b) {
  	          if ((!a.unicode || !a.unicode.length) && (!b.unicode || !b.unicode.length)) {
  	            return 0;
  	          } else if ((!a.unicode || !a.unicode.length) && b.unicode) {
  	            return 1;
  	          } else if (a.unicode && (!b.unicode || !b.unicode.length)) {
  	            return -1;
  	          }
  	          return Math.min.apply(null, a.unicode) - Math.min.apply(null, b.unicode);
  	        });
  	        glyf.unshift(notdef);
  	        return glyf;
  	      }
  	      return -1;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {string} name 
  	     * @return {Object} 
  	     */
  	  }, {
  	    key: "setName",
  	    value: function setName(name) {
  	      if (name) {
  	        this.ttf.name.fontFamily = this.ttf.name.fullName = name.fontFamily || _default.default.name.fontFamily;
  	        this.ttf.name.fontSubFamily = name.fontSubFamily || _default.default.name.fontSubFamily;
  	        this.ttf.name.uniqueSubFamily = name.uniqueSubFamily || '';
  	        this.ttf.name.postScriptName = name.postScriptName || '';
  	      }
  	      return this.ttf.name;
  	    }

  	    /**
  	     * head
  	     *
  	     * @param {Object} head 
  	     * @return {Object} 
  	     */
  	  }, {
  	    key: "setHead",
  	    value: function setHead(head) {
  	      if (head) {
  	        // unitsperem
  	        if (head.unitsPerEm && head.unitsPerEm >= 64 && head.unitsPerEm <= 16384) {
  	          this.ttf.head.unitsPerEm = head.unitsPerEm;
  	        }

  	        // lowestrecppem
  	        if (head.lowestRecPPEM && head.lowestRecPPEM >= 8 && head.lowestRecPPEM <= 16384) {
  	          this.ttf.head.lowestRecPPEM = head.lowestRecPPEM;
  	        }
  	        // created
  	        if (head.created) {
  	          this.ttf.head.created = head.created;
  	        }
  	        if (head.modified) {
  	          this.ttf.head.modified = head.modified;
  	        }
  	      }
  	      return this.ttf.head;
  	    }

  	    /**
  	     * hhea
  	     *
  	     * @param {Object} fields 
  	     * @return {Object} 
  	     */
  	  }, {
  	    key: "setHhea",
  	    value: function setHhea(fields) {
  	      (0, _lang.overwrite)(this.ttf.hhea, fields, ['ascent', 'descent', 'lineGap']);
  	      return this.ttf.hhea;
  	    }

  	    /**
  	     * OS2
  	     *
  	     * @param {Object} fields 
  	     * @return {Object} 
  	     */
  	  }, {
  	    key: "setOS2",
  	    value: function setOS2(fields) {
  	      (0, _lang.overwrite)(this.ttf['OS/2'], fields, ['usWinAscent', 'usWinDescent', 'sTypoAscender', 'sTypoDescender', 'sTypoLineGap', 'sxHeight', 'bXHeight', 'usWeightClass', 'usWidthClass', 'yStrikeoutPosition', 'yStrikeoutSize', 'achVendID',
  	      // panose
  	      'bFamilyType', 'bSerifStyle', 'bWeight', 'bProportion', 'bContrast', 'bStrokeVariation', 'bArmStyle', 'bLetterform', 'bMidline', 'bXHeight']);
  	      return this.ttf['OS/2'];
  	    }

  	    /**
  	     * post
  	     *
  	     * @param {Object} fields 
  	     * @return {Object} 
  	     */
  	  }, {
  	    key: "setPost",
  	    value: function setPost(fields) {
  	      (0, _lang.overwrite)(this.ttf.post, fields, ['underlinePosition', 'underlineThickness']);
  	      return this.ttf.post;
  	    }

  	    /**
  	     * 
  	     *
  	     * @return {Object} 
  	     */
  	  }, {
  	    key: "calcMetrics",
  	    value: function calcMetrics() {
  	      var ascent = -16384;
  	      var descent = 16384;
  	      var uX = 0x78;
  	      var uH = 0x48;
  	      var sxHeight;
  	      var sCapHeight;
  	      this.ttf.glyf.forEach(function (g) {
  	        if (g.yMax > ascent) {
  	          ascent = g.yMax;
  	        }
  	        if (g.yMin < descent) {
  	          descent = g.yMin;
  	        }
  	        if (g.unicode) {
  	          if (g.unicode.indexOf(uX) >= 0) {
  	            sxHeight = g.yMax;
  	          }
  	          if (g.unicode.indexOf(uH) >= 0) {
  	            sCapHeight = g.yMax;
  	          }
  	        }
  	      });
  	      ascent = Math.round(ascent);
  	      descent = Math.round(descent);
  	      return {
  	        // 
  	        ascent: ascent,
  	        descent: descent,
  	        sTypoAscender: ascent,
  	        sTypoDescender: descent,
  	        // 
  	        usWinAscent: ascent,
  	        usWinDescent: -descent,
  	        sxHeight: sxHeight || 0,
  	        sCapHeight: sCapHeight || 0
  	      };
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "optimize",
  	    value: function optimize() {
  	      return (0, _optimizettf.default)(this.ttf);
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Array=} indexList 
  	     * @return {Array} glyf
  	     */
  	  }, {
  	    key: "compound2simple",
  	    value: function compound2simple(indexList) {
  	      var ttf = this.ttf;
  	      if (ttf.maxp && !ttf.maxp.maxComponentElements) {
  	        return [];
  	      }
  	      var i;
  	      var l;
  	      // compound glyf
  	      if (!indexList || !indexList.length) {
  	        indexList = [];
  	        for (i = 0, l = ttf.glyf.length; i < l; ++i) {
  	          if (ttf.glyf[i].compound) {
  	            indexList.push(i);
  	          }
  	        }
  	      }
  	      var list = [];
  	      for (i = 0, l = indexList.length; i < l; ++i) {
  	        var glyfIndex = indexList[i];
  	        if (ttf.glyf[glyfIndex] && ttf.glyf[glyfIndex].compound) {
  	          (0, _compound2simpleglyf.default)(glyfIndex, ttf, true);
  	          list.push(ttf.glyf[glyfIndex]);
  	        }
  	      }
  	      return list;
  	    }
  	  }]);
  	}();
  	return ttf;
  }

  var woff2ttf = {};

  var reader = {};

  var error = {};

  var string = {};

  var hasRequiredString;

  function requireString () {
  	if (hasRequiredString) return string;
  	hasRequiredString = 1;

  	Object.defineProperty(string, "__esModule", {
  	  value: true
  	});
  	string.default = void 0;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	string.default = {
  	  /**
  	   * HTML
  	   *
  	   * @param {string} source 
  	   * @return {string}
  	   */
  	  decodeHTML: function decodeHTML(source) {
  	    var str = String(source).replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&amp;/g, '&');

  	    // 
  	    return str.replace(/&#([\d]+);/g, function ($0, $1) {
  	      return String.fromCodePoint(parseInt($1, 10));
  	    });
  	  },
  	  /**
  	   * HTML
  	   *
  	   * @param {string} source 
  	   * @return {string}
  	   */
  	  encodeHTML: function encodeHTML(source) {
  	    return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  	  },
  	  /**
  	   * string
  	   *
  	   * @param {string} source 
  	   * @return {number} 
  	   */
  	  getLength: function getLength(source) {
  	    // eslint-disable-next-line no-control-regex
  	    return String(source).replace(/[^\x00-\xff]/g, '11').length;
  	  },
  	  /**
  	   *  ${xxx.xxx} 
  	   *
  	   * @param {string} source 
  	   * @param {Object} data 
  	   * @return {string} 
  	   */
  	  format: function format(source, data) {
  	    return source.replace(/\$\{([\w.]+)\}/g, function ($0, $1) {
  	      var ref = $1.split('.');
  	      var refObject = data;
  	      var level;
  	      while (refObject != null && (level = ref.shift())) {
  	        refObject = refObject[level];
  	      }
  	      return refObject != null ? refObject : '';
  	    });
  	  },
  	  /**
  	   * ,`0`
  	   *
  	   * @param {string} str 
  	   * @param {number} size 
  	   * @param {string=} ch 
  	   * @return {string} 
  	   */
  	  pad: function pad(str, size, ch) {
  	    str = String(str);
  	    if (str.length > size) {
  	      return str.slice(str.length - size);
  	    }
  	    return new Array(size - str.length + 1).join(ch || '0') + str;
  	  },
  	  /**
  	   * 
  	   *
  	   * @param {string} str 
  	   * @return {number} 
  	   */
  	  hashcode: function hashcode(str) {
  	    if (!str) {
  	      return 0;
  	    }
  	    var hash = 0;
  	    for (var i = 0, l = str.length; i < l; i++) {
  	      hash = 0x7FFFFFFFF & hash * 31 + str.charCodeAt(i);
  	    }
  	    return hash;
  	  }
  	};
  	return string;
  }

  var i18n = {};

  var I18n = {};

  var hasRequiredI18n$1;

  function requireI18n$1 () {
  	if (hasRequiredI18n$1) return I18n;
  	hasRequiredI18n$1 = 1;

  	Object.defineProperty(I18n, "__esModule", {
  	  value: true
  	});
  	I18n.default = void 0;
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	function appendLanguage(store, languageList) {
  	  languageList.forEach(function (item) {
  	    var language = item[0];
  	    store[language] = Object.assign(store[language] || {}, item[1]);
  	  });
  	  return store;
  	}

  	/**
  	 * lang
  	 *
  	 * @class I18n
  	 * @param {Array} languageList 
  	 * @param {string=} defaultLanguage 
  	 * languageList = [
  	 *     'en-us', // 
  	 *     langObject // 
  	 * ]
  	 */
  	I18n.default = /*#__PURE__*/function () {
  	  function I18n(languageList, defaultLanguage) {
  	    _classCallCheck(this, I18n);
  	    this.store = appendLanguage({}, languageList);
  	    this.setLanguage(defaultLanguage || typeof navigator !== 'undefined' && navigator.language && navigator.language.toLowerCase() || 'en-us');
  	  }

  	  /**
  	   * 
  	   *
  	   * @param {string} language 
  	   * @return {this}
  	   */
  	  return _createClass(I18n, [{
  	    key: "setLanguage",
  	    value: function setLanguage(language) {
  	      if (!this.store[language]) {
  	        language = 'en-us';
  	      }
  	      this.lang = this.store[this.language = language];
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {string} language 
  	     * @param {Object} langObject 
  	     * @return {this}
  	     */
  	  }, {
  	    key: "addLanguage",
  	    value: function addLanguage(language, langObject) {
  	      appendLanguage(this.store, [[language, langObject]]);
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param  {string} path 
  	     * @return {string}      
  	     */
  	  }, {
  	    key: "get",
  	    value: function get(path) {
  	      var ref = path.split('.');
  	      var refObject = this.lang;
  	      var level;
  	      while (refObject != null && (level = ref.shift())) {
  	        refObject = refObject[level];
  	      }
  	      return refObject != null ? refObject : '';
  	    }
  	  }]);
  	}();
  	return I18n;
  }

  var hasRequiredI18n;

  function requireI18n () {
  	if (hasRequiredI18n) return i18n;
  	hasRequiredI18n = 1;

  	Object.defineProperty(i18n, "__esModule", {
  	  value: true
  	});
  	i18n.default = void 0;
  	var _I18n = _interopRequireDefault(requireI18n$1());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var zh = {
  	  // error define
  	  10001: '${0}, ${1}',
  	  10002: '${0}, ${1}',
  	  10003: '${0}, ${1}',
  	  10004: 'svg',
  	  10101: 'ttf',
  	  10102: 'woff',
  	  10103: 'svg',
  	  10104: 'ttf',
  	  10105: 'woff',
  	  10106: 'svg',
  	  10107: 'ttf',
  	  10108: 'woff',
  	  10109: 'svg',
  	  10112: 'svg symbol ',
  	  10110: 'eot',
  	  10111: 'eot',
  	  10200: 'unicode${0}',
  	  10201: 'ttf',
  	  10202: 'ARGS_ARE_XY_VALUES',
  	  10203: '${0}',
  	  10204: 'ttf',
  	  10205: '',
  	  10301: 'otf',
  	  10302: 'otf',
  	  10303: 'otf'
  	};
  	var en = {
  	  // error define
  	  10001: 'Reading index out of range: ${0}, ${1}',
  	  10002: 'Writing index out of range: ${0}, ${1}',
  	  10003: 'Unknown datatype: ${0}, ${1}',
  	  10004: 'No svg parser',
  	  10101: 'ttf file damaged',
  	  10102: 'woff file damaged',
  	  10103: 'svg file damaged',
  	  10104: 'Read ttf error',
  	  10105: 'Read woff error',
  	  10106: 'Read svg error',
  	  10107: 'Write ttf error',
  	  10108: 'Write woff error',
  	  10109: 'Write svg error',
  	  10112: 'Write svg symbol error',
  	  10110: 'Read eot error',
  	  10111: 'Write eot error',
  	  10200: 'Repeat unicode, glyph index: ${0}',
  	  10201: 'ttf `glyph` data is empty',
  	  10202: 'Not support compound glyph flag: ARGS_ARE_XY_VALUES',
  	  10203: 'No ttf table: ${0}',
  	  10204: 'Read ttf table data error',
  	  10205: 'No zip deflate function',
  	  10301: 'otf file damaged',
  	  10302: 'Read otf table error',
  	  10303: 'otf `glyph` data is empty'
  	};
  	i18n.default = new _I18n.default([['zh-cn', zh], ['en-us', en]], typeof window !== 'undefined' ? window.language : 'en-us');
  	return i18n;
  }

  var hasRequiredError;

  function requireError () {
  	if (hasRequiredError) return error;
  	hasRequiredError = 1;

  	Object.defineProperty(error, "__esModule", {
  	  value: true
  	});
  	error.default = void 0;
  	var _string = _interopRequireDefault(requireString());
  	var _i18n = _interopRequireDefault(requireI18n());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } /**
  	 * @file ttf 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	error.default = {
  	  /**
  	   * 
  	   *
  	   * @param  {Object} e 
  	   * @param  {...Array} fargs args 
  	   *
  	   * 
  	   * e = 1001
  	   * e = {
  	   *     number: 1001,
  	   *     data: 
  	   * }
  	   */
  	  raise: function raise(e) {
  	    var number;
  	    var data;
  	    if (_typeof(e) === 'object') {
  	      number = e.number || 0;
  	      data = e.data;
  	    } else {
  	      number = e;
  	    }
  	    var message = _i18n.default.lang[number];
  	    for (var _len = arguments.length, fargs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
  	      fargs[_key - 1] = arguments[_key];
  	    }
  	    if (fargs.length > 0) {
  	      var args = _typeof(fargs[0]) === 'object' ? fargs[0] : fargs;
  	      message = _string.default.format(message, args);
  	    }
  	    var event = new Error(message);
  	    event.number = number;
  	    if (data) {
  	      event.data = data;
  	    }
  	    throw event;
  	  }
  	};
  	return error;
  }

  var hasRequiredReader;

  function requireReader () {
  	if (hasRequiredReader) return reader;
  	hasRequiredReader = 1;

  	Object.defineProperty(reader, "__esModule", {
  	  value: true
  	});
  	reader.default = void 0;
  	var _lang = requireLang();
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
  	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
  	function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
  	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * thanks to
  	 * ynakajima/ttf.js
  	 * https://github.com/ynakajima/ttf.js
  	 */
  	// 
  	if (typeof ArrayBuffer === 'undefined' || typeof DataView === 'undefined') {
  	  throw new Error('not support ArrayBuffer and DataView');
  	}

  	// 
  	var dataType = {
  	  Int8: 1,
  	  Int16: 2,
  	  Int32: 4,
  	  Uint8: 1,
  	  Uint16: 2,
  	  Uint32: 4,
  	  Float32: 4,
  	  Float64: 8
  	};
  	var Reader = reader.default = /*#__PURE__*/function () {
  	  /**
  	   * 
  	   *
  	   * @constructor
  	   * @param {Array.<byte>} buffer 
  	   * @param {number} offset 
  	   * @param {number} length 
  	   * @param {boolean} littleEndian 
  	   */
  	  function Reader(buffer, offset, length, littleEndian) {
  	    _classCallCheck(this, Reader);
  	    var bufferLength = buffer.byteLength || buffer.length;
  	    this.offset = offset || 0;
  	    this.length = length || bufferLength - this.offset;
  	    this.littleEndian = littleEndian || false;
  	    this.view = new DataView(buffer, this.offset, this.length);
  	  }

  	  /**
  	   * 
  	   *
  	   * @param {string} type 
  	   * @param {number=} offset 
  	   * @param {boolean=} littleEndian 
  	   * @return {number} 
  	   */
  	  return _createClass(Reader, [{
  	    key: "read",
  	    value: function read(type, offset, littleEndian) {
  	      // 
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }

  	      // 
  	      if (undefined === littleEndian) {
  	        littleEndian = this.littleEndian;
  	      }

  	      // 
  	      if (undefined === dataType[type]) {
  	        return this['read' + type](offset, littleEndian);
  	      }
  	      var size = dataType[type];
  	      this.offset = offset + size;
  	      return this.view['get' + type](offset, littleEndian);
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number} offset 
  	     * @param {number} length 
  	     * @return {Array} 
  	     */
  	  }, {
  	    key: "readBytes",
  	    value: function readBytes(offset) {
  	      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  	      if (length == null) {
  	        length = offset;
  	        offset = this.offset;
  	      }
  	      if (length < 0 || offset + length > this.length) {
  	        _error.default.raise(10001, this.length, offset + length);
  	      }
  	      var buffer = [];
  	      for (var i = 0; i < length; ++i) {
  	        buffer.push(this.view.getUint8(offset + i));
  	      }
  	      this.offset = offset + length;
  	      return buffer;
  	    }

  	    /**
  	     * string
  	     *
  	     * @param {number} offset 
  	     * @param {number} length 
  	     * @return {string} 
  	     */
  	  }, {
  	    key: "readString",
  	    value: function readString(offset) {
  	      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  	      if (length == null) {
  	        length = offset;
  	        offset = this.offset;
  	      }
  	      if (length < 0 || offset + length > this.length) {
  	        _error.default.raise(10001, this.length, offset + length);
  	      }
  	      var value = '';
  	      for (var i = 0; i < length; ++i) {
  	        var c = this.readUint8(offset + i);
  	        value += String.fromCharCode(c);
  	      }
  	      this.offset = offset + length;
  	      return value;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number} offset 
  	     * @return {string} 
  	     */
  	  }, {
  	    key: "readChar",
  	    value: function readChar(offset) {
  	      return this.readString(offset, 1);
  	    }

  	    /**
  	     * uint24
  	     *
  	     * @param {number} offset 
  	     * @return {number}
  	     */
  	  }, {
  	    key: "readUint24",
  	    value: function readUint24(offset) {
  	      var _this$readBytes = this.readBytes(offset || this.offset, 3),
  	        _this$readBytes2 = _slicedToArray(_this$readBytes, 3),
  	        i = _this$readBytes2[0],
  	        j = _this$readBytes2[1],
  	        k = _this$readBytes2[2];
  	      return (i << 16) + (j << 8) + k;
  	    }

  	    /**
  	     * fixed
  	     *
  	     * @param {number} offset 
  	     * @return {number} float
  	     */
  	  }, {
  	    key: "readFixed",
  	    value: function readFixed(offset) {
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }
  	      var val = this.readInt32(offset, false) / 65536.0;
  	      return Math.ceil(val * 100000) / 100000;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number} offset 
  	     * @return {Date} Date
  	     */
  	  }, {
  	    key: "readLongDateTime",
  	    value: function readLongDateTime(offset) {
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }

  	      // new Date(1970, 1, 1).getTime() - new Date(1904, 1, 1).getTime();
  	      var delta = -2077545600000;
  	      var time = this.readUint32(offset + 4, false);
  	      var date = new Date();
  	      date.setTime(time * 1000 + delta);
  	      return date;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number} offset 
  	     * @return {Object} this
  	     */
  	  }, {
  	    key: "seek",
  	    value: function seek(offset) {
  	      if (undefined === offset) {
  	        this.offset = 0;
  	      }
  	      if (offset < 0 || offset > this.length) {
  	        _error.default.raise(10001, this.length, offset);
  	      }
  	      this.offset = offset;
  	      return this;
  	    }

  	    /**
  	     * 
  	     */
  	  }, {
  	    key: "dispose",
  	    value: function dispose() {
  	      delete this.view;
  	    }
  	  }]);
  	}(); // 
  	Object.keys(dataType).forEach(function (type) {
  	  Reader.prototype['read' + type] = (0, _lang.curry)(Reader.prototype.read, type);
  	});
  	return reader;
  }

  var writer = {};

  var hasRequiredWriter;

  function requireWriter () {
  	if (hasRequiredWriter) return writer;
  	hasRequiredWriter = 1;

  	Object.defineProperty(writer, "__esModule", {
  	  value: true
  	});
  	writer.default = void 0;
  	var _lang = requireLang();
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	// 
  	if (typeof ArrayBuffer === 'undefined' || typeof DataView === 'undefined') {
  	  throw new Error('not support ArrayBuffer and DataView');
  	}

  	// 
  	var dataType = {
  	  Int8: 1,
  	  Int16: 2,
  	  Int32: 4,
  	  Uint8: 1,
  	  Uint16: 2,
  	  Uint32: 4,
  	  Float32: 4,
  	  Float64: 8
  	};

  	/**
  	 * 
  	 *
  	 * @constructor
  	 * @param {Array.<byte>} buffer 
  	 * @param {number} offset 
  	 * @param {number=} length 
  	 * @param {boolean=} littleEndian 
  	 */
  	var Writer = /*#__PURE__*/function () {
  	  function Writer(buffer, offset, length, littleEndian) {
  	    _classCallCheck(this, Writer);
  	    var bufferLength = buffer.byteLength || buffer.length;
  	    this.offset = offset || 0;
  	    this.length = length || bufferLength - this.offset;
  	    this.littleEndian = littleEndian || false;
  	    this.view = new DataView(buffer, this.offset, this.length);
  	  }

  	  /**
  	   * 
  	   *
  	   * @param {string} type 
  	   * @param {number} value value
  	   * @param {number=} offset 
  	   * @param {boolean=} littleEndian 
  	   *
  	   * @return {this}
  	   */
  	  return _createClass(Writer, [{
  	    key: "write",
  	    value: function write(type, value, offset, littleEndian) {
  	      // 
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }

  	      // 
  	      if (undefined === littleEndian) {
  	        littleEndian = this.littleEndian;
  	      }

  	      // 
  	      if (undefined === dataType[type]) {
  	        return this['write' + type](value, offset, littleEndian);
  	      }
  	      var size = dataType[type];
  	      this.offset = offset + size;
  	      this.view['set' + type](offset, value, littleEndian);
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {ArrayBuffer} value 
  	     * @param {number=} length 
  	     * @param {number=} offset 
  	     * @return {this}
  	     */
  	  }, {
  	    key: "writeBytes",
  	    value: function writeBytes(value, length, offset) {
  	      length = length || value.byteLength || value.length;
  	      var i;
  	      if (!length) {
  	        return this;
  	      }
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }
  	      if (length < 0 || offset + length > this.length) {
  	        _error.default.raise(10002, this.length, offset + length);
  	      }
  	      var littleEndian = this.littleEndian;
  	      if (value instanceof ArrayBuffer) {
  	        var view = new DataView(value, 0, length);
  	        for (i = 0; i < length; ++i) {
  	          this.view.setUint8(offset + i, view.getUint8(i, littleEndian), littleEndian);
  	        }
  	      } else {
  	        for (i = 0; i < length; ++i) {
  	          this.view.setUint8(offset + i, value[i], littleEndian);
  	        }
  	      }
  	      this.offset = offset + length;
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number} length 
  	     * @param {number=} offset 
  	     * @return {this}
  	     */
  	  }, {
  	    key: "writeEmpty",
  	    value: function writeEmpty(length, offset) {
  	      if (length < 0) {
  	        _error.default.raise(10002, this.length, length);
  	      }
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }
  	      var littleEndian = this.littleEndian;
  	      for (var i = 0; i < length; ++i) {
  	        this.view.setUint8(offset + i, 0, littleEndian);
  	      }
  	      this.offset = offset + length;
  	      return this;
  	    }

  	    /**
  	     * string
  	     *
  	     * @param {string} str 
  	     * @param {number=} length 
  	     * @param {number=} offset 
  	     *
  	     * @return {this}
  	     */
  	  }, {
  	    key: "writeString",
  	    value: function writeString() {
  	      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  	      var length = arguments.length > 1 ? arguments[1] : undefined;
  	      var offset = arguments.length > 2 ? arguments[2] : undefined;
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }

  	      // eslint-disable-next-line no-control-regex
  	      length = length || str.replace(/[^\x00-\xff]/g, '11').length;
  	      if (length < 0 || offset + length > this.length) {
  	        _error.default.raise(10002, this.length, offset + length);
  	      }
  	      this.seek(offset);
  	      for (var i = 0, l = str.length, charCode; i < l; ++i) {
  	        charCode = str.charCodeAt(i) || 0;
  	        if (charCode > 127) {
  	          // unicode2,
  	          // 
  	          this.writeUint16(charCode);
  	        } else {
  	          this.writeUint8(charCode);
  	        }
  	      }
  	      this.offset = offset + length;
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {string} value 
  	     * @param {number=} offset 
  	     * @return {this}
  	     */
  	  }, {
  	    key: "writeChar",
  	    value: function writeChar(value, offset) {
  	      return this.writeString(value, offset);
  	    }

  	    /**
  	     * fixed
  	     *
  	     * @param {number} value 
  	     * @param {number=} offset 
  	     * @return {number} float
  	     */
  	  }, {
  	    key: "writeFixed",
  	    value: function writeFixed(value, offset) {
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }
  	      this.writeInt32(Math.round(value * 65536), offset);
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Date} value 
  	     * @param {number=} offset 
  	     *
  	     * @return {Date} Date
  	     */
  	  }, {
  	    key: "writeLongDateTime",
  	    value: function writeLongDateTime(value, offset) {
  	      if (undefined === offset) {
  	        offset = this.offset;
  	      }

  	      // new Date(1970, 1, 1).getTime() - new Date(1904, 1, 1).getTime();
  	      var delta = -2077545600000;
  	      if (typeof value === 'undefined') {
  	        value = delta;
  	      } else if (typeof value.getTime === 'function') {
  	        value = value.getTime();
  	      } else if (/^\d+$/.test(value)) {
  	        value = +value;
  	      } else {
  	        value = Date.parse(value);
  	      }
  	      var time = Math.round((value - delta) / 1000);
  	      this.writeUint32(0, offset);
  	      this.writeUint32(time, offset + 4);
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {number=} offset 
  	     * @return {this}
  	     */
  	  }, {
  	    key: "seek",
  	    value: function seek(offset) {
  	      if (undefined === offset) {
  	        this.offset = 0;
  	      }
  	      if (offset < 0 || offset > this.length) {
  	        _error.default.raise(10002, this.length, offset);
  	      }
  	      this._offset = this.offset;
  	      this.offset = offset;
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @return {this}
  	     */
  	  }, {
  	    key: "head",
  	    value: function head() {
  	      this.offset = this._offset || 0;
  	      return this;
  	    }

  	    /**
  	     * byte
  	     *
  	     * @return {ArrayBuffer}
  	     */
  	  }, {
  	    key: "getBuffer",
  	    value: function getBuffer() {
  	      return this.view.buffer;
  	    }

  	    /**
  	     * 
  	     */
  	  }, {
  	    key: "dispose",
  	    value: function dispose() {
  	      delete this.view;
  	    }
  	  }]);
  	}(); // 
  	Object.keys(dataType).forEach(function (type) {
  	  Writer.prototype['write' + type] = (0, _lang.curry)(Writer.prototype.write, type);
  	});
  	writer.default = Writer;
  	return writer;
  }

  var hasRequiredWoff2ttf;

  function requireWoff2ttf () {
  	if (hasRequiredWoff2ttf) return woff2ttf;
  	hasRequiredWoff2ttf = 1;

  	Object.defineProperty(woff2ttf, "__esModule", {
  	  value: true
  	});
  	woff2ttf.default = woff2ttf$1;
  	var _reader = _interopRequireDefault(requireReader());
  	var _writer = _interopRequireDefault(requireWriter());
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file woffttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * woffttf
  	 *
  	 * @param {ArrayBuffer} woffBuffer woff
  	 * @param {Object} options 
  	 * @param {Object} options.inflate 
  	 *
  	 * @return {ArrayBuffer} ttfbyte
  	 */
  	function woff2ttf$1(woffBuffer) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  var reader = new _reader.default(woffBuffer);
  	  var signature = reader.readUint32(0);
  	  var flavor = reader.readUint32(4);
  	  if (signature !== 0x774F4646 || flavor !== 0x10000 && flavor !== 0x4f54544f) {
  	    reader.dispose();
  	    _error.default.raise(10102);
  	  }
  	  var numTables = reader.readUint16(12);
  	  var ttfSize = reader.readUint32(16);
  	  var tableEntries = [];
  	  var tableEntry;
  	  var i;
  	  var l;

  	  // woff
  	  for (i = 0; i < numTables; ++i) {
  	    reader.seek(44 + i * 20);
  	    tableEntry = {
  	      tag: reader.readString(reader.offset, 4),
  	      offset: reader.readUint32(),
  	      compLength: reader.readUint32(),
  	      length: reader.readUint32(),
  	      checkSum: reader.readUint32()
  	    };

  	    // ttf 
  	    var deflateData = reader.readBytes(tableEntry.offset, tableEntry.compLength);
  	    // 
  	    if (deflateData.length < tableEntry.length) {
  	      if (!options.inflate) {
  	        reader.dispose();
  	        _error.default.raise(10105);
  	      }
  	      tableEntry.data = options.inflate(deflateData);
  	    } else {
  	      tableEntry.data = deflateData;
  	    }
  	    tableEntry.length = tableEntry.data.length;
  	    tableEntries.push(tableEntry);
  	  }
  	  var writer = new _writer.default(new ArrayBuffer(ttfSize));
  	  // 
  	  var entrySelector = Math.floor(Math.log(numTables) / Math.LN2);
  	  var searchRange = Math.pow(2, entrySelector) * 16;
  	  var rangeShift = numTables * 16 - searchRange;
  	  writer.writeUint32(flavor);
  	  writer.writeUint16(numTables);
  	  writer.writeUint16(searchRange);
  	  writer.writeUint16(entrySelector);
  	  writer.writeUint16(rangeShift);

  	  // ttf
  	  var tblOffset = 12 + 16 * tableEntries.length;
  	  for (i = 0, l = tableEntries.length; i < l; ++i) {
  	    tableEntry = tableEntries[i];
  	    writer.writeString(tableEntry.tag);
  	    writer.writeUint32(tableEntry.checkSum);
  	    writer.writeUint32(tblOffset);
  	    writer.writeUint32(tableEntry.length);
  	    tblOffset += tableEntry.length + (tableEntry.length % 4 ? 4 - tableEntry.length % 4 : 0);
  	  }

  	  // ttf
  	  for (i = 0, l = tableEntries.length; i < l; ++i) {
  	    tableEntry = tableEntries[i];
  	    writer.writeBytes(tableEntry.data);
  	    if (tableEntry.length % 4) {
  	      writer.writeEmpty(4 - tableEntry.length % 4);
  	    }
  	  }
  	  return writer.getBuffer();
  	}
  	return woff2ttf;
  }

  var otf2ttfobject = {};

  var otfreader = {};

  var directory = {};

  var table = {};

  var struct = {};

  var hasRequiredStruct;

  function requireStruct () {
  	if (hasRequiredStruct) return struct;
  	hasRequiredStruct = 1;

  	Object.defineProperty(struct, "__esModule", {
  	  value: true
  	});
  	struct.default = void 0;
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html
  	 */

  	var struct$1 = {
  	  Int8: 1,
  	  Uint8: 2,
  	  Int16: 3,
  	  Uint16: 4,
  	  Int32: 5,
  	  Uint32: 6,
  	  Fixed: 7,
  	  // 32-bit signed fixed-point number (16.16)
  	  FUnit: 8,
  	  // Smallest measurable distance in the em space
  	  // 16-bit signed fixed number with the low 14 bits of fraction
  	  F2Dot14: 11,
  	  // The long internal format of a date in seconds since 12:00 midnight,
  	  // January 1, 1904. It is represented as a signed 64-bit integer.
  	  LongDateTime: 12,
  	  // extend data type
  	  Char: 13,
  	  String: 14,
  	  Bytes: 15,
  	  Uint24: 20
  	};

  	// 
  	var names = {};
  	Object.keys(struct$1).forEach(function (key) {
  	  names[struct$1[key]] = key;
  	});
  	struct$1.names = names;
  	struct.default = struct$1;
  	return struct;
  }

  var hasRequiredTable;

  function requireTable () {
  	if (hasRequiredTable) return table;
  	hasRequiredTable = 1;

  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	Object.defineProperty(table, "__esModule", {
  	  value: true
  	});
  	table.default = void 0;
  	var _struct = _interopRequireDefault(requireStruct());
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/* eslint-disable no-invalid-this */
  	/**
  	 * 
  	 *
  	 * @param {Reader} reader reader
  	 * @return {Object} 
  	 */
  	function read(reader) {
  	  var offset = this.offset;
  	  if (undefined !== offset) {
  	    reader.seek(offset);
  	  }
  	  var me = this;
  	  this.struct.forEach(function (item) {
  	    var name = item[0];
  	    var type = item[1];
  	    var typeName = null;
  	    switch (type) {
  	      case _struct.default.Int8:
  	      case _struct.default.Uint8:
  	      case _struct.default.Int16:
  	      case _struct.default.Uint16:
  	      case _struct.default.Int32:
  	      case _struct.default.Uint32:
  	        typeName = _struct.default.names[type];
  	        me[name] = reader.read(typeName);
  	        break;
  	      case _struct.default.Fixed:
  	        me[name] = reader.readFixed();
  	        break;
  	      case _struct.default.LongDateTime:
  	        me[name] = reader.readLongDateTime();
  	        break;
  	      case _struct.default.Bytes:
  	        me[name] = reader.readBytes(reader.offset, item[2] || 0);
  	        break;
  	      case _struct.default.Char:
  	        me[name] = reader.readChar();
  	        break;
  	      case _struct.default.String:
  	        me[name] = reader.readString(reader.offset, item[2] || 0);
  	        break;
  	      default:
  	        _error.default.raise(10003, name, type);
  	    }
  	  });
  	  return this.valueOf();
  	}

  	/**
  	 * 
  	 *
  	 * @param {Object} writer writer
  	 * @param {Object} ttf ttf
  	 *
  	 * @return {Writer} writer
  	 */
  	function write(writer, ttf) {
  	  var table = ttf[this.name];
  	  if (!table) {
  	    _error.default.raise(10203, this.name);
  	  }
  	  this.struct.forEach(function (item) {
  	    var name = item[0];
  	    var type = item[1];
  	    var typeName = null;
  	    switch (type) {
  	      case _struct.default.Int8:
  	      case _struct.default.Uint8:
  	      case _struct.default.Int16:
  	      case _struct.default.Uint16:
  	      case _struct.default.Int32:
  	      case _struct.default.Uint32:
  	        typeName = _struct.default.names[type];
  	        writer.write(typeName, table[name]);
  	        break;
  	      case _struct.default.Fixed:
  	        writer.writeFixed(table[name]);
  	        break;
  	      case _struct.default.LongDateTime:
  	        writer.writeLongDateTime(table[name]);
  	        break;
  	      case _struct.default.Bytes:
  	        writer.writeBytes(table[name], item[2] || 0);
  	        break;
  	      case _struct.default.Char:
  	        writer.writeChar(table[name]);
  	        break;
  	      case _struct.default.String:
  	        writer.writeString(table[name], item[2] || 0);
  	        break;
  	      default:
  	        _error.default.raise(10003, name, type);
  	    }
  	  });
  	  return writer;
  	}

  	/**
  	 * ttfsize
  	 *
  	 * @param {string} name 
  	 * @return {number} 
  	 */
  	function size() {
  	  var sz = 0;
  	  this.struct.forEach(function (item) {
  	    var type = item[1];
  	    switch (type) {
  	      case _struct.default.Int8:
  	      case _struct.default.Uint8:
  	        sz += 1;
  	        break;
  	      case _struct.default.Int16:
  	      case _struct.default.Uint16:
  	        sz += 2;
  	        break;
  	      case _struct.default.Int32:
  	      case _struct.default.Uint32:
  	      case _struct.default.Fixed:
  	        sz += 4;
  	        break;
  	      case _struct.default.LongDateTime:
  	        sz += 8;
  	        break;
  	      case _struct.default.Bytes:
  	        sz += item[2] || 0;
  	        break;
  	      case _struct.default.Char:
  	        sz += 1;
  	        break;
  	      case _struct.default.String:
  	        sz += item[2] || 0;
  	        break;
  	      default:
  	        _error.default.raise(10003, name, type);
  	    }
  	  });
  	  return sz;
  	}

  	/**
  	 * 
  	 *
  	 * @return {*} 
  	 */
  	function valueOf() {
  	  var val = {};
  	  var me = this;
  	  this.struct.forEach(function (item) {
  	    val[item[0]] = me[item[0]];
  	  });
  	  return val;
  	}
  	table.default = {
  	  read: read,
  	  write: write,
  	  size: size,
  	  valueOf: valueOf,
  	  /**
  	   * 
  	   *
  	   * @param {string} name 
  	   * @param {Array<[string, number]>} struct 
  	   * @param {Object} proto 
  	   * @return {Function} 
  	   */
  	  create: function create(name, struct, proto) {
  	    var Table = /*#__PURE__*/_createClass(function Table(offset) {
  	      _classCallCheck(this, Table);
  	      this.name = name;
  	      this.struct = struct;
  	      this.offset = offset;
  	    });
  	    Table.prototype.read = read;
  	    Table.prototype.write = write;
  	    Table.prototype.size = size;
  	    Table.prototype.valueOf = valueOf;
  	    Object.assign(Table.prototype, proto);
  	    return Table;
  	  }
  	};
  	return table;
  }

  var hasRequiredDirectory;

  function requireDirectory () {
  	if (hasRequiredDirectory) return directory;
  	hasRequiredDirectory = 1;

  	Object.defineProperty(directory, "__esModule", {
  	  value: true
  	});
  	directory.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file directory , ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6.html
  	 */
  	directory.default = _table.default.create('directory', [], {
  	  read: function read(reader, ttf) {
  	    var tables = {};
  	    var numTables = ttf.numTables;
  	    var offset = this.offset;
  	    for (var i = offset, l = numTables * 16; i < l; i += 16) {
  	      var name = reader.readString(i, 4).trim();
  	      tables[name] = {
  	        name: name,
  	        checkSum: reader.readUint32(i + 4),
  	        offset: reader.readUint32(i + 8),
  	        length: reader.readUint32(i + 12)
  	      };
  	    }
  	    return tables;
  	  },
  	  write: function write(writer, ttf) {
  	    var tables = ttf.support.tables;
  	    for (var i = 0, l = tables.length; i < l; i++) {
  	      writer.writeString((tables[i].name + '    ').slice(0, 4));
  	      writer.writeUint32(tables[i].checkSum);
  	      writer.writeUint32(tables[i].offset);
  	      writer.writeUint32(tables[i].length);
  	    }
  	    return writer;
  	  },
  	  size: function size(ttf) {
  	    return ttf.numTables * 16;
  	  }
  	});
  	return directory;
  }

  var supportOtf = {};

  var head = {};

  var hasRequiredHead;

  function requireHead () {
  	if (hasRequiredHead) return head;
  	hasRequiredHead = 1;

  	Object.defineProperty(head, "__esModule", {
  	  value: true
  	});
  	head.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file head
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	head.default = _table.default.create('head', [['version', _struct.default.Fixed], ['fontRevision', _struct.default.Fixed], ['checkSumAdjustment', _struct.default.Uint32], ['magickNumber', _struct.default.Uint32], ['flags', _struct.default.Uint16], ['unitsPerEm', _struct.default.Uint16], ['created', _struct.default.LongDateTime], ['modified', _struct.default.LongDateTime], ['xMin', _struct.default.Int16], ['yMin', _struct.default.Int16], ['xMax', _struct.default.Int16], ['yMax', _struct.default.Int16], ['macStyle', _struct.default.Uint16], ['lowestRecPPEM', _struct.default.Uint16], ['fontDirectionHint', _struct.default.Int16], ['indexToLocFormat', _struct.default.Int16], ['glyphDataFormat', _struct.default.Int16]]);
  	return head;
  }

  var maxp = {};

  var hasRequiredMaxp;

  function requireMaxp () {
  	if (hasRequiredMaxp) return maxp;
  	hasRequiredMaxp = 1;

  	Object.defineProperty(maxp, "__esModule", {
  	  value: true
  	});
  	maxp.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file maxp 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	maxp.default = _table.default.create('maxp', [['version', _struct.default.Fixed], ['numGlyphs', _struct.default.Uint16], ['maxPoints', _struct.default.Uint16], ['maxContours', _struct.default.Uint16], ['maxCompositePoints', _struct.default.Uint16], ['maxCompositeContours', _struct.default.Uint16], ['maxZones', _struct.default.Uint16], ['maxTwilightPoints', _struct.default.Uint16], ['maxStorage', _struct.default.Uint16], ['maxFunctionDefs', _struct.default.Uint16], ['maxInstructionDefs', _struct.default.Uint16], ['maxStackElements', _struct.default.Uint16], ['maxSizeOfInstructions', _struct.default.Uint16], ['maxComponentElements', _struct.default.Uint16], ['maxComponentDepth', _struct.default.Int16]], {
  	  write: function write(writer, ttf) {
  	    _table.default.write.call(this, writer, ttf.support);
  	    return writer;
  	  },
  	  size: function size() {
  	    return 32;
  	  }
  	});
  	return maxp;
  }

  var cmap = {};

  var parse$1 = {};

  var readWindowsAllCodes = {};

  var hasRequiredReadWindowsAllCodes;

  function requireReadWindowsAllCodes () {
  	if (hasRequiredReadWindowsAllCodes) return readWindowsAllCodes;
  	hasRequiredReadWindowsAllCodes = 1;

  	Object.defineProperty(readWindowsAllCodes, "__esModule", {
  	  value: true
  	});
  	readWindowsAllCodes.default = readWindowsAllCodes$1;
  	/* eslint-disable */

  	/**
  	 * @file windows
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * @see
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html
  	 */

  	/**
  	 * ttfwindows
  	 *
  	 * @param {Array} tables cmap
  	 * @param {Object} ttf ttf
  	 * @return {Object} unicode => glyf index
  	 */
  	function readWindowsAllCodes$1(tables, ttf) {
  	  var codes = {};

  	  // windows unicode 
  	  var format0 = tables.find(function (item) {
  	    return item.format === 0;
  	  });

  	  // windows unicode 
  	  var format12 = tables.find(function (item) {
  	    return item.platformID === 3 && item.encodingID === 10 && item.format === 12;
  	  });
  	  var format4 = tables.find(function (item) {
  	    return item.platformID === 3 && item.encodingID === 1 && item.format === 4;
  	  });
  	  var format2 = tables.find(function (item) {
  	    return item.platformID === 3 && item.encodingID === 3 && item.format === 2;
  	  });
  	  var format14 = tables.find(function (item) {
  	    return item.platformID === 0 && item.encodingID === 5 && item.format === 14;
  	  });
  	  if (format0) {
  	    for (var i = 0, l = format0.glyphIdArray.length; i < l; i++) {
  	      if (format0.glyphIdArray[i]) {
  	        codes[i] = format0.glyphIdArray[i];
  	      }
  	    }
  	  }

  	  // format 14 support
  	  if (format14) {
  	    for (var _i = 0, _l = format14.groups.length; _i < _l; _i++) {
  	      var _format14$groups$_i = format14.groups[_i],
  	        unicode = _format14$groups$_i.unicode,
  	        glyphId = _format14$groups$_i.glyphId;
  	      if (unicode) {
  	        codes[unicode] = glyphId;
  	      }
  	    }
  	  }

  	  // format12
  	  if (format12) {
  	    for (var _i2 = 0, _l2 = format12.nGroups; _i2 < _l2; _i2++) {
  	      var group = format12.groups[_i2];
  	      var startId = group.startId;
  	      var start = group.start;
  	      var end = group.end;
  	      for (; start <= end;) {
  	        codes[start++] = startId++;
  	      }
  	    }
  	  }
  	  // format4
  	  else if (format4) {
  	    var segCount = format4.segCountX2 / 2;
  	    // graphIdArray idRangeOffset
  	    var graphIdArrayIndexOffset = (format4.glyphIdArrayOffset - format4.idRangeOffsetOffset) / 2;
  	    for (var _i3 = 0; _i3 < segCount; ++_i3) {
  	      // 
  	      for (var _start = format4.startCode[_i3], _end = format4.endCode[_i3]; _start <= _end; ++_start) {
  	        // range offset = 0
  	        if (format4.idRangeOffset[_i3] === 0) {
  	          codes[_start] = (_start + format4.idDelta[_i3]) % 0x10000;
  	        }
  	        // rely on to glyphIndexArray
  	        else {
  	          var index = _i3 + format4.idRangeOffset[_i3] / 2 + (_start - format4.startCode[_i3]) - graphIdArrayIndexOffset;
  	          var graphId = format4.glyphIdArray[index];
  	          if (graphId !== 0) {
  	            codes[_start] = (graphId + format4.idDelta[_i3]) % 0x10000;
  	          } else {
  	            codes[_start] = 0;
  	          }
  	        }
  	      }
  	    }
  	    delete codes[65535];
  	  }
  	  // format2
  	  // see https://github.com/fontforge/fontforge/blob/master/fontforge/parsettf.c
  	  else if (format2) {
  	    var subHeadKeys = format2.subHeadKeys;
  	    var subHeads = format2.subHeads;
  	    var glyphs = format2.glyphs;
  	    var numGlyphs = ttf.maxp.numGlyphs;
  	    var _index = 0;
  	    for (var _i4 = 0; _i4 < 256; _i4++) {
  	      // 
  	      if (subHeadKeys[_i4] === 0) {
  	        if (_i4 >= format2.maxPos) {
  	          _index = 0;
  	        } else if (_i4 < subHeads[0].firstCode || _i4 >= subHeads[0].firstCode + subHeads[0].entryCount || subHeads[0].idRangeOffset + (_i4 - subHeads[0].firstCode) >= glyphs.length) {
  	          _index = 0;
  	        } else if ((_index = glyphs[subHeads[0].idRangeOffset + (_i4 - subHeads[0].firstCode)]) !== 0) {
  	          _index = _index + subHeads[0].idDelta;
  	        }

  	        // 
  	        if (_index !== 0 && _index < numGlyphs) {
  	          codes[_i4] = _index;
  	        }
  	      } else {
  	        var k = subHeadKeys[_i4];
  	        for (var j = 0, entryCount = subHeads[k].entryCount; j < entryCount; j++) {
  	          if (subHeads[k].idRangeOffset + j >= glyphs.length) {
  	            _index = 0;
  	          } else if ((_index = glyphs[subHeads[k].idRangeOffset + j]) !== 0) {
  	            _index = _index + subHeads[k].idDelta;
  	          }
  	          if (_index !== 0 && _index < numGlyphs) {
  	            var _unicode = (_i4 << 8 | j + subHeads[k].firstCode) % 0xffff;
  	            codes[_unicode] = _index;
  	          }
  	        }
  	      }
  	    }
  	  }
  	  return codes;
  	}
  	return readWindowsAllCodes;
  }

  var hasRequiredParse$1;

  function requireParse$1 () {
  	if (hasRequiredParse$1) return parse$1;
  	hasRequiredParse$1 = 1;

  	Object.defineProperty(parse$1, "__esModule", {
  	  value: true
  	});
  	parse$1.default = parse;
  	var _readWindowsAllCodes = _interopRequireDefault(requireReadWindowsAllCodes());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cmap
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * cmap
  	 *
  	 * @param {Reader} reader Reader
  	 * @param {Object} ttf ttf
  	 * @param {Object} subTable 
  	 * @param {number} cmapOffset 
  	 */
  	function readSubTable(reader, ttf, subTable, cmapOffset) {
  	  var i;
  	  var l;
  	  var glyphIdArray;
  	  var startOffset = cmapOffset + subTable.offset;
  	  var glyphCount;
  	  subTable.format = reader.readUint16(startOffset);

  	  // 0256 
  	  if (subTable.format === 0) {
  	    var format0 = subTable;
  	    // format
  	    format0.length = reader.readUint16();
  	    format0.language = reader.readUint16();
  	    glyphIdArray = [];
  	    for (i = 0, l = format0.length - 6; i < l; i++) {
  	      glyphIdArray.push(reader.readUint8());
  	    }
  	    format0.glyphIdArray = glyphIdArray;
  	  } else if (subTable.format === 2) {
  	    var format2 = subTable;
  	    // format
  	    format2.length = reader.readUint16();
  	    format2.language = reader.readUint16();
  	    var subHeadKeys = [];
  	    var maxSubHeadKey = 0; // 
  	    var maxPos = -1; // 
  	    for (var _i = 0, _l = 256; _i < _l; _i++) {
  	      subHeadKeys[_i] = reader.readUint16() / 8;
  	      if (subHeadKeys[_i] > maxSubHeadKey) {
  	        maxSubHeadKey = subHeadKeys[_i];
  	        maxPos = _i;
  	      }
  	    }
  	    var subHeads = [];
  	    for (i = 0; i <= maxSubHeadKey; i++) {
  	      subHeads[i] = {
  	        firstCode: reader.readUint16(),
  	        entryCount: reader.readUint16(),
  	        idDelta: reader.readUint16(),
  	        idRangeOffset: (reader.readUint16() - (maxSubHeadKey - i) * 8 - 2) / 2
  	      };
  	    }
  	    glyphCount = (startOffset + format2.length - reader.offset) / 2;
  	    var glyphs = [];
  	    for (i = 0; i < glyphCount; i++) {
  	      glyphs[i] = reader.readUint16();
  	    }
  	    format2.subHeadKeys = subHeadKeys;
  	    format2.maxPos = maxPos;
  	    format2.subHeads = subHeads;
  	    format2.glyphs = glyphs;
  	  }
  	  // 
  	  else if (subTable.format === 4) {
  	    var format4 = subTable;
  	    // format
  	    format4.length = reader.readUint16();
  	    format4.language = reader.readUint16();
  	    format4.segCountX2 = reader.readUint16();
  	    format4.searchRange = reader.readUint16();
  	    format4.entrySelector = reader.readUint16();
  	    format4.rangeShift = reader.readUint16();
  	    var segCount = format4.segCountX2 / 2;

  	    // end code
  	    var endCode = [];
  	    for (i = 0; i < segCount; ++i) {
  	      endCode.push(reader.readUint16());
  	    }
  	    format4.endCode = endCode;
  	    format4.reservedPad = reader.readUint16();

  	    // start code
  	    var startCode = [];
  	    for (i = 0; i < segCount; ++i) {
  	      startCode.push(reader.readUint16());
  	    }
  	    format4.startCode = startCode;

  	    // idDelta
  	    var idDelta = [];
  	    for (i = 0; i < segCount; ++i) {
  	      idDelta.push(reader.readUint16());
  	    }
  	    format4.idDelta = idDelta;
  	    format4.idRangeOffsetOffset = reader.offset;

  	    // idRangeOffset
  	    var idRangeOffset = [];
  	    for (i = 0; i < segCount; ++i) {
  	      idRangeOffset.push(reader.readUint16());
  	    }
  	    format4.idRangeOffset = idRangeOffset;

  	    //  - glyphIdArray/2
  	    glyphCount = (format4.length - (reader.offset - startOffset)) / 2;

  	    // array offset
  	    format4.glyphIdArrayOffset = reader.offset;

  	    // glyphIdArray
  	    glyphIdArray = [];
  	    for (i = 0; i < glyphCount; ++i) {
  	      glyphIdArray.push(reader.readUint16());
  	    }
  	    format4.glyphIdArray = glyphIdArray;
  	  } else if (subTable.format === 6) {
  	    var format6 = subTable;
  	    format6.length = reader.readUint16();
  	    format6.language = reader.readUint16();
  	    format6.firstCode = reader.readUint16();
  	    format6.entryCount = reader.readUint16();

  	    // array offset
  	    format6.glyphIdArrayOffset = reader.offset;
  	    var glyphIndexArray = [];
  	    var entryCount = format6.entryCount;
  	    // 
  	    for (i = 0; i < entryCount; ++i) {
  	      glyphIndexArray.push(reader.readUint16());
  	    }
  	    format6.glyphIdArray = glyphIndexArray;
  	  }
  	  // defines segments for sparse representation in 4-byte character space
  	  else if (subTable.format === 12) {
  	    var format12 = subTable;
  	    format12.reserved = reader.readUint16();
  	    format12.length = reader.readUint32();
  	    format12.language = reader.readUint32();
  	    format12.nGroups = reader.readUint32();
  	    var groups = [];
  	    var nGroups = format12.nGroups;
  	    // 
  	    for (i = 0; i < nGroups; ++i) {
  	      var group = {};
  	      group.start = reader.readUint32();
  	      group.end = reader.readUint32();
  	      group.startId = reader.readUint32();
  	      groups.push(group);
  	    }
  	    format12.groups = groups;
  	  }
  	  // format 14
  	  else if (subTable.format === 14) {
  	    var format14 = subTable;
  	    format14.length = reader.readUint32();
  	    var numVarSelectorRecords = reader.readUint32();
  	    var _groups = [];
  	    var offset = reader.offset;
  	    for (var _i2 = 0; _i2 < numVarSelectorRecords; _i2++) {
  	      var varSelector = reader.readUint24(offset);
  	      var defaultUVSOffset = reader.readUint32(offset + 3);
  	      var nonDefaultUVSOffset = reader.readUint32(offset + 7);
  	      offset += 11;
  	      if (defaultUVSOffset) {
  	        var numUnicodeValueRanges = reader.readUint32(startOffset + defaultUVSOffset);
  	        for (var j = 0; j < numUnicodeValueRanges; j++) {
  	          var startUnicode = reader.readUint24();
  	          var additionalCount = reader.readUint8();
  	          _groups.push({
  	            start: startUnicode,
  	            end: startUnicode + additionalCount,
  	            varSelector: varSelector
  	          });
  	        }
  	      }
  	      if (nonDefaultUVSOffset) {
  	        var numUVSMappings = reader.readUint32(startOffset + nonDefaultUVSOffset);
  	        for (var _j = 0; _j < numUVSMappings; _j++) {
  	          var unicode = reader.readUint24();
  	          var glyphId = reader.readUint16();
  	          _groups.push({
  	            unicode: unicode,
  	            glyphId: glyphId,
  	            varSelector: varSelector
  	          });
  	        }
  	      }
  	    }
  	    format14.groups = _groups;
  	  } else {
  	    console.warn('not support cmap format:' + subTable.format);
  	  }
  	}
  	function parse(reader, ttf) {
  	  // eslint-disable-next-line no-invalid-this
  	  var cmapOffset = this.offset;
  	  reader.seek(cmapOffset);
  	  reader.readUint16(); // 
  	  var numberSubtables = reader.readUint16(); // 

  	  var subTables = []; // 
  	  var offset = reader.offset;

  	  // offset
  	  for (var i = 0, l = numberSubtables; i < l; i++) {
  	    var subTable = {};
  	    subTable.platformID = reader.readUint16(offset);
  	    subTable.encodingID = reader.readUint16(offset + 2);
  	    subTable.offset = reader.readUint32(offset + 4);
  	    readSubTable(reader, ttf, subTable, cmapOffset);
  	    subTables.push(subTable);
  	    offset += 8;
  	  }
  	  var cmap = (0, _readWindowsAllCodes.default)(subTables, ttf);
  	  return cmap;
  	}
  	return parse$1;
  }

  var write$1 = {};

  var hasRequiredWrite$1;

  function requireWrite$1 () {
  	if (hasRequiredWrite$1) return write$1;
  	hasRequiredWrite$1 = 1;

  	Object.defineProperty(write$1, "__esModule", {
  	  value: true
  	});
  	write$1.default = write;
  	/**
  	 * @file cmap
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * `0`
  	 *
  	 * @param {Writer} writer 
  	 * @param {Array} unicodes unicodes
  	 * @return {Writer}
  	 */
  	function writeSubTable0(writer, unicodes) {
  	  writer.writeUint16(0); // format
  	  writer.writeUint16(262); // length
  	  writer.writeUint16(0); // language

  	  // Array of unicodes 0..255
  	  var i = -1;
  	  var unicode;
  	  while (unicode = unicodes.shift()) {
  	    while (++i < unicode[0]) {
  	      writer.writeUint8(0);
  	    }
  	    writer.writeUint8(unicode[1]);
  	    i = unicode[0];
  	  }
  	  while (++i < 256) {
  	    writer.writeUint8(0);
  	  }
  	  return writer;
  	}

  	/**
  	 * `4`
  	 *
  	 * @param {Writer} writer 
  	 * @param {Array} segments 
  	 * @return {Writer}
  	 */
  	function writeSubTable4(writer, segments) {
  	  writer.writeUint16(4); // format
  	  writer.writeUint16(24 + segments.length * 8); // length
  	  writer.writeUint16(0); // language

  	  var segCount = segments.length + 1;
  	  var maxExponent = Math.floor(Math.log(segCount) / Math.LN2);
  	  var searchRange = 2 * Math.pow(2, maxExponent);
  	  writer.writeUint16(segCount * 2); // segCountX2
  	  writer.writeUint16(searchRange); // searchRange
  	  writer.writeUint16(maxExponent); // entrySelector
  	  writer.writeUint16(2 * segCount - searchRange); // rangeShift

  	  // end list
  	  segments.forEach(function (segment) {
  	    writer.writeUint16(segment.end);
  	  });
  	  writer.writeUint16(0xFFFF); // end code
  	  writer.writeUint16(0); // reservedPad

  	  // start list
  	  segments.forEach(function (segment) {
  	    writer.writeUint16(segment.start);
  	  });
  	  writer.writeUint16(0xFFFF); // start code

  	  // id delta
  	  segments.forEach(function (segment) {
  	    writer.writeUint16(segment.delta);
  	  });
  	  writer.writeUint16(1);

  	  // Array of range offsets, it doesn't matter when deltas present
  	  for (var i = 0, l = segments.length; i < l; i++) {
  	    writer.writeUint16(0);
  	  }
  	  writer.writeUint16(0); // rangeOffsetArray should be finished with 0

  	  return writer;
  	}

  	/**
  	 * `12`
  	 *
  	 * @param {Writer} writer 
  	 * @param {Array} segments 
  	 * @return {Writer}
  	 */
  	function writeSubTable12(writer, segments) {
  	  writer.writeUint16(12); // format
  	  writer.writeUint16(0); // reserved
  	  writer.writeUint32(16 + segments.length * 12); // length
  	  writer.writeUint32(0); // language
  	  writer.writeUint32(segments.length); // nGroups

  	  segments.forEach(function (segment) {
  	    writer.writeUint32(segment.start);
  	    writer.writeUint32(segment.end);
  	    writer.writeUint32(segment.startId);
  	  });
  	  return writer;
  	}

  	/**
  	 * subtableheader
  	 *
  	 * @param {Writer} writer Writer
  	 * @param {number} platform 
  	 * @param {number} encoding 
  	 * @param {number} offset 
  	 * @return {Writer}
  	 */
  	function writeSubTableHeader(writer, platform, encoding, offset) {
  	  writer.writeUint16(platform); // platform
  	  writer.writeUint16(encoding); // encoding
  	  writer.writeUint32(offset); // offset
  	  return writer;
  	}

  	/**
  	 * cmap
  	 *
  	 * @param  {Object} writer 
  	 * @param  {Object} ttf    ttf
  	 * @return {Object}        
  	 */
  	function write(writer, ttf) {
  	  var hasGLyphsOver2Bytes = ttf.support.cmap.hasGLyphsOver2Bytes;

  	  // write table header.
  	  writer.writeUint16(0); // version
  	  writer.writeUint16(hasGLyphsOver2Bytes ? 4 : 3); // count

  	  // header size
  	  var subTableOffset = 4 + (hasGLyphsOver2Bytes ? 32 : 24);
  	  var format4Size = ttf.support.cmap.format4Size;
  	  var format0Size = ttf.support.cmap.format0Size;

  	  // subtable 4, unicode
  	  writeSubTableHeader(writer, 0, 3, subTableOffset);

  	  // subtable 0, mac standard
  	  writeSubTableHeader(writer, 1, 0, subTableOffset + format4Size);

  	  // subtable 4, windows standard
  	  writeSubTableHeader(writer, 3, 1, subTableOffset);
  	  if (hasGLyphsOver2Bytes) {
  	    writeSubTableHeader(writer, 3, 10, subTableOffset + format4Size + format0Size);
  	  }

  	  // write tables, order of table seem to be magic, it is taken from TTX tool
  	  writeSubTable4(writer, ttf.support.cmap.format4Segments);
  	  writeSubTable0(writer, ttf.support.cmap.format0Segments);
  	  if (hasGLyphsOver2Bytes) {
  	    writeSubTable12(writer, ttf.support.cmap.format12Segments);
  	  }
  	  return writer;
  	}
  	return write$1;
  }

  var sizeof$1 = {};

  var hasRequiredSizeof$1;

  function requireSizeof$1 () {
  	if (hasRequiredSizeof$1) return sizeof$1;
  	hasRequiredSizeof$1 = 1;

  	Object.defineProperty(sizeof$1, "__esModule", {
  	  value: true
  	});
  	sizeof$1.default = sizeof;
  	/**
  	 * @file cmap
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * format4 delta
  	 * Delta is saved in signed int in cmap format 4 subtable,
  	 * but can be in -0xFFFF..0 interval.
  	 * -0x10000..-0x7FFF values are stored with offset.
  	 *
  	 * @param {number} delta delta
  	 * @return {number} delta
  	 */
  	function encodeDelta(delta) {
  	  return delta > 0x7FFF ? delta - 0x10000 : delta < -0x7FFF ? delta + 0x10000 : delta;
  	}

  	/**
  	 * boundglyf segment
  	 *
  	 * @param {Array} glyfUnicodes glyf
  	 * @param {number} bound 
  	 * @return {Array} 
  	 */
  	function getSegments(glyfUnicodes, bound) {
  	  var prevGlyph = null;
  	  var result = [];
  	  var segment = {};
  	  glyfUnicodes.forEach(function (glyph) {
  	    if (bound === undefined || glyph.unicode <= bound) {
  	      // unicodegraph id 
  	      if (prevGlyph === null || glyph.unicode !== prevGlyph.unicode + 1 || glyph.id !== prevGlyph.id + 1) {
  	        if (prevGlyph !== null) {
  	          segment.end = prevGlyph.unicode;
  	          result.push(segment);
  	          segment = {
  	            start: glyph.unicode,
  	            startId: glyph.id,
  	            delta: encodeDelta(glyph.id - glyph.unicode)
  	          };
  	        } else {
  	          segment.start = glyph.unicode;
  	          segment.startId = glyph.id;
  	          segment.delta = encodeDelta(glyph.id - glyph.unicode);
  	        }
  	      }
  	      prevGlyph = glyph;
  	    }
  	  });

  	  // need to finish the last segment
  	  if (prevGlyph !== null) {
  	    segment.end = prevGlyph.unicode;
  	    result.push(segment);
  	  }

  	  // 
  	  return result;
  	}

  	/**
  	 * format0
  	 *
  	 * @param {Array} glyfUnicodes glyf
  	 * @return {Array} 
  	 */
  	function getFormat0Segment(glyfUnicodes) {
  	  var unicodes = [];
  	  glyfUnicodes.forEach(function (u) {
  	    if (u.unicode !== undefined && u.unicode < 256) {
  	      unicodes.push([u.unicode, u.id]);
  	    }
  	  });

  	  // 
  	  unicodes.sort(function (a, b) {
  	    return a[0] - b[0];
  	  });
  	  return unicodes;
  	}

  	/**
  	 * cmap
  	 *
  	 * @param  {Object} ttf ttf
  	 * @return {number} 
  	 */
  	function sizeof(ttf) {
  	  ttf.support.cmap = {};
  	  var glyfUnicodes = [];
  	  ttf.glyf.forEach(function (glyph, index) {
  	    var unicodes = glyph.unicode;
  	    if (typeof glyph.unicode === 'number') {
  	      unicodes = [glyph.unicode];
  	    }
  	    if (unicodes && unicodes.length) {
  	      unicodes.forEach(function (unicode) {
  	        glyfUnicodes.push({
  	          unicode: unicode,
  	          id: unicode !== 0xFFFF ? index : 0
  	        });
  	      });
  	    }
  	  });
  	  glyfUnicodes = glyfUnicodes.sort(function (a, b) {
  	    return a.unicode - b.unicode;
  	  });
  	  ttf.support.cmap.unicodes = glyfUnicodes;
  	  var unicodes2Bytes = glyfUnicodes;
  	  ttf.support.cmap.format4Segments = getSegments(unicodes2Bytes, 0xFFFF);
  	  ttf.support.cmap.format4Size = 24 + ttf.support.cmap.format4Segments.length * 8;
  	  ttf.support.cmap.format0Segments = getFormat0Segment(glyfUnicodes);
  	  ttf.support.cmap.format0Size = 262;

  	  // we need subtable 12 only if found unicodes with > 2 bytes.
  	  var hasGLyphsOver2Bytes = unicodes2Bytes.some(function (glyph) {
  	    return glyph.unicode > 0xFFFF;
  	  });
  	  if (hasGLyphsOver2Bytes) {
  	    ttf.support.cmap.hasGLyphsOver2Bytes = hasGLyphsOver2Bytes;
  	    var unicodes4Bytes = glyfUnicodes;
  	    ttf.support.cmap.format12Segments = getSegments(unicodes4Bytes);
  	    ttf.support.cmap.format12Size = 16 + ttf.support.cmap.format12Segments.length * 12;
  	  }
  	  var size = 4 + (hasGLyphsOver2Bytes ? 32 : 24) // cmap header
  	  + ttf.support.cmap.format0Size // format 0
  	  + ttf.support.cmap.format4Size // format 4
  	  + (hasGLyphsOver2Bytes ? ttf.support.cmap.format12Size : 0); // format 12

  	  return size;
  	}
  	return sizeof$1;
  }

  var hasRequiredCmap;

  function requireCmap () {
  	if (hasRequiredCmap) return cmap;
  	hasRequiredCmap = 1;

  	Object.defineProperty(cmap, "__esModule", {
  	  value: true
  	});
  	cmap.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _parse = _interopRequireDefault(requireParse$1());
  	var _write = _interopRequireDefault(requireWrite$1());
  	var _sizeof = _interopRequireDefault(requireSizeof$1());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cmap 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * @see
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cmap.html
  	 */
  	cmap.default = _table.default.create('cmap', [], {
  	  write: _write.default,
  	  read: _parse.default,
  	  size: _sizeof.default
  	});
  	return cmap;
  }

  var name$1 = {};

  var nameId = {};

  var hasRequiredNameId;

  function requireNameId () {
  	if (hasRequiredNameId) return nameId;
  	hasRequiredNameId = 1;

  	Object.defineProperty(nameId, "__esModule", {
  	  value: true
  	});
  	nameId.default = void 0;
  	/**
  	 * @file ttf `name`
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var nameId$1 = {
  	  0: 'copyright',
  	  1: 'fontFamily',
  	  2: 'fontSubFamily',
  	  3: 'uniqueSubFamily',
  	  4: 'fullName',
  	  5: 'version',
  	  6: 'postScriptName',
  	  7: 'tradeMark',
  	  8: 'manufacturer',
  	  9: 'designer',
  	  10: 'description',
  	  11: 'urlOfFontVendor',
  	  12: 'urlOfFontDesigner',
  	  13: 'licence',
  	  14: 'urlOfLicence',
  	  16: 'preferredFamily',
  	  17: 'preferredSubFamily',
  	  18: 'compatibleFull',
  	  19: 'sampleText'
  	};

  	// names
  	var nameIdHash = {};
  	Object.keys(nameId$1).forEach(function (id) {
  	  nameIdHash[nameId$1[id]] = +id;
  	});
  	nameId$1.names = nameIdHash;
  	nameId.default = nameId$1;
  	return nameId;
  }

  var platform = {};

  var hasRequiredPlatform;

  function requirePlatform () {
  	if (hasRequiredPlatform) return platform;
  	hasRequiredPlatform = 1;

  	Object.defineProperty(platform, "__esModule", {
  	  value: true
  	});
  	platform.default = void 0;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	platform.default = {
  	  Unicode: 0,
  	  Macintosh: 1,
  	  // mac
  	  reserved: 2,
  	  Microsoft: 3 // win
  	};
  	return platform;
  }

  var encoding$1 = {};

  var hasRequiredEncoding$1;

  function requireEncoding$1 () {
  	if (hasRequiredEncoding$1) return encoding$1;
  	hasRequiredEncoding$1 = 1;

  	Object.defineProperty(encoding$1, "__esModule", {
  	  value: true
  	});
  	encoding$1.win = encoding$1.mac = void 0;
  	/**
  	 * @file Unicode Platform-specific Encoding Identifiers
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	// mac encoding id
  	encoding$1.mac = {
  	  'Default': 0,
  	  // default use
  	  'Version1.1': 1,
  	  'ISO10646': 2,
  	  'UnicodeBMP': 3,
  	  'UnicodenonBMP': 4,
  	  'UnicodeVariationSequences': 5,
  	  'FullUnicodecoverage': 6
  	};

  	// windows encoding id
  	encoding$1.win = {
  	  Symbol: 0,
  	  UCS2: 1,
  	  // default use
  	  ShiftJIS: 2,
  	  PRC: 3,
  	  BigFive: 4,
  	  Johab: 5,
  	  UCS4: 6
  	};
  	return encoding$1;
  }

  var hasRequiredName;

  function requireName () {
  	if (hasRequiredName) return name$1;
  	hasRequiredName = 1;

  	Object.defineProperty(name$1, "__esModule", {
  	  value: true
  	});
  	name$1.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _nameId = _interopRequireDefault(requireNameId());
  	var _string = _interopRequireDefault(requireString$1());
  	var _platform = _interopRequireDefault(requirePlatform());
  	var _encoding = requireEncoding$1();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file name
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	name$1.default = _table.default.create('name', [], {
  	  read: function read(reader) {
  	    var offset = this.offset;
  	    reader.seek(offset);
  	    var nameTbl = {};
  	    nameTbl.format = reader.readUint16();
  	    nameTbl.count = reader.readUint16();
  	    nameTbl.stringOffset = reader.readUint16();
  	    var nameRecordTbl = [];
  	    var count = nameTbl.count;
  	    var i;
  	    var nameRecord;
  	    for (i = 0; i < count; ++i) {
  	      nameRecord = {};
  	      nameRecord.platform = reader.readUint16();
  	      nameRecord.encoding = reader.readUint16();
  	      nameRecord.language = reader.readUint16();
  	      nameRecord.nameId = reader.readUint16();
  	      nameRecord.length = reader.readUint16();
  	      nameRecord.offset = reader.readUint16();
  	      nameRecordTbl.push(nameRecord);
  	    }
  	    offset += nameTbl.stringOffset;

  	    // 
  	    for (i = 0; i < count; ++i) {
  	      nameRecord = nameRecordTbl[i];
  	      nameRecord.name = reader.readBytes(offset + nameRecord.offset, nameRecord.length);
  	    }
  	    var names = {};

  	    // mac english name
  	    var platform = _platform.default.Macintosh;
  	    var encoding = _encoding.mac.Default;
  	    var language = 0;

  	    // windows  englishwindows name
  	    if (nameRecordTbl.some(function (record) {
  	      return record.platform === _platform.default.Microsoft && record.encoding === _encoding.win.UCS2 && record.language === 1033;
  	    })) {
  	      platform = _platform.default.Microsoft;
  	      encoding = _encoding.win.UCS2;
  	      language = 1033;
  	    }
  	    for (i = 0; i < count; ++i) {
  	      nameRecord = nameRecordTbl[i];
  	      if (nameRecord.platform === platform && nameRecord.encoding === encoding && nameRecord.language === language && _nameId.default[nameRecord.nameId]) {
  	        names[_nameId.default[nameRecord.nameId]] = language === 0 ? _string.default.getUTF8String(nameRecord.name) : _string.default.getUCS2String(nameRecord.name);
  	      }
  	    }
  	    return names;
  	  },
  	  write: function write(writer, ttf) {
  	    var nameRecordTbl = ttf.support.name;
  	    writer.writeUint16(0); // format
  	    writer.writeUint16(nameRecordTbl.length); // count
  	    writer.writeUint16(6 + nameRecordTbl.length * 12); // string offset

  	    // write name tbl header
  	    var offset = 0;
  	    nameRecordTbl.forEach(function (nameRecord) {
  	      writer.writeUint16(nameRecord.platform);
  	      writer.writeUint16(nameRecord.encoding);
  	      writer.writeUint16(nameRecord.language);
  	      writer.writeUint16(nameRecord.nameId);
  	      writer.writeUint16(nameRecord.name.length);
  	      writer.writeUint16(offset); // offset
  	      offset += nameRecord.name.length;
  	    });

  	    // write name tbl strings
  	    nameRecordTbl.forEach(function (nameRecord) {
  	      writer.writeBytes(nameRecord.name);
  	    });
  	    return writer;
  	  },
  	  size: function size(ttf) {
  	    var names = ttf.name;
  	    var nameRecordTbl = [];

  	    // name
  	    // 
  	    // url encode
  	    var size = 6;
  	    Object.keys(names).forEach(function (name) {
  	      var id = _nameId.default.names[name];
  	      var utf8Bytes = _string.default.toUTF8Bytes(names[name]);
  	      var usc2Bytes = _string.default.toUCS2Bytes(names[name]);
  	      if (undefined !== id) {
  	        // mac
  	        nameRecordTbl.push({
  	          nameId: id,
  	          platform: 1,
  	          encoding: 0,
  	          language: 0,
  	          name: utf8Bytes
  	        });

  	        // windows
  	        nameRecordTbl.push({
  	          nameId: id,
  	          platform: 3,
  	          encoding: 1,
  	          language: 1033,
  	          name: usc2Bytes
  	        });

  	        // 
  	        size += 12 * 2 + utf8Bytes.length + usc2Bytes.length;
  	      }
  	    });
  	    var namingOrder = ['platform', 'encoding', 'language', 'nameId'];
  	    nameRecordTbl = nameRecordTbl.sort(function (a, b) {
  	      var l = 0;
  	      namingOrder.some(function (name) {
  	        var o = a[name] - b[name];
  	        if (o) {
  	          l = o;
  	          return true;
  	        }
  	        return false;
  	      });
  	      return l;
  	    });

  	    // 
  	    ttf.support.name = nameRecordTbl;
  	    return size;
  	  }
  	});
  	return name$1;
  }

  var hhea = {};

  var hasRequiredHhea;

  function requireHhea () {
  	if (hasRequiredHhea) return hhea;
  	hasRequiredHhea = 1;

  	Object.defineProperty(hhea, "__esModule", {
  	  value: true
  	});
  	hhea.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file hhea 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hhea.html
  	 */
  	hhea.default = _table.default.create('hhea', [['version', _struct.default.Fixed], ['ascent', _struct.default.Int16], ['descent', _struct.default.Int16], ['lineGap', _struct.default.Int16], ['advanceWidthMax', _struct.default.Uint16], ['minLeftSideBearing', _struct.default.Int16], ['minRightSideBearing', _struct.default.Int16], ['xMaxExtent', _struct.default.Int16], ['caretSlopeRise', _struct.default.Int16], ['caretSlopeRun', _struct.default.Int16], ['caretOffset', _struct.default.Int16], ['reserved0', _struct.default.Int16], ['reserved1', _struct.default.Int16], ['reserved2', _struct.default.Int16], ['reserved3', _struct.default.Int16], ['metricDataFormat', _struct.default.Int16], ['numOfLongHorMetrics', _struct.default.Uint16]]);
  	return hhea;
  }

  var hmtx = {};

  var hasRequiredHmtx;

  function requireHmtx () {
  	if (hasRequiredHmtx) return hmtx;
  	hasRequiredHmtx = 1;

  	Object.defineProperty(hmtx, "__esModule", {
  	  value: true
  	});
  	hmtx.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file hmtx 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6hmtx.html
  	 */
  	hmtx.default = _table.default.create('hmtx', [], {
  	  read: function read(reader, ttf) {
  	    var offset = this.offset;
  	    reader.seek(offset);
  	    var numOfLongHorMetrics = ttf.hhea.numOfLongHorMetrics;
  	    var hMetrics = [];
  	    var i;
  	    var hMetric;
  	    for (i = 0; i < numOfLongHorMetrics; ++i) {
  	      hMetric = {};
  	      hMetric.advanceWidth = reader.readUint16();
  	      hMetric.leftSideBearing = reader.readInt16();
  	      hMetrics.push(hMetric);
  	    }

  	    // 
  	    var advanceWidth = hMetrics[numOfLongHorMetrics - 1].advanceWidth;
  	    var numOfLast = ttf.maxp.numGlyphs - numOfLongHorMetrics;

  	    // hmetrics
  	    for (i = 0; i < numOfLast; ++i) {
  	      hMetric = {};
  	      hMetric.advanceWidth = advanceWidth;
  	      hMetric.leftSideBearing = reader.readInt16();
  	      hMetrics.push(hMetric);
  	    }
  	    return hMetrics;
  	  },
  	  write: function write(writer, ttf) {
  	    var i;
  	    var numOfLongHorMetrics = ttf.hhea.numOfLongHorMetrics;
  	    for (i = 0; i < numOfLongHorMetrics; ++i) {
  	      writer.writeUint16(ttf.glyf[i].advanceWidth);
  	      writer.writeInt16(ttf.glyf[i].leftSideBearing);
  	    }

  	    // 
  	    var numOfLast = ttf.glyf.length - numOfLongHorMetrics;
  	    for (i = 0; i < numOfLast; ++i) {
  	      writer.writeInt16(ttf.glyf[numOfLongHorMetrics + i].leftSideBearing);
  	    }
  	    return writer;
  	  },
  	  size: function size(ttf) {
  	    // advanceWidth
  	    var numOfLast = 0;
  	    // advanceWidth
  	    var advanceWidth = ttf.glyf[ttf.glyf.length - 1].advanceWidth;
  	    for (var i = ttf.glyf.length - 2; i >= 0; i--) {
  	      if (advanceWidth === ttf.glyf[i].advanceWidth) {
  	        numOfLast++;
  	      } else {
  	        break;
  	      }
  	    }
  	    ttf.hhea.numOfLongHorMetrics = ttf.glyf.length - numOfLast;
  	    return 4 * ttf.hhea.numOfLongHorMetrics + 2 * numOfLast;
  	  }
  	});
  	return hmtx;
  }

  var post = {};

  var hasRequiredPost;

  function requirePost () {
  	if (hasRequiredPost) return post;
  	hasRequiredPost = 1;

  	Object.defineProperty(post, "__esModule", {
  	  value: true
  	});
  	post.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	var _string = _interopRequireDefault(requireString$1());
  	var _unicodeName = _interopRequireDefault(requireUnicodeName());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file post 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6post.html
  	 */

  	var Posthead = _table.default.create('posthead', [['format', _struct.default.Fixed], ['italicAngle', _struct.default.Fixed], ['underlinePosition', _struct.default.Int16], ['underlineThickness', _struct.default.Int16], ['isFixedPitch', _struct.default.Uint32], ['minMemType42', _struct.default.Uint32], ['maxMemType42', _struct.default.Uint32], ['minMemType1', _struct.default.Uint32], ['maxMemType1', _struct.default.Uint32]]);
  	post.default = _table.default.create('post', [], {
  	  read: function read(reader, ttf) {
  	    var format = reader.readFixed(this.offset);
  	    // 
  	    var tbl = new Posthead(this.offset).read(reader, ttf);

  	    // format2
  	    if (format === 2) {
  	      var numberOfGlyphs = reader.readUint16();
  	      var glyphNameIndex = [];
  	      for (var i = 0; i < numberOfGlyphs; ++i) {
  	        glyphNameIndex.push(reader.readUint16());
  	      }
  	      var pascalStringOffset = reader.offset;
  	      var pascalStringLength = ttf.tables.post.length - (pascalStringOffset - this.offset);
  	      var pascalStringBytes = reader.readBytes(reader.offset, pascalStringLength);
  	      tbl.nameIndex = glyphNameIndex; // glyf
  	      tbl.names = _string.default.getPascalString(pascalStringBytes); // glyf
  	    }
  	    // deprecated
  	    else if (format === 2.5) {
  	      tbl.format = 3;
  	    }
  	    return tbl;
  	  },
  	  write: function write(writer, ttf) {
  	    var post = ttf.post || {
  	      format: 3
  	    };

  	    // write header
  	    writer.writeFixed(post.format); // format
  	    writer.writeFixed(post.italicAngle || 0); // italicAngle
  	    writer.writeInt16(post.underlinePosition || 0); // underlinePosition
  	    writer.writeInt16(post.underlineThickness || 0); // underlineThickness
  	    writer.writeUint32(post.isFixedPitch || 0); // isFixedPitch
  	    writer.writeUint32(post.minMemType42 || 0); // minMemType42
  	    writer.writeUint32(post.maxMemType42 || 0); // maxMemType42
  	    writer.writeUint32(post.minMemType1 || 0); // minMemType1
  	    writer.writeUint32(post.maxMemType1 || 0); // maxMemType1

  	    // version 3 post
  	    if (post.format === 2) {
  	      var numberOfGlyphs = ttf.glyf.length;
  	      writer.writeUint16(numberOfGlyphs); // numberOfGlyphs
  	      // write glyphNameIndex
  	      var nameIndex = ttf.support.post.nameIndex;
  	      for (var i = 0, l = nameIndex.length; i < l; i++) {
  	        writer.writeUint16(nameIndex[i]);
  	      }

  	      // write names
  	      ttf.support.post.names.forEach(function (name) {
  	        writer.writeBytes(name);
  	      });
  	    }
  	  },
  	  size: function size(ttf) {
  	    var numberOfGlyphs = ttf.glyf.length;
  	    ttf.post = ttf.post || {};
  	    ttf.post.format = ttf.post.format || 3;
  	    ttf.post.maxMemType1 = numberOfGlyphs;

  	    // version 3 post
  	    if (ttf.post.format === 3 || ttf.post.format === 1) {
  	      return 32;
  	    }

  	    // version 2
  	    var size = 34 + numberOfGlyphs * 2; // header + numberOfGlyphs + numberOfGlyphs * 2
  	    var glyphNames = [];
  	    var nameIndexArr = [];
  	    var nameIndex = 0;

  	    //  name
  	    for (var i = 0; i < numberOfGlyphs; i++) {
  	      // .notdef
  	      if (i === 0) {
  	        nameIndexArr.push(0);
  	      } else {
  	        var glyf = ttf.glyf[i];
  	        var unicode = glyf.unicode ? glyf.unicode[0] : 0;
  	        var unicodeNameIndex = _unicodeName.default[unicode];
  	        if (undefined !== unicodeNameIndex) {
  	          nameIndexArr.push(unicodeNameIndex);
  	        } else {
  	          // "" "\3" length0
  	          var name = glyf.name;
  	          if (!name || name.charCodeAt(0) < 32) {
  	            nameIndexArr.push(258 + nameIndex++);
  	            glyphNames.push([0]);
  	            size++;
  	          } else {
  	            nameIndexArr.push(258 + nameIndex++);
  	            var bytes = _string.default.toPascalStringBytes(name); // pascal string bytes
  	            glyphNames.push(bytes);
  	            size += bytes.length;
  	          }
  	        }
  	      }
  	    }
  	    ttf.support.post = {
  	      nameIndex: nameIndexArr,
  	      names: glyphNames
  	    };
  	    return size;
  	  }
  	});
  	return post;
  }

  var OS2 = {};

  var hasRequiredOS2;

  function requireOS2 () {
  	if (hasRequiredOS2) return OS2;
  	hasRequiredOS2 = 1;

  	Object.defineProperty(OS2, "__esModule", {
  	  value: true
  	});
  	OS2.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file OS/2
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * http://www.microsoft.com/typography/otspec/os2.htm
  	 */
  	OS2.default = _table.default.create('OS/2', [['version', _struct.default.Uint16], ['xAvgCharWidth', _struct.default.Int16], ['usWeightClass', _struct.default.Uint16], ['usWidthClass', _struct.default.Uint16], ['fsType', _struct.default.Uint16], ['ySubscriptXSize', _struct.default.Uint16], ['ySubscriptYSize', _struct.default.Uint16], ['ySubscriptXOffset', _struct.default.Uint16], ['ySubscriptYOffset', _struct.default.Uint16], ['ySuperscriptXSize', _struct.default.Uint16], ['ySuperscriptYSize', _struct.default.Uint16], ['ySuperscriptXOffset', _struct.default.Uint16], ['ySuperscriptYOffset', _struct.default.Uint16], ['yStrikeoutSize', _struct.default.Uint16], ['yStrikeoutPosition', _struct.default.Uint16], ['sFamilyClass', _struct.default.Uint16],
  	// Panose
  	['bFamilyType', _struct.default.Uint8], ['bSerifStyle', _struct.default.Uint8], ['bWeight', _struct.default.Uint8], ['bProportion', _struct.default.Uint8], ['bContrast', _struct.default.Uint8], ['bStrokeVariation', _struct.default.Uint8], ['bArmStyle', _struct.default.Uint8], ['bLetterform', _struct.default.Uint8], ['bMidline', _struct.default.Uint8], ['bXHeight', _struct.default.Uint8],
  	// unicode range
  	['ulUnicodeRange1', _struct.default.Uint32], ['ulUnicodeRange2', _struct.default.Uint32], ['ulUnicodeRange3', _struct.default.Uint32], ['ulUnicodeRange4', _struct.default.Uint32],
  	// char 4
  	['achVendID', _struct.default.String, 4], ['fsSelection', _struct.default.Uint16], ['usFirstCharIndex', _struct.default.Uint16], ['usLastCharIndex', _struct.default.Uint16], ['sTypoAscender', _struct.default.Int16], ['sTypoDescender', _struct.default.Int16], ['sTypoLineGap', _struct.default.Int16], ['usWinAscent', _struct.default.Uint16], ['usWinDescent', _struct.default.Uint16],
  	// version 0 above 39

  	['ulCodePageRange1', _struct.default.Uint32], ['ulCodePageRange2', _struct.default.Uint32],
  	// version 1 above 41

  	['sxHeight', _struct.default.Int16], ['sCapHeight', _struct.default.Int16], ['usDefaultChar', _struct.default.Uint16], ['usBreakChar', _struct.default.Uint16], ['usMaxContext', _struct.default.Uint16]
  	// version 2,3,4 above 46
  	], {
  	  read: function read(reader, ttf) {
  	    var format = reader.readUint16(this.offset);
  	    var struct = this.struct;

  	    // format2
  	    if (format === 0) {
  	      struct = struct.slice(0, 39);
  	    } else if (format === 1) {
  	      struct = struct.slice(0, 41);
  	    }
  	    var OS2Head = _table.default.create('os2head', struct);
  	    var tbl = new OS2Head(this.offset).read(reader, ttf);

  	    // version
  	    var os2Fields = {
  	      ulCodePageRange1: 1,
  	      ulCodePageRange2: 0,
  	      sxHeight: 0,
  	      sCapHeight: 0,
  	      usDefaultChar: 0,
  	      usBreakChar: 32,
  	      usMaxContext: 0
  	    };
  	    return Object.assign(os2Fields, tbl);
  	  },
  	  size: function size(ttf) {
  	    // 
  	    // header
  	    var xMin = 16384;
  	    var yMin = 16384;
  	    var xMax = -16384;
  	    var yMax = -16384;

  	    // hhea
  	    var advanceWidthMax = -1;
  	    var minLeftSideBearing = 16384;
  	    var minRightSideBearing = 16384;
  	    var xMaxExtent = -16384;

  	    // os2 count
  	    var xAvgCharWidth = 0;
  	    var usFirstCharIndex = 0x10FFFF;
  	    var usLastCharIndex = -1;

  	    // maxp
  	    var maxPoints = 0;
  	    var maxContours = 0;
  	    var maxCompositePoints = 0;
  	    var maxCompositeContours = 0;
  	    var maxSizeOfInstructions = 0;
  	    var maxComponentElements = 0;
  	    var glyfNotEmpty = 0; // glyf
  	    var hinting = ttf.writeOptions ? ttf.writeOptions.hinting : false;

  	    // instructionsfunctiondefs
  	    if (hinting) {
  	      if (ttf.cvt) {
  	        maxSizeOfInstructions = Math.max(maxSizeOfInstructions, ttf.cvt.length);
  	      }
  	      if (ttf.prep) {
  	        maxSizeOfInstructions = Math.max(maxSizeOfInstructions, ttf.prep.length);
  	      }
  	      if (ttf.fpgm) {
  	        maxSizeOfInstructions = Math.max(maxSizeOfInstructions, ttf.fpgm.length);
  	      }
  	    }
  	    ttf.glyf.forEach(function (glyf) {
  	      // control point
  	      if (glyf.compound) {
  	        var compositeContours = 0;
  	        var compositePoints = 0;
  	        glyf.glyfs.forEach(function (g) {
  	          var cglyf = ttf.glyf[g.glyphIndex];
  	          if (!cglyf) {
  	            return;
  	          }
  	          compositeContours += cglyf.contours ? cglyf.contours.length : 0;
  	          if (cglyf.contours && cglyf.contours.length) {
  	            cglyf.contours.forEach(function (contour) {
  	              compositePoints += contour.length;
  	            });
  	          }
  	        });
  	        maxComponentElements = Math.max(maxComponentElements, glyf.glyfs.length);
  	        maxCompositePoints = Math.max(maxCompositePoints, compositePoints);
  	        maxCompositeContours = Math.max(maxCompositeContours, compositeContours);
  	      }
  	      // 
  	      else if (glyf.contours && glyf.contours.length) {
  	        maxContours = Math.max(maxContours, glyf.contours.length);
  	        var points = 0;
  	        glyf.contours.forEach(function (contour) {
  	          points += contour.length;
  	        });
  	        maxPoints = Math.max(maxPoints, points);
  	      }
  	      if (hinting && glyf.instructions) {
  	        maxSizeOfInstructions = Math.max(maxSizeOfInstructions, glyf.instructions.length);
  	      }

  	      // 
  	      if (null != glyf.xMin && glyf.xMin < xMin) {
  	        xMin = glyf.xMin;
  	      }
  	      if (null != glyf.yMin && glyf.yMin < yMin) {
  	        yMin = glyf.yMin;
  	      }
  	      if (null != glyf.xMax && glyf.xMax > xMax) {
  	        xMax = glyf.xMax;
  	      }
  	      if (null != glyf.yMax && glyf.yMax > yMax) {
  	        yMax = glyf.yMax;
  	      }
  	      advanceWidthMax = Math.max(advanceWidthMax, glyf.advanceWidth);
  	      minLeftSideBearing = Math.min(minLeftSideBearing, glyf.leftSideBearing);
  	      if (null != glyf.xMax) {
  	        minRightSideBearing = Math.min(minRightSideBearing, glyf.advanceWidth - glyf.xMax);
  	        xMaxExtent = Math.max(xMaxExtent, glyf.xMax);
  	      }
  	      if (null != glyf.advanceWidth) {
  	        xAvgCharWidth += glyf.advanceWidth;
  	        glyfNotEmpty++;
  	      }
  	      var unicodes = glyf.unicode;
  	      if (typeof glyf.unicode === 'number') {
  	        unicodes = [glyf.unicode];
  	      }
  	      if (Array.isArray(unicodes)) {
  	        unicodes.forEach(function (unicode) {
  	          if (unicode !== 0xFFFF) {
  	            usFirstCharIndex = Math.min(usFirstCharIndex, unicode);
  	            usLastCharIndex = Math.max(usLastCharIndex, unicode);
  	          }
  	        });
  	      }
  	    });

  	    // version 4
  	    ttf['OS/2'].version = 0x4;
  	    ttf['OS/2'].achVendID = (ttf['OS/2'].achVendID + '    ').slice(0, 4);
  	    ttf['OS/2'].xAvgCharWidth = xAvgCharWidth / (glyfNotEmpty || 1);
  	    ttf['OS/2'].ulUnicodeRange2 = 268435456;
  	    ttf['OS/2'].usFirstCharIndex = usFirstCharIndex;
  	    ttf['OS/2'].usLastCharIndex = usLastCharIndex;

  	    // rewrite hhea
  	    ttf.hhea.version = ttf.hhea.version || 0x1;
  	    ttf.hhea.advanceWidthMax = advanceWidthMax;
  	    ttf.hhea.minLeftSideBearing = minLeftSideBearing;
  	    ttf.hhea.minRightSideBearing = minRightSideBearing;
  	    ttf.hhea.xMaxExtent = xMaxExtent;

  	    // rewrite head
  	    ttf.head.version = ttf.head.version || 0x1;
  	    ttf.head.lowestRecPPEM = ttf.head.lowestRecPPEM || 0x8;
  	    ttf.head.xMin = xMin;
  	    ttf.head.yMin = yMin;
  	    ttf.head.xMax = xMax;
  	    ttf.head.yMax = yMax;

  	    // head rewrite
  	    if (ttf.support.head) {
  	      var _ttf$support$head = ttf.support.head,
  	        _xMin = _ttf$support$head.xMin,
  	        _yMin = _ttf$support$head.yMin,
  	        _xMax = _ttf$support$head.xMax,
  	        _yMax = _ttf$support$head.yMax;
  	      if (_xMin != null) {
  	        ttf.head.xMin = _xMin;
  	      }
  	      if (_yMin != null) {
  	        ttf.head.yMin = _yMin;
  	      }
  	      if (_xMax != null) {
  	        ttf.head.xMax = _xMax;
  	      }
  	      if (_yMax != null) {
  	        ttf.head.yMax = _yMax;
  	      }
  	    }
  	    // hhea rewrite
  	    if (ttf.support.hhea) {
  	      var _ttf$support$hhea = ttf.support.hhea,
  	        _advanceWidthMax = _ttf$support$hhea.advanceWidthMax,
  	        _xMaxExtent = _ttf$support$hhea.xMaxExtent,
  	        _minLeftSideBearing = _ttf$support$hhea.minLeftSideBearing,
  	        _minRightSideBearing = _ttf$support$hhea.minRightSideBearing;
  	      if (_advanceWidthMax != null) {
  	        ttf.hhea.advanceWidthMax = _advanceWidthMax;
  	      }
  	      if (_xMaxExtent != null) {
  	        ttf.hhea.xMaxExtent = _xMaxExtent;
  	      }
  	      if (_minLeftSideBearing != null) {
  	        ttf.hhea.minLeftSideBearing = _minLeftSideBearing;
  	      }
  	      if (_minRightSideBearing != null) {
  	        ttf.hhea.minRightSideBearing = _minRightSideBearing;
  	      }
  	    }
  	    // maxpmaxpmaxp
  	    ttf.maxp = ttf.maxp || {};
  	    ttf.support.maxp = {
  	      version: 1.0,
  	      numGlyphs: ttf.glyf.length,
  	      maxPoints: maxPoints,
  	      maxContours: maxContours,
  	      maxCompositePoints: maxCompositePoints,
  	      maxCompositeContours: maxCompositeContours,
  	      maxZones: ttf.maxp.maxZones || 0,
  	      maxTwilightPoints: ttf.maxp.maxTwilightPoints || 0,
  	      maxStorage: ttf.maxp.maxStorage || 0,
  	      maxFunctionDefs: ttf.maxp.maxFunctionDefs || 0,
  	      maxStackElements: ttf.maxp.maxStackElements || 0,
  	      maxSizeOfInstructions: maxSizeOfInstructions,
  	      maxComponentElements: maxComponentElements,
  	      maxComponentDepth: maxComponentElements ? 1 : 0
  	    };
  	    return _table.default.size.call(this, ttf);
  	  }
  	});
  	return OS2;
  }

  var CFF = {};

  var encoding = {};

  var hasRequiredEncoding;

  function requireEncoding () {
  	if (hasRequiredEncoding) return encoding;
  	hasRequiredEncoding = 1;

  	Object.defineProperty(encoding, "__esModule", {
  	  value: true
  	});
  	encoding.default = void 0;
  	/**
  	 * @file cff
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var cffStandardEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger', 'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron', 'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '', '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '', 'lslash', 'oslash', 'oe', 'germandbls'];
  	var cffExpertEncoding = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader', 'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon', 'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl', 'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior', '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '', '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];
  	encoding.default = {
  	  standardEncoding: cffStandardEncoding,
  	  expertEncoding: cffExpertEncoding
  	};
  	return encoding;
  }

  var cffStandardStrings = {};

  var hasRequiredCffStandardStrings;

  function requireCffStandardStrings () {
  	if (hasRequiredCffStandardStrings) return cffStandardStrings;
  	hasRequiredCffStandardStrings = 1;

  	Object.defineProperty(cffStandardStrings, "__esModule", {
  	  value: true
  	});
  	cffStandardStrings.default = void 0;
  	/**
  	 * @file cffStandardStrings.js
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	var cffStandardStrings$1 = ['.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand', 'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE', 'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu', 'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn', 'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright', 'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex', 'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute', 'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute', 'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute', 'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave', 'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior', 'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior', 'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl', 'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall', 'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall', 'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall', 'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall', 'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall', 'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', 'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', 'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000', '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];
  	cffStandardStrings.default = cffStandardStrings$1;
  	return cffStandardStrings;
  }

  var parseCFFDict = {};

  var getCFFString = {};

  var hasRequiredGetCFFString;

  function requireGetCFFString () {
  	if (hasRequiredGetCFFString) return getCFFString;
  	hasRequiredGetCFFString = 1;

  	Object.defineProperty(getCFFString, "__esModule", {
  	  value: true
  	});
  	getCFFString.default = getCFFString$1;
  	var _cffStandardStrings = _interopRequireDefault(requireCffStandardStrings());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cff
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * cff
  	 *
  	 * @param  {Object} strings cff
  	 * @param  {number} index   
  	 * @return {number}         
  	 */
  	function getCFFString$1(strings, index) {
  	  if (index <= 390) {
  	    index = _cffStandardStrings.default[index];
  	  }
  	  // Strings below index 392 are standard CFF strings and are not encoded in the font.
  	  else {
  	    index = strings[index - 391];
  	  }
  	  return index;
  	}
  	return getCFFString;
  }

  var hasRequiredParseCFFDict;

  function requireParseCFFDict () {
  	if (hasRequiredParseCFFDict) return parseCFFDict;
  	hasRequiredParseCFFDict = 1;

  	Object.defineProperty(parseCFFDict, "__esModule", {
  	  value: true
  	});
  	parseCFFDict.default = void 0;
  	var _getCFFString = _interopRequireDefault(requireGetCFFString());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cffdict
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var TOP_DICT_META = [{
  	  name: 'version',
  	  op: 0,
  	  type: 'SID'
  	}, {
  	  name: 'notice',
  	  op: 1,
  	  type: 'SID'
  	}, {
  	  name: 'copyright',
  	  op: 1200,
  	  type: 'SID'
  	}, {
  	  name: 'fullName',
  	  op: 2,
  	  type: 'SID'
  	}, {
  	  name: 'familyName',
  	  op: 3,
  	  type: 'SID'
  	}, {
  	  name: 'weight',
  	  op: 4,
  	  type: 'SID'
  	}, {
  	  name: 'isFixedPitch',
  	  op: 1201,
  	  type: 'number',
  	  value: 0
  	}, {
  	  name: 'italicAngle',
  	  op: 1202,
  	  type: 'number',
  	  value: 0
  	}, {
  	  name: 'underlinePosition',
  	  op: 1203,
  	  type: 'number',
  	  value: -100
  	}, {
  	  name: 'underlineThickness',
  	  op: 1204,
  	  type: 'number',
  	  value: 50
  	}, {
  	  name: 'paintType',
  	  op: 1205,
  	  type: 'number',
  	  value: 0
  	}, {
  	  name: 'charstringType',
  	  op: 1206,
  	  type: 'number',
  	  value: 2
  	}, {
  	  name: 'fontMatrix',
  	  op: 1207,
  	  type: ['real', 'real', 'real', 'real', 'real', 'real'],
  	  value: [0.001, 0, 0, 0.001, 0, 0]
  	}, {
  	  name: 'uniqueId',
  	  op: 13,
  	  type: 'number'
  	}, {
  	  name: 'fontBBox',
  	  op: 5,
  	  type: ['number', 'number', 'number', 'number'],
  	  value: [0, 0, 0, 0]
  	}, {
  	  name: 'strokeWidth',
  	  op: 1208,
  	  type: 'number',
  	  value: 0
  	}, {
  	  name: 'xuid',
  	  op: 14,
  	  type: [],
  	  value: null
  	}, {
  	  name: 'charset',
  	  op: 15,
  	  type: 'offset',
  	  value: 0
  	}, {
  	  name: 'encoding',
  	  op: 16,
  	  type: 'offset',
  	  value: 0
  	}, {
  	  name: 'charStrings',
  	  op: 17,
  	  type: 'offset',
  	  value: 0
  	}, {
  	  name: 'private',
  	  op: 18,
  	  type: ['number', 'offset'],
  	  value: [0, 0]
  	}];
  	var PRIVATE_DICT_META = [{
  	  name: 'subrs',
  	  op: 19,
  	  type: 'offset',
  	  value: 0
  	}, {
  	  name: 'defaultWidthX',
  	  op: 20,
  	  type: 'number',
  	  value: 0
  	}, {
  	  name: 'nominalWidthX',
  	  op: 21,
  	  type: 'number',
  	  value: 0
  	}];
  	function entriesToObject(entries) {
  	  var hash = {};
  	  for (var i = 0, l = entries.length; i < l; i++) {
  	    var key = entries[i][0];
  	    if (undefined !== hash[key]) {
  	      console.warn('dict already has key:' + key);
  	      continue;
  	    }
  	    var values = entries[i][1];
  	    hash[key] = values.length === 1 ? values[0] : values;
  	  }
  	  return hash;
  	}

  	/* eslint-disable no-constant-condition */
  	function parseFloatOperand(reader) {
  	  var s = '';
  	  var eof = 15;
  	  var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
  	  while (true) {
  	    var b = reader.readUint8();
  	    var n1 = b >> 4;
  	    var n2 = b & 15;
  	    if (n1 === eof) {
  	      break;
  	    }
  	    s += lookup[n1];
  	    if (n2 === eof) {
  	      break;
  	    }
  	    s += lookup[n2];
  	  }
  	  return parseFloat(s);
  	}
  	/* eslint-enable no-constant-condition */

  	/**
  	 * cff
  	 *
  	 * @param  {Reader} reader 
  	 * @param  {number} b0     
  	 * @return {number}        
  	 */
  	function parseOperand(reader, b0) {
  	  var b1;
  	  var b2;
  	  var b3;
  	  var b4;
  	  if (b0 === 28) {
  	    b1 = reader.readUint8();
  	    b2 = reader.readUint8();
  	    return b1 << 8 | b2;
  	  }
  	  if (b0 === 29) {
  	    b1 = reader.readUint8();
  	    b2 = reader.readUint8();
  	    b3 = reader.readUint8();
  	    b4 = reader.readUint8();
  	    return b1 << 24 | b2 << 16 | b3 << 8 | b4;
  	  }
  	  if (b0 === 30) {
  	    return parseFloatOperand(reader);
  	  }
  	  if (b0 >= 32 && b0 <= 246) {
  	    return b0 - 139;
  	  }
  	  if (b0 >= 247 && b0 <= 250) {
  	    b1 = reader.readUint8();
  	    return (b0 - 247) * 256 + b1 + 108;
  	  }
  	  if (b0 >= 251 && b0 <= 254) {
  	    b1 = reader.readUint8();
  	    return -(b0 - 251) * 256 - b1 - 108;
  	  }
  	  throw new Error('invalid b0 ' + b0 + ',at:' + reader.offset);
  	}

  	/**
  	 * 
  	 *
  	 * @param  {Object} dict    
  	 * @param  {Array} meta    
  	 * @param  {Object} strings cff
  	 * @return {Object}         
  	 */
  	function interpretDict(dict, meta, strings) {
  	  var newDict = {};

  	  // Because we also want to include missing values, we start out from the meta list
  	  // and lookup values in the dict.
  	  for (var i = 0, l = meta.length; i < l; i++) {
  	    var m = meta[i];
  	    var value = dict[m.op];
  	    if (value === undefined) {
  	      value = m.value !== undefined ? m.value : null;
  	    }
  	    if (m.type === 'SID') {
  	      value = (0, _getCFFString.default)(strings, value);
  	    }
  	    newDict[m.name] = value;
  	  }
  	  return newDict;
  	}

  	/**
  	 * cff dict
  	 *
  	 * @param  {Reader} reader 
  	 * @param  {number} offset  
  	 * @param  {number} length   
  	 * @return {Object}        
  	 */
  	function parseCFFDict$1(reader, offset, length) {
  	  if (null != offset) {
  	    reader.seek(offset);
  	  }
  	  var entries = [];
  	  var operands = [];
  	  var lastOffset = reader.offset + (null != length ? length : reader.length);
  	  while (reader.offset < lastOffset) {
  	    var op = reader.readUint8();

  	    // The first byte for each dict item distinguishes between operator (key) and operand (value).
  	    // Values <= 21 are operators.
  	    if (op <= 21) {
  	      // Two-byte operators have an initial escape byte of 12.
  	      if (op === 12) {
  	        op = 1200 + reader.readUint8();
  	      }
  	      entries.push([op, operands]);
  	      operands = [];
  	    } else {
  	      // Since the operands (values) come before the operators (keys), we store all operands in a list
  	      // until we encounter an operator.
  	      operands.push(parseOperand(reader, op));
  	    }
  	  }
  	  return entriesToObject(entries);
  	}

  	/**
  	 * cff top
  	 *
  	 * @param  {Reader} reader  
  	 * @param  {number} start offset
  	 * @param  {number} length 
  	 * @param  {Object} strings 
  	 * @return {Object}         
  	 */
  	function parseTopDict(reader, start, length, strings) {
  	  var dict = parseCFFDict$1(reader, start || 0, length || reader.length);
  	  return interpretDict(dict, TOP_DICT_META, strings);
  	}

  	/**
  	 * cff
  	 *
  	 * @param  {Reader} reader  
  	 * @param  {number} start offset
  	 * @param  {number} length 
  	 * @param  {Object} strings 
  	 * @return {Object}         
  	 */
  	function parsePrivateDict(reader, start, length, strings) {
  	  var dict = parseCFFDict$1(reader, start || 0, length || reader.length);
  	  return interpretDict(dict, PRIVATE_DICT_META, strings);
  	}
  	parseCFFDict.default = {
  	  parseTopDict: parseTopDict,
  	  parsePrivateDict: parsePrivateDict
  	};
  	return parseCFFDict;
  }

  var parseCFFGlyph = {};

  var hasRequiredParseCFFGlyph;

  function requireParseCFFGlyph () {
  	if (hasRequiredParseCFFGlyph) return parseCFFGlyph;
  	hasRequiredParseCFFGlyph = 1;

  	Object.defineProperty(parseCFFGlyph, "__esModule", {
  	  value: true
  	});
  	parseCFFGlyph.default = parseCFFCharstring;
  	/**
  	 * @file cff
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * cffbezier
  	 *
  	 * @param  {Array} code  
  	 * @param  {Object} font  font
  	 * @param  {number} index glyf
  	 * @return {Object}       glyf
  	 */
  	function parseCFFCharstring(code, font, index) {
  	  var c1x;
  	  var c1y;
  	  var c2x;
  	  var c2y;
  	  var contours = [];
  	  var contour = [];
  	  var stack = [];
  	  var glyfs = [];
  	  var nStems = 0;
  	  var haveWidth = false;
  	  var width = font.defaultWidthX;
  	  var open = false;
  	  var x = 0;
  	  var y = 0;
  	  function lineTo(x, y) {
  	    contour.push({
  	      onCurve: true,
  	      x: x,
  	      y: y
  	    });
  	  }
  	  function curveTo(c1x, c1y, c2x, c2y, x, y) {
  	    contour.push({
  	      x: c1x,
  	      y: c1y
  	    });
  	    contour.push({
  	      x: c2x,
  	      y: c2y
  	    });
  	    contour.push({
  	      onCurve: true,
  	      x: x,
  	      y: y
  	    });
  	  }
  	  function newContour(x, y) {
  	    if (open) {
  	      contours.push(contour);
  	    }
  	    contour = [];
  	    lineTo(x, y);
  	    open = true;
  	  }
  	  function parseStems() {
  	    // The number of stem operators on the stack is always even.
  	    // If the value is uneven, that means a width is specified.
  	    var hasWidthArg = stack.length % 2 !== 0;
  	    if (hasWidthArg && !haveWidth) {
  	      width = stack.shift() + font.nominalWidthX;
  	    }
  	    nStems += stack.length >> 1;
  	    stack.length = 0;
  	    haveWidth = true;
  	  }
  	  function parse(code) {
  	    var b1;
  	    var b2;
  	    var b3;
  	    var b4;
  	    var codeIndex;
  	    var subrCode;
  	    var jpx;
  	    var jpy;
  	    var c3x;
  	    var c3y;
  	    var c4x;
  	    var c4y;
  	    var i = 0;
  	    while (i < code.length) {
  	      var v = code[i];
  	      i += 1;
  	      switch (v) {
  	        case 1:
  	          // hstem
  	          parseStems();
  	          break;
  	        case 3:
  	          // vstem
  	          parseStems();
  	          break;
  	        case 4:
  	          // vmoveto
  	          if (stack.length > 1 && !haveWidth) {
  	            width = stack.shift() + font.nominalWidthX;
  	            haveWidth = true;
  	          }
  	          y += stack.pop();
  	          newContour(x, y);
  	          break;
  	        case 5:
  	          // rlineto
  	          while (stack.length > 0) {
  	            x += stack.shift();
  	            y += stack.shift();
  	            lineTo(x, y);
  	          }
  	          break;
  	        case 6:
  	          // hlineto
  	          while (stack.length > 0) {
  	            x += stack.shift();
  	            lineTo(x, y);
  	            if (stack.length === 0) {
  	              break;
  	            }
  	            y += stack.shift();
  	            lineTo(x, y);
  	          }
  	          break;
  	        case 7:
  	          // vlineto
  	          while (stack.length > 0) {
  	            y += stack.shift();
  	            lineTo(x, y);
  	            if (stack.length === 0) {
  	              break;
  	            }
  	            x += stack.shift();
  	            lineTo(x, y);
  	          }
  	          break;
  	        case 8:
  	          // rrcurveto
  	          while (stack.length > 0) {
  	            c1x = x + stack.shift();
  	            c1y = y + stack.shift();
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            x = c2x + stack.shift();
  	            y = c2y + stack.shift();
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	          }
  	          break;
  	        case 10:
  	          // callsubr
  	          codeIndex = stack.pop() + font.subrsBias;
  	          subrCode = font.subrs[codeIndex];
  	          if (subrCode) {
  	            parse(subrCode);
  	          }
  	          break;
  	        case 11:
  	          // return
  	          return;
  	        case 12:
  	          // flex operators
  	          v = code[i];
  	          i += 1;
  	          switch (v) {
  	            case 35:
  	              // flex
  	              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
  	              c1x = x + stack.shift(); // dx1
  	              c1y = y + stack.shift(); // dy1
  	              c2x = c1x + stack.shift(); // dx2
  	              c2y = c1y + stack.shift(); // dy2
  	              jpx = c2x + stack.shift(); // dx3
  	              jpy = c2y + stack.shift(); // dy3
  	              c3x = jpx + stack.shift(); // dx4
  	              c3y = jpy + stack.shift(); // dy4
  	              c4x = c3x + stack.shift(); // dx5
  	              c4y = c3y + stack.shift(); // dy5
  	              x = c4x + stack.shift(); // dx6
  	              y = c4y + stack.shift(); // dy6
  	              stack.shift(); // flex depth
  	              curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	              curveTo(c3x, c3y, c4x, c4y, x, y);
  	              break;
  	            case 34:
  	              // hflex
  	              // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
  	              c1x = x + stack.shift(); // dx1
  	              c1y = y; // dy1
  	              c2x = c1x + stack.shift(); // dx2
  	              c2y = c1y + stack.shift(); // dy2
  	              jpx = c2x + stack.shift(); // dx3
  	              jpy = c2y; // dy3
  	              c3x = jpx + stack.shift(); // dx4
  	              c3y = c2y; // dy4
  	              c4x = c3x + stack.shift(); // dx5
  	              c4y = y; // dy5
  	              x = c4x + stack.shift(); // dx6
  	              curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	              curveTo(c3x, c3y, c4x, c4y, x, y);
  	              break;
  	            case 36:
  	              // hflex1
  	              // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
  	              c1x = x + stack.shift(); // dx1
  	              c1y = y + stack.shift(); // dy1
  	              c2x = c1x + stack.shift(); // dx2
  	              c2y = c1y + stack.shift(); // dy2
  	              jpx = c2x + stack.shift(); // dx3
  	              jpy = c2y; // dy3
  	              c3x = jpx + stack.shift(); // dx4
  	              c3y = c2y; // dy4
  	              c4x = c3x + stack.shift(); // dx5
  	              c4y = c3y + stack.shift(); // dy5
  	              x = c4x + stack.shift(); // dx6
  	              curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	              curveTo(c3x, c3y, c4x, c4y, x, y);
  	              break;
  	            case 37:
  	              // flex1
  	              // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
  	              c1x = x + stack.shift(); // dx1
  	              c1y = y + stack.shift(); // dy1
  	              c2x = c1x + stack.shift(); // dx2
  	              c2y = c1y + stack.shift(); // dy2
  	              jpx = c2x + stack.shift(); // dx3
  	              jpy = c2y + stack.shift(); // dy3
  	              c3x = jpx + stack.shift(); // dx4
  	              c3y = jpy + stack.shift(); // dy4
  	              c4x = c3x + stack.shift(); // dx5
  	              c4y = c3y + stack.shift(); // dy5
  	              if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
  	                x = c4x + stack.shift();
  	              } else {
  	                y = c4y + stack.shift();
  	              }
  	              curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
  	              curveTo(c3x, c3y, c4x, c4y, x, y);
  	              break;
  	            default:
  	              console.warn('Glyph ' + index + ': unknown operator ' + (1200 + v));
  	              stack.length = 0;
  	          }
  	          break;
  	        case 14:
  	          // endchar
  	          if (stack.length === 1 && !haveWidth) {
  	            width = stack.shift() + font.nominalWidthX;
  	            haveWidth = true;
  	          } else if (stack.length === 4) {
  	            glyfs[1] = {
  	              glyphIndex: font.charset.indexOf(font.encoding[stack.pop()]),
  	              transform: {
  	                a: 1,
  	                b: 0,
  	                c: 0,
  	                d: 1,
  	                e: 0,
  	                f: 0
  	              }
  	            };
  	            glyfs[0] = {
  	              glyphIndex: font.charset.indexOf(font.encoding[stack.pop()]),
  	              transform: {
  	                a: 1,
  	                b: 0,
  	                c: 0,
  	                d: 1,
  	                e: 0,
  	                f: 0
  	              }
  	            };
  	            glyfs[1].transform.f = stack.pop();
  	            glyfs[1].transform.e = stack.pop();
  	          } else if (stack.length === 5) {
  	            if (!haveWidth) {
  	              width = stack.shift() + font.nominalWidthX;
  	            }
  	            haveWidth = true;
  	            glyfs[1] = {
  	              glyphIndex: font.charset.indexOf(font.encoding[stack.pop()]),
  	              transform: {
  	                a: 1,
  	                b: 0,
  	                c: 0,
  	                d: 1,
  	                e: 0,
  	                f: 0
  	              }
  	            };
  	            glyfs[0] = {
  	              glyphIndex: font.charset.indexOf(font.encoding[stack.pop()]),
  	              transform: {
  	                a: 1,
  	                b: 0,
  	                c: 0,
  	                d: 1,
  	                e: 0,
  	                f: 0
  	              }
  	            };
  	            glyfs[1].transform.f = stack.pop();
  	            glyfs[1].transform.e = stack.pop();
  	          }
  	          if (open) {
  	            contours.push(contour);
  	            open = false;
  	          }
  	          break;
  	        case 18:
  	          // hstemhm
  	          parseStems();
  	          break;
  	        case 19: // hintmask
  	        case 20:
  	          // cntrmask
  	          parseStems();
  	          i += nStems + 7 >> 3;
  	          break;
  	        case 21:
  	          // rmoveto
  	          if (stack.length > 2 && !haveWidth) {
  	            width = stack.shift() + font.nominalWidthX;
  	            haveWidth = true;
  	          }
  	          y += stack.pop();
  	          x += stack.pop();
  	          newContour(x, y);
  	          break;
  	        case 22:
  	          // hmoveto
  	          if (stack.length > 1 && !haveWidth) {
  	            width = stack.shift() + font.nominalWidthX;
  	            haveWidth = true;
  	          }
  	          x += stack.pop();
  	          newContour(x, y);
  	          break;
  	        case 23:
  	          // vstemhm
  	          parseStems();
  	          break;
  	        case 24:
  	          // rcurveline
  	          while (stack.length > 2) {
  	            c1x = x + stack.shift();
  	            c1y = y + stack.shift();
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            x = c2x + stack.shift();
  	            y = c2y + stack.shift();
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	          }
  	          x += stack.shift();
  	          y += stack.shift();
  	          lineTo(x, y);
  	          break;
  	        case 25:
  	          // rlinecurve
  	          while (stack.length > 6) {
  	            x += stack.shift();
  	            y += stack.shift();
  	            lineTo(x, y);
  	          }
  	          c1x = x + stack.shift();
  	          c1y = y + stack.shift();
  	          c2x = c1x + stack.shift();
  	          c2y = c1y + stack.shift();
  	          x = c2x + stack.shift();
  	          y = c2y + stack.shift();
  	          curveTo(c1x, c1y, c2x, c2y, x, y);
  	          break;
  	        case 26:
  	          // vvcurveto
  	          if (stack.length % 2) {
  	            x += stack.shift();
  	          }
  	          while (stack.length > 0) {
  	            c1x = x;
  	            c1y = y + stack.shift();
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            x = c2x;
  	            y = c2y + stack.shift();
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	          }
  	          break;
  	        case 27:
  	          // hhcurveto
  	          if (stack.length % 2) {
  	            y += stack.shift();
  	          }
  	          while (stack.length > 0) {
  	            c1x = x + stack.shift();
  	            c1y = y;
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            x = c2x + stack.shift();
  	            y = c2y;
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	          }
  	          break;
  	        case 28:
  	          // shortint
  	          b1 = code[i];
  	          b2 = code[i + 1];
  	          stack.push((b1 << 24 | b2 << 16) >> 16);
  	          i += 2;
  	          break;
  	        case 29:
  	          // callgsubr
  	          codeIndex = stack.pop() + font.gsubrsBias;
  	          subrCode = font.gsubrs[codeIndex];
  	          if (subrCode) {
  	            parse(subrCode);
  	          }
  	          break;
  	        case 30:
  	          // vhcurveto
  	          while (stack.length > 0) {
  	            c1x = x;
  	            c1y = y + stack.shift();
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            x = c2x + stack.shift();
  	            y = c2y + (stack.length === 1 ? stack.shift() : 0);
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	            if (stack.length === 0) {
  	              break;
  	            }
  	            c1x = x + stack.shift();
  	            c1y = y;
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            y = c2y + stack.shift();
  	            x = c2x + (stack.length === 1 ? stack.shift() : 0);
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	          }
  	          break;
  	        case 31:
  	          // hvcurveto
  	          while (stack.length > 0) {
  	            c1x = x + stack.shift();
  	            c1y = y;
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            y = c2y + stack.shift();
  	            x = c2x + (stack.length === 1 ? stack.shift() : 0);
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	            if (stack.length === 0) {
  	              break;
  	            }
  	            c1x = x;
  	            c1y = y + stack.shift();
  	            c2x = c1x + stack.shift();
  	            c2y = c1y + stack.shift();
  	            x = c2x + stack.shift();
  	            y = c2y + (stack.length === 1 ? stack.shift() : 0);
  	            curveTo(c1x, c1y, c2x, c2y, x, y);
  	          }
  	          break;
  	        default:
  	          if (v < 32) {
  	            console.warn('Glyph ' + index + ': unknown operator ' + v);
  	          } else if (v < 247) {
  	            stack.push(v - 139);
  	          } else if (v < 251) {
  	            b1 = code[i];
  	            i += 1;
  	            stack.push((v - 247) * 256 + b1 + 108);
  	          } else if (v < 255) {
  	            b1 = code[i];
  	            i += 1;
  	            stack.push(-(v - 251) * 256 - b1 - 108);
  	          } else {
  	            b1 = code[i];
  	            b2 = code[i + 1];
  	            b3 = code[i + 2];
  	            b4 = code[i + 3];
  	            i += 4;
  	            stack.push((b1 << 24 | b2 << 16 | b3 << 8 | b4) / 65536);
  	          }
  	      }
  	    }
  	  }
  	  parse(code);
  	  var glyf = {
  	    // 
  	    contours: contours.map(function (contour) {
  	      var last = contour.length - 1;
  	      if (contour[0].x === contour[last].x && contour[0].y === contour[last].y) {
  	        contour.splice(last, 1);
  	      }
  	      return contour;
  	    }),
  	    advanceWidth: width
  	  };
  	  if (glyfs.length) {
  	    glyf.compound = true;
  	    glyf.glyfs = glyfs;
  	  }
  	  return glyf;
  	}
  	return parseCFFGlyph;
  }

  var parseCFFCharset = {};

  var hasRequiredParseCFFCharset;

  function requireParseCFFCharset () {
  	if (hasRequiredParseCFFCharset) return parseCFFCharset;
  	hasRequiredParseCFFCharset = 1;

  	Object.defineProperty(parseCFFCharset, "__esModule", {
  	  value: true
  	});
  	parseCFFCharset.default = parseCFFCharset$1;
  	var _getCFFString = _interopRequireDefault(requireGetCFFString());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cff
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * cff
  	 * See Adobe TN #5176 chapter 13, "Charsets".
  	 *
  	 * @param  {Reader} reader  
  	 * @param  {number} start   
  	 * @param  {number} nGlyphs 
  	 * @param  {Object} strings cff
  	 * @return {Array}         
  	 */
  	function parseCFFCharset$1(reader, start, nGlyphs, strings) {
  	  if (start) {
  	    reader.seek(start);
  	  }
  	  var i;
  	  var sid;
  	  var count;
  	  // The .notdef glyph is not included, so subtract 1.
  	  nGlyphs -= 1;
  	  var charset = ['.notdef'];
  	  var format = reader.readUint8();
  	  if (format === 0) {
  	    for (i = 0; i < nGlyphs; i += 1) {
  	      sid = reader.readUint16();
  	      charset.push((0, _getCFFString.default)(strings, sid));
  	    }
  	  } else if (format === 1) {
  	    while (charset.length <= nGlyphs) {
  	      sid = reader.readUint16();
  	      count = reader.readUint8();
  	      for (i = 0; i <= count; i += 1) {
  	        charset.push((0, _getCFFString.default)(strings, sid));
  	        sid += 1;
  	      }
  	    }
  	  } else if (format === 2) {
  	    while (charset.length <= nGlyphs) {
  	      sid = reader.readUint16();
  	      count = reader.readUint16();
  	      for (i = 0; i <= count; i += 1) {
  	        charset.push((0, _getCFFString.default)(strings, sid));
  	        sid += 1;
  	      }
  	    }
  	  } else {
  	    throw new Error('Unknown charset format ' + format);
  	  }
  	  return charset;
  	}
  	return parseCFFCharset;
  }

  var parseCFFEncoding = {};

  var hasRequiredParseCFFEncoding;

  function requireParseCFFEncoding () {
  	if (hasRequiredParseCFFEncoding) return parseCFFEncoding;
  	hasRequiredParseCFFEncoding = 1;

  	Object.defineProperty(parseCFFEncoding, "__esModule", {
  	  value: true
  	});
  	parseCFFEncoding.default = parseCFFEncoding$1;
  	/**
  	 * @file cff
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * cff encoding
  	 * See Adobe TN #5176 chapter 12, "Encodings".
  	 *
  	 * @param  {Reader} reader 
  	 * @param  {number=} start  
  	 * @return {Object}        
  	 */
  	function parseCFFEncoding$1(reader, start) {
  	  if (null != start) {
  	    reader.seek(start);
  	  }
  	  var i;
  	  var code;
  	  var encoding = {};
  	  var format = reader.readUint8();
  	  if (format === 0) {
  	    var nCodes = reader.readUint8();
  	    for (i = 0; i < nCodes; i += 1) {
  	      code = reader.readUint8();
  	      encoding[code] = i;
  	    }
  	  } else if (format === 1) {
  	    var nRanges = reader.readUint8();
  	    code = 1;
  	    for (i = 0; i < nRanges; i += 1) {
  	      var first = reader.readUint8();
  	      var nLeft = reader.readUint8();
  	      for (var j = first; j <= first + nLeft; j += 1) {
  	        encoding[j] = code;
  	        code += 1;
  	      }
  	    }
  	  } else {
  	    console.warn('unknown encoding format:' + format);
  	  }
  	  return encoding;
  	}
  	return parseCFFEncoding;
  }

  var hasRequiredCFF;

  function requireCFF () {
  	if (hasRequiredCFF) return CFF;
  	hasRequiredCFF = 1;

  	Object.defineProperty(CFF, "__esModule", {
  	  value: true
  	});
  	CFF.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _string = _interopRequireDefault(requireString$1());
  	var _encoding = _interopRequireDefault(requireEncoding());
  	var _cffStandardStrings = _interopRequireDefault(requireCffStandardStrings());
  	var _parseCFFDict = _interopRequireDefault(requireParseCFFDict());
  	var _parseCFFGlyph = _interopRequireDefault(requireParseCFFGlyph());
  	var _parseCFFCharset = _interopRequireDefault(requireParseCFFCharset());
  	var _parseCFFEncoding = _interopRequireDefault(requireParseCFFEncoding());
  	var _reader = _interopRequireDefault(requireReader());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cff
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * reference:
  	 * http://wwwimages.adobe.com/content/dam/Adobe/en/devnet/font/pdfs/5176.CFF.pdf
  	 *
  	 * modify from:
  	 * https://github.com/nodebox/opentype.js/blob/master/src/tables/cff.js
  	 */

  	/**
  	 * cff
  	 *
  	 * @param  {Reader} reader  
  	 * @param  {number} offSize 
  	 * @param  {number} offset  
  	 * @return {number}         
  	 */
  	function getOffset(reader, offSize) {
  	  var v = 0;
  	  for (var i = 0; i < offSize; i++) {
  	    v <<= 8;
  	    v += reader.readUint8();
  	  }
  	  return v;
  	}

  	/**
  	 * cff
  	 *
  	 * @param  {Reader} reader 
  	 * @return {Object}        
  	 */
  	function parseCFFHead(reader) {
  	  var head = {};
  	  head.startOffset = reader.offset;
  	  head.endOffset = head.startOffset + 4;
  	  head.formatMajor = reader.readUint8();
  	  head.formatMinor = reader.readUint8();
  	  head.size = reader.readUint8();
  	  head.offsetSize = reader.readUint8();
  	  return head;
  	}

  	/**
  	 * `CFF`
  	 *
  	 * @param  {Reader} reader       
  	 * @param  {number} offset       
  	 * @param  {Funciton} conversionFn 
  	 * @return {Object}              
  	 */
  	function parseCFFIndex(reader, offset, conversionFn) {
  	  if (offset) {
  	    reader.seek(offset);
  	  }
  	  var start = reader.offset;
  	  var offsets = [];
  	  var objects = [];
  	  var count = reader.readUint16();
  	  var i;
  	  var l;
  	  if (count !== 0) {
  	    var offsetSize = reader.readUint8();
  	    for (i = 0, l = count + 1; i < l; i++) {
  	      offsets.push(getOffset(reader, offsetSize));
  	    }
  	    for (i = 0, l = count; i < l; i++) {
  	      var value = reader.readBytes(offsets[i + 1] - offsets[i]);
  	      if (conversionFn) {
  	        value = conversionFn(value);
  	      }
  	      objects.push(value);
  	    }
  	  }
  	  return {
  	    objects: objects,
  	    startOffset: start,
  	    endOffset: reader.offset
  	  };
  	}

  	// Subroutines are encoded using the negative half of the number space.
  	// See type 2 chapter 4.7 "Subroutine operators".
  	function calcCFFSubroutineBias(subrs) {
  	  var bias;
  	  if (subrs.length < 1240) {
  	    bias = 107;
  	  } else if (subrs.length < 33900) {
  	    bias = 1131;
  	  } else {
  	    bias = 32768;
  	  }
  	  return bias;
  	}
  	CFF.default = _table.default.create('cff', [], {
  	  read: function read(reader, font) {
  	    var offset = this.offset;
  	    reader.seek(offset);
  	    var head = parseCFFHead(reader);
  	    var nameIndex = parseCFFIndex(reader, head.endOffset, _string.default.getString);
  	    var topDictIndex = parseCFFIndex(reader, nameIndex.endOffset);
  	    var stringIndex = parseCFFIndex(reader, topDictIndex.endOffset, _string.default.getString);
  	    var globalSubrIndex = parseCFFIndex(reader, stringIndex.endOffset);
  	    var cff = {
  	      head: head
  	    };

  	    // glyf
  	    cff.gsubrs = globalSubrIndex.objects;
  	    cff.gsubrsBias = calcCFFSubroutineBias(globalSubrIndex.objects);

  	    // 
  	    var dictReader = new _reader.default(new Uint8Array(topDictIndex.objects[0]).buffer);
  	    var topDict = _parseCFFDict.default.parseTopDict(dictReader, 0, dictReader.length, stringIndex.objects);
  	    cff.topDict = topDict;

  	    // 
  	    var privateDictLength = topDict.private[0];
  	    var privateDict = {};
  	    var privateDictOffset;
  	    if (privateDictLength) {
  	      privateDictOffset = offset + topDict.private[1];
  	      privateDict = _parseCFFDict.default.parsePrivateDict(reader, privateDictOffset, privateDictLength, stringIndex.objects);
  	      cff.defaultWidthX = privateDict.defaultWidthX;
  	      cff.nominalWidthX = privateDict.nominalWidthX;
  	    } else {
  	      cff.defaultWidthX = 0;
  	      cff.nominalWidthX = 0;
  	    }

  	    // glyf
  	    if (privateDict.subrs) {
  	      var subrOffset = privateDictOffset + privateDict.subrs;
  	      var subrIndex = parseCFFIndex(reader, subrOffset);
  	      cff.subrs = subrIndex.objects;
  	      cff.subrsBias = calcCFFSubroutineBias(cff.subrs);
  	    } else {
  	      cff.subrs = [];
  	      cff.subrsBias = 0;
  	    }
  	    cff.privateDict = privateDict;

  	    // glyf
  	    var charStringsIndex = parseCFFIndex(reader, offset + topDict.charStrings);
  	    var nGlyphs = charStringsIndex.objects.length;
  	    if (topDict.charset < 3) {
  	      // @author: fr33z00
  	      // See end of chapter 13 (p22) of #5176.CFF.pdf :
  	      // Still more optimization is possible by
  	      // observing that many fonts adopt one of 3 common charsets. In
  	      // these cases the operand to the charset operator in the Top DICT
  	      // specifies a predefined charset id, in place of an offset, as shown in table 22
  	      cff.charset = _cffStandardStrings.default;
  	    } else {
  	      cff.charset = (0, _parseCFFCharset.default)(reader, offset + topDict.charset, nGlyphs, stringIndex.objects);
  	    }

  	    // Standard encoding
  	    if (topDict.encoding === 0) {
  	      cff.encoding = _encoding.default.standardEncoding;
  	    }
  	    // Expert encoding
  	    else if (topDict.encoding === 1) {
  	      cff.encoding = _encoding.default.expertEncoding;
  	    } else {
  	      cff.encoding = (0, _parseCFFEncoding.default)(reader, offset + topDict.encoding);
  	    }
  	    cff.glyf = [];

  	    // only parse subset glyphs
  	    var subset = font.readOptions.subset;
  	    if (subset && subset.length > 0) {
  	      // subset map
  	      var subsetMap = {
  	        0: true // .notdef
  	      };
  	      var codes = font.cmap;

  	      // unicode to index
  	      Object.keys(codes).forEach(function (c) {
  	        if (subset.indexOf(+c) > -1) {
  	          var i = codes[c];
  	          subsetMap[i] = true;
  	        }
  	      });
  	      font.subsetMap = subsetMap;
  	      Object.keys(subsetMap).forEach(function (i) {
  	        i = +i;
  	        var glyf = (0, _parseCFFGlyph.default)(charStringsIndex.objects[i], cff, i);
  	        glyf.name = cff.charset[i];
  	        cff.glyf[i] = glyf;
  	      });
  	    }
  	    // parse all
  	    else {
  	      for (var i = 0, l = nGlyphs; i < l; i++) {
  	        var glyf = (0, _parseCFFGlyph.default)(charStringsIndex.objects[i], cff, i);
  	        glyf.name = cff.charset[i];
  	        cff.glyf.push(glyf);
  	      }
  	    }
  	    return cff;
  	  },
  	  // eslint-disable-next-line no-unused-vars
  	  write: function write(writer, font) {
  	    throw new Error('not support write cff table');
  	  },
  	  // eslint-disable-next-line no-unused-vars
  	  size: function size(font) {
  	    throw new Error('not support get cff table size');
  	  }
  	});
  	return CFF;
  }

  var GPOS = {};

  var hasRequiredGPOS;

  function requireGPOS () {
  	if (hasRequiredGPOS) return GPOS;
  	hasRequiredGPOS = 1;

  	Object.defineProperty(GPOS, "__esModule", {
  	  value: true
  	});
  	GPOS.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file GPOS
  	 * @author fr33z00(https://github.com/fr33z00)
  	 *
  	 * @reference: https://learn.microsoft.com/en-us/typography/opentype/spec/gpos
  	 */
  	GPOS.default = _table.default.create('GPOS', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.GPOS.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.GPOS) {
  	      writer.writeBytes(ttf.GPOS, ttf.GPOS.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.GPOS ? ttf.GPOS.length : 0;
  	  }
  	});
  	return GPOS;
  }

  var kern = {};

  var hasRequiredKern;

  function requireKern () {
  	if (hasRequiredKern) return kern;
  	hasRequiredKern = 1;

  	Object.defineProperty(kern, "__esModule", {
  	  value: true
  	});
  	kern.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file kern
  	 * @author fr33z00(https://github.com/fr33z00)
  	 *
  	 * @reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
  	 */
  	kern.default = _table.default.create('kern', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.kern.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.kern) {
  	      writer.writeBytes(ttf.kern, ttf.kern.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.kern ? ttf.kern.length : 0;
  	  }
  	});
  	return kern;
  }

  var hasRequiredSupportOtf;

  function requireSupportOtf () {
  	if (hasRequiredSupportOtf) return supportOtf;
  	hasRequiredSupportOtf = 1;

  	Object.defineProperty(supportOtf, "__esModule", {
  	  value: true
  	});
  	supportOtf.default = void 0;
  	var _head = _interopRequireDefault(requireHead());
  	var _maxp = _interopRequireDefault(requireMaxp());
  	var _cmap = _interopRequireDefault(requireCmap());
  	var _name = _interopRequireDefault(requireName());
  	var _hhea = _interopRequireDefault(requireHhea());
  	var _hmtx = _interopRequireDefault(requireHmtx());
  	var _post = _interopRequireDefault(requirePost());
  	var _OS = _interopRequireDefault(requireOS2());
  	var _CFF = _interopRequireDefault(requireCFF());
  	var _GPOS = _interopRequireDefault(requireGPOS());
  	var _kern = _interopRequireDefault(requireKern());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file otf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	supportOtf.default = {
  	  head: _head.default,
  	  maxp: _maxp.default,
  	  cmap: _cmap.default,
  	  name: _name.default,
  	  hhea: _hhea.default,
  	  hmtx: _hmtx.default,
  	  post: _post.default,
  	  'OS/2': _OS.default,
  	  CFF: _CFF.default,
  	  GPOS: _GPOS.default,
  	  kern: _kern.default
  	};
  	return supportOtf;
  }

  var hasRequiredOtfreader;

  function requireOtfreader () {
  	if (hasRequiredOtfreader) return otfreader;
  	hasRequiredOtfreader = 1;

  	Object.defineProperty(otfreader, "__esModule", {
  	  value: true
  	});
  	otfreader.default = void 0;
  	var _directory = _interopRequireDefault(requireDirectory());
  	var _supportOtf = _interopRequireDefault(requireSupportOtf());
  	var _reader = _interopRequireDefault(requireReader());
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
  	 * @file otf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	otfreader.default = /*#__PURE__*/function () {
  	  /**
  	   * OTF
  	   *
  	   * @param {Object} options 
  	   * @constructor
  	   */
  	  function OTFReader() {
  	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	    _classCallCheck(this, OTFReader);
  	    options.subset = options.subset || [];
  	    this.options = options;
  	  }

  	  /**
  	   * 
  	   *
  	   * @param {ArrayBuffer} buffer buffer
  	   * @return {Object} ttf
  	   */
  	  return _createClass(OTFReader, [{
  	    key: "readBuffer",
  	    value: function readBuffer(buffer) {
  	      var reader = new _reader.default(buffer, 0, buffer.byteLength, false);
  	      var font = {};

  	      // version
  	      font.version = reader.readString(0, 4);
  	      if (font.version !== 'OTTO') {
  	        _error.default.raise(10301);
  	      }

  	      // num tables
  	      font.numTables = reader.readUint16();
  	      if (font.numTables <= 0 || font.numTables > 100) {
  	        _error.default.raise(10302);
  	      }

  	      // searchRange
  	      font.searchRange = reader.readUint16();

  	      // entrySelector
  	      font.entrySelector = reader.readUint16();

  	      // rangeShift
  	      font.rangeShift = reader.readUint16();
  	      font.tables = new _directory.default(reader.offset).read(reader, font);
  	      if (!font.tables.head || !font.tables.cmap || !font.tables.CFF) {
  	        _error.default.raise(10302);
  	      }
  	      font.readOptions = this.options;

  	      // 
  	      Object.keys(_supportOtf.default).forEach(function (tableName) {
  	        if (font.tables[tableName]) {
  	          var offset = font.tables[tableName].offset;
  	          font[tableName] = new _supportOtf.default[tableName](offset).read(reader, font);
  	        }
  	      });
  	      if (!font.CFF.glyf) {
  	        _error.default.raise(10303);
  	      }
  	      reader.dispose();
  	      return font;
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Object} font font
  	     */
  	  }, {
  	    key: "resolveGlyf",
  	    value: function resolveGlyf(font) {
  	      var codes = font.cmap;
  	      var glyf = font.CFF.glyf;
  	      var subsetMap = font.readOptions.subset ? font.subsetMap : null; // ttf
  	      // unicode
  	      Object.keys(codes).forEach(function (c) {
  	        var i = codes[c];
  	        if (subsetMap && !subsetMap[i]) {
  	          return;
  	        }
  	        if (!glyf[i].unicode) {
  	          glyf[i].unicode = [];
  	        }
  	        glyf[i].unicode.push(+c);
  	      });

  	      // leftSideBearing
  	      font.hmtx.forEach(function (item, i) {
  	        if (subsetMap && !subsetMap[i]) {
  	          return;
  	        }
  	        glyf[i].advanceWidth = glyf[i].advanceWidth || item.advanceWidth || 0;
  	        glyf[i].leftSideBearing = item.leftSideBearing;
  	      });

  	      // subsetMapsubset
  	      if (subsetMap) {
  	        var subGlyf = [];
  	        Object.keys(subsetMap).forEach(function (i) {
  	          subGlyf.push(glyf[+i]);
  	        });
  	        glyf = subGlyf;
  	      }
  	      font.glyf = glyf;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Object} font font
  	     */
  	  }, {
  	    key: "cleanTables",
  	    value: function cleanTables(font) {
  	      delete font.readOptions;
  	      delete font.tables;
  	      delete font.hmtx;
  	      delete font.post.glyphNameIndex;
  	      delete font.post.names;
  	      delete font.subsetMap;

  	      // 
  	      var cff = font.CFF;
  	      delete cff.glyf;
  	      delete cff.charset;
  	      delete cff.encoding;
  	      delete cff.gsubrs;
  	      delete cff.gsubrsBias;
  	      delete cff.subrs;
  	      delete cff.subrsBias;
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @param {ArrayBuffer} buffer buffer
  	     *
  	     * @return {Object} ttf
  	     */
  	  }, {
  	    key: "read",
  	    value: function read(buffer) {
  	      this.font = this.readBuffer(buffer);
  	      this.resolveGlyf(this.font);
  	      this.cleanTables(this.font);
  	      return this.font;
  	    }

  	    /**
  	     * 
  	     */
  	  }, {
  	    key: "dispose",
  	    value: function dispose() {
  	      delete this.font;
  	      delete this.options;
  	    }
  	  }]);
  	}();
  	return otfreader;
  }

  var otfContours2ttfContours = {};

  var bezierCubic2Q2 = {};

  var hasRequiredBezierCubic2Q2;

  function requireBezierCubic2Q2 () {
  	if (hasRequiredBezierCubic2Q2) return bezierCubic2Q2;
  	hasRequiredBezierCubic2Q2 = 1;

  	Object.defineProperty(bezierCubic2Q2, "__esModule", {
  	  value: true
  	});
  	bezierCubic2Q2.default = bezierCubic2Q2$1;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * references:
  	 * https://github.com/search?utf8=%E2%9C%93&q=svg2ttf
  	 * http://www.caffeineowl.com/graphics/2d/vectorial/cubic2quad01.html
  	 *
  	 */

  	function toQuad(p1, c1, c2, p2) {
  	  // Quad control point is (3*c2 - p2 + 3*c1 - p1)/4
  	  var x = (3 * c2.x - p2.x + 3 * c1.x - p1.x) / 4;
  	  var y = (3 * c2.y - p2.y + 3 * c1.y - p1.y) / 4;
  	  return [p1, {
  	    x: x,
  	    y: y
  	  }, p2];
  	}

  	/**
  	 * 
  	 *
  	 * @param {Object} p1 
  	 * @param {Object} c1 1
  	 * @param {Object} c2 2
  	 * @param {Object} p2 
  	 * @return {Array} 
  	 */
  	function bezierCubic2Q2$1(p1, c1, c2, p2) {
  	  // 
  	  if (p1.x === c1.x && p1.y === c1.y && c2.x === p2.x && c2.y === p2.y) {
  	    return [[p1, {
  	      x: (p1.x + p2.x) / 2,
  	      y: (p1.y + p2.y) / 2
  	    }, p2]];
  	  }
  	  var mx = p2.x - 3 * c2.x + 3 * c1.x - p1.x;
  	  var my = p2.y - 3 * c2.y + 3 * c1.y - p1.y;

  	  // control points near
  	  if (mx * mx + my * my <= 4) {
  	    return [toQuad(p1, c1, c2, p2)];
  	  }

  	  // Split to 2 qubic beziers by midpoints
  	  // (p2 + 3*c2 + 3*c1 + p1)/8
  	  var mp = {
  	    x: (p2.x + 3 * c2.x + 3 * c1.x + p1.x) / 8,
  	    y: (p2.y + 3 * c2.y + 3 * c1.y + p1.y) / 8
  	  };
  	  return [toQuad(p1, {
  	    x: (p1.x + c1.x) / 2,
  	    y: (p1.y + c1.y) / 2
  	  }, {
  	    x: (p1.x + 2 * c1.x + c2.x) / 4,
  	    y: (p1.y + 2 * c1.y + c2.y) / 4
  	  }, mp), toQuad(mp, {
  	    x: (p2.x + c1.x + 2 * c2.x) / 4,
  	    y: (p2.y + c1.y + 2 * c2.y) / 4
  	  }, {
  	    x: (p2.x + c2.x) / 2,
  	    y: (p2.y + c2.y) / 2
  	  }, p2)];
  	}
  	return bezierCubic2Q2;
  }

  var hasRequiredOtfContours2ttfContours;

  function requireOtfContours2ttfContours () {
  	if (hasRequiredOtfContours2ttfContours) return otfContours2ttfContours;
  	hasRequiredOtfContours2ttfContours = 1;

  	Object.defineProperty(otfContours2ttfContours, "__esModule", {
  	  value: true
  	});
  	otfContours2ttfContours.default = otfContours2ttfContours$1;
  	var _bezierCubic2Q = _interopRequireDefault(requireBezierCubic2Q2());
  	var _pathCeil = _interopRequireDefault(requirePathCeil());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file otfttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param  {Array} otfContour otf
  	 * @return {Array}            ttf
  	 */
  	function transformContour(otfContour) {
  	  var contour = [];
  	  var prevPoint;
  	  var curPoint;
  	  var nextPoint;
  	  var nextNextPoint;
  	  contour.push(prevPoint = otfContour[0]);
  	  for (var i = 1, l = otfContour.length; i < l; i++) {
  	    curPoint = otfContour[i];
  	    if (curPoint.onCurve) {
  	      contour.push(curPoint);
  	      prevPoint = curPoint;
  	    }
  	    // bezier
  	    else {
  	      nextPoint = otfContour[i + 1];
  	      nextNextPoint = i === l - 2 ? otfContour[0] : otfContour[i + 2];
  	      var bezierArray = (0, _bezierCubic2Q.default)(prevPoint, curPoint, nextPoint, nextNextPoint);
  	      bezierArray[0][2].onCurve = true;
  	      contour.push(bezierArray[0][1]);
  	      contour.push(bezierArray[0][2]);

  	      // 
  	      if (bezierArray[1]) {
  	        bezierArray[1][2].onCurve = true;
  	        contour.push(bezierArray[1][1]);
  	        contour.push(bezierArray[1][2]);
  	      }
  	      prevPoint = nextNextPoint;
  	      i += 2;
  	    }
  	  }
  	  return (0, _pathCeil.default)(contour);
  	}

  	/**
  	 * otfttf
  	 *
  	 * @param  {Array} otfContours otf
  	 * @return {Array} ttf
  	 */
  	function otfContours2ttfContours$1(otfContours) {
  	  if (!otfContours || !otfContours.length) {
  	    return otfContours;
  	  }
  	  var contours = [];
  	  for (var i = 0, l = otfContours.length; i < l; i++) {
  	    // 
  	    if (otfContours[i][0]) {
  	      contours.push(transformContour(otfContours[i]));
  	    }
  	  }
  	  return contours;
  	}
  	return otfContours2ttfContours;
  }

  var hasRequiredOtf2ttfobject;

  function requireOtf2ttfobject () {
  	if (hasRequiredOtf2ttfobject) return otf2ttfobject;
  	hasRequiredOtf2ttfobject = 1;

  	Object.defineProperty(otf2ttfobject, "__esModule", {
  	  value: true
  	});
  	otf2ttfobject.default = otf2ttfobject$1;
  	var _error = _interopRequireDefault(requireError());
  	var _otfreader = _interopRequireDefault(requireOtfreader());
  	var _otfContours2ttfContours = _interopRequireDefault(requireOtfContours2ttfContours());
  	var _computeBoundingBox = requireComputeBoundingBox();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
  	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
  	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
  	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
  	 * @file otfttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/**
  	 * otfttf
  	 *
  	 * @param  {ArrayBuffer|otfObject} otfBuffer otf
  	 * @param  {Object} options   
  	 * @return {Object}          ttfObject
  	 */
  	function otf2ttfobject$1(otfBuffer, options) {
  	  var otfObject;
  	  if (otfBuffer instanceof ArrayBuffer) {
  	    var otfReader = new _otfreader.default(options);
  	    otfObject = otfReader.read(otfBuffer);
  	    otfReader.dispose();
  	  } else if (otfBuffer.head && otfBuffer.glyf && otfBuffer.cmap) {
  	    otfObject = otfBuffer;
  	  } else {
  	    _error.default.raise(10111);
  	  }

  	  // otf
  	  otfObject.glyf.forEach(function (g) {
  	    g.contours = (0, _otfContours2ttfContours.default)(g.contours);
  	    var box = _computeBoundingBox.computePathBox.apply(void 0, _toConsumableArray(g.contours));
  	    if (box) {
  	      g.xMin = box.x;
  	      g.xMax = box.x + box.width;
  	      g.yMin = box.y;
  	      g.yMax = box.y + box.height;
  	      g.leftSideBearing = g.xMin;
  	    } else {
  	      g.xMin = 0;
  	      g.xMax = 0;
  	      g.yMin = 0;
  	      g.yMax = 0;
  	      g.leftSideBearing = 0;
  	    }
  	  });
  	  otfObject.version = 0x1;

  	  // maxp
  	  otfObject.maxp.version = 1.0;
  	  otfObject.maxp.maxZones = otfObject.maxp.maxTwilightPoints ? 2 : 1;
  	  delete otfObject.CFF;
  	  delete otfObject.VORG;
  	  return otfObject;
  	}
  	return otf2ttfobject;
  }

  var eot2ttf = {};

  var hasRequiredEot2ttf;

  function requireEot2ttf () {
  	if (hasRequiredEot2ttf) return eot2ttf;
  	hasRequiredEot2ttf = 1;

  	Object.defineProperty(eot2ttf, "__esModule", {
  	  value: true
  	});
  	eot2ttf.default = eot2ttf$1;
  	var _reader = _interopRequireDefault(requireReader());
  	var _writer = _interopRequireDefault(requireWriter());
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file eotttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * eotttf
  	 *
  	 * @param {ArrayBuffer} eotBuffer eot
  	 * @param {Object} options 
  	 *
  	 * @return {ArrayBuffer} ttfbyte
  	 */
  	// eslint-disable-next-line no-unused-vars
  	function eot2ttf$1(eotBuffer) {
  	  // 
  	  var eotReader = new _reader.default(eotBuffer, 0, eotBuffer.byteLength, true);

  	  // check magic number
  	  var magicNumber = eotReader.readUint16(34);
  	  if (magicNumber !== 0x504C) {
  	    _error.default.raise(10110);
  	  }

  	  // check version
  	  var version = eotReader.readUint32(8);
  	  if (version !== 0x20001 && version !== 0x10000 && version !== 0x20002) {
  	    _error.default.raise(10110);
  	  }
  	  var eotSize = eotBuffer.byteLength || eotBuffer.length;
  	  var fontSize = eotReader.readUint32(4);
  	  var fontOffset = 82;
  	  var familyNameSize = eotReader.readUint16(fontOffset);
  	  fontOffset += 4 + familyNameSize;
  	  var styleNameSize = eotReader.readUint16(fontOffset);
  	  fontOffset += 4 + styleNameSize;
  	  var versionNameSize = eotReader.readUint16(fontOffset);
  	  fontOffset += 4 + versionNameSize;
  	  var fullNameSize = eotReader.readUint16(fontOffset);
  	  fontOffset += 2 + fullNameSize;

  	  // version 0x20001
  	  if (version === 0x20001 || version === 0x20002) {
  	    var rootStringSize = eotReader.readUint16(fontOffset + 2);
  	    fontOffset += 4 + rootStringSize;
  	  }

  	  // version 0x20002
  	  if (version === 0x20002) {
  	    fontOffset += 10;
  	    var signatureSize = eotReader.readUint16(fontOffset);
  	    fontOffset += 2 + signatureSize;
  	    fontOffset += 4;
  	    var eudcFontSize = eotReader.readUint32(fontOffset);
  	    fontOffset += 4 + eudcFontSize;
  	  }
  	  if (fontOffset + fontSize > eotSize) {
  	    _error.default.raise(10001);
  	  }

  	  // support slice
  	  if (eotBuffer.slice) {
  	    return eotBuffer.slice(fontOffset, fontOffset + fontSize);
  	  }

  	  // not support ArrayBuffer.slice eg. IE10
  	  var bytes = eotReader.readBytes(fontOffset, fontSize);
  	  return new _writer.default(new ArrayBuffer(fontSize)).writeBytes(bytes).getBuffer();
  	}
  	return eot2ttf;
  }

  var svg2ttfobject = {};

  var DOMParser$1 = {};

  var lib = {};

  var dom = {};

  var conventions = {};

  var hasRequiredConventions;

  function requireConventions () {
  	if (hasRequiredConventions) return conventions;
  	hasRequiredConventions = 1;

  	/**
  	 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
  	 *
  	 * Works with anything that has a `length` property and index access properties, including NodeList.
  	 *
  	 * @template {unknown} T
  	 * @param {Array<T> | ({length:number, [number]: T})} list
  	 * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
  	 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
  	 * 				allows injecting a custom implementation in tests
  	 * @returns {T | undefined}
  	 *
  	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
  	 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
  	 */
  	function find(list, predicate, ac) {
  		if (ac === undefined) {
  			ac = Array.prototype;
  		}
  		if (list && typeof ac.find === 'function') {
  			return ac.find.call(list, predicate);
  		}
  		for (var i = 0; i < list.length; i++) {
  			if (Object.prototype.hasOwnProperty.call(list, i)) {
  				var item = list[i];
  				if (predicate.call(undefined, item, i, list)) {
  					return item;
  				}
  			}
  		}
  	}

  	/**
  	 * "Shallow freezes" an object to render it immutable.
  	 * Uses `Object.freeze` if available,
  	 * otherwise the immutability is only in the type.
  	 *
  	 * Is used to create "enum like" objects.
  	 *
  	 * @template T
  	 * @param {T} object the object to freeze
  	 * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
  	 * 				allows to inject custom object constructor for tests
  	 * @returns {Readonly<T>}
  	 *
  	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
  	 */
  	function freeze(object, oc) {
  		if (oc === undefined) {
  			oc = Object;
  		}
  		return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object
  	}

  	/**
  	 * Since we can not rely on `Object.assign` we provide a simplified version
  	 * that is sufficient for our needs.
  	 *
  	 * @param {Object} target
  	 * @param {Object | null | undefined} source
  	 *
  	 * @returns {Object} target
  	 * @throws TypeError if target is not an object
  	 *
  	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  	 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
  	 */
  	function assign(target, source) {
  		if (target === null || typeof target !== 'object') {
  			throw new TypeError('target is not an object')
  		}
  		for (var key in source) {
  			if (Object.prototype.hasOwnProperty.call(source, key)) {
  				target[key] = source[key];
  			}
  		}
  		return target
  	}

  	/**
  	 * All mime types that are allowed as input to `DOMParser.parseFromString`
  	 *
  	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
  	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
  	 * @see DOMParser.prototype.parseFromString
  	 */
  	var MIME_TYPE = freeze({
  		/**
  		 * `text/html`, the only mime type that triggers treating an XML document as HTML.
  		 *
  		 * @see DOMParser.SupportedType.isHTML
  		 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
  		 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
  		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
  		 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
  		 */
  		HTML: 'text/html',

  		/**
  		 * Helper method to check a mime type if it indicates an HTML document
  		 *
  		 * @param {string} [value]
  		 * @returns {boolean}
  		 *
  		 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
  		 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
  		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
  		 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
  		isHTML: function (value) {
  			return value === MIME_TYPE.HTML
  		},

  		/**
  		 * `application/xml`, the standard mime type for XML documents.
  		 *
  		 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
  		 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
  		 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
  		 */
  		XML_APPLICATION: 'application/xml',

  		/**
  		 * `text/html`, an alias for `application/xml`.
  		 *
  		 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
  		 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
  		 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
  		 */
  		XML_TEXT: 'text/xml',

  		/**
  		 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
  		 * but is parsed as an XML document.
  		 *
  		 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
  		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
  		 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
  		 */
  		XML_XHTML_APPLICATION: 'application/xhtml+xml',

  		/**
  		 * `image/svg+xml`,
  		 *
  		 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
  		 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
  		 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
  		 */
  		XML_SVG_IMAGE: 'image/svg+xml',
  	});

  	/**
  	 * Namespaces that are used in this code base.
  	 *
  	 * @see http://www.w3.org/TR/REC-xml-names
  	 */
  	var NAMESPACE = freeze({
  		/**
  		 * The XHTML namespace.
  		 *
  		 * @see http://www.w3.org/1999/xhtml
  		 */
  		HTML: 'http://www.w3.org/1999/xhtml',

  		/**
  		 * Checks if `uri` equals `NAMESPACE.HTML`.
  		 *
  		 * @param {string} [uri]
  		 *
  		 * @see NAMESPACE.HTML
  		 */
  		isHTML: function (uri) {
  			return uri === NAMESPACE.HTML
  		},

  		/**
  		 * The SVG namespace.
  		 *
  		 * @see http://www.w3.org/2000/svg
  		 */
  		SVG: 'http://www.w3.org/2000/svg',

  		/**
  		 * The `xml:` namespace.
  		 *
  		 * @see http://www.w3.org/XML/1998/namespace
  		 */
  		XML: 'http://www.w3.org/XML/1998/namespace',

  		/**
  		 * The `xmlns:` namespace
  		 *
  		 * @see https://www.w3.org/2000/xmlns/
  		 */
  		XMLNS: 'http://www.w3.org/2000/xmlns/',
  	});

  	conventions.assign = assign;
  	conventions.find = find;
  	conventions.freeze = freeze;
  	conventions.MIME_TYPE = MIME_TYPE;
  	conventions.NAMESPACE = NAMESPACE;
  	return conventions;
  }

  var hasRequiredDom;

  function requireDom () {
  	if (hasRequiredDom) return dom;
  	hasRequiredDom = 1;
  	var conventions = requireConventions();

  	var find = conventions.find;
  	var NAMESPACE = conventions.NAMESPACE;

  	/**
  	 * A prerequisite for `[].filter`, to drop elements that are empty
  	 * @param {string} input
  	 * @returns {boolean}
  	 */
  	function notEmptyString (input) {
  		return input !== ''
  	}
  	/**
  	 * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
  	 * @see https://infra.spec.whatwg.org/#ascii-whitespace
  	 *
  	 * @param {string} input
  	 * @returns {string[]} (can be empty)
  	 */
  	function splitOnASCIIWhitespace(input) {
  		// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
  		return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : []
  	}

  	/**
  	 * Adds element as a key to current if it is not already present.
  	 *
  	 * @param {Record<string, boolean | undefined>} current
  	 * @param {string} element
  	 * @returns {Record<string, boolean | undefined>}
  	 */
  	function orderedSetReducer (current, element) {
  		if (!current.hasOwnProperty(element)) {
  			current[element] = true;
  		}
  		return current;
  	}

  	/**
  	 * @see https://infra.spec.whatwg.org/#ordered-set
  	 * @param {string} input
  	 * @returns {string[]}
  	 */
  	function toOrderedSet(input) {
  		if (!input) return [];
  		var list = splitOnASCIIWhitespace(input);
  		return Object.keys(list.reduce(orderedSetReducer, {}))
  	}

  	/**
  	 * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
  	 * which we can not rely on being available.
  	 *
  	 * @param {any[]} list
  	 * @returns {function(any): boolean}
  	 */
  	function arrayIncludes (list) {
  		return function(element) {
  			return list && list.indexOf(element) !== -1;
  		}
  	}

  	function copy(src,dest){
  		for(var p in src){
  			if (Object.prototype.hasOwnProperty.call(src, p)) {
  				dest[p] = src[p];
  			}
  		}
  	}

  	/**
  	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
  	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
  	 */
  	function _extends(Class,Super){
  		var pt = Class.prototype;
  		if(!(pt instanceof Super)){
  			function t(){}			t.prototype = Super.prototype;
  			t = new t();
  			copy(pt,t);
  			Class.prototype = pt = t;
  		}
  		if(pt.constructor != Class){
  			if(typeof Class != 'function'){
  				console.error("unknown Class:"+Class);
  			}
  			pt.constructor = Class;
  		}
  	}

  	// Node Types
  	var NodeType = {};
  	var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
  	var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
  	var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
  	var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
  	var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
  	var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
  	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
  	var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
  	var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
  	var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
  	var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
  	var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

  	// ExceptionCode
  	var ExceptionCode = {};
  	var ExceptionMessage = {};
  	ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
  	ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
  	var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
  	ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
  	ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
  	ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
  	ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
  	var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
  	ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
  	var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
  	//level2
  	ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
  	ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
  	ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
  	ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
  	ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);

  	/**
  	 * DOM Level 2
  	 * Object DOMException
  	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
  	 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
  	 */
  	function DOMException(code, message) {
  		if(message instanceof Error){
  			var error = message;
  		}else {
  			error = this;
  			Error.call(this, ExceptionMessage[code]);
  			this.message = ExceptionMessage[code];
  			if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
  		}
  		error.code = code;
  		if(message) this.message = this.message + ": " + message;
  		return error;
  	}	DOMException.prototype = Error.prototype;
  	copy(ExceptionCode,DOMException);

  	/**
  	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
  	 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
  	 * The items in the NodeList are accessible via an integral index, starting from 0.
  	 */
  	function NodeList() {
  	}	NodeList.prototype = {
  		/**
  		 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
  		 * @standard level1
  		 */
  		length:0,
  		/**
  		 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
  		 * @standard level1
  		 * @param index  unsigned long
  		 *   Index into the collection.
  		 * @return Node
  		 * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
  		 */
  		item: function(index) {
  			return index >= 0 && index < this.length ? this[index] : null;
  		},
  		toString:function(isHTML,nodeFilter){
  			for(var buf = [], i = 0;i<this.length;i++){
  				serializeToString(this[i],buf,isHTML,nodeFilter);
  			}
  			return buf.join('');
  		},
  		/**
  		 * @private
  		 * @param {function (Node):boolean} predicate
  		 * @returns {Node[]}
  		 */
  		filter: function (predicate) {
  			return Array.prototype.filter.call(this, predicate);
  		},
  		/**
  		 * @private
  		 * @param {Node} item
  		 * @returns {number}
  		 */
  		indexOf: function (item) {
  			return Array.prototype.indexOf.call(this, item);
  		},
  	};

  	function LiveNodeList(node,refresh){
  		this._node = node;
  		this._refresh = refresh;
  		_updateLiveList(this);
  	}
  	function _updateLiveList(list){
  		var inc = list._node._inc || list._node.ownerDocument._inc;
  		if (list._inc !== inc) {
  			var ls = list._refresh(list._node);
  			__set__(list,'length',ls.length);
  			if (!list.$$length || ls.length < list.$$length) {
  				for (var i = ls.length; i in list; i++) {
  					if (Object.prototype.hasOwnProperty.call(list, i)) {
  						delete list[i];
  					}
  				}
  			}
  			copy(ls,list);
  			list._inc = inc;
  		}
  	}
  	LiveNodeList.prototype.item = function(i){
  		_updateLiveList(this);
  		return this[i] || null;
  	};

  	_extends(LiveNodeList,NodeList);

  	/**
  	 * Objects implementing the NamedNodeMap interface are used
  	 * to represent collections of nodes that can be accessed by name.
  	 * Note that NamedNodeMap does not inherit from NodeList;
  	 * NamedNodeMaps are not maintained in any particular order.
  	 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
  	 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
  	 * and does not imply that the DOM specifies an order to these Nodes.
  	 * NamedNodeMap objects in the DOM are live.
  	 * used for attributes or DocumentType entities
  	 */
  	function NamedNodeMap() {
  	}
  	function _findNodeIndex(list,node){
  		var i = list.length;
  		while(i--){
  			if(list[i] === node){return i}
  		}
  	}

  	function _addNamedNode(el,list,newAttr,oldAttr){
  		if(oldAttr){
  			list[_findNodeIndex(list,oldAttr)] = newAttr;
  		}else {
  			list[list.length++] = newAttr;
  		}
  		if(el){
  			newAttr.ownerElement = el;
  			var doc = el.ownerDocument;
  			if(doc){
  				oldAttr && _onRemoveAttribute(doc,el,oldAttr);
  				_onAddAttribute(doc,el,newAttr);
  			}
  		}
  	}
  	function _removeNamedNode(el,list,attr){
  		//console.log('remove attr:'+attr)
  		var i = _findNodeIndex(list,attr);
  		if(i>=0){
  			var lastIndex = list.length-1;
  			while(i<lastIndex){
  				list[i] = list[++i];
  			}
  			list.length = lastIndex;
  			if(el){
  				var doc = el.ownerDocument;
  				if(doc){
  					_onRemoveAttribute(doc,el,attr);
  					attr.ownerElement = null;
  				}
  			}
  		}else {
  			throw new DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
  		}
  	}
  	NamedNodeMap.prototype = {
  		length:0,
  		item:NodeList.prototype.item,
  		getNamedItem: function(key) {
  	//		if(key.indexOf(':')>0 || key == 'xmlns'){
  	//			return null;
  	//		}
  			//console.log()
  			var i = this.length;
  			while(i--){
  				var attr = this[i];
  				//console.log(attr.nodeName,key)
  				if(attr.nodeName == key){
  					return attr;
  				}
  			}
  		},
  		setNamedItem: function(attr) {
  			var el = attr.ownerElement;
  			if(el && el!=this._ownerElement){
  				throw new DOMException(INUSE_ATTRIBUTE_ERR);
  			}
  			var oldAttr = this.getNamedItem(attr.nodeName);
  			_addNamedNode(this._ownerElement,this,attr,oldAttr);
  			return oldAttr;
  		},
  		/* returns Node */
  		setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
  			var el = attr.ownerElement, oldAttr;
  			if(el && el!=this._ownerElement){
  				throw new DOMException(INUSE_ATTRIBUTE_ERR);
  			}
  			oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
  			_addNamedNode(this._ownerElement,this,attr,oldAttr);
  			return oldAttr;
  		},

  		/* returns Node */
  		removeNamedItem: function(key) {
  			var attr = this.getNamedItem(key);
  			_removeNamedNode(this._ownerElement,this,attr);
  			return attr;


  		},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

  		//for level2
  		removeNamedItemNS:function(namespaceURI,localName){
  			var attr = this.getNamedItemNS(namespaceURI,localName);
  			_removeNamedNode(this._ownerElement,this,attr);
  			return attr;
  		},
  		getNamedItemNS: function(namespaceURI, localName) {
  			var i = this.length;
  			while(i--){
  				var node = this[i];
  				if(node.localName == localName && node.namespaceURI == namespaceURI){
  					return node;
  				}
  			}
  			return null;
  		}
  	};

  	/**
  	 * The DOMImplementation interface represents an object providing methods
  	 * which are not dependent on any particular document.
  	 * Such an object is returned by the `Document.implementation` property.
  	 *
  	 * __The individual methods describe the differences compared to the specs.__
  	 *
  	 * @constructor
  	 *
  	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
  	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
  	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
  	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
  	 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
  	 */
  	function DOMImplementation() {
  	}

  	DOMImplementation.prototype = {
  		/**
  		 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
  		 * The different implementations fairly diverged in what kind of features were reported.
  		 * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
  		 *
  		 * @deprecated It is deprecated and modern browsers return true in all cases.
  		 *
  		 * @param {string} feature
  		 * @param {string} [version]
  		 * @returns {boolean} always true
  		 *
  		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
  		 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
  		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
  		 */
  		hasFeature: function(feature, version) {
  				return true;
  		},
  		/**
  		 * Creates an XML Document object of the specified type with its document element.
  		 *
  		 * __It behaves slightly different from the description in the living standard__:
  		 * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
  		 * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
  		 * - this implementation is not validating names or qualified names
  		 *   (when parsing XML strings, the SAX parser takes care of that)
  		 *
  		 * @param {string|null} namespaceURI
  		 * @param {string} qualifiedName
  		 * @param {DocumentType=null} doctype
  		 * @returns {Document}
  		 *
  		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
  		 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
  		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
  		 *
  		 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
  		 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
  		 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
  		 */
  		createDocument: function(namespaceURI,  qualifiedName, doctype){
  			var doc = new Document();
  			doc.implementation = this;
  			doc.childNodes = new NodeList();
  			doc.doctype = doctype || null;
  			if (doctype){
  				doc.appendChild(doctype);
  			}
  			if (qualifiedName){
  				var root = doc.createElementNS(namespaceURI, qualifiedName);
  				doc.appendChild(root);
  			}
  			return doc;
  		},
  		/**
  		 * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
  		 *
  		 * __This behavior is slightly different from the in the specs__:
  		 * - this implementation is not validating names or qualified names
  		 *   (when parsing XML strings, the SAX parser takes care of that)
  		 *
  		 * @param {string} qualifiedName
  		 * @param {string} [publicId]
  		 * @param {string} [systemId]
  		 * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
  		 * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
  		 *
  		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
  		 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
  		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
  		 *
  		 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
  		 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
  		 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
  		 */
  		createDocumentType: function(qualifiedName, publicId, systemId){
  			var node = new DocumentType();
  			node.name = qualifiedName;
  			node.nodeName = qualifiedName;
  			node.publicId = publicId || '';
  			node.systemId = systemId || '';

  			return node;
  		}
  	};


  	/**
  	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
  	 */

  	function Node() {
  	}
  	Node.prototype = {
  		firstChild : null,
  		lastChild : null,
  		previousSibling : null,
  		nextSibling : null,
  		attributes : null,
  		parentNode : null,
  		childNodes : null,
  		ownerDocument : null,
  		nodeValue : null,
  		namespaceURI : null,
  		prefix : null,
  		localName : null,
  		// Modified in DOM Level 2:
  		insertBefore:function(newChild, refChild){//raises
  			return _insertBefore(this,newChild,refChild);
  		},
  		replaceChild:function(newChild, oldChild){//raises
  			_insertBefore(this, newChild,oldChild, assertPreReplacementValidityInDocument);
  			if(oldChild){
  				this.removeChild(oldChild);
  			}
  		},
  		removeChild:function(oldChild){
  			return _removeChild(this,oldChild);
  		},
  		appendChild:function(newChild){
  			return this.insertBefore(newChild,null);
  		},
  		hasChildNodes:function(){
  			return this.firstChild != null;
  		},
  		cloneNode:function(deep){
  			return cloneNode(this.ownerDocument||this,this,deep);
  		},
  		// Modified in DOM Level 2:
  		normalize:function(){
  			var child = this.firstChild;
  			while(child){
  				var next = child.nextSibling;
  				if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
  					this.removeChild(next);
  					child.appendData(next.data);
  				}else {
  					child.normalize();
  					child = next;
  				}
  			}
  		},
  	  	// Introduced in DOM Level 2:
  		isSupported:function(feature, version){
  			return this.ownerDocument.implementation.hasFeature(feature,version);
  		},
  	    // Introduced in DOM Level 2:
  	    hasAttributes:function(){
  	    	return this.attributes.length>0;
  	    },
  		/**
  		 * Look up the prefix associated to the given namespace URI, starting from this node.
  		 * **The default namespace declarations are ignored by this method.**
  		 * See Namespace Prefix Lookup for details on the algorithm used by this method.
  		 *
  		 * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
  		 *
  		 * @param {string | null} namespaceURI
  		 * @returns {string | null}
  		 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
  		 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
  		 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
  		 * @see https://github.com/xmldom/xmldom/issues/322
  		 */
  	    lookupPrefix:function(namespaceURI){
  	    	var el = this;
  	    	while(el){
  	    		var map = el._nsMap;
  	    		//console.dir(map)
  	    		if(map){
  	    			for(var n in map){
  							if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
  								return n;
  							}
  	    			}
  	    		}
  	    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
  	    	}
  	    	return null;
  	    },
  	    // Introduced in DOM Level 3:
  	    lookupNamespaceURI:function(prefix){
  	    	var el = this;
  	    	while(el){
  	    		var map = el._nsMap;
  	    		//console.dir(map)
  	    		if(map){
  	    			if(Object.prototype.hasOwnProperty.call(map, prefix)){
  	    				return map[prefix] ;
  	    			}
  	    		}
  	    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
  	    	}
  	    	return null;
  	    },
  	    // Introduced in DOM Level 3:
  	    isDefaultNamespace:function(namespaceURI){
  	    	var prefix = this.lookupPrefix(namespaceURI);
  	    	return prefix == null;
  	    }
  	};


  	function _xmlEncoder(c){
  		return c == '<' && '&lt;' ||
  	         c == '>' && '&gt;' ||
  	         c == '&' && '&amp;' ||
  	         c == '"' && '&quot;' ||
  	         '&#'+c.charCodeAt()+';'
  	}


  	copy(NodeType,Node);
  	copy(NodeType,Node.prototype);

  	/**
  	 * @param callback return true for continue,false for break
  	 * @return boolean true: break visit;
  	 */
  	function _visitNode(node,callback){
  		if(callback(node)){
  			return true;
  		}
  		if(node = node.firstChild){
  			do{
  				if(_visitNode(node,callback)){return true}
  	        }while(node=node.nextSibling)
  	    }
  	}



  	function Document(){
  		this.ownerDocument = this;
  	}

  	function _onAddAttribute(doc,el,newAttr){
  		doc && doc._inc++;
  		var ns = newAttr.namespaceURI ;
  		if(ns === NAMESPACE.XMLNS){
  			//update namespace
  			el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value;
  		}
  	}

  	function _onRemoveAttribute(doc,el,newAttr,remove){
  		doc && doc._inc++;
  		var ns = newAttr.namespaceURI ;
  		if(ns === NAMESPACE.XMLNS){
  			//update namespace
  			delete el._nsMap[newAttr.prefix?newAttr.localName:''];
  		}
  	}

  	/**
  	 * Updates `el.childNodes`, updating the indexed items and it's `length`.
  	 * Passing `newChild` means it will be appended.
  	 * Otherwise it's assumed that an item has been removed,
  	 * and `el.firstNode` and it's `.nextSibling` are used
  	 * to walk the current list of child nodes.
  	 *
  	 * @param {Document} doc
  	 * @param {Node} el
  	 * @param {Node} [newChild]
  	 * @private
  	 */
  	function _onUpdateChild (doc, el, newChild) {
  		if(doc && doc._inc){
  			doc._inc++;
  			//update childNodes
  			var cs = el.childNodes;
  			if (newChild) {
  				cs[cs.length++] = newChild;
  			} else {
  				var child = el.firstChild;
  				var i = 0;
  				while (child) {
  					cs[i++] = child;
  					child = child.nextSibling;
  				}
  				cs.length = i;
  				delete cs[cs.length];
  			}
  		}
  	}

  	/**
  	 * Removes the connections between `parentNode` and `child`
  	 * and any existing `child.previousSibling` or `child.nextSibling`.
  	 *
  	 * @see https://github.com/xmldom/xmldom/issues/135
  	 * @see https://github.com/xmldom/xmldom/issues/145
  	 *
  	 * @param {Node} parentNode
  	 * @param {Node} child
  	 * @returns {Node} the child that was removed.
  	 * @private
  	 */
  	function _removeChild (parentNode, child) {
  		var previous = child.previousSibling;
  		var next = child.nextSibling;
  		if (previous) {
  			previous.nextSibling = next;
  		} else {
  			parentNode.firstChild = next;
  		}
  		if (next) {
  			next.previousSibling = previous;
  		} else {
  			parentNode.lastChild = previous;
  		}
  		child.parentNode = null;
  		child.previousSibling = null;
  		child.nextSibling = null;
  		_onUpdateChild(parentNode.ownerDocument, parentNode);
  		return child;
  	}

  	/**
  	 * Returns `true` if `node` can be a parent for insertion.
  	 * @param {Node} node
  	 * @returns {boolean}
  	 */
  	function hasValidParentNodeType(node) {
  		return (
  			node &&
  			(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
  		);
  	}

  	/**
  	 * Returns `true` if `node` can be inserted according to it's `nodeType`.
  	 * @param {Node} node
  	 * @returns {boolean}
  	 */
  	function hasInsertableNodeType(node) {
  		return (
  			node &&
  			(isElementNode(node) ||
  				isTextNode(node) ||
  				isDocTypeNode(node) ||
  				node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
  				node.nodeType === Node.COMMENT_NODE ||
  				node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
  		);
  	}

  	/**
  	 * Returns true if `node` is a DOCTYPE node
  	 * @param {Node} node
  	 * @returns {boolean}
  	 */
  	function isDocTypeNode(node) {
  		return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
  	}

  	/**
  	 * Returns true if the node is an element
  	 * @param {Node} node
  	 * @returns {boolean}
  	 */
  	function isElementNode(node) {
  		return node && node.nodeType === Node.ELEMENT_NODE;
  	}
  	/**
  	 * Returns true if `node` is a text node
  	 * @param {Node} node
  	 * @returns {boolean}
  	 */
  	function isTextNode(node) {
  		return node && node.nodeType === Node.TEXT_NODE;
  	}

  	/**
  	 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
  	 * according to the presence and position of a doctype node on the same level.
  	 *
  	 * @param {Document} doc The document node
  	 * @param {Node} child the node that would become the nextSibling if the element would be inserted
  	 * @returns {boolean} `true` if an element can be inserted before child
  	 * @private
  	 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  	 */
  	function isElementInsertionPossible(doc, child) {
  		var parentChildNodes = doc.childNodes || [];
  		if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
  			return false;
  		}
  		var docTypeNode = find(parentChildNodes, isDocTypeNode);
  		return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  	}

  	/**
  	 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
  	 * according to the presence and position of a doctype node on the same level.
  	 *
  	 * @param {Node} doc The document node
  	 * @param {Node} child the node that would become the nextSibling if the element would be inserted
  	 * @returns {boolean} `true` if an element can be inserted before child
  	 * @private
  	 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  	 */
  	function isElementReplacementPossible(doc, child) {
  		var parentChildNodes = doc.childNodes || [];

  		function hasElementChildThatIsNotChild(node) {
  			return isElementNode(node) && node !== child;
  		}

  		if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
  			return false;
  		}
  		var docTypeNode = find(parentChildNodes, isDocTypeNode);
  		return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  	}

  	/**
  	 * @private
  	 * Steps 1-5 of the checks before inserting and before replacing a child are the same.
  	 *
  	 * @param {Node} parent the parent node to insert `node` into
  	 * @param {Node} node the node to insert
  	 * @param {Node=} child the node that should become the `nextSibling` of `node`
  	 * @returns {Node}
  	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
  	 * @throws DOMException if `child` is provided but is not a child of `parent`.
  	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  	 * @see https://dom.spec.whatwg.org/#concept-node-replace
  	 */
  	function assertPreInsertionValidity1to5(parent, node, child) {
  		// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
  		if (!hasValidParentNodeType(parent)) {
  			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
  		}
  		// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
  		// not implemented!
  		// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
  		if (child && child.parentNode !== parent) {
  			throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
  		}
  		if (
  			// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
  			!hasInsertableNodeType(node) ||
  			// 5. If either `node` is a Text node and `parent` is a document,
  			// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
  			// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
  			// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
  			(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
  		) {
  			throw new DOMException(
  				HIERARCHY_REQUEST_ERR,
  				'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
  			);
  		}
  	}

  	/**
  	 * @private
  	 * Step 6 of the checks before inserting and before replacing a child are different.
  	 *
  	 * @param {Document} parent the parent node to insert `node` into
  	 * @param {Node} node the node to insert
  	 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
  	 * @returns {Node}
  	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
  	 * @throws DOMException if `child` is provided but is not a child of `parent`.
  	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  	 * @see https://dom.spec.whatwg.org/#concept-node-replace
  	 */
  	function assertPreInsertionValidityInDocument(parent, node, child) {
  		var parentChildNodes = parent.childNodes || [];
  		var nodeChildNodes = node.childNodes || [];

  		// DocumentFragment
  		if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
  			var nodeChildElements = nodeChildNodes.filter(isElementNode);
  			// If node has more than one element child or has a Text node child.
  			if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
  			}
  			// Otherwise, if `node` has one element child and either `parent` has an element child,
  			// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
  			if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
  			}
  		}
  		// Element
  		if (isElementNode(node)) {
  			// `parent` has an element child, `child` is a doctype,
  			// or `child` is non-null and a doctype is following `child`.
  			if (!isElementInsertionPossible(parent, child)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
  			}
  		}
  		// DocumentType
  		if (isDocTypeNode(node)) {
  			// `parent` has a doctype child,
  			if (find(parentChildNodes, isDocTypeNode)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
  			}
  			var parentElementChild = find(parentChildNodes, isElementNode);
  			// `child` is non-null and an element is preceding `child`,
  			if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
  			}
  			// or `child` is null and `parent` has an element child.
  			if (!child && parentElementChild) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
  			}
  		}
  	}

  	/**
  	 * @private
  	 * Step 6 of the checks before inserting and before replacing a child are different.
  	 *
  	 * @param {Document} parent the parent node to insert `node` into
  	 * @param {Node} node the node to insert
  	 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
  	 * @returns {Node}
  	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
  	 * @throws DOMException if `child` is provided but is not a child of `parent`.
  	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  	 * @see https://dom.spec.whatwg.org/#concept-node-replace
  	 */
  	function assertPreReplacementValidityInDocument(parent, node, child) {
  		var parentChildNodes = parent.childNodes || [];
  		var nodeChildNodes = node.childNodes || [];

  		// DocumentFragment
  		if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
  			var nodeChildElements = nodeChildNodes.filter(isElementNode);
  			// If `node` has more than one element child or has a Text node child.
  			if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
  			}
  			// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
  			if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
  			}
  		}
  		// Element
  		if (isElementNode(node)) {
  			// `parent` has an element child that is not `child` or a doctype is following `child`.
  			if (!isElementReplacementPossible(parent, child)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
  			}
  		}
  		// DocumentType
  		if (isDocTypeNode(node)) {
  			function hasDoctypeChildThatIsNotChild(node) {
  				return isDocTypeNode(node) && node !== child;
  			}

  			// `parent` has a doctype child that is not `child`,
  			if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
  			}
  			var parentElementChild = find(parentChildNodes, isElementNode);
  			// or an element is preceding `child`.
  			if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
  				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
  			}
  		}
  	}

  	/**
  	 * @private
  	 * @param {Node} parent the parent node to insert `node` into
  	 * @param {Node} node the node to insert
  	 * @param {Node=} child the node that should become the `nextSibling` of `node`
  	 * @returns {Node}
  	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
  	 * @throws DOMException if `child` is provided but is not a child of `parent`.
  	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
  	 */
  	function _insertBefore(parent, node, child, _inDocumentAssertion) {
  		// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
  		assertPreInsertionValidity1to5(parent, node, child);

  		// If parent is a document, and any of the statements below, switched on the interface node implements,
  		// are true, then throw a "HierarchyRequestError" DOMException.
  		if (parent.nodeType === Node.DOCUMENT_NODE) {
  			(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
  		}

  		var cp = node.parentNode;
  		if(cp){
  			cp.removeChild(node);//remove and update
  		}
  		if(node.nodeType === DOCUMENT_FRAGMENT_NODE){
  			var newFirst = node.firstChild;
  			if (newFirst == null) {
  				return node;
  			}
  			var newLast = node.lastChild;
  		}else {
  			newFirst = newLast = node;
  		}
  		var pre = child ? child.previousSibling : parent.lastChild;

  		newFirst.previousSibling = pre;
  		newLast.nextSibling = child;


  		if(pre){
  			pre.nextSibling = newFirst;
  		}else {
  			parent.firstChild = newFirst;
  		}
  		if(child == null){
  			parent.lastChild = newLast;
  		}else {
  			child.previousSibling = newLast;
  		}
  		do{
  			newFirst.parentNode = parent;
  			// Update ownerDocument for each node being inserted
  			var targetDoc = parent.ownerDocument || parent;
  			_updateOwnerDocument(newFirst, targetDoc);
  		}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
  		_onUpdateChild(parent.ownerDocument||parent, parent);
  		//console.log(parent.lastChild.nextSibling == null)
  		if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
  			node.firstChild = node.lastChild = null;
  		}
  		return node;
  	}

  	/**
  	 * Recursively updates the ownerDocument property for a node and all its descendants
  	 * @param {Node} node
  	 * @param {Document} newOwnerDocument
  	 * @private
  	 */
  	function _updateOwnerDocument(node, newOwnerDocument) {
  		if (node.ownerDocument === newOwnerDocument) {
  			return;
  		}
  		
  		node.ownerDocument = newOwnerDocument;
  		
  		// Update attributes if this is an element
  		if (node.nodeType === ELEMENT_NODE && node.attributes) {
  			for (var i = 0; i < node.attributes.length; i++) {
  				var attr = node.attributes.item(i);
  				if (attr) {
  					attr.ownerDocument = newOwnerDocument;
  				}
  			}
  		}
  		
  		// Recursively update child nodes
  		var child = node.firstChild;
  		while (child) {
  			_updateOwnerDocument(child, newOwnerDocument);
  			child = child.nextSibling;
  		}
  	}

  	/**
  	 * Appends `newChild` to `parentNode`.
  	 * If `newChild` is already connected to a `parentNode` it is first removed from it.
  	 *
  	 * @see https://github.com/xmldom/xmldom/issues/135
  	 * @see https://github.com/xmldom/xmldom/issues/145
  	 * @param {Node} parentNode
  	 * @param {Node} newChild
  	 * @returns {Node}
  	 * @private
  	 */
  	function _appendSingleChild (parentNode, newChild) {
  		if (newChild.parentNode) {
  			newChild.parentNode.removeChild(newChild);
  		}
  		newChild.parentNode = parentNode;
  		newChild.previousSibling = parentNode.lastChild;
  		newChild.nextSibling = null;
  		if (newChild.previousSibling) {
  			newChild.previousSibling.nextSibling = newChild;
  		} else {
  			parentNode.firstChild = newChild;
  		}
  		parentNode.lastChild = newChild;
  		_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
  		
  		// Update ownerDocument for the new child and all its descendants
  		var targetDoc = parentNode.ownerDocument || parentNode;
  		_updateOwnerDocument(newChild, targetDoc);
  		
  		return newChild;
  	}

  	Document.prototype = {
  		//implementation : null,
  		nodeName :  '#document',
  		nodeType :  DOCUMENT_NODE,
  		/**
  		 * The DocumentType node of the document.
  		 *
  		 * @readonly
  		 * @type DocumentType
  		 */
  		doctype :  null,
  		documentElement :  null,
  		_inc : 1,

  		insertBefore :  function(newChild, refChild){//raises
  			if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
  				var child = newChild.firstChild;
  				while(child){
  					var next = child.nextSibling;
  					this.insertBefore(child,refChild);
  					child = next;
  				}
  				return newChild;
  			}
  			_insertBefore(this, newChild, refChild);
  			_updateOwnerDocument(newChild, this);
  			if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
  				this.documentElement = newChild;
  			}

  			return newChild;
  		},
  		removeChild :  function(oldChild){
  			if(this.documentElement == oldChild){
  				this.documentElement = null;
  			}
  			return _removeChild(this,oldChild);
  		},
  		replaceChild: function (newChild, oldChild) {
  			//raises
  			_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
  			_updateOwnerDocument(newChild, this);
  			if (oldChild) {
  				this.removeChild(oldChild);
  			}
  			if (isElementNode(newChild)) {
  				this.documentElement = newChild;
  			}
  		},
  		// Introduced in DOM Level 2:
  		importNode : function(importedNode,deep){
  			return importNode(this,importedNode,deep);
  		},
  		// Introduced in DOM Level 2:
  		getElementById :	function(id){
  			var rtv = null;
  			_visitNode(this.documentElement,function(node){
  				if(node.nodeType == ELEMENT_NODE){
  					if(node.getAttribute('id') == id){
  						rtv = node;
  						return true;
  					}
  				}
  			});
  			return rtv;
  		},

  		/**
  		 * The `getElementsByClassName` method of `Document` interface returns an array-like object
  		 * of all child elements which have **all** of the given class name(s).
  		 *
  		 * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
  		 *
  		 *
  		 * Warning: This is a live LiveNodeList.
  		 * Changes in the DOM will reflect in the array as the changes occur.
  		 * If an element selected by this array no longer qualifies for the selector,
  		 * it will automatically be removed. Be aware of this for iteration purposes.
  		 *
  		 * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
  		 *
  		 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
  		 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
  		 */
  		getElementsByClassName: function(classNames) {
  			var classNamesSet = toOrderedSet(classNames);
  			return new LiveNodeList(this, function(base) {
  				var ls = [];
  				if (classNamesSet.length > 0) {
  					_visitNode(base.documentElement, function(node) {
  						if(node !== base && node.nodeType === ELEMENT_NODE) {
  							var nodeClassNames = node.getAttribute('class');
  							// can be null if the attribute does not exist
  							if (nodeClassNames) {
  								// before splitting and iterating just compare them for the most common case
  								var matches = classNames === nodeClassNames;
  								if (!matches) {
  									var nodeClassNamesSet = toOrderedSet(nodeClassNames);
  									matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
  								}
  								if(matches) {
  									ls.push(node);
  								}
  							}
  						}
  					});
  				}
  				return ls;
  			});
  		},

  		//document factory method:
  		createElement :	function(tagName){
  			var node = new Element();
  			node.ownerDocument = this;
  			node.nodeName = tagName;
  			node.tagName = tagName;
  			node.localName = tagName;
  			node.childNodes = new NodeList();
  			var attrs	= node.attributes = new NamedNodeMap();
  			attrs._ownerElement = node;
  			return node;
  		},
  		createDocumentFragment :	function(){
  			var node = new DocumentFragment();
  			node.ownerDocument = this;
  			node.childNodes = new NodeList();
  			return node;
  		},
  		createTextNode :	function(data){
  			var node = new Text();
  			node.ownerDocument = this;
  			node.appendData(data);
  			return node;
  		},
  		createComment :	function(data){
  			var node = new Comment();
  			node.ownerDocument = this;
  			node.appendData(data);
  			return node;
  		},
  		createCDATASection :	function(data){
  			var node = new CDATASection();
  			node.ownerDocument = this;
  			node.appendData(data);
  			return node;
  		},
  		createProcessingInstruction :	function(target,data){
  			var node = new ProcessingInstruction();
  			node.ownerDocument = this;
  			node.tagName = node.nodeName = node.target = target;
  			node.nodeValue = node.data = data;
  			return node;
  		},
  		createAttribute :	function(name){
  			var node = new Attr();
  			node.ownerDocument	= this;
  			node.name = name;
  			node.nodeName	= name;
  			node.localName = name;
  			node.specified = true;
  			return node;
  		},
  		createEntityReference :	function(name){
  			var node = new EntityReference();
  			node.ownerDocument	= this;
  			node.nodeName	= name;
  			return node;
  		},
  		// Introduced in DOM Level 2:
  		createElementNS :	function(namespaceURI,qualifiedName){
  			var node = new Element();
  			var pl = qualifiedName.split(':');
  			var attrs	= node.attributes = new NamedNodeMap();
  			node.childNodes = new NodeList();
  			node.ownerDocument = this;
  			node.nodeName = qualifiedName;
  			node.tagName = qualifiedName;
  			node.namespaceURI = namespaceURI;
  			if(pl.length == 2){
  				node.prefix = pl[0];
  				node.localName = pl[1];
  			}else {
  				//el.prefix = null;
  				node.localName = qualifiedName;
  			}
  			attrs._ownerElement = node;
  			return node;
  		},
  		// Introduced in DOM Level 2:
  		createAttributeNS :	function(namespaceURI,qualifiedName){
  			var node = new Attr();
  			var pl = qualifiedName.split(':');
  			node.ownerDocument = this;
  			node.nodeName = qualifiedName;
  			node.name = qualifiedName;
  			node.namespaceURI = namespaceURI;
  			node.specified = true;
  			if(pl.length == 2){
  				node.prefix = pl[0];
  				node.localName = pl[1];
  			}else {
  				//el.prefix = null;
  				node.localName = qualifiedName;
  			}
  			return node;
  		}
  	};
  	_extends(Document,Node);


  	function Element() {
  		this._nsMap = {};
  	}	Element.prototype = {
  		nodeType : ELEMENT_NODE,
  		hasAttribute : function(name){
  			return this.getAttributeNode(name)!=null;
  		},
  		getAttribute : function(name){
  			var attr = this.getAttributeNode(name);
  			return attr && attr.value || '';
  		},
  		getAttributeNode : function(name){
  			return this.attributes.getNamedItem(name);
  		},
  		setAttribute : function(name, value){
  			var attr = this.ownerDocument.createAttribute(name);
  			attr.value = attr.nodeValue = "" + value;
  			this.setAttributeNode(attr);
  		},
  		removeAttribute : function(name){
  			var attr = this.getAttributeNode(name);
  			attr && this.removeAttributeNode(attr);
  		},

  		//four real opeartion method
  		appendChild:function(newChild){
  			if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
  				return this.insertBefore(newChild,null);
  			}else {
  				return _appendSingleChild(this,newChild);
  			}
  		},
  		setAttributeNode : function(newAttr){
  			return this.attributes.setNamedItem(newAttr);
  		},
  		setAttributeNodeNS : function(newAttr){
  			return this.attributes.setNamedItemNS(newAttr);
  		},
  		removeAttributeNode : function(oldAttr){
  			//console.log(this == oldAttr.ownerElement)
  			return this.attributes.removeNamedItem(oldAttr.nodeName);
  		},
  		//get real attribute name,and remove it by removeAttributeNode
  		removeAttributeNS : function(namespaceURI, localName){
  			var old = this.getAttributeNodeNS(namespaceURI, localName);
  			old && this.removeAttributeNode(old);
  		},

  		hasAttributeNS : function(namespaceURI, localName){
  			return this.getAttributeNodeNS(namespaceURI, localName)!=null;
  		},
  		getAttributeNS : function(namespaceURI, localName){
  			var attr = this.getAttributeNodeNS(namespaceURI, localName);
  			return attr && attr.value || '';
  		},
  		setAttributeNS : function(namespaceURI, qualifiedName, value){
  			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
  			attr.value = attr.nodeValue = "" + value;
  			this.setAttributeNode(attr);
  		},
  		getAttributeNodeNS : function(namespaceURI, localName){
  			return this.attributes.getNamedItemNS(namespaceURI, localName);
  		},

  		getElementsByTagName : function(tagName){
  			return new LiveNodeList(this,function(base){
  				var ls = [];
  				_visitNode(base,function(node){
  					if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
  						ls.push(node);
  					}
  				});
  				return ls;
  			});
  		},
  		getElementsByTagNameNS : function(namespaceURI, localName){
  			return new LiveNodeList(this,function(base){
  				var ls = [];
  				_visitNode(base,function(node){
  					if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
  						ls.push(node);
  					}
  				});
  				return ls;

  			});
  		}
  	};
  	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


  	_extends(Element,Node);
  	function Attr() {
  	}	Attr.prototype.nodeType = ATTRIBUTE_NODE;
  	_extends(Attr,Node);


  	function CharacterData() {
  	}	CharacterData.prototype = {
  		data : '',
  		substringData : function(offset, count) {
  			return this.data.substring(offset, offset+count);
  		},
  		appendData: function(text) {
  			text = this.data+text;
  			this.nodeValue = this.data = text;
  			this.length = text.length;
  		},
  		insertData: function(offset,text) {
  			this.replaceData(offset,0,text);

  		},
  		appendChild:function(newChild){
  			throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
  		},
  		deleteData: function(offset, count) {
  			this.replaceData(offset,count,"");
  		},
  		replaceData: function(offset, count, text) {
  			var start = this.data.substring(0,offset);
  			var end = this.data.substring(offset+count);
  			text = start + text + end;
  			this.nodeValue = this.data = text;
  			this.length = text.length;
  		}
  	};
  	_extends(CharacterData,Node);
  	function Text() {
  	}	Text.prototype = {
  		nodeName : "#text",
  		nodeType : TEXT_NODE,
  		splitText : function(offset) {
  			var text = this.data;
  			var newText = text.substring(offset);
  			text = text.substring(0, offset);
  			this.data = this.nodeValue = text;
  			this.length = text.length;
  			var newNode = this.ownerDocument.createTextNode(newText);
  			if(this.parentNode){
  				this.parentNode.insertBefore(newNode, this.nextSibling);
  			}
  			return newNode;
  		}
  	};
  	_extends(Text,CharacterData);
  	function Comment() {
  	}	Comment.prototype = {
  		nodeName : "#comment",
  		nodeType : COMMENT_NODE
  	};
  	_extends(Comment,CharacterData);

  	function CDATASection() {
  	}	CDATASection.prototype = {
  		nodeName : "#cdata-section",
  		nodeType : CDATA_SECTION_NODE
  	};
  	_extends(CDATASection,CharacterData);


  	function DocumentType() {
  	}	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  	_extends(DocumentType,Node);

  	function Notation() {
  	}	Notation.prototype.nodeType = NOTATION_NODE;
  	_extends(Notation,Node);

  	function Entity() {
  	}	Entity.prototype.nodeType = ENTITY_NODE;
  	_extends(Entity,Node);

  	function EntityReference() {
  	}	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  	_extends(EntityReference,Node);

  	function DocumentFragment() {
  	}	DocumentFragment.prototype.nodeName =	"#document-fragment";
  	DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
  	_extends(DocumentFragment,Node);


  	function ProcessingInstruction() {
  	}
  	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  	_extends(ProcessingInstruction,Node);
  	function XMLSerializer(){}
  	XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
  		return nodeSerializeToString.call(node,isHtml,nodeFilter);
  	};
  	Node.prototype.toString = nodeSerializeToString;
  	function nodeSerializeToString(isHtml,nodeFilter){
  		var buf = [];
  		var refNode = this.nodeType == 9 && this.documentElement || this;
  		var prefix = refNode.prefix;
  		var uri = refNode.namespaceURI;

  		if(uri && prefix == null){
  			//console.log(prefix)
  			var prefix = refNode.lookupPrefix(uri);
  			if(prefix == null){
  				//isHTML = true;
  				var visibleNamespaces=[
  				{namespace:uri,prefix:null}
  				//{namespace:uri,prefix:''}
  				];
  			}
  		}
  		serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
  		//console.log('###',this.nodeType,uri,prefix,buf.join(''))
  		return buf.join('');
  	}

  	function needNamespaceDefine(node, isHTML, visibleNamespaces) {
  		var prefix = node.prefix || '';
  		var uri = node.namespaceURI;
  		// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
  		// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
  		// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
  		// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
  		// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
  		// > [...] Furthermore, the attribute value [...] must not be an empty string.
  		// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
  		if (!uri) {
  			return false;
  		}
  		if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
  			return false;
  		}

  		var i = visibleNamespaces.length;
  		while (i--) {
  			var ns = visibleNamespaces[i];
  			// get namespace prefix
  			if (ns.prefix === prefix) {
  				return ns.namespace !== uri;
  			}
  		}
  		return true;
  	}
  	/**
  	 * Well-formed constraint: No < in Attribute Values
  	 * > The replacement text of any entity referred to directly or indirectly
  	 * > in an attribute value must not contain a <.
  	 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
  	 * @see https://www.w3.org/TR/xml11/#NT-AttValue
  	 *
  	 * Literal whitespace other than space that appear in attribute values
  	 * are serialized as their entity references, so they will be preserved.
  	 * (In contrast to whitespace literals in the input which are normalized to spaces)
  	 * @see https://www.w3.org/TR/xml11/#AVNormalize
  	 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
  	 */
  	function addSerializedAttribute(buf, qualifiedName, value) {
  		buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
  	}

  	function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
  		if (!visibleNamespaces) {
  			visibleNamespaces = [];
  		}

  		if(nodeFilter){
  			node = nodeFilter(node);
  			if(node){
  				if(typeof node == 'string'){
  					buf.push(node);
  					return;
  				}
  			}else {
  				return;
  			}
  			//buf.sort.apply(attrs, attributeSorter);
  		}

  		switch(node.nodeType){
  		case ELEMENT_NODE:
  			var attrs = node.attributes;
  			var len = attrs.length;
  			var child = node.firstChild;
  			var nodeName = node.tagName;

  			isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;

  			var prefixedNodeName = nodeName;
  			if (!isHTML && !node.prefix && node.namespaceURI) {
  				var defaultNS;
  				// lookup current default ns from `xmlns` attribute
  				for (var ai = 0; ai < attrs.length; ai++) {
  					if (attrs.item(ai).name === 'xmlns') {
  						defaultNS = attrs.item(ai).value;
  						break
  					}
  				}
  				if (!defaultNS) {
  					// lookup current default ns in visibleNamespaces
  					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
  						var namespace = visibleNamespaces[nsi];
  						if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
  							defaultNS = namespace.namespace;
  							break
  						}
  					}
  				}
  				if (defaultNS !== node.namespaceURI) {
  					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
  						var namespace = visibleNamespaces[nsi];
  						if (namespace.namespace === node.namespaceURI) {
  							if (namespace.prefix) {
  								prefixedNodeName = namespace.prefix + ':' + nodeName;
  							}
  							break
  						}
  					}
  				}
  			}

  			buf.push('<', prefixedNodeName);

  			for(var i=0;i<len;i++){
  				// add namespaces for attributes
  				var attr = attrs.item(i);
  				if (attr.prefix == 'xmlns') {
  					visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
  				}else if(attr.nodeName == 'xmlns'){
  					visibleNamespaces.push({ prefix: '', namespace: attr.value });
  				}
  			}

  			for(var i=0;i<len;i++){
  				var attr = attrs.item(i);
  				if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
  					var prefix = attr.prefix||'';
  					var uri = attr.namespaceURI;
  					addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
  					visibleNamespaces.push({ prefix: prefix, namespace:uri });
  				}
  				serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
  			}

  			// add namespace for current node
  			if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
  				var prefix = node.prefix||'';
  				var uri = node.namespaceURI;
  				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
  				visibleNamespaces.push({ prefix: prefix, namespace:uri });
  			}

  			if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
  				buf.push('>');
  				//if is cdata child node
  				if(isHTML && /^script$/i.test(nodeName)){
  					while(child){
  						if(child.data){
  							buf.push(child.data);
  						}else {
  							serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
  						}
  						child = child.nextSibling;
  					}
  				}else
  				{
  					while(child){
  						serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
  						child = child.nextSibling;
  					}
  				}
  				buf.push('</',prefixedNodeName,'>');
  			}else {
  				buf.push('/>');
  			}
  			// remove added visible namespaces
  			//visibleNamespaces.length = startVisibleNamespaces;
  			return;
  		case DOCUMENT_NODE:
  		case DOCUMENT_FRAGMENT_NODE:
  			var child = node.firstChild;
  			while(child){
  				serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
  				child = child.nextSibling;
  			}
  			return;
  		case ATTRIBUTE_NODE:
  			return addSerializedAttribute(buf, node.name, node.value);
  		case TEXT_NODE:
  			/**
  			 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
  			 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
  			 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
  			 * `&amp;` and `&lt;` respectively.
  			 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
  			 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
  			 * when that string is not marking the end of a CDATA section.
  			 *
  			 * In the content of elements, character data is any string of characters
  			 * which does not contain the start-delimiter of any markup
  			 * and does not include the CDATA-section-close delimiter, `]]>`.
  			 *
  			 * @see https://www.w3.org/TR/xml/#NT-CharData
  			 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
  			 */
  			return buf.push(node.data
  				.replace(/[<&>]/g,_xmlEncoder)
  			);
  		case CDATA_SECTION_NODE:
  			return buf.push( '<![CDATA[',node.data,']]>');
  		case COMMENT_NODE:
  			return buf.push( "<!--",node.data,"-->");
  		case DOCUMENT_TYPE_NODE:
  			var pubid = node.publicId;
  			var sysid = node.systemId;
  			buf.push('<!DOCTYPE ',node.name);
  			if(pubid){
  				buf.push(' PUBLIC ', pubid);
  				if (sysid && sysid!='.') {
  					buf.push(' ', sysid);
  				}
  				buf.push('>');
  			}else if(sysid && sysid!='.'){
  				buf.push(' SYSTEM ', sysid, '>');
  			}else {
  				var sub = node.internalSubset;
  				if(sub){
  					buf.push(" [",sub,"]");
  				}
  				buf.push(">");
  			}
  			return;
  		case PROCESSING_INSTRUCTION_NODE:
  			return buf.push( "<?",node.target," ",node.data,"?>");
  		case ENTITY_REFERENCE_NODE:
  			return buf.push( '&',node.nodeName,';');
  		//case ENTITY_NODE:
  		//case NOTATION_NODE:
  		default:
  			buf.push('??',node.nodeName);
  		}
  	}
  	function importNode(doc,node,deep){
  		var node2;
  		switch (node.nodeType) {
  		case ELEMENT_NODE:
  			node2 = node.cloneNode(false);
  			node2.ownerDocument = doc;
  			//var attrs = node2.attributes;
  			//var len = attrs.length;
  			//for(var i=0;i<len;i++){
  				//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
  			//}
  		case DOCUMENT_FRAGMENT_NODE:
  			break;
  		case ATTRIBUTE_NODE:
  			deep = true;
  			break;
  		//case ENTITY_REFERENCE_NODE:
  		//case PROCESSING_INSTRUCTION_NODE:
  		////case TEXT_NODE:
  		//case CDATA_SECTION_NODE:
  		//case COMMENT_NODE:
  		//	deep = false;
  		//	break;
  		//case DOCUMENT_NODE:
  		//case DOCUMENT_TYPE_NODE:
  		//cannot be imported.
  		//case ENTITY_NODE:
  		//case NOTATION_NODE
  		//can not hit in level3
  		//default:throw e;
  		}
  		if(!node2){
  			node2 = node.cloneNode(false);//false
  		}
  		node2.ownerDocument = doc;
  		node2.parentNode = null;
  		if(deep){
  			var child = node.firstChild;
  			while(child){
  				node2.appendChild(importNode(doc,child,deep));
  				child = child.nextSibling;
  			}
  		}
  		return node2;
  	}
  	//
  	//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
  	//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
  	function cloneNode(doc,node,deep){
  		var node2 = new node.constructor();
  		for (var n in node) {
  			if (Object.prototype.hasOwnProperty.call(node, n)) {
  				var v = node[n];
  				if (typeof v != "object") {
  					if (v != node2[n]) {
  						node2[n] = v;
  					}
  				}
  			}
  		}
  		if(node.childNodes){
  			node2.childNodes = new NodeList();
  		}
  		node2.ownerDocument = doc;
  		switch (node2.nodeType) {
  		case ELEMENT_NODE:
  			var attrs	= node.attributes;
  			var attrs2	= node2.attributes = new NamedNodeMap();
  			var len = attrs.length;
  			attrs2._ownerElement = node2;
  			for(var i=0;i<len;i++){
  				node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
  			}
  			break;		case ATTRIBUTE_NODE:
  			deep = true;
  		}
  		if(deep){
  			var child = node.firstChild;
  			while(child){
  				node2.appendChild(cloneNode(doc,child,deep));
  				child = child.nextSibling;
  			}
  		}
  		return node2;
  	}

  	function __set__(object,key,value){
  		object[key] = value;
  	}
  	//do dynamic
  	try{
  		if(Object.defineProperty){
  			Object.defineProperty(LiveNodeList.prototype,'length',{
  				get:function(){
  					_updateLiveList(this);
  					return this.$$length;
  				}
  			});

  			Object.defineProperty(Node.prototype,'textContent',{
  				get:function(){
  					return getTextContent(this);
  				},

  				set:function(data){
  					switch(this.nodeType){
  					case ELEMENT_NODE:
  					case DOCUMENT_FRAGMENT_NODE:
  						while(this.firstChild){
  							this.removeChild(this.firstChild);
  						}
  						if(data || String(data)){
  							this.appendChild(this.ownerDocument.createTextNode(data));
  						}
  						break;

  					default:
  						this.data = data;
  						this.value = data;
  						this.nodeValue = data;
  					}
  				}
  			});

  			function getTextContent(node){
  				switch(node.nodeType){
  				case ELEMENT_NODE:
  				case DOCUMENT_FRAGMENT_NODE:
  					var buf = [];
  					node = node.firstChild;
  					while(node){
  						if(node.nodeType!==7 && node.nodeType !==8){
  							buf.push(getTextContent(node));
  						}
  						node = node.nextSibling;
  					}
  					return buf.join('');
  				default:
  					return node.nodeValue;
  				}
  			}

  			__set__ = function(object,key,value){
  				//console.log(value)
  				object['$$'+key] = value;
  			};
  		}
  	}catch(e){//ie8
  	}

  	//if(typeof require == 'function'){
  		dom.DocumentType = DocumentType;
  		dom.DOMException = DOMException;
  		dom.DOMImplementation = DOMImplementation;
  		dom.Element = Element;
  		dom.Node = Node;
  		dom.NodeList = NodeList;
  		dom.XMLSerializer = XMLSerializer;
  	//}
  	return dom;
  }

  var domParser = {};

  var entities = {};

  var hasRequiredEntities;

  function requireEntities () {
  	if (hasRequiredEntities) return entities;
  	hasRequiredEntities = 1;
  	(function (exports) {

  		var freeze = requireConventions().freeze;

  		/**
  		 * The entities that are predefined in every XML document.
  		 *
  		 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
  		 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
  		 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
  		 */
  		exports.XML_ENTITIES = freeze({
  			amp: '&',
  			apos: "'",
  			gt: '>',
  			lt: '<',
  			quot: '"',
  		});

  		/**
  		 * A map of all entities that are detected in an HTML document.
  		 * They contain all entries from `XML_ENTITIES`.
  		 *
  		 * @see XML_ENTITIES
  		 * @see DOMParser.parseFromString
  		 * @see DOMImplementation.prototype.createHTMLDocument
  		 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
  		 * @see https://html.spec.whatwg.org/entities.json JSON
  		 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
  		 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
  		 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
  		 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
  		 */
  		exports.HTML_ENTITIES = freeze({
  			Aacute: '\u00C1',
  			aacute: '\u00E1',
  			Abreve: '\u0102',
  			abreve: '\u0103',
  			ac: '\u223E',
  			acd: '\u223F',
  			acE: '\u223E\u0333',
  			Acirc: '\u00C2',
  			acirc: '\u00E2',
  			acute: '\u00B4',
  			Acy: '\u0410',
  			acy: '\u0430',
  			AElig: '\u00C6',
  			aelig: '\u00E6',
  			af: '\u2061',
  			Afr: '\uD835\uDD04',
  			afr: '\uD835\uDD1E',
  			Agrave: '\u00C0',
  			agrave: '\u00E0',
  			alefsym: '\u2135',
  			aleph: '\u2135',
  			Alpha: '\u0391',
  			alpha: '\u03B1',
  			Amacr: '\u0100',
  			amacr: '\u0101',
  			amalg: '\u2A3F',
  			AMP: '\u0026',
  			amp: '\u0026',
  			And: '\u2A53',
  			and: '\u2227',
  			andand: '\u2A55',
  			andd: '\u2A5C',
  			andslope: '\u2A58',
  			andv: '\u2A5A',
  			ang: '\u2220',
  			ange: '\u29A4',
  			angle: '\u2220',
  			angmsd: '\u2221',
  			angmsdaa: '\u29A8',
  			angmsdab: '\u29A9',
  			angmsdac: '\u29AA',
  			angmsdad: '\u29AB',
  			angmsdae: '\u29AC',
  			angmsdaf: '\u29AD',
  			angmsdag: '\u29AE',
  			angmsdah: '\u29AF',
  			angrt: '\u221F',
  			angrtvb: '\u22BE',
  			angrtvbd: '\u299D',
  			angsph: '\u2222',
  			angst: '\u00C5',
  			angzarr: '\u237C',
  			Aogon: '\u0104',
  			aogon: '\u0105',
  			Aopf: '\uD835\uDD38',
  			aopf: '\uD835\uDD52',
  			ap: '\u2248',
  			apacir: '\u2A6F',
  			apE: '\u2A70',
  			ape: '\u224A',
  			apid: '\u224B',
  			apos: '\u0027',
  			ApplyFunction: '\u2061',
  			approx: '\u2248',
  			approxeq: '\u224A',
  			Aring: '\u00C5',
  			aring: '\u00E5',
  			Ascr: '\uD835\uDC9C',
  			ascr: '\uD835\uDCB6',
  			Assign: '\u2254',
  			ast: '\u002A',
  			asymp: '\u2248',
  			asympeq: '\u224D',
  			Atilde: '\u00C3',
  			atilde: '\u00E3',
  			Auml: '\u00C4',
  			auml: '\u00E4',
  			awconint: '\u2233',
  			awint: '\u2A11',
  			backcong: '\u224C',
  			backepsilon: '\u03F6',
  			backprime: '\u2035',
  			backsim: '\u223D',
  			backsimeq: '\u22CD',
  			Backslash: '\u2216',
  			Barv: '\u2AE7',
  			barvee: '\u22BD',
  			Barwed: '\u2306',
  			barwed: '\u2305',
  			barwedge: '\u2305',
  			bbrk: '\u23B5',
  			bbrktbrk: '\u23B6',
  			bcong: '\u224C',
  			Bcy: '\u0411',
  			bcy: '\u0431',
  			bdquo: '\u201E',
  			becaus: '\u2235',
  			Because: '\u2235',
  			because: '\u2235',
  			bemptyv: '\u29B0',
  			bepsi: '\u03F6',
  			bernou: '\u212C',
  			Bernoullis: '\u212C',
  			Beta: '\u0392',
  			beta: '\u03B2',
  			beth: '\u2136',
  			between: '\u226C',
  			Bfr: '\uD835\uDD05',
  			bfr: '\uD835\uDD1F',
  			bigcap: '\u22C2',
  			bigcirc: '\u25EF',
  			bigcup: '\u22C3',
  			bigodot: '\u2A00',
  			bigoplus: '\u2A01',
  			bigotimes: '\u2A02',
  			bigsqcup: '\u2A06',
  			bigstar: '\u2605',
  			bigtriangledown: '\u25BD',
  			bigtriangleup: '\u25B3',
  			biguplus: '\u2A04',
  			bigvee: '\u22C1',
  			bigwedge: '\u22C0',
  			bkarow: '\u290D',
  			blacklozenge: '\u29EB',
  			blacksquare: '\u25AA',
  			blacktriangle: '\u25B4',
  			blacktriangledown: '\u25BE',
  			blacktriangleleft: '\u25C2',
  			blacktriangleright: '\u25B8',
  			blank: '\u2423',
  			blk12: '\u2592',
  			blk14: '\u2591',
  			blk34: '\u2593',
  			block: '\u2588',
  			bne: '\u003D\u20E5',
  			bnequiv: '\u2261\u20E5',
  			bNot: '\u2AED',
  			bnot: '\u2310',
  			Bopf: '\uD835\uDD39',
  			bopf: '\uD835\uDD53',
  			bot: '\u22A5',
  			bottom: '\u22A5',
  			bowtie: '\u22C8',
  			boxbox: '\u29C9',
  			boxDL: '\u2557',
  			boxDl: '\u2556',
  			boxdL: '\u2555',
  			boxdl: '\u2510',
  			boxDR: '\u2554',
  			boxDr: '\u2553',
  			boxdR: '\u2552',
  			boxdr: '\u250C',
  			boxH: '\u2550',
  			boxh: '\u2500',
  			boxHD: '\u2566',
  			boxHd: '\u2564',
  			boxhD: '\u2565',
  			boxhd: '\u252C',
  			boxHU: '\u2569',
  			boxHu: '\u2567',
  			boxhU: '\u2568',
  			boxhu: '\u2534',
  			boxminus: '\u229F',
  			boxplus: '\u229E',
  			boxtimes: '\u22A0',
  			boxUL: '\u255D',
  			boxUl: '\u255C',
  			boxuL: '\u255B',
  			boxul: '\u2518',
  			boxUR: '\u255A',
  			boxUr: '\u2559',
  			boxuR: '\u2558',
  			boxur: '\u2514',
  			boxV: '\u2551',
  			boxv: '\u2502',
  			boxVH: '\u256C',
  			boxVh: '\u256B',
  			boxvH: '\u256A',
  			boxvh: '\u253C',
  			boxVL: '\u2563',
  			boxVl: '\u2562',
  			boxvL: '\u2561',
  			boxvl: '\u2524',
  			boxVR: '\u2560',
  			boxVr: '\u255F',
  			boxvR: '\u255E',
  			boxvr: '\u251C',
  			bprime: '\u2035',
  			Breve: '\u02D8',
  			breve: '\u02D8',
  			brvbar: '\u00A6',
  			Bscr: '\u212C',
  			bscr: '\uD835\uDCB7',
  			bsemi: '\u204F',
  			bsim: '\u223D',
  			bsime: '\u22CD',
  			bsol: '\u005C',
  			bsolb: '\u29C5',
  			bsolhsub: '\u27C8',
  			bull: '\u2022',
  			bullet: '\u2022',
  			bump: '\u224E',
  			bumpE: '\u2AAE',
  			bumpe: '\u224F',
  			Bumpeq: '\u224E',
  			bumpeq: '\u224F',
  			Cacute: '\u0106',
  			cacute: '\u0107',
  			Cap: '\u22D2',
  			cap: '\u2229',
  			capand: '\u2A44',
  			capbrcup: '\u2A49',
  			capcap: '\u2A4B',
  			capcup: '\u2A47',
  			capdot: '\u2A40',
  			CapitalDifferentialD: '\u2145',
  			caps: '\u2229\uFE00',
  			caret: '\u2041',
  			caron: '\u02C7',
  			Cayleys: '\u212D',
  			ccaps: '\u2A4D',
  			Ccaron: '\u010C',
  			ccaron: '\u010D',
  			Ccedil: '\u00C7',
  			ccedil: '\u00E7',
  			Ccirc: '\u0108',
  			ccirc: '\u0109',
  			Cconint: '\u2230',
  			ccups: '\u2A4C',
  			ccupssm: '\u2A50',
  			Cdot: '\u010A',
  			cdot: '\u010B',
  			cedil: '\u00B8',
  			Cedilla: '\u00B8',
  			cemptyv: '\u29B2',
  			cent: '\u00A2',
  			CenterDot: '\u00B7',
  			centerdot: '\u00B7',
  			Cfr: '\u212D',
  			cfr: '\uD835\uDD20',
  			CHcy: '\u0427',
  			chcy: '\u0447',
  			check: '\u2713',
  			checkmark: '\u2713',
  			Chi: '\u03A7',
  			chi: '\u03C7',
  			cir: '\u25CB',
  			circ: '\u02C6',
  			circeq: '\u2257',
  			circlearrowleft: '\u21BA',
  			circlearrowright: '\u21BB',
  			circledast: '\u229B',
  			circledcirc: '\u229A',
  			circleddash: '\u229D',
  			CircleDot: '\u2299',
  			circledR: '\u00AE',
  			circledS: '\u24C8',
  			CircleMinus: '\u2296',
  			CirclePlus: '\u2295',
  			CircleTimes: '\u2297',
  			cirE: '\u29C3',
  			cire: '\u2257',
  			cirfnint: '\u2A10',
  			cirmid: '\u2AEF',
  			cirscir: '\u29C2',
  			ClockwiseContourIntegral: '\u2232',
  			CloseCurlyDoubleQuote: '\u201D',
  			CloseCurlyQuote: '\u2019',
  			clubs: '\u2663',
  			clubsuit: '\u2663',
  			Colon: '\u2237',
  			colon: '\u003A',
  			Colone: '\u2A74',
  			colone: '\u2254',
  			coloneq: '\u2254',
  			comma: '\u002C',
  			commat: '\u0040',
  			comp: '\u2201',
  			compfn: '\u2218',
  			complement: '\u2201',
  			complexes: '\u2102',
  			cong: '\u2245',
  			congdot: '\u2A6D',
  			Congruent: '\u2261',
  			Conint: '\u222F',
  			conint: '\u222E',
  			ContourIntegral: '\u222E',
  			Copf: '\u2102',
  			copf: '\uD835\uDD54',
  			coprod: '\u2210',
  			Coproduct: '\u2210',
  			COPY: '\u00A9',
  			copy: '\u00A9',
  			copysr: '\u2117',
  			CounterClockwiseContourIntegral: '\u2233',
  			crarr: '\u21B5',
  			Cross: '\u2A2F',
  			cross: '\u2717',
  			Cscr: '\uD835\uDC9E',
  			cscr: '\uD835\uDCB8',
  			csub: '\u2ACF',
  			csube: '\u2AD1',
  			csup: '\u2AD0',
  			csupe: '\u2AD2',
  			ctdot: '\u22EF',
  			cudarrl: '\u2938',
  			cudarrr: '\u2935',
  			cuepr: '\u22DE',
  			cuesc: '\u22DF',
  			cularr: '\u21B6',
  			cularrp: '\u293D',
  			Cup: '\u22D3',
  			cup: '\u222A',
  			cupbrcap: '\u2A48',
  			CupCap: '\u224D',
  			cupcap: '\u2A46',
  			cupcup: '\u2A4A',
  			cupdot: '\u228D',
  			cupor: '\u2A45',
  			cups: '\u222A\uFE00',
  			curarr: '\u21B7',
  			curarrm: '\u293C',
  			curlyeqprec: '\u22DE',
  			curlyeqsucc: '\u22DF',
  			curlyvee: '\u22CE',
  			curlywedge: '\u22CF',
  			curren: '\u00A4',
  			curvearrowleft: '\u21B6',
  			curvearrowright: '\u21B7',
  			cuvee: '\u22CE',
  			cuwed: '\u22CF',
  			cwconint: '\u2232',
  			cwint: '\u2231',
  			cylcty: '\u232D',
  			Dagger: '\u2021',
  			dagger: '\u2020',
  			daleth: '\u2138',
  			Darr: '\u21A1',
  			dArr: '\u21D3',
  			darr: '\u2193',
  			dash: '\u2010',
  			Dashv: '\u2AE4',
  			dashv: '\u22A3',
  			dbkarow: '\u290F',
  			dblac: '\u02DD',
  			Dcaron: '\u010E',
  			dcaron: '\u010F',
  			Dcy: '\u0414',
  			dcy: '\u0434',
  			DD: '\u2145',
  			dd: '\u2146',
  			ddagger: '\u2021',
  			ddarr: '\u21CA',
  			DDotrahd: '\u2911',
  			ddotseq: '\u2A77',
  			deg: '\u00B0',
  			Del: '\u2207',
  			Delta: '\u0394',
  			delta: '\u03B4',
  			demptyv: '\u29B1',
  			dfisht: '\u297F',
  			Dfr: '\uD835\uDD07',
  			dfr: '\uD835\uDD21',
  			dHar: '\u2965',
  			dharl: '\u21C3',
  			dharr: '\u21C2',
  			DiacriticalAcute: '\u00B4',
  			DiacriticalDot: '\u02D9',
  			DiacriticalDoubleAcute: '\u02DD',
  			DiacriticalGrave: '\u0060',
  			DiacriticalTilde: '\u02DC',
  			diam: '\u22C4',
  			Diamond: '\u22C4',
  			diamond: '\u22C4',
  			diamondsuit: '\u2666',
  			diams: '\u2666',
  			die: '\u00A8',
  			DifferentialD: '\u2146',
  			digamma: '\u03DD',
  			disin: '\u22F2',
  			div: '\u00F7',
  			divide: '\u00F7',
  			divideontimes: '\u22C7',
  			divonx: '\u22C7',
  			DJcy: '\u0402',
  			djcy: '\u0452',
  			dlcorn: '\u231E',
  			dlcrop: '\u230D',
  			dollar: '\u0024',
  			Dopf: '\uD835\uDD3B',
  			dopf: '\uD835\uDD55',
  			Dot: '\u00A8',
  			dot: '\u02D9',
  			DotDot: '\u20DC',
  			doteq: '\u2250',
  			doteqdot: '\u2251',
  			DotEqual: '\u2250',
  			dotminus: '\u2238',
  			dotplus: '\u2214',
  			dotsquare: '\u22A1',
  			doublebarwedge: '\u2306',
  			DoubleContourIntegral: '\u222F',
  			DoubleDot: '\u00A8',
  			DoubleDownArrow: '\u21D3',
  			DoubleLeftArrow: '\u21D0',
  			DoubleLeftRightArrow: '\u21D4',
  			DoubleLeftTee: '\u2AE4',
  			DoubleLongLeftArrow: '\u27F8',
  			DoubleLongLeftRightArrow: '\u27FA',
  			DoubleLongRightArrow: '\u27F9',
  			DoubleRightArrow: '\u21D2',
  			DoubleRightTee: '\u22A8',
  			DoubleUpArrow: '\u21D1',
  			DoubleUpDownArrow: '\u21D5',
  			DoubleVerticalBar: '\u2225',
  			DownArrow: '\u2193',
  			Downarrow: '\u21D3',
  			downarrow: '\u2193',
  			DownArrowBar: '\u2913',
  			DownArrowUpArrow: '\u21F5',
  			DownBreve: '\u0311',
  			downdownarrows: '\u21CA',
  			downharpoonleft: '\u21C3',
  			downharpoonright: '\u21C2',
  			DownLeftRightVector: '\u2950',
  			DownLeftTeeVector: '\u295E',
  			DownLeftVector: '\u21BD',
  			DownLeftVectorBar: '\u2956',
  			DownRightTeeVector: '\u295F',
  			DownRightVector: '\u21C1',
  			DownRightVectorBar: '\u2957',
  			DownTee: '\u22A4',
  			DownTeeArrow: '\u21A7',
  			drbkarow: '\u2910',
  			drcorn: '\u231F',
  			drcrop: '\u230C',
  			Dscr: '\uD835\uDC9F',
  			dscr: '\uD835\uDCB9',
  			DScy: '\u0405',
  			dscy: '\u0455',
  			dsol: '\u29F6',
  			Dstrok: '\u0110',
  			dstrok: '\u0111',
  			dtdot: '\u22F1',
  			dtri: '\u25BF',
  			dtrif: '\u25BE',
  			duarr: '\u21F5',
  			duhar: '\u296F',
  			dwangle: '\u29A6',
  			DZcy: '\u040F',
  			dzcy: '\u045F',
  			dzigrarr: '\u27FF',
  			Eacute: '\u00C9',
  			eacute: '\u00E9',
  			easter: '\u2A6E',
  			Ecaron: '\u011A',
  			ecaron: '\u011B',
  			ecir: '\u2256',
  			Ecirc: '\u00CA',
  			ecirc: '\u00EA',
  			ecolon: '\u2255',
  			Ecy: '\u042D',
  			ecy: '\u044D',
  			eDDot: '\u2A77',
  			Edot: '\u0116',
  			eDot: '\u2251',
  			edot: '\u0117',
  			ee: '\u2147',
  			efDot: '\u2252',
  			Efr: '\uD835\uDD08',
  			efr: '\uD835\uDD22',
  			eg: '\u2A9A',
  			Egrave: '\u00C8',
  			egrave: '\u00E8',
  			egs: '\u2A96',
  			egsdot: '\u2A98',
  			el: '\u2A99',
  			Element: '\u2208',
  			elinters: '\u23E7',
  			ell: '\u2113',
  			els: '\u2A95',
  			elsdot: '\u2A97',
  			Emacr: '\u0112',
  			emacr: '\u0113',
  			empty: '\u2205',
  			emptyset: '\u2205',
  			EmptySmallSquare: '\u25FB',
  			emptyv: '\u2205',
  			EmptyVerySmallSquare: '\u25AB',
  			emsp: '\u2003',
  			emsp13: '\u2004',
  			emsp14: '\u2005',
  			ENG: '\u014A',
  			eng: '\u014B',
  			ensp: '\u2002',
  			Eogon: '\u0118',
  			eogon: '\u0119',
  			Eopf: '\uD835\uDD3C',
  			eopf: '\uD835\uDD56',
  			epar: '\u22D5',
  			eparsl: '\u29E3',
  			eplus: '\u2A71',
  			epsi: '\u03B5',
  			Epsilon: '\u0395',
  			epsilon: '\u03B5',
  			epsiv: '\u03F5',
  			eqcirc: '\u2256',
  			eqcolon: '\u2255',
  			eqsim: '\u2242',
  			eqslantgtr: '\u2A96',
  			eqslantless: '\u2A95',
  			Equal: '\u2A75',
  			equals: '\u003D',
  			EqualTilde: '\u2242',
  			equest: '\u225F',
  			Equilibrium: '\u21CC',
  			equiv: '\u2261',
  			equivDD: '\u2A78',
  			eqvparsl: '\u29E5',
  			erarr: '\u2971',
  			erDot: '\u2253',
  			Escr: '\u2130',
  			escr: '\u212F',
  			esdot: '\u2250',
  			Esim: '\u2A73',
  			esim: '\u2242',
  			Eta: '\u0397',
  			eta: '\u03B7',
  			ETH: '\u00D0',
  			eth: '\u00F0',
  			Euml: '\u00CB',
  			euml: '\u00EB',
  			euro: '\u20AC',
  			excl: '\u0021',
  			exist: '\u2203',
  			Exists: '\u2203',
  			expectation: '\u2130',
  			ExponentialE: '\u2147',
  			exponentiale: '\u2147',
  			fallingdotseq: '\u2252',
  			Fcy: '\u0424',
  			fcy: '\u0444',
  			female: '\u2640',
  			ffilig: '\uFB03',
  			fflig: '\uFB00',
  			ffllig: '\uFB04',
  			Ffr: '\uD835\uDD09',
  			ffr: '\uD835\uDD23',
  			filig: '\uFB01',
  			FilledSmallSquare: '\u25FC',
  			FilledVerySmallSquare: '\u25AA',
  			fjlig: '\u0066\u006A',
  			flat: '\u266D',
  			fllig: '\uFB02',
  			fltns: '\u25B1',
  			fnof: '\u0192',
  			Fopf: '\uD835\uDD3D',
  			fopf: '\uD835\uDD57',
  			ForAll: '\u2200',
  			forall: '\u2200',
  			fork: '\u22D4',
  			forkv: '\u2AD9',
  			Fouriertrf: '\u2131',
  			fpartint: '\u2A0D',
  			frac12: '\u00BD',
  			frac13: '\u2153',
  			frac14: '\u00BC',
  			frac15: '\u2155',
  			frac16: '\u2159',
  			frac18: '\u215B',
  			frac23: '\u2154',
  			frac25: '\u2156',
  			frac34: '\u00BE',
  			frac35: '\u2157',
  			frac38: '\u215C',
  			frac45: '\u2158',
  			frac56: '\u215A',
  			frac58: '\u215D',
  			frac78: '\u215E',
  			frasl: '\u2044',
  			frown: '\u2322',
  			Fscr: '\u2131',
  			fscr: '\uD835\uDCBB',
  			gacute: '\u01F5',
  			Gamma: '\u0393',
  			gamma: '\u03B3',
  			Gammad: '\u03DC',
  			gammad: '\u03DD',
  			gap: '\u2A86',
  			Gbreve: '\u011E',
  			gbreve: '\u011F',
  			Gcedil: '\u0122',
  			Gcirc: '\u011C',
  			gcirc: '\u011D',
  			Gcy: '\u0413',
  			gcy: '\u0433',
  			Gdot: '\u0120',
  			gdot: '\u0121',
  			gE: '\u2267',
  			ge: '\u2265',
  			gEl: '\u2A8C',
  			gel: '\u22DB',
  			geq: '\u2265',
  			geqq: '\u2267',
  			geqslant: '\u2A7E',
  			ges: '\u2A7E',
  			gescc: '\u2AA9',
  			gesdot: '\u2A80',
  			gesdoto: '\u2A82',
  			gesdotol: '\u2A84',
  			gesl: '\u22DB\uFE00',
  			gesles: '\u2A94',
  			Gfr: '\uD835\uDD0A',
  			gfr: '\uD835\uDD24',
  			Gg: '\u22D9',
  			gg: '\u226B',
  			ggg: '\u22D9',
  			gimel: '\u2137',
  			GJcy: '\u0403',
  			gjcy: '\u0453',
  			gl: '\u2277',
  			gla: '\u2AA5',
  			glE: '\u2A92',
  			glj: '\u2AA4',
  			gnap: '\u2A8A',
  			gnapprox: '\u2A8A',
  			gnE: '\u2269',
  			gne: '\u2A88',
  			gneq: '\u2A88',
  			gneqq: '\u2269',
  			gnsim: '\u22E7',
  			Gopf: '\uD835\uDD3E',
  			gopf: '\uD835\uDD58',
  			grave: '\u0060',
  			GreaterEqual: '\u2265',
  			GreaterEqualLess: '\u22DB',
  			GreaterFullEqual: '\u2267',
  			GreaterGreater: '\u2AA2',
  			GreaterLess: '\u2277',
  			GreaterSlantEqual: '\u2A7E',
  			GreaterTilde: '\u2273',
  			Gscr: '\uD835\uDCA2',
  			gscr: '\u210A',
  			gsim: '\u2273',
  			gsime: '\u2A8E',
  			gsiml: '\u2A90',
  			Gt: '\u226B',
  			GT: '\u003E',
  			gt: '\u003E',
  			gtcc: '\u2AA7',
  			gtcir: '\u2A7A',
  			gtdot: '\u22D7',
  			gtlPar: '\u2995',
  			gtquest: '\u2A7C',
  			gtrapprox: '\u2A86',
  			gtrarr: '\u2978',
  			gtrdot: '\u22D7',
  			gtreqless: '\u22DB',
  			gtreqqless: '\u2A8C',
  			gtrless: '\u2277',
  			gtrsim: '\u2273',
  			gvertneqq: '\u2269\uFE00',
  			gvnE: '\u2269\uFE00',
  			Hacek: '\u02C7',
  			hairsp: '\u200A',
  			half: '\u00BD',
  			hamilt: '\u210B',
  			HARDcy: '\u042A',
  			hardcy: '\u044A',
  			hArr: '\u21D4',
  			harr: '\u2194',
  			harrcir: '\u2948',
  			harrw: '\u21AD',
  			Hat: '\u005E',
  			hbar: '\u210F',
  			Hcirc: '\u0124',
  			hcirc: '\u0125',
  			hearts: '\u2665',
  			heartsuit: '\u2665',
  			hellip: '\u2026',
  			hercon: '\u22B9',
  			Hfr: '\u210C',
  			hfr: '\uD835\uDD25',
  			HilbertSpace: '\u210B',
  			hksearow: '\u2925',
  			hkswarow: '\u2926',
  			hoarr: '\u21FF',
  			homtht: '\u223B',
  			hookleftarrow: '\u21A9',
  			hookrightarrow: '\u21AA',
  			Hopf: '\u210D',
  			hopf: '\uD835\uDD59',
  			horbar: '\u2015',
  			HorizontalLine: '\u2500',
  			Hscr: '\u210B',
  			hscr: '\uD835\uDCBD',
  			hslash: '\u210F',
  			Hstrok: '\u0126',
  			hstrok: '\u0127',
  			HumpDownHump: '\u224E',
  			HumpEqual: '\u224F',
  			hybull: '\u2043',
  			hyphen: '\u2010',
  			Iacute: '\u00CD',
  			iacute: '\u00ED',
  			ic: '\u2063',
  			Icirc: '\u00CE',
  			icirc: '\u00EE',
  			Icy: '\u0418',
  			icy: '\u0438',
  			Idot: '\u0130',
  			IEcy: '\u0415',
  			iecy: '\u0435',
  			iexcl: '\u00A1',
  			iff: '\u21D4',
  			Ifr: '\u2111',
  			ifr: '\uD835\uDD26',
  			Igrave: '\u00CC',
  			igrave: '\u00EC',
  			ii: '\u2148',
  			iiiint: '\u2A0C',
  			iiint: '\u222D',
  			iinfin: '\u29DC',
  			iiota: '\u2129',
  			IJlig: '\u0132',
  			ijlig: '\u0133',
  			Im: '\u2111',
  			Imacr: '\u012A',
  			imacr: '\u012B',
  			image: '\u2111',
  			ImaginaryI: '\u2148',
  			imagline: '\u2110',
  			imagpart: '\u2111',
  			imath: '\u0131',
  			imof: '\u22B7',
  			imped: '\u01B5',
  			Implies: '\u21D2',
  			in: '\u2208',
  			incare: '\u2105',
  			infin: '\u221E',
  			infintie: '\u29DD',
  			inodot: '\u0131',
  			Int: '\u222C',
  			int: '\u222B',
  			intcal: '\u22BA',
  			integers: '\u2124',
  			Integral: '\u222B',
  			intercal: '\u22BA',
  			Intersection: '\u22C2',
  			intlarhk: '\u2A17',
  			intprod: '\u2A3C',
  			InvisibleComma: '\u2063',
  			InvisibleTimes: '\u2062',
  			IOcy: '\u0401',
  			iocy: '\u0451',
  			Iogon: '\u012E',
  			iogon: '\u012F',
  			Iopf: '\uD835\uDD40',
  			iopf: '\uD835\uDD5A',
  			Iota: '\u0399',
  			iota: '\u03B9',
  			iprod: '\u2A3C',
  			iquest: '\u00BF',
  			Iscr: '\u2110',
  			iscr: '\uD835\uDCBE',
  			isin: '\u2208',
  			isindot: '\u22F5',
  			isinE: '\u22F9',
  			isins: '\u22F4',
  			isinsv: '\u22F3',
  			isinv: '\u2208',
  			it: '\u2062',
  			Itilde: '\u0128',
  			itilde: '\u0129',
  			Iukcy: '\u0406',
  			iukcy: '\u0456',
  			Iuml: '\u00CF',
  			iuml: '\u00EF',
  			Jcirc: '\u0134',
  			jcirc: '\u0135',
  			Jcy: '\u0419',
  			jcy: '\u0439',
  			Jfr: '\uD835\uDD0D',
  			jfr: '\uD835\uDD27',
  			jmath: '\u0237',
  			Jopf: '\uD835\uDD41',
  			jopf: '\uD835\uDD5B',
  			Jscr: '\uD835\uDCA5',
  			jscr: '\uD835\uDCBF',
  			Jsercy: '\u0408',
  			jsercy: '\u0458',
  			Jukcy: '\u0404',
  			jukcy: '\u0454',
  			Kappa: '\u039A',
  			kappa: '\u03BA',
  			kappav: '\u03F0',
  			Kcedil: '\u0136',
  			kcedil: '\u0137',
  			Kcy: '\u041A',
  			kcy: '\u043A',
  			Kfr: '\uD835\uDD0E',
  			kfr: '\uD835\uDD28',
  			kgreen: '\u0138',
  			KHcy: '\u0425',
  			khcy: '\u0445',
  			KJcy: '\u040C',
  			kjcy: '\u045C',
  			Kopf: '\uD835\uDD42',
  			kopf: '\uD835\uDD5C',
  			Kscr: '\uD835\uDCA6',
  			kscr: '\uD835\uDCC0',
  			lAarr: '\u21DA',
  			Lacute: '\u0139',
  			lacute: '\u013A',
  			laemptyv: '\u29B4',
  			lagran: '\u2112',
  			Lambda: '\u039B',
  			lambda: '\u03BB',
  			Lang: '\u27EA',
  			lang: '\u27E8',
  			langd: '\u2991',
  			langle: '\u27E8',
  			lap: '\u2A85',
  			Laplacetrf: '\u2112',
  			laquo: '\u00AB',
  			Larr: '\u219E',
  			lArr: '\u21D0',
  			larr: '\u2190',
  			larrb: '\u21E4',
  			larrbfs: '\u291F',
  			larrfs: '\u291D',
  			larrhk: '\u21A9',
  			larrlp: '\u21AB',
  			larrpl: '\u2939',
  			larrsim: '\u2973',
  			larrtl: '\u21A2',
  			lat: '\u2AAB',
  			lAtail: '\u291B',
  			latail: '\u2919',
  			late: '\u2AAD',
  			lates: '\u2AAD\uFE00',
  			lBarr: '\u290E',
  			lbarr: '\u290C',
  			lbbrk: '\u2772',
  			lbrace: '\u007B',
  			lbrack: '\u005B',
  			lbrke: '\u298B',
  			lbrksld: '\u298F',
  			lbrkslu: '\u298D',
  			Lcaron: '\u013D',
  			lcaron: '\u013E',
  			Lcedil: '\u013B',
  			lcedil: '\u013C',
  			lceil: '\u2308',
  			lcub: '\u007B',
  			Lcy: '\u041B',
  			lcy: '\u043B',
  			ldca: '\u2936',
  			ldquo: '\u201C',
  			ldquor: '\u201E',
  			ldrdhar: '\u2967',
  			ldrushar: '\u294B',
  			ldsh: '\u21B2',
  			lE: '\u2266',
  			le: '\u2264',
  			LeftAngleBracket: '\u27E8',
  			LeftArrow: '\u2190',
  			Leftarrow: '\u21D0',
  			leftarrow: '\u2190',
  			LeftArrowBar: '\u21E4',
  			LeftArrowRightArrow: '\u21C6',
  			leftarrowtail: '\u21A2',
  			LeftCeiling: '\u2308',
  			LeftDoubleBracket: '\u27E6',
  			LeftDownTeeVector: '\u2961',
  			LeftDownVector: '\u21C3',
  			LeftDownVectorBar: '\u2959',
  			LeftFloor: '\u230A',
  			leftharpoondown: '\u21BD',
  			leftharpoonup: '\u21BC',
  			leftleftarrows: '\u21C7',
  			LeftRightArrow: '\u2194',
  			Leftrightarrow: '\u21D4',
  			leftrightarrow: '\u2194',
  			leftrightarrows: '\u21C6',
  			leftrightharpoons: '\u21CB',
  			leftrightsquigarrow: '\u21AD',
  			LeftRightVector: '\u294E',
  			LeftTee: '\u22A3',
  			LeftTeeArrow: '\u21A4',
  			LeftTeeVector: '\u295A',
  			leftthreetimes: '\u22CB',
  			LeftTriangle: '\u22B2',
  			LeftTriangleBar: '\u29CF',
  			LeftTriangleEqual: '\u22B4',
  			LeftUpDownVector: '\u2951',
  			LeftUpTeeVector: '\u2960',
  			LeftUpVector: '\u21BF',
  			LeftUpVectorBar: '\u2958',
  			LeftVector: '\u21BC',
  			LeftVectorBar: '\u2952',
  			lEg: '\u2A8B',
  			leg: '\u22DA',
  			leq: '\u2264',
  			leqq: '\u2266',
  			leqslant: '\u2A7D',
  			les: '\u2A7D',
  			lescc: '\u2AA8',
  			lesdot: '\u2A7F',
  			lesdoto: '\u2A81',
  			lesdotor: '\u2A83',
  			lesg: '\u22DA\uFE00',
  			lesges: '\u2A93',
  			lessapprox: '\u2A85',
  			lessdot: '\u22D6',
  			lesseqgtr: '\u22DA',
  			lesseqqgtr: '\u2A8B',
  			LessEqualGreater: '\u22DA',
  			LessFullEqual: '\u2266',
  			LessGreater: '\u2276',
  			lessgtr: '\u2276',
  			LessLess: '\u2AA1',
  			lesssim: '\u2272',
  			LessSlantEqual: '\u2A7D',
  			LessTilde: '\u2272',
  			lfisht: '\u297C',
  			lfloor: '\u230A',
  			Lfr: '\uD835\uDD0F',
  			lfr: '\uD835\uDD29',
  			lg: '\u2276',
  			lgE: '\u2A91',
  			lHar: '\u2962',
  			lhard: '\u21BD',
  			lharu: '\u21BC',
  			lharul: '\u296A',
  			lhblk: '\u2584',
  			LJcy: '\u0409',
  			ljcy: '\u0459',
  			Ll: '\u22D8',
  			ll: '\u226A',
  			llarr: '\u21C7',
  			llcorner: '\u231E',
  			Lleftarrow: '\u21DA',
  			llhard: '\u296B',
  			lltri: '\u25FA',
  			Lmidot: '\u013F',
  			lmidot: '\u0140',
  			lmoust: '\u23B0',
  			lmoustache: '\u23B0',
  			lnap: '\u2A89',
  			lnapprox: '\u2A89',
  			lnE: '\u2268',
  			lne: '\u2A87',
  			lneq: '\u2A87',
  			lneqq: '\u2268',
  			lnsim: '\u22E6',
  			loang: '\u27EC',
  			loarr: '\u21FD',
  			lobrk: '\u27E6',
  			LongLeftArrow: '\u27F5',
  			Longleftarrow: '\u27F8',
  			longleftarrow: '\u27F5',
  			LongLeftRightArrow: '\u27F7',
  			Longleftrightarrow: '\u27FA',
  			longleftrightarrow: '\u27F7',
  			longmapsto: '\u27FC',
  			LongRightArrow: '\u27F6',
  			Longrightarrow: '\u27F9',
  			longrightarrow: '\u27F6',
  			looparrowleft: '\u21AB',
  			looparrowright: '\u21AC',
  			lopar: '\u2985',
  			Lopf: '\uD835\uDD43',
  			lopf: '\uD835\uDD5D',
  			loplus: '\u2A2D',
  			lotimes: '\u2A34',
  			lowast: '\u2217',
  			lowbar: '\u005F',
  			LowerLeftArrow: '\u2199',
  			LowerRightArrow: '\u2198',
  			loz: '\u25CA',
  			lozenge: '\u25CA',
  			lozf: '\u29EB',
  			lpar: '\u0028',
  			lparlt: '\u2993',
  			lrarr: '\u21C6',
  			lrcorner: '\u231F',
  			lrhar: '\u21CB',
  			lrhard: '\u296D',
  			lrm: '\u200E',
  			lrtri: '\u22BF',
  			lsaquo: '\u2039',
  			Lscr: '\u2112',
  			lscr: '\uD835\uDCC1',
  			Lsh: '\u21B0',
  			lsh: '\u21B0',
  			lsim: '\u2272',
  			lsime: '\u2A8D',
  			lsimg: '\u2A8F',
  			lsqb: '\u005B',
  			lsquo: '\u2018',
  			lsquor: '\u201A',
  			Lstrok: '\u0141',
  			lstrok: '\u0142',
  			Lt: '\u226A',
  			LT: '\u003C',
  			lt: '\u003C',
  			ltcc: '\u2AA6',
  			ltcir: '\u2A79',
  			ltdot: '\u22D6',
  			lthree: '\u22CB',
  			ltimes: '\u22C9',
  			ltlarr: '\u2976',
  			ltquest: '\u2A7B',
  			ltri: '\u25C3',
  			ltrie: '\u22B4',
  			ltrif: '\u25C2',
  			ltrPar: '\u2996',
  			lurdshar: '\u294A',
  			luruhar: '\u2966',
  			lvertneqq: '\u2268\uFE00',
  			lvnE: '\u2268\uFE00',
  			macr: '\u00AF',
  			male: '\u2642',
  			malt: '\u2720',
  			maltese: '\u2720',
  			Map: '\u2905',
  			map: '\u21A6',
  			mapsto: '\u21A6',
  			mapstodown: '\u21A7',
  			mapstoleft: '\u21A4',
  			mapstoup: '\u21A5',
  			marker: '\u25AE',
  			mcomma: '\u2A29',
  			Mcy: '\u041C',
  			mcy: '\u043C',
  			mdash: '\u2014',
  			mDDot: '\u223A',
  			measuredangle: '\u2221',
  			MediumSpace: '\u205F',
  			Mellintrf: '\u2133',
  			Mfr: '\uD835\uDD10',
  			mfr: '\uD835\uDD2A',
  			mho: '\u2127',
  			micro: '\u00B5',
  			mid: '\u2223',
  			midast: '\u002A',
  			midcir: '\u2AF0',
  			middot: '\u00B7',
  			minus: '\u2212',
  			minusb: '\u229F',
  			minusd: '\u2238',
  			minusdu: '\u2A2A',
  			MinusPlus: '\u2213',
  			mlcp: '\u2ADB',
  			mldr: '\u2026',
  			mnplus: '\u2213',
  			models: '\u22A7',
  			Mopf: '\uD835\uDD44',
  			mopf: '\uD835\uDD5E',
  			mp: '\u2213',
  			Mscr: '\u2133',
  			mscr: '\uD835\uDCC2',
  			mstpos: '\u223E',
  			Mu: '\u039C',
  			mu: '\u03BC',
  			multimap: '\u22B8',
  			mumap: '\u22B8',
  			nabla: '\u2207',
  			Nacute: '\u0143',
  			nacute: '\u0144',
  			nang: '\u2220\u20D2',
  			nap: '\u2249',
  			napE: '\u2A70\u0338',
  			napid: '\u224B\u0338',
  			napos: '\u0149',
  			napprox: '\u2249',
  			natur: '\u266E',
  			natural: '\u266E',
  			naturals: '\u2115',
  			nbsp: '\u00A0',
  			nbump: '\u224E\u0338',
  			nbumpe: '\u224F\u0338',
  			ncap: '\u2A43',
  			Ncaron: '\u0147',
  			ncaron: '\u0148',
  			Ncedil: '\u0145',
  			ncedil: '\u0146',
  			ncong: '\u2247',
  			ncongdot: '\u2A6D\u0338',
  			ncup: '\u2A42',
  			Ncy: '\u041D',
  			ncy: '\u043D',
  			ndash: '\u2013',
  			ne: '\u2260',
  			nearhk: '\u2924',
  			neArr: '\u21D7',
  			nearr: '\u2197',
  			nearrow: '\u2197',
  			nedot: '\u2250\u0338',
  			NegativeMediumSpace: '\u200B',
  			NegativeThickSpace: '\u200B',
  			NegativeThinSpace: '\u200B',
  			NegativeVeryThinSpace: '\u200B',
  			nequiv: '\u2262',
  			nesear: '\u2928',
  			nesim: '\u2242\u0338',
  			NestedGreaterGreater: '\u226B',
  			NestedLessLess: '\u226A',
  			NewLine: '\u000A',
  			nexist: '\u2204',
  			nexists: '\u2204',
  			Nfr: '\uD835\uDD11',
  			nfr: '\uD835\uDD2B',
  			ngE: '\u2267\u0338',
  			nge: '\u2271',
  			ngeq: '\u2271',
  			ngeqq: '\u2267\u0338',
  			ngeqslant: '\u2A7E\u0338',
  			nges: '\u2A7E\u0338',
  			nGg: '\u22D9\u0338',
  			ngsim: '\u2275',
  			nGt: '\u226B\u20D2',
  			ngt: '\u226F',
  			ngtr: '\u226F',
  			nGtv: '\u226B\u0338',
  			nhArr: '\u21CE',
  			nharr: '\u21AE',
  			nhpar: '\u2AF2',
  			ni: '\u220B',
  			nis: '\u22FC',
  			nisd: '\u22FA',
  			niv: '\u220B',
  			NJcy: '\u040A',
  			njcy: '\u045A',
  			nlArr: '\u21CD',
  			nlarr: '\u219A',
  			nldr: '\u2025',
  			nlE: '\u2266\u0338',
  			nle: '\u2270',
  			nLeftarrow: '\u21CD',
  			nleftarrow: '\u219A',
  			nLeftrightarrow: '\u21CE',
  			nleftrightarrow: '\u21AE',
  			nleq: '\u2270',
  			nleqq: '\u2266\u0338',
  			nleqslant: '\u2A7D\u0338',
  			nles: '\u2A7D\u0338',
  			nless: '\u226E',
  			nLl: '\u22D8\u0338',
  			nlsim: '\u2274',
  			nLt: '\u226A\u20D2',
  			nlt: '\u226E',
  			nltri: '\u22EA',
  			nltrie: '\u22EC',
  			nLtv: '\u226A\u0338',
  			nmid: '\u2224',
  			NoBreak: '\u2060',
  			NonBreakingSpace: '\u00A0',
  			Nopf: '\u2115',
  			nopf: '\uD835\uDD5F',
  			Not: '\u2AEC',
  			not: '\u00AC',
  			NotCongruent: '\u2262',
  			NotCupCap: '\u226D',
  			NotDoubleVerticalBar: '\u2226',
  			NotElement: '\u2209',
  			NotEqual: '\u2260',
  			NotEqualTilde: '\u2242\u0338',
  			NotExists: '\u2204',
  			NotGreater: '\u226F',
  			NotGreaterEqual: '\u2271',
  			NotGreaterFullEqual: '\u2267\u0338',
  			NotGreaterGreater: '\u226B\u0338',
  			NotGreaterLess: '\u2279',
  			NotGreaterSlantEqual: '\u2A7E\u0338',
  			NotGreaterTilde: '\u2275',
  			NotHumpDownHump: '\u224E\u0338',
  			NotHumpEqual: '\u224F\u0338',
  			notin: '\u2209',
  			notindot: '\u22F5\u0338',
  			notinE: '\u22F9\u0338',
  			notinva: '\u2209',
  			notinvb: '\u22F7',
  			notinvc: '\u22F6',
  			NotLeftTriangle: '\u22EA',
  			NotLeftTriangleBar: '\u29CF\u0338',
  			NotLeftTriangleEqual: '\u22EC',
  			NotLess: '\u226E',
  			NotLessEqual: '\u2270',
  			NotLessGreater: '\u2278',
  			NotLessLess: '\u226A\u0338',
  			NotLessSlantEqual: '\u2A7D\u0338',
  			NotLessTilde: '\u2274',
  			NotNestedGreaterGreater: '\u2AA2\u0338',
  			NotNestedLessLess: '\u2AA1\u0338',
  			notni: '\u220C',
  			notniva: '\u220C',
  			notnivb: '\u22FE',
  			notnivc: '\u22FD',
  			NotPrecedes: '\u2280',
  			NotPrecedesEqual: '\u2AAF\u0338',
  			NotPrecedesSlantEqual: '\u22E0',
  			NotReverseElement: '\u220C',
  			NotRightTriangle: '\u22EB',
  			NotRightTriangleBar: '\u29D0\u0338',
  			NotRightTriangleEqual: '\u22ED',
  			NotSquareSubset: '\u228F\u0338',
  			NotSquareSubsetEqual: '\u22E2',
  			NotSquareSuperset: '\u2290\u0338',
  			NotSquareSupersetEqual: '\u22E3',
  			NotSubset: '\u2282\u20D2',
  			NotSubsetEqual: '\u2288',
  			NotSucceeds: '\u2281',
  			NotSucceedsEqual: '\u2AB0\u0338',
  			NotSucceedsSlantEqual: '\u22E1',
  			NotSucceedsTilde: '\u227F\u0338',
  			NotSuperset: '\u2283\u20D2',
  			NotSupersetEqual: '\u2289',
  			NotTilde: '\u2241',
  			NotTildeEqual: '\u2244',
  			NotTildeFullEqual: '\u2247',
  			NotTildeTilde: '\u2249',
  			NotVerticalBar: '\u2224',
  			npar: '\u2226',
  			nparallel: '\u2226',
  			nparsl: '\u2AFD\u20E5',
  			npart: '\u2202\u0338',
  			npolint: '\u2A14',
  			npr: '\u2280',
  			nprcue: '\u22E0',
  			npre: '\u2AAF\u0338',
  			nprec: '\u2280',
  			npreceq: '\u2AAF\u0338',
  			nrArr: '\u21CF',
  			nrarr: '\u219B',
  			nrarrc: '\u2933\u0338',
  			nrarrw: '\u219D\u0338',
  			nRightarrow: '\u21CF',
  			nrightarrow: '\u219B',
  			nrtri: '\u22EB',
  			nrtrie: '\u22ED',
  			nsc: '\u2281',
  			nsccue: '\u22E1',
  			nsce: '\u2AB0\u0338',
  			Nscr: '\uD835\uDCA9',
  			nscr: '\uD835\uDCC3',
  			nshortmid: '\u2224',
  			nshortparallel: '\u2226',
  			nsim: '\u2241',
  			nsime: '\u2244',
  			nsimeq: '\u2244',
  			nsmid: '\u2224',
  			nspar: '\u2226',
  			nsqsube: '\u22E2',
  			nsqsupe: '\u22E3',
  			nsub: '\u2284',
  			nsubE: '\u2AC5\u0338',
  			nsube: '\u2288',
  			nsubset: '\u2282\u20D2',
  			nsubseteq: '\u2288',
  			nsubseteqq: '\u2AC5\u0338',
  			nsucc: '\u2281',
  			nsucceq: '\u2AB0\u0338',
  			nsup: '\u2285',
  			nsupE: '\u2AC6\u0338',
  			nsupe: '\u2289',
  			nsupset: '\u2283\u20D2',
  			nsupseteq: '\u2289',
  			nsupseteqq: '\u2AC6\u0338',
  			ntgl: '\u2279',
  			Ntilde: '\u00D1',
  			ntilde: '\u00F1',
  			ntlg: '\u2278',
  			ntriangleleft: '\u22EA',
  			ntrianglelefteq: '\u22EC',
  			ntriangleright: '\u22EB',
  			ntrianglerighteq: '\u22ED',
  			Nu: '\u039D',
  			nu: '\u03BD',
  			num: '\u0023',
  			numero: '\u2116',
  			numsp: '\u2007',
  			nvap: '\u224D\u20D2',
  			nVDash: '\u22AF',
  			nVdash: '\u22AE',
  			nvDash: '\u22AD',
  			nvdash: '\u22AC',
  			nvge: '\u2265\u20D2',
  			nvgt: '\u003E\u20D2',
  			nvHarr: '\u2904',
  			nvinfin: '\u29DE',
  			nvlArr: '\u2902',
  			nvle: '\u2264\u20D2',
  			nvlt: '\u003C\u20D2',
  			nvltrie: '\u22B4\u20D2',
  			nvrArr: '\u2903',
  			nvrtrie: '\u22B5\u20D2',
  			nvsim: '\u223C\u20D2',
  			nwarhk: '\u2923',
  			nwArr: '\u21D6',
  			nwarr: '\u2196',
  			nwarrow: '\u2196',
  			nwnear: '\u2927',
  			Oacute: '\u00D3',
  			oacute: '\u00F3',
  			oast: '\u229B',
  			ocir: '\u229A',
  			Ocirc: '\u00D4',
  			ocirc: '\u00F4',
  			Ocy: '\u041E',
  			ocy: '\u043E',
  			odash: '\u229D',
  			Odblac: '\u0150',
  			odblac: '\u0151',
  			odiv: '\u2A38',
  			odot: '\u2299',
  			odsold: '\u29BC',
  			OElig: '\u0152',
  			oelig: '\u0153',
  			ofcir: '\u29BF',
  			Ofr: '\uD835\uDD12',
  			ofr: '\uD835\uDD2C',
  			ogon: '\u02DB',
  			Ograve: '\u00D2',
  			ograve: '\u00F2',
  			ogt: '\u29C1',
  			ohbar: '\u29B5',
  			ohm: '\u03A9',
  			oint: '\u222E',
  			olarr: '\u21BA',
  			olcir: '\u29BE',
  			olcross: '\u29BB',
  			oline: '\u203E',
  			olt: '\u29C0',
  			Omacr: '\u014C',
  			omacr: '\u014D',
  			Omega: '\u03A9',
  			omega: '\u03C9',
  			Omicron: '\u039F',
  			omicron: '\u03BF',
  			omid: '\u29B6',
  			ominus: '\u2296',
  			Oopf: '\uD835\uDD46',
  			oopf: '\uD835\uDD60',
  			opar: '\u29B7',
  			OpenCurlyDoubleQuote: '\u201C',
  			OpenCurlyQuote: '\u2018',
  			operp: '\u29B9',
  			oplus: '\u2295',
  			Or: '\u2A54',
  			or: '\u2228',
  			orarr: '\u21BB',
  			ord: '\u2A5D',
  			order: '\u2134',
  			orderof: '\u2134',
  			ordf: '\u00AA',
  			ordm: '\u00BA',
  			origof: '\u22B6',
  			oror: '\u2A56',
  			orslope: '\u2A57',
  			orv: '\u2A5B',
  			oS: '\u24C8',
  			Oscr: '\uD835\uDCAA',
  			oscr: '\u2134',
  			Oslash: '\u00D8',
  			oslash: '\u00F8',
  			osol: '\u2298',
  			Otilde: '\u00D5',
  			otilde: '\u00F5',
  			Otimes: '\u2A37',
  			otimes: '\u2297',
  			otimesas: '\u2A36',
  			Ouml: '\u00D6',
  			ouml: '\u00F6',
  			ovbar: '\u233D',
  			OverBar: '\u203E',
  			OverBrace: '\u23DE',
  			OverBracket: '\u23B4',
  			OverParenthesis: '\u23DC',
  			par: '\u2225',
  			para: '\u00B6',
  			parallel: '\u2225',
  			parsim: '\u2AF3',
  			parsl: '\u2AFD',
  			part: '\u2202',
  			PartialD: '\u2202',
  			Pcy: '\u041F',
  			pcy: '\u043F',
  			percnt: '\u0025',
  			period: '\u002E',
  			permil: '\u2030',
  			perp: '\u22A5',
  			pertenk: '\u2031',
  			Pfr: '\uD835\uDD13',
  			pfr: '\uD835\uDD2D',
  			Phi: '\u03A6',
  			phi: '\u03C6',
  			phiv: '\u03D5',
  			phmmat: '\u2133',
  			phone: '\u260E',
  			Pi: '\u03A0',
  			pi: '\u03C0',
  			pitchfork: '\u22D4',
  			piv: '\u03D6',
  			planck: '\u210F',
  			planckh: '\u210E',
  			plankv: '\u210F',
  			plus: '\u002B',
  			plusacir: '\u2A23',
  			plusb: '\u229E',
  			pluscir: '\u2A22',
  			plusdo: '\u2214',
  			plusdu: '\u2A25',
  			pluse: '\u2A72',
  			PlusMinus: '\u00B1',
  			plusmn: '\u00B1',
  			plussim: '\u2A26',
  			plustwo: '\u2A27',
  			pm: '\u00B1',
  			Poincareplane: '\u210C',
  			pointint: '\u2A15',
  			Popf: '\u2119',
  			popf: '\uD835\uDD61',
  			pound: '\u00A3',
  			Pr: '\u2ABB',
  			pr: '\u227A',
  			prap: '\u2AB7',
  			prcue: '\u227C',
  			prE: '\u2AB3',
  			pre: '\u2AAF',
  			prec: '\u227A',
  			precapprox: '\u2AB7',
  			preccurlyeq: '\u227C',
  			Precedes: '\u227A',
  			PrecedesEqual: '\u2AAF',
  			PrecedesSlantEqual: '\u227C',
  			PrecedesTilde: '\u227E',
  			preceq: '\u2AAF',
  			precnapprox: '\u2AB9',
  			precneqq: '\u2AB5',
  			precnsim: '\u22E8',
  			precsim: '\u227E',
  			Prime: '\u2033',
  			prime: '\u2032',
  			primes: '\u2119',
  			prnap: '\u2AB9',
  			prnE: '\u2AB5',
  			prnsim: '\u22E8',
  			prod: '\u220F',
  			Product: '\u220F',
  			profalar: '\u232E',
  			profline: '\u2312',
  			profsurf: '\u2313',
  			prop: '\u221D',
  			Proportion: '\u2237',
  			Proportional: '\u221D',
  			propto: '\u221D',
  			prsim: '\u227E',
  			prurel: '\u22B0',
  			Pscr: '\uD835\uDCAB',
  			pscr: '\uD835\uDCC5',
  			Psi: '\u03A8',
  			psi: '\u03C8',
  			puncsp: '\u2008',
  			Qfr: '\uD835\uDD14',
  			qfr: '\uD835\uDD2E',
  			qint: '\u2A0C',
  			Qopf: '\u211A',
  			qopf: '\uD835\uDD62',
  			qprime: '\u2057',
  			Qscr: '\uD835\uDCAC',
  			qscr: '\uD835\uDCC6',
  			quaternions: '\u210D',
  			quatint: '\u2A16',
  			quest: '\u003F',
  			questeq: '\u225F',
  			QUOT: '\u0022',
  			quot: '\u0022',
  			rAarr: '\u21DB',
  			race: '\u223D\u0331',
  			Racute: '\u0154',
  			racute: '\u0155',
  			radic: '\u221A',
  			raemptyv: '\u29B3',
  			Rang: '\u27EB',
  			rang: '\u27E9',
  			rangd: '\u2992',
  			range: '\u29A5',
  			rangle: '\u27E9',
  			raquo: '\u00BB',
  			Rarr: '\u21A0',
  			rArr: '\u21D2',
  			rarr: '\u2192',
  			rarrap: '\u2975',
  			rarrb: '\u21E5',
  			rarrbfs: '\u2920',
  			rarrc: '\u2933',
  			rarrfs: '\u291E',
  			rarrhk: '\u21AA',
  			rarrlp: '\u21AC',
  			rarrpl: '\u2945',
  			rarrsim: '\u2974',
  			Rarrtl: '\u2916',
  			rarrtl: '\u21A3',
  			rarrw: '\u219D',
  			rAtail: '\u291C',
  			ratail: '\u291A',
  			ratio: '\u2236',
  			rationals: '\u211A',
  			RBarr: '\u2910',
  			rBarr: '\u290F',
  			rbarr: '\u290D',
  			rbbrk: '\u2773',
  			rbrace: '\u007D',
  			rbrack: '\u005D',
  			rbrke: '\u298C',
  			rbrksld: '\u298E',
  			rbrkslu: '\u2990',
  			Rcaron: '\u0158',
  			rcaron: '\u0159',
  			Rcedil: '\u0156',
  			rcedil: '\u0157',
  			rceil: '\u2309',
  			rcub: '\u007D',
  			Rcy: '\u0420',
  			rcy: '\u0440',
  			rdca: '\u2937',
  			rdldhar: '\u2969',
  			rdquo: '\u201D',
  			rdquor: '\u201D',
  			rdsh: '\u21B3',
  			Re: '\u211C',
  			real: '\u211C',
  			realine: '\u211B',
  			realpart: '\u211C',
  			reals: '\u211D',
  			rect: '\u25AD',
  			REG: '\u00AE',
  			reg: '\u00AE',
  			ReverseElement: '\u220B',
  			ReverseEquilibrium: '\u21CB',
  			ReverseUpEquilibrium: '\u296F',
  			rfisht: '\u297D',
  			rfloor: '\u230B',
  			Rfr: '\u211C',
  			rfr: '\uD835\uDD2F',
  			rHar: '\u2964',
  			rhard: '\u21C1',
  			rharu: '\u21C0',
  			rharul: '\u296C',
  			Rho: '\u03A1',
  			rho: '\u03C1',
  			rhov: '\u03F1',
  			RightAngleBracket: '\u27E9',
  			RightArrow: '\u2192',
  			Rightarrow: '\u21D2',
  			rightarrow: '\u2192',
  			RightArrowBar: '\u21E5',
  			RightArrowLeftArrow: '\u21C4',
  			rightarrowtail: '\u21A3',
  			RightCeiling: '\u2309',
  			RightDoubleBracket: '\u27E7',
  			RightDownTeeVector: '\u295D',
  			RightDownVector: '\u21C2',
  			RightDownVectorBar: '\u2955',
  			RightFloor: '\u230B',
  			rightharpoondown: '\u21C1',
  			rightharpoonup: '\u21C0',
  			rightleftarrows: '\u21C4',
  			rightleftharpoons: '\u21CC',
  			rightrightarrows: '\u21C9',
  			rightsquigarrow: '\u219D',
  			RightTee: '\u22A2',
  			RightTeeArrow: '\u21A6',
  			RightTeeVector: '\u295B',
  			rightthreetimes: '\u22CC',
  			RightTriangle: '\u22B3',
  			RightTriangleBar: '\u29D0',
  			RightTriangleEqual: '\u22B5',
  			RightUpDownVector: '\u294F',
  			RightUpTeeVector: '\u295C',
  			RightUpVector: '\u21BE',
  			RightUpVectorBar: '\u2954',
  			RightVector: '\u21C0',
  			RightVectorBar: '\u2953',
  			ring: '\u02DA',
  			risingdotseq: '\u2253',
  			rlarr: '\u21C4',
  			rlhar: '\u21CC',
  			rlm: '\u200F',
  			rmoust: '\u23B1',
  			rmoustache: '\u23B1',
  			rnmid: '\u2AEE',
  			roang: '\u27ED',
  			roarr: '\u21FE',
  			robrk: '\u27E7',
  			ropar: '\u2986',
  			Ropf: '\u211D',
  			ropf: '\uD835\uDD63',
  			roplus: '\u2A2E',
  			rotimes: '\u2A35',
  			RoundImplies: '\u2970',
  			rpar: '\u0029',
  			rpargt: '\u2994',
  			rppolint: '\u2A12',
  			rrarr: '\u21C9',
  			Rrightarrow: '\u21DB',
  			rsaquo: '\u203A',
  			Rscr: '\u211B',
  			rscr: '\uD835\uDCC7',
  			Rsh: '\u21B1',
  			rsh: '\u21B1',
  			rsqb: '\u005D',
  			rsquo: '\u2019',
  			rsquor: '\u2019',
  			rthree: '\u22CC',
  			rtimes: '\u22CA',
  			rtri: '\u25B9',
  			rtrie: '\u22B5',
  			rtrif: '\u25B8',
  			rtriltri: '\u29CE',
  			RuleDelayed: '\u29F4',
  			ruluhar: '\u2968',
  			rx: '\u211E',
  			Sacute: '\u015A',
  			sacute: '\u015B',
  			sbquo: '\u201A',
  			Sc: '\u2ABC',
  			sc: '\u227B',
  			scap: '\u2AB8',
  			Scaron: '\u0160',
  			scaron: '\u0161',
  			sccue: '\u227D',
  			scE: '\u2AB4',
  			sce: '\u2AB0',
  			Scedil: '\u015E',
  			scedil: '\u015F',
  			Scirc: '\u015C',
  			scirc: '\u015D',
  			scnap: '\u2ABA',
  			scnE: '\u2AB6',
  			scnsim: '\u22E9',
  			scpolint: '\u2A13',
  			scsim: '\u227F',
  			Scy: '\u0421',
  			scy: '\u0441',
  			sdot: '\u22C5',
  			sdotb: '\u22A1',
  			sdote: '\u2A66',
  			searhk: '\u2925',
  			seArr: '\u21D8',
  			searr: '\u2198',
  			searrow: '\u2198',
  			sect: '\u00A7',
  			semi: '\u003B',
  			seswar: '\u2929',
  			setminus: '\u2216',
  			setmn: '\u2216',
  			sext: '\u2736',
  			Sfr: '\uD835\uDD16',
  			sfr: '\uD835\uDD30',
  			sfrown: '\u2322',
  			sharp: '\u266F',
  			SHCHcy: '\u0429',
  			shchcy: '\u0449',
  			SHcy: '\u0428',
  			shcy: '\u0448',
  			ShortDownArrow: '\u2193',
  			ShortLeftArrow: '\u2190',
  			shortmid: '\u2223',
  			shortparallel: '\u2225',
  			ShortRightArrow: '\u2192',
  			ShortUpArrow: '\u2191',
  			shy: '\u00AD',
  			Sigma: '\u03A3',
  			sigma: '\u03C3',
  			sigmaf: '\u03C2',
  			sigmav: '\u03C2',
  			sim: '\u223C',
  			simdot: '\u2A6A',
  			sime: '\u2243',
  			simeq: '\u2243',
  			simg: '\u2A9E',
  			simgE: '\u2AA0',
  			siml: '\u2A9D',
  			simlE: '\u2A9F',
  			simne: '\u2246',
  			simplus: '\u2A24',
  			simrarr: '\u2972',
  			slarr: '\u2190',
  			SmallCircle: '\u2218',
  			smallsetminus: '\u2216',
  			smashp: '\u2A33',
  			smeparsl: '\u29E4',
  			smid: '\u2223',
  			smile: '\u2323',
  			smt: '\u2AAA',
  			smte: '\u2AAC',
  			smtes: '\u2AAC\uFE00',
  			SOFTcy: '\u042C',
  			softcy: '\u044C',
  			sol: '\u002F',
  			solb: '\u29C4',
  			solbar: '\u233F',
  			Sopf: '\uD835\uDD4A',
  			sopf: '\uD835\uDD64',
  			spades: '\u2660',
  			spadesuit: '\u2660',
  			spar: '\u2225',
  			sqcap: '\u2293',
  			sqcaps: '\u2293\uFE00',
  			sqcup: '\u2294',
  			sqcups: '\u2294\uFE00',
  			Sqrt: '\u221A',
  			sqsub: '\u228F',
  			sqsube: '\u2291',
  			sqsubset: '\u228F',
  			sqsubseteq: '\u2291',
  			sqsup: '\u2290',
  			sqsupe: '\u2292',
  			sqsupset: '\u2290',
  			sqsupseteq: '\u2292',
  			squ: '\u25A1',
  			Square: '\u25A1',
  			square: '\u25A1',
  			SquareIntersection: '\u2293',
  			SquareSubset: '\u228F',
  			SquareSubsetEqual: '\u2291',
  			SquareSuperset: '\u2290',
  			SquareSupersetEqual: '\u2292',
  			SquareUnion: '\u2294',
  			squarf: '\u25AA',
  			squf: '\u25AA',
  			srarr: '\u2192',
  			Sscr: '\uD835\uDCAE',
  			sscr: '\uD835\uDCC8',
  			ssetmn: '\u2216',
  			ssmile: '\u2323',
  			sstarf: '\u22C6',
  			Star: '\u22C6',
  			star: '\u2606',
  			starf: '\u2605',
  			straightepsilon: '\u03F5',
  			straightphi: '\u03D5',
  			strns: '\u00AF',
  			Sub: '\u22D0',
  			sub: '\u2282',
  			subdot: '\u2ABD',
  			subE: '\u2AC5',
  			sube: '\u2286',
  			subedot: '\u2AC3',
  			submult: '\u2AC1',
  			subnE: '\u2ACB',
  			subne: '\u228A',
  			subplus: '\u2ABF',
  			subrarr: '\u2979',
  			Subset: '\u22D0',
  			subset: '\u2282',
  			subseteq: '\u2286',
  			subseteqq: '\u2AC5',
  			SubsetEqual: '\u2286',
  			subsetneq: '\u228A',
  			subsetneqq: '\u2ACB',
  			subsim: '\u2AC7',
  			subsub: '\u2AD5',
  			subsup: '\u2AD3',
  			succ: '\u227B',
  			succapprox: '\u2AB8',
  			succcurlyeq: '\u227D',
  			Succeeds: '\u227B',
  			SucceedsEqual: '\u2AB0',
  			SucceedsSlantEqual: '\u227D',
  			SucceedsTilde: '\u227F',
  			succeq: '\u2AB0',
  			succnapprox: '\u2ABA',
  			succneqq: '\u2AB6',
  			succnsim: '\u22E9',
  			succsim: '\u227F',
  			SuchThat: '\u220B',
  			Sum: '\u2211',
  			sum: '\u2211',
  			sung: '\u266A',
  			Sup: '\u22D1',
  			sup: '\u2283',
  			sup1: '\u00B9',
  			sup2: '\u00B2',
  			sup3: '\u00B3',
  			supdot: '\u2ABE',
  			supdsub: '\u2AD8',
  			supE: '\u2AC6',
  			supe: '\u2287',
  			supedot: '\u2AC4',
  			Superset: '\u2283',
  			SupersetEqual: '\u2287',
  			suphsol: '\u27C9',
  			suphsub: '\u2AD7',
  			suplarr: '\u297B',
  			supmult: '\u2AC2',
  			supnE: '\u2ACC',
  			supne: '\u228B',
  			supplus: '\u2AC0',
  			Supset: '\u22D1',
  			supset: '\u2283',
  			supseteq: '\u2287',
  			supseteqq: '\u2AC6',
  			supsetneq: '\u228B',
  			supsetneqq: '\u2ACC',
  			supsim: '\u2AC8',
  			supsub: '\u2AD4',
  			supsup: '\u2AD6',
  			swarhk: '\u2926',
  			swArr: '\u21D9',
  			swarr: '\u2199',
  			swarrow: '\u2199',
  			swnwar: '\u292A',
  			szlig: '\u00DF',
  			Tab: '\u0009',
  			target: '\u2316',
  			Tau: '\u03A4',
  			tau: '\u03C4',
  			tbrk: '\u23B4',
  			Tcaron: '\u0164',
  			tcaron: '\u0165',
  			Tcedil: '\u0162',
  			tcedil: '\u0163',
  			Tcy: '\u0422',
  			tcy: '\u0442',
  			tdot: '\u20DB',
  			telrec: '\u2315',
  			Tfr: '\uD835\uDD17',
  			tfr: '\uD835\uDD31',
  			there4: '\u2234',
  			Therefore: '\u2234',
  			therefore: '\u2234',
  			Theta: '\u0398',
  			theta: '\u03B8',
  			thetasym: '\u03D1',
  			thetav: '\u03D1',
  			thickapprox: '\u2248',
  			thicksim: '\u223C',
  			ThickSpace: '\u205F\u200A',
  			thinsp: '\u2009',
  			ThinSpace: '\u2009',
  			thkap: '\u2248',
  			thksim: '\u223C',
  			THORN: '\u00DE',
  			thorn: '\u00FE',
  			Tilde: '\u223C',
  			tilde: '\u02DC',
  			TildeEqual: '\u2243',
  			TildeFullEqual: '\u2245',
  			TildeTilde: '\u2248',
  			times: '\u00D7',
  			timesb: '\u22A0',
  			timesbar: '\u2A31',
  			timesd: '\u2A30',
  			tint: '\u222D',
  			toea: '\u2928',
  			top: '\u22A4',
  			topbot: '\u2336',
  			topcir: '\u2AF1',
  			Topf: '\uD835\uDD4B',
  			topf: '\uD835\uDD65',
  			topfork: '\u2ADA',
  			tosa: '\u2929',
  			tprime: '\u2034',
  			TRADE: '\u2122',
  			trade: '\u2122',
  			triangle: '\u25B5',
  			triangledown: '\u25BF',
  			triangleleft: '\u25C3',
  			trianglelefteq: '\u22B4',
  			triangleq: '\u225C',
  			triangleright: '\u25B9',
  			trianglerighteq: '\u22B5',
  			tridot: '\u25EC',
  			trie: '\u225C',
  			triminus: '\u2A3A',
  			TripleDot: '\u20DB',
  			triplus: '\u2A39',
  			trisb: '\u29CD',
  			tritime: '\u2A3B',
  			trpezium: '\u23E2',
  			Tscr: '\uD835\uDCAF',
  			tscr: '\uD835\uDCC9',
  			TScy: '\u0426',
  			tscy: '\u0446',
  			TSHcy: '\u040B',
  			tshcy: '\u045B',
  			Tstrok: '\u0166',
  			tstrok: '\u0167',
  			twixt: '\u226C',
  			twoheadleftarrow: '\u219E',
  			twoheadrightarrow: '\u21A0',
  			Uacute: '\u00DA',
  			uacute: '\u00FA',
  			Uarr: '\u219F',
  			uArr: '\u21D1',
  			uarr: '\u2191',
  			Uarrocir: '\u2949',
  			Ubrcy: '\u040E',
  			ubrcy: '\u045E',
  			Ubreve: '\u016C',
  			ubreve: '\u016D',
  			Ucirc: '\u00DB',
  			ucirc: '\u00FB',
  			Ucy: '\u0423',
  			ucy: '\u0443',
  			udarr: '\u21C5',
  			Udblac: '\u0170',
  			udblac: '\u0171',
  			udhar: '\u296E',
  			ufisht: '\u297E',
  			Ufr: '\uD835\uDD18',
  			ufr: '\uD835\uDD32',
  			Ugrave: '\u00D9',
  			ugrave: '\u00F9',
  			uHar: '\u2963',
  			uharl: '\u21BF',
  			uharr: '\u21BE',
  			uhblk: '\u2580',
  			ulcorn: '\u231C',
  			ulcorner: '\u231C',
  			ulcrop: '\u230F',
  			ultri: '\u25F8',
  			Umacr: '\u016A',
  			umacr: '\u016B',
  			uml: '\u00A8',
  			UnderBar: '\u005F',
  			UnderBrace: '\u23DF',
  			UnderBracket: '\u23B5',
  			UnderParenthesis: '\u23DD',
  			Union: '\u22C3',
  			UnionPlus: '\u228E',
  			Uogon: '\u0172',
  			uogon: '\u0173',
  			Uopf: '\uD835\uDD4C',
  			uopf: '\uD835\uDD66',
  			UpArrow: '\u2191',
  			Uparrow: '\u21D1',
  			uparrow: '\u2191',
  			UpArrowBar: '\u2912',
  			UpArrowDownArrow: '\u21C5',
  			UpDownArrow: '\u2195',
  			Updownarrow: '\u21D5',
  			updownarrow: '\u2195',
  			UpEquilibrium: '\u296E',
  			upharpoonleft: '\u21BF',
  			upharpoonright: '\u21BE',
  			uplus: '\u228E',
  			UpperLeftArrow: '\u2196',
  			UpperRightArrow: '\u2197',
  			Upsi: '\u03D2',
  			upsi: '\u03C5',
  			upsih: '\u03D2',
  			Upsilon: '\u03A5',
  			upsilon: '\u03C5',
  			UpTee: '\u22A5',
  			UpTeeArrow: '\u21A5',
  			upuparrows: '\u21C8',
  			urcorn: '\u231D',
  			urcorner: '\u231D',
  			urcrop: '\u230E',
  			Uring: '\u016E',
  			uring: '\u016F',
  			urtri: '\u25F9',
  			Uscr: '\uD835\uDCB0',
  			uscr: '\uD835\uDCCA',
  			utdot: '\u22F0',
  			Utilde: '\u0168',
  			utilde: '\u0169',
  			utri: '\u25B5',
  			utrif: '\u25B4',
  			uuarr: '\u21C8',
  			Uuml: '\u00DC',
  			uuml: '\u00FC',
  			uwangle: '\u29A7',
  			vangrt: '\u299C',
  			varepsilon: '\u03F5',
  			varkappa: '\u03F0',
  			varnothing: '\u2205',
  			varphi: '\u03D5',
  			varpi: '\u03D6',
  			varpropto: '\u221D',
  			vArr: '\u21D5',
  			varr: '\u2195',
  			varrho: '\u03F1',
  			varsigma: '\u03C2',
  			varsubsetneq: '\u228A\uFE00',
  			varsubsetneqq: '\u2ACB\uFE00',
  			varsupsetneq: '\u228B\uFE00',
  			varsupsetneqq: '\u2ACC\uFE00',
  			vartheta: '\u03D1',
  			vartriangleleft: '\u22B2',
  			vartriangleright: '\u22B3',
  			Vbar: '\u2AEB',
  			vBar: '\u2AE8',
  			vBarv: '\u2AE9',
  			Vcy: '\u0412',
  			vcy: '\u0432',
  			VDash: '\u22AB',
  			Vdash: '\u22A9',
  			vDash: '\u22A8',
  			vdash: '\u22A2',
  			Vdashl: '\u2AE6',
  			Vee: '\u22C1',
  			vee: '\u2228',
  			veebar: '\u22BB',
  			veeeq: '\u225A',
  			vellip: '\u22EE',
  			Verbar: '\u2016',
  			verbar: '\u007C',
  			Vert: '\u2016',
  			vert: '\u007C',
  			VerticalBar: '\u2223',
  			VerticalLine: '\u007C',
  			VerticalSeparator: '\u2758',
  			VerticalTilde: '\u2240',
  			VeryThinSpace: '\u200A',
  			Vfr: '\uD835\uDD19',
  			vfr: '\uD835\uDD33',
  			vltri: '\u22B2',
  			vnsub: '\u2282\u20D2',
  			vnsup: '\u2283\u20D2',
  			Vopf: '\uD835\uDD4D',
  			vopf: '\uD835\uDD67',
  			vprop: '\u221D',
  			vrtri: '\u22B3',
  			Vscr: '\uD835\uDCB1',
  			vscr: '\uD835\uDCCB',
  			vsubnE: '\u2ACB\uFE00',
  			vsubne: '\u228A\uFE00',
  			vsupnE: '\u2ACC\uFE00',
  			vsupne: '\u228B\uFE00',
  			Vvdash: '\u22AA',
  			vzigzag: '\u299A',
  			Wcirc: '\u0174',
  			wcirc: '\u0175',
  			wedbar: '\u2A5F',
  			Wedge: '\u22C0',
  			wedge: '\u2227',
  			wedgeq: '\u2259',
  			weierp: '\u2118',
  			Wfr: '\uD835\uDD1A',
  			wfr: '\uD835\uDD34',
  			Wopf: '\uD835\uDD4E',
  			wopf: '\uD835\uDD68',
  			wp: '\u2118',
  			wr: '\u2240',
  			wreath: '\u2240',
  			Wscr: '\uD835\uDCB2',
  			wscr: '\uD835\uDCCC',
  			xcap: '\u22C2',
  			xcirc: '\u25EF',
  			xcup: '\u22C3',
  			xdtri: '\u25BD',
  			Xfr: '\uD835\uDD1B',
  			xfr: '\uD835\uDD35',
  			xhArr: '\u27FA',
  			xharr: '\u27F7',
  			Xi: '\u039E',
  			xi: '\u03BE',
  			xlArr: '\u27F8',
  			xlarr: '\u27F5',
  			xmap: '\u27FC',
  			xnis: '\u22FB',
  			xodot: '\u2A00',
  			Xopf: '\uD835\uDD4F',
  			xopf: '\uD835\uDD69',
  			xoplus: '\u2A01',
  			xotime: '\u2A02',
  			xrArr: '\u27F9',
  			xrarr: '\u27F6',
  			Xscr: '\uD835\uDCB3',
  			xscr: '\uD835\uDCCD',
  			xsqcup: '\u2A06',
  			xuplus: '\u2A04',
  			xutri: '\u25B3',
  			xvee: '\u22C1',
  			xwedge: '\u22C0',
  			Yacute: '\u00DD',
  			yacute: '\u00FD',
  			YAcy: '\u042F',
  			yacy: '\u044F',
  			Ycirc: '\u0176',
  			ycirc: '\u0177',
  			Ycy: '\u042B',
  			ycy: '\u044B',
  			yen: '\u00A5',
  			Yfr: '\uD835\uDD1C',
  			yfr: '\uD835\uDD36',
  			YIcy: '\u0407',
  			yicy: '\u0457',
  			Yopf: '\uD835\uDD50',
  			yopf: '\uD835\uDD6A',
  			Yscr: '\uD835\uDCB4',
  			yscr: '\uD835\uDCCE',
  			YUcy: '\u042E',
  			yucy: '\u044E',
  			Yuml: '\u0178',
  			yuml: '\u00FF',
  			Zacute: '\u0179',
  			zacute: '\u017A',
  			Zcaron: '\u017D',
  			zcaron: '\u017E',
  			Zcy: '\u0417',
  			zcy: '\u0437',
  			Zdot: '\u017B',
  			zdot: '\u017C',
  			zeetrf: '\u2128',
  			ZeroWidthSpace: '\u200B',
  			Zeta: '\u0396',
  			zeta: '\u03B6',
  			Zfr: '\u2128',
  			zfr: '\uD835\uDD37',
  			ZHcy: '\u0416',
  			zhcy: '\u0436',
  			zigrarr: '\u21DD',
  			Zopf: '\u2124',
  			zopf: '\uD835\uDD6B',
  			Zscr: '\uD835\uDCB5',
  			zscr: '\uD835\uDCCF',
  			zwj: '\u200D',
  			zwnj: '\u200C',
  		});

  		/**
  		 * @deprecated use `HTML_ENTITIES` instead
  		 * @see HTML_ENTITIES
  		 */
  		exports.entityMap = exports.HTML_ENTITIES; 
  	} (entities));
  	return entities;
  }

  var sax = {};

  var hasRequiredSax;

  function requireSax () {
  	if (hasRequiredSax) return sax;
  	hasRequiredSax = 1;
  	var NAMESPACE = requireConventions().NAMESPACE;

  	//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
  	//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
  	//[5]   	Name	   ::=   	NameStartChar (NameChar)*
  	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;//\u10000-\uEFFFF
  	var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  	var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
  	//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
  	//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

  	//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
  	//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
  	var S_TAG = 0;//tag name offerring
  	var S_ATTR = 1;//attr name offerring
  	var S_ATTR_SPACE=2;//attr name end and space offer
  	var S_EQ = 3;//=space?
  	var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
  	var S_ATTR_END = 5;//attr value end and no space(quot end)
  	var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
  	var S_TAG_CLOSE = 7;//closed el<el />

  	/**
  	 * Creates an error that will not be caught by XMLReader aka the SAX parser.
  	 *
  	 * @param {string} message
  	 * @param {any?} locator Optional, can provide details about the location in the source
  	 * @constructor
  	 */
  	function ParseError(message, locator) {
  		this.message = message;
  		this.locator = locator;
  		if(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
  	}
  	ParseError.prototype = new Error();
  	ParseError.prototype.name = ParseError.name;

  	function XMLReader(){

  	}

  	XMLReader.prototype = {
  		parse:function(source,defaultNSMap,entityMap){
  			var domBuilder = this.domBuilder;
  			domBuilder.startDocument();
  			_copy(defaultNSMap ,defaultNSMap = {});
  			parse(source,defaultNSMap,entityMap,
  					domBuilder,this.errorHandler);
  			domBuilder.endDocument();
  		}
  	};
  	function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
  		function fixedFromCharCode(code) {
  			// String.prototype.fromCharCode does not supports
  			// > 2 bytes unicode chars directly
  			if (code > 0xffff) {
  				code -= 0x10000;
  				var surrogate1 = 0xd800 + (code >> 10)
  					, surrogate2 = 0xdc00 + (code & 0x3ff);

  				return String.fromCharCode(surrogate1, surrogate2);
  			} else {
  				return String.fromCharCode(code);
  			}
  		}
  		function entityReplacer(a){
  			var k = a.slice(1,-1);
  			if (Object.hasOwnProperty.call(entityMap, k)) {
  				return entityMap[k];
  			}else if(k.charAt(0) === '#'){
  				return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
  			}else {
  				errorHandler.error('entity not found:'+a);
  				return a;
  			}
  		}
  		function appendText(end){//has some bugs
  			if(end>start){
  				var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
  				locator&&position(start);
  				domBuilder.characters(xt,0,end-start);
  				start = end;
  			}
  		}
  		function position(p,m){
  			while(p>=lineEnd && (m = linePattern.exec(source))){
  				lineStart = m.index;
  				lineEnd = lineStart + m[0].length;
  				locator.lineNumber++;
  				//console.log('line++:',locator,startPos,endPos)
  			}
  			locator.columnNumber = p-lineStart+1;
  		}
  		var lineStart = 0;
  		var lineEnd = 0;
  		var linePattern = /.*(?:\r\n?|\n)|.*$/g;
  		var locator = domBuilder.locator;

  		var parseStack = [{currentNSMap:defaultNSMapCopy}];
  		var closeMap = {};
  		var start = 0;
  		while(true){
  			try{
  				var tagStart = source.indexOf('<',start);
  				if(tagStart<0){
  					if(!source.substr(start).match(/^\s*$/)){
  						var doc = domBuilder.doc;
  		    			var text = doc.createTextNode(source.substr(start));
  		    			doc.appendChild(text);
  		    			domBuilder.currentElement = text;
  					}
  					return;
  				}
  				if(tagStart>start){
  					appendText(tagStart);
  				}
  				switch(source.charAt(tagStart+1)){
  				case '/':
  					var end = source.indexOf('>',tagStart+3);
  					var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
  					var config = parseStack.pop();
  					if(end<0){

  		        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
  		        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
  		        		end = tagStart+1+tagName.length;
  		        	}else if(tagName.match(/\s</)){
  		        		tagName = tagName.replace(/[\s<].*/,'');
  		        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
  		        		end = tagStart+1+tagName.length;
  					}
  					var localNSMap = config.localNSMap;
  					var endMatch = config.tagName == tagName;
  					var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase();
  			        if(endIgnoreCaseMach){
  			        	domBuilder.endElement(config.uri,config.localName,tagName);
  						if(localNSMap){
  							for (var prefix in localNSMap) {
  								if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
  									domBuilder.endPrefixMapping(prefix);
  								}
  							}
  						}
  						if(!endMatch){
  			            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case
  						}
  			        }else {
  			        	parseStack.push(config);
  			        }

  					end++;
  					break;
  					// end elment
  				case '?':// <?...?>
  					locator&&position(tagStart);
  					end = parseInstruction(source,tagStart,domBuilder);
  					break;
  				case '!':// <!doctype,<![CDATA,<!--
  					locator&&position(tagStart);
  					end = parseDCC(source,tagStart,domBuilder,errorHandler);
  					break;
  				default:
  					locator&&position(tagStart);
  					var el = new ElementAttributes();
  					var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
  					//elStartEnd
  					var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
  					var len = el.length;


  					if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
  						el.closed = true;
  						if(!entityMap.nbsp){
  							errorHandler.warning('unclosed xml attribute');
  						}
  					}
  					if(locator && len){
  						var locator2 = copyLocator(locator,{});
  						//try{//attribute position fixed
  						for(var i = 0;i<len;i++){
  							var a = el[i];
  							position(a.offset);
  							a.locator = copyLocator(locator,{});
  						}
  						domBuilder.locator = locator2;
  						if(appendElement(el,domBuilder,currentNSMap)){
  							parseStack.push(el);
  						}
  						domBuilder.locator = locator;
  					}else {
  						if(appendElement(el,domBuilder,currentNSMap)){
  							parseStack.push(el);
  						}
  					}

  					if (NAMESPACE.isHTML(el.uri) && !el.closed) {
  						end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder);
  					} else {
  						end++;
  					}
  				}
  			}catch(e){
  				if (e instanceof ParseError) {
  					throw e;
  				}
  				errorHandler.error('element parse error: '+e);
  				end = -1;
  			}
  			if(end>start){
  				start = end;
  			}else {
  				//TODO: sax
  				appendText(Math.max(tagStart,start)+1);
  			}
  		}
  	}
  	function copyLocator(f,t){
  		t.lineNumber = f.lineNumber;
  		t.columnNumber = f.columnNumber;
  		return t;
  	}

  	/**
  	 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
  	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
  	 */
  	function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){

  		/**
  		 * @param {string} qname
  		 * @param {string} value
  		 * @param {number} startIndex
  		 */
  		function addAttribute(qname, value, startIndex) {
  			if (el.attributeNames.hasOwnProperty(qname)) {
  				errorHandler.fatalError('Attribute ' + qname + ' redefined');
  			}
  			el.addValue(
  				qname,
  				// @see https://www.w3.org/TR/xml/#AVNormalize
  				// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
  				// - recursive replacement of (DTD) entity references
  				// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
  				value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer),
  				startIndex
  			);
  		}
  		var attrName;
  		var value;
  		var p = ++start;
  		var s = S_TAG;//status
  		while(true){
  			var c = source.charAt(p);
  			switch(c){
  			case '=':
  				if(s === S_ATTR){//attrName
  					attrName = source.slice(start,p);
  					s = S_EQ;
  				}else if(s === S_ATTR_SPACE){
  					s = S_EQ;
  				}else {
  					//fatalError: equal must after attrName or space after attrName
  					throw new Error('attribute equal must after attrName'); // No known test case
  				}
  				break;
  			case '\'':
  			case '"':
  				if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
  					){//equal
  					if(s === S_ATTR){
  						errorHandler.warning('attribute value must after "="');
  						attrName = source.slice(start,p);
  					}
  					start = p+1;
  					p = source.indexOf(c,start);
  					if(p>0){
  						value = source.slice(start, p);
  						addAttribute(attrName, value, start-1);
  						s = S_ATTR_END;
  					}else {
  						//fatalError: no end quot match
  						throw new Error('attribute value no end \''+c+'\' match');
  					}
  				}else if(s == S_ATTR_NOQUOT_VALUE){
  					value = source.slice(start, p);
  					addAttribute(attrName, value, start);
  					errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
  					start = p+1;
  					s = S_ATTR_END;
  				}else {
  					//fatalError: no equal before
  					throw new Error('attribute value must after "="'); // No known test case
  				}
  				break;
  			case '/':
  				switch(s){
  				case S_TAG:
  					el.setTagName(source.slice(start,p));
  				case S_ATTR_END:
  				case S_TAG_SPACE:
  				case S_TAG_CLOSE:
  					s =S_TAG_CLOSE;
  					el.closed = true;
  				case S_ATTR_NOQUOT_VALUE:
  				case S_ATTR:
  					break;
  					case S_ATTR_SPACE:
  						el.closed = true;
  					break;
  				//case S_EQ:
  				default:
  					throw new Error("attribute invalid close char('/')") // No known test case
  				}
  				break;
  			case ''://end document
  				errorHandler.error('unexpected end of input');
  				if(s == S_TAG){
  					el.setTagName(source.slice(start,p));
  				}
  				return p;
  			case '>':
  				switch(s){
  				case S_TAG:
  					el.setTagName(source.slice(start,p));
  				case S_ATTR_END:
  				case S_TAG_SPACE:
  				case S_TAG_CLOSE:
  					break;//normal
  				case S_ATTR_NOQUOT_VALUE://Compatible state
  				case S_ATTR:
  					value = source.slice(start,p);
  					if(value.slice(-1) === '/'){
  						el.closed  = true;
  						value = value.slice(0,-1);
  					}
  				case S_ATTR_SPACE:
  					if(s === S_ATTR_SPACE){
  						value = attrName;
  					}
  					if(s == S_ATTR_NOQUOT_VALUE){
  						errorHandler.warning('attribute "'+value+'" missed quot(")!');
  						addAttribute(attrName, value, start);
  					}else {
  						if(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){
  							errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!');
  						}
  						addAttribute(value, value, start);
  					}
  					break;
  				case S_EQ:
  					throw new Error('attribute value missed!!');
  				}
  	//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
  				return p;
  			/*xml space '\x20' | #x9 | #xD | #xA; */
  			case '\u0080':
  				c = ' ';
  			default:
  				if(c<= ' '){//space
  					switch(s){
  					case S_TAG:
  						el.setTagName(source.slice(start,p));//tagName
  						s = S_TAG_SPACE;
  						break;
  					case S_ATTR:
  						attrName = source.slice(start,p);
  						s = S_ATTR_SPACE;
  						break;
  					case S_ATTR_NOQUOT_VALUE:
  						var value = source.slice(start, p);
  						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
  						addAttribute(attrName, value, start);
  					case S_ATTR_END:
  						s = S_TAG_SPACE;
  						break;
  					//case S_TAG_SPACE:
  					//case S_EQ:
  					//case S_ATTR_SPACE:
  					//	void();break;
  					//case S_TAG_CLOSE:
  						//ignore warning
  					}
  				}else {//not space
  	//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
  	//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
  					switch(s){
  					//case S_TAG:void();break;
  					//case S_ATTR:void();break;
  					//case S_ATTR_NOQUOT_VALUE:void();break;
  					case S_ATTR_SPACE:
  						el.tagName;
  						if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
  							errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!');
  						}
  						addAttribute(attrName, attrName, start);
  						start = p;
  						s = S_ATTR;
  						break;
  					case S_ATTR_END:
  						errorHandler.warning('attribute space is required"'+attrName+'"!!');
  					case S_TAG_SPACE:
  						s = S_ATTR;
  						start = p;
  						break;
  					case S_EQ:
  						s = S_ATTR_NOQUOT_VALUE;
  						start = p;
  						break;
  					case S_TAG_CLOSE:
  						throw new Error("elements closed character '/' and '>' must be connected to");
  					}
  				}
  			}//end outer switch
  			//console.log('p++',p)
  			p++;
  		}
  	}
  	/**
  	 * @return true if has new namespace define
  	 */
  	function appendElement(el,domBuilder,currentNSMap){
  		var tagName = el.tagName;
  		var localNSMap = null;
  		//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
  		var i = el.length;
  		while(i--){
  			var a = el[i];
  			var qName = a.qName;
  			var value = a.value;
  			var nsp = qName.indexOf(':');
  			if(nsp>0){
  				var prefix = a.prefix = qName.slice(0,nsp);
  				var localName = qName.slice(nsp+1);
  				var nsPrefix = prefix === 'xmlns' && localName;
  			}else {
  				localName = qName;
  				prefix = null;
  				nsPrefix = qName === 'xmlns' && '';
  			}
  			//can not set prefix,because prefix !== ''
  			a.localName = localName ;
  			//prefix == null for no ns prefix attribute
  			if(nsPrefix !== false){//hack!!
  				if(localNSMap == null){
  					localNSMap = {};
  					//console.log(currentNSMap,0)
  					_copy(currentNSMap,currentNSMap={});
  					//console.log(currentNSMap,1)
  				}
  				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
  				a.uri = NAMESPACE.XMLNS;
  				domBuilder.startPrefixMapping(nsPrefix, value);
  			}
  		}
  		var i = el.length;
  		while(i--){
  			a = el[i];
  			var prefix = a.prefix;
  			if(prefix){//no prefix attribute has no namespace
  				if(prefix === 'xml'){
  					a.uri = NAMESPACE.XML;
  				}if(prefix !== 'xmlns'){
  					a.uri = currentNSMap[prefix || ''];

  					//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
  				}
  			}
  		}
  		var nsp = tagName.indexOf(':');
  		if(nsp>0){
  			prefix = el.prefix = tagName.slice(0,nsp);
  			localName = el.localName = tagName.slice(nsp+1);
  		}else {
  			prefix = null;//important!!
  			localName = el.localName = tagName;
  		}
  		//no prefix element has default namespace
  		var ns = el.uri = currentNSMap[prefix || ''];
  		domBuilder.startElement(ns,localName,tagName,el);
  		//endPrefixMapping and startPrefixMapping have not any help for dom builder
  		//localNSMap = null
  		if(el.closed){
  			domBuilder.endElement(ns,localName,tagName);
  			if(localNSMap){
  				for (prefix in localNSMap) {
  					if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
  						domBuilder.endPrefixMapping(prefix);
  					}
  				}
  			}
  		}else {
  			el.currentNSMap = currentNSMap;
  			el.localNSMap = localNSMap;
  			//parseStack.push(el);
  			return true;
  		}
  	}
  	function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
  		if(/^(?:script|textarea)$/i.test(tagName)){
  			var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
  			var text = source.substring(elStartEnd+1,elEndStart);
  			if(/[&<]/.test(text)){
  				if(/^script$/i.test(tagName)){
  					//if(!/\]\]>/.test(text)){
  						//lexHandler.startCDATA();
  						domBuilder.characters(text,0,text.length);
  						//lexHandler.endCDATA();
  						return elEndStart;
  					//}
  				}//}else{//text area
  					text = text.replace(/&#?\w+;/g,entityReplacer);
  					domBuilder.characters(text,0,text.length);
  					return elEndStart;
  				//}

  			}
  		}
  		return elStartEnd+1;
  	}
  	function fixSelfClosed(source,elStartEnd,tagName,closeMap){
  		//if(tagName in closeMap){
  		var pos = closeMap[tagName];
  		if(pos == null){
  			//console.log(tagName)
  			pos =  source.lastIndexOf('</'+tagName+'>');
  			if(pos<elStartEnd){//
  				pos = source.lastIndexOf('</'+tagName);
  			}
  			closeMap[tagName] =pos;
  		}
  		return pos<elStartEnd;
  		//}
  	}

  	function _copy (source, target) {
  		for (var n in source) {
  			if (Object.prototype.hasOwnProperty.call(source, n)) {
  				target[n] = source[n];
  			}
  		}
  	}

  	function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
  		var next= source.charAt(start+2);
  		switch(next){
  		case '-':
  			if(source.charAt(start + 3) === '-'){
  				var end = source.indexOf('-->',start+4);
  				//append comment source.substring(4,end)//<!--
  				if(end>start){
  					domBuilder.comment(source,start+4,end-start-4);
  					return end+3;
  				}else {
  					errorHandler.error("Unclosed comment");
  					return -1;
  				}
  			}else {
  				//error
  				return -1;
  			}
  		default:
  			if(source.substr(start+3,6) == 'CDATA['){
  				var end = source.indexOf(']]>',start+9);
  				domBuilder.startCDATA();
  				domBuilder.characters(source,start+9,end-start-9);
  				domBuilder.endCDATA();
  				return end+3;
  			}
  			//<!DOCTYPE
  			//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
  			var matchs = split(source,start);
  			var len = matchs.length;
  			if(len>1 && /!doctype/i.test(matchs[0][0])){
  				var name = matchs[1][0];
  				var pubid = false;
  				var sysid = false;
  				if(len>3){
  					if(/^public$/i.test(matchs[2][0])){
  						pubid = matchs[3][0];
  						sysid = len>4 && matchs[4][0];
  					}else if(/^system$/i.test(matchs[2][0])){
  						sysid = matchs[3][0];
  					}
  				}
  				var lastMatch = matchs[len-1];
  				domBuilder.startDTD(name, pubid, sysid);
  				domBuilder.endDTD();

  				return lastMatch.index+lastMatch[0].length
  			}
  		}
  		return -1;
  	}



  	function parseInstruction(source,start,domBuilder){
  		var end = source.indexOf('?>',start);
  		if(end){
  			var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
  			if(match){
  				match[0].length;
  				domBuilder.processingInstruction(match[1], match[2]) ;
  				return end+2;
  			}else {//error
  				return -1;
  			}
  		}
  		return -1;
  	}

  	function ElementAttributes(){
  		this.attributeNames = {};
  	}
  	ElementAttributes.prototype = {
  		setTagName:function(tagName){
  			if(!tagNamePattern.test(tagName)){
  				throw new Error('invalid tagName:'+tagName)
  			}
  			this.tagName = tagName;
  		},
  		addValue:function(qName, value, offset) {
  			if(!tagNamePattern.test(qName)){
  				throw new Error('invalid attribute:'+qName)
  			}
  			this.attributeNames[qName] = this.length;
  			this[this.length++] = {qName:qName,value:value,offset:offset};
  		},
  		length:0,
  		getLocalName:function(i){return this[i].localName},
  		getLocator:function(i){return this[i].locator},
  		getQName:function(i){return this[i].qName},
  		getURI:function(i){return this[i].uri},
  		getValue:function(i){return this[i].value}
  	//	,getIndex:function(uri, localName)){
  	//		if(localName){
  	//
  	//		}else{
  	//			var qName = uri
  	//		}
  	//	},
  	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
  	//	getType:function(uri,localName){}
  	//	getType:function(i){},
  	};



  	function split(source,start){
  		var match;
  		var buf = [];
  		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
  		reg.lastIndex = start;
  		reg.exec(source);//skip <
  		while(match = reg.exec(source)){
  			buf.push(match);
  			if(match[1])return buf;
  		}
  	}

  	sax.XMLReader = XMLReader;
  	sax.ParseError = ParseError;
  	return sax;
  }

  var hasRequiredDomParser;

  function requireDomParser () {
  	if (hasRequiredDomParser) return domParser;
  	hasRequiredDomParser = 1;
  	var conventions = requireConventions();
  	var dom = requireDom();
  	var entities = requireEntities();
  	var sax = requireSax();

  	var DOMImplementation = dom.DOMImplementation;

  	var NAMESPACE = conventions.NAMESPACE;

  	var ParseError = sax.ParseError;
  	var XMLReader = sax.XMLReader;

  	/**
  	 * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
  	 *
  	 * > XML parsed entities are often stored in computer files which,
  	 * > for editing convenience, are organized into lines.
  	 * > These lines are typically separated by some combination
  	 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
  	 * >
  	 * > To simplify the tasks of applications, the XML processor must behave
  	 * > as if it normalized all line breaks in external parsed entities (including the document entity)
  	 * > on input, before parsing, by translating all of the following to a single #xA character:
  	 * >
  	 * > 1. the two-character sequence #xD #xA
  	 * > 2. the two-character sequence #xD #x85
  	 * > 3. the single character #x85
  	 * > 4. the single character #x2028
  	 * > 5. any #xD character that is not immediately followed by #xA or #x85.
  	 *
  	 * @param {string} input
  	 * @returns {string}
  	 */
  	function normalizeLineEndings(input) {
  		return input
  			.replace(/\r[\n\u0085]/g, '\n')
  			.replace(/[\r\u0085\u2028]/g, '\n')
  	}

  	/**
  	 * @typedef Locator
  	 * @property {number} [columnNumber]
  	 * @property {number} [lineNumber]
  	 */

  	/**
  	 * @typedef DOMParserOptions
  	 * @property {DOMHandler} [domBuilder]
  	 * @property {Function} [errorHandler]
  	 * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
  	 * 						defaults to `normalizeLineEndings`
  	 * @property {Locator} [locator]
  	 * @property {Record<string, string>} [xmlns]
  	 *
  	 * @see normalizeLineEndings
  	 */

  	/**
  	 * The DOMParser interface provides the ability to parse XML or HTML source code
  	 * from a string into a DOM `Document`.
  	 *
  	 * _xmldom is different from the spec in that it allows an `options` parameter,
  	 * to override the default behavior._
  	 *
  	 * @param {DOMParserOptions} [options]
  	 * @constructor
  	 *
  	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
  	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
  	 */
  	function DOMParser(options){
  		this.options = options ||{locator:{}};
  	}

  	DOMParser.prototype.parseFromString = function(source,mimeType){
  		var options = this.options;
  		var sax =  new XMLReader();
  		var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
  		var errorHandler = options.errorHandler;
  		var locator = options.locator;
  		var defaultNSMap = options.xmlns||{};
  		var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
  	  	var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
  		if(locator){
  			domBuilder.setDocumentLocator(locator);
  		}

  		sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
  		sax.domBuilder = options.domBuilder || domBuilder;
  		if(isHTML){
  			defaultNSMap[''] = NAMESPACE.HTML;
  		}
  		defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
  		var normalize = options.normalizeLineEndings || normalizeLineEndings;
  		if (source && typeof source === 'string') {
  			sax.parse(
  				normalize(source),
  				defaultNSMap,
  				entityMap
  			);
  		} else {
  			sax.errorHandler.error('invalid doc source');
  		}
  		return domBuilder.doc;
  	};
  	function buildErrorHandler(errorImpl,domBuilder,locator){
  		if(!errorImpl){
  			if(domBuilder instanceof DOMHandler){
  				return domBuilder;
  			}
  			errorImpl = domBuilder ;
  		}
  		var errorHandler = {};
  		var isCallback = errorImpl instanceof Function;
  		locator = locator||{};
  		function build(key){
  			var fn = errorImpl[key];
  			if(!fn && isCallback){
  				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg);}:errorImpl;
  			}
  			errorHandler[key] = fn && function(msg){
  				fn('[xmldom '+key+']\t'+msg+_locator(locator));
  			}||function(){};
  		}
  		build('warning');
  		build('error');
  		build('fatalError');
  		return errorHandler;
  	}

  	//console.log('#\n\n\n\n\n\n\n####')
  	/**
  	 * +ContentHandler+ErrorHandler
  	 * +LexicalHandler+EntityResolver2
  	 * -DeclHandler-DTDHandler
  	 *
  	 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
  	 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
  	 */
  	function DOMHandler() {
  	    this.cdata = false;
  	}
  	function position(locator,node){
  		node.lineNumber = locator.lineNumber;
  		node.columnNumber = locator.columnNumber;
  	}
  	/**
  	 * @see org.xml.sax.ContentHandler#startDocument
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
  	 */
  	DOMHandler.prototype = {
  		startDocument : function() {
  	    	this.doc = new DOMImplementation().createDocument(null, null, null);
  	    	if (this.locator) {
  	        	this.doc.documentURI = this.locator.systemId;
  	    	}
  		},
  		startElement:function(namespaceURI, localName, qName, attrs) {
  			var doc = this.doc;
  		    var el = doc.createElementNS(namespaceURI, qName||localName);
  		    var len = attrs.length;
  		    appendElement(this, el);
  		    this.currentElement = el;

  			this.locator && position(this.locator,el);
  		    for (var i = 0 ; i < len; i++) {
  		        var namespaceURI = attrs.getURI(i);
  		        var value = attrs.getValue(i);
  		        var qName = attrs.getQName(i);
  				var attr = doc.createAttributeNS(namespaceURI, qName);
  				this.locator &&position(attrs.getLocator(i),attr);
  				attr.value = attr.nodeValue = value;
  				el.setAttributeNode(attr);
  		    }
  		},
  		endElement:function(namespaceURI, localName, qName) {
  			var current = this.currentElement;
  			current.tagName;
  			this.currentElement = current.parentNode;
  		},
  		startPrefixMapping:function(prefix, uri) {
  		},
  		endPrefixMapping:function(prefix) {
  		},
  		processingInstruction:function(target, data) {
  		    var ins = this.doc.createProcessingInstruction(target, data);
  		    this.locator && position(this.locator,ins);
  		    appendElement(this, ins);
  		},
  		ignorableWhitespace:function(ch, start, length) {
  		},
  		characters:function(chars, start, length) {
  			chars = _toString.apply(this,arguments);
  			//console.log(chars)
  			if(chars){
  				if (this.cdata) {
  					var charNode = this.doc.createCDATASection(chars);
  				} else {
  					var charNode = this.doc.createTextNode(chars);
  				}
  				if(this.currentElement){
  					this.currentElement.appendChild(charNode);
  				}else if(/^\s*$/.test(chars)){
  					this.doc.appendChild(charNode);
  					//process xml
  				}
  				this.locator && position(this.locator,charNode);
  			}
  		},
  		skippedEntity:function(name) {
  		},
  		endDocument:function() {
  			this.doc.normalize();
  		},
  		setDocumentLocator:function (locator) {
  		    if(this.locator = locator){// && !('lineNumber' in locator)){
  		    	locator.lineNumber = 0;
  		    }
  		},
  		//LexicalHandler
  		comment:function(chars, start, length) {
  			chars = _toString.apply(this,arguments);
  		    var comm = this.doc.createComment(chars);
  		    this.locator && position(this.locator,comm);
  		    appendElement(this, comm);
  		},

  		startCDATA:function() {
  		    //used in characters() methods
  		    this.cdata = true;
  		},
  		endCDATA:function() {
  		    this.cdata = false;
  		},

  		startDTD:function(name, publicId, systemId) {
  			var impl = this.doc.implementation;
  		    if (impl && impl.createDocumentType) {
  		        var dt = impl.createDocumentType(name, publicId, systemId);
  		        this.locator && position(this.locator,dt);
  		        appendElement(this, dt);
  						this.doc.doctype = dt;
  		    }
  		},
  		/**
  		 * @see org.xml.sax.ErrorHandler
  		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
  		 */
  		warning:function(error) {
  			console.warn('[xmldom warning]\t'+error,_locator(this.locator));
  		},
  		error:function(error) {
  			console.error('[xmldom error]\t'+error,_locator(this.locator));
  		},
  		fatalError:function(error) {
  			throw new ParseError(error, this.locator);
  		}
  	};
  	function _locator(l){
  		if(l){
  			return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
  		}
  	}
  	function _toString(chars,start,length){
  		if(typeof chars == 'string'){
  			return chars.substr(start,length)
  		}else {//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
  			if(chars.length >= start+length || start){
  				return new java.lang.String(chars,start,length)+'';
  			}
  			return chars;
  		}
  	}

  	/*
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
  	 * used method of org.xml.sax.ext.LexicalHandler:
  	 *  #comment(chars, start, length)
  	 *  #startCDATA()
  	 *  #endCDATA()
  	 *  #startDTD(name, publicId, systemId)
  	 *
  	 *
  	 * IGNORED method of org.xml.sax.ext.LexicalHandler:
  	 *  #endDTD()
  	 *  #startEntity(name)
  	 *  #endEntity(name)
  	 *
  	 *
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
  	 * IGNORED method of org.xml.sax.ext.DeclHandler
  	 * 	#attributeDecl(eName, aName, type, mode, value)
  	 *  #elementDecl(name, model)
  	 *  #externalEntityDecl(name, publicId, systemId)
  	 *  #internalEntityDecl(name, value)
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
  	 * IGNORED method of org.xml.sax.EntityResolver2
  	 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
  	 *  #resolveEntity(publicId, systemId)
  	 *  #getExternalSubset(name, baseURI)
  	 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
  	 * IGNORED method of org.xml.sax.DTDHandler
  	 *  #notationDecl(name, publicId, systemId) {};
  	 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
  	 */
  	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
  		DOMHandler.prototype[key] = function(){return null};
  	});

  	/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
  	function appendElement (hander,node) {
  	    if (!hander.currentElement) {
  	        hander.doc.appendChild(node);
  	    } else {
  	        hander.currentElement.appendChild(node);
  	    }
  	}//appendChild and setAttributeNS are preformance key

  	domParser.__DOMHandler = DOMHandler;
  	domParser.normalizeLineEndings = normalizeLineEndings;
  	domParser.DOMParser = DOMParser;
  	return domParser;
  }

  var hasRequiredLib;

  function requireLib () {
  	if (hasRequiredLib) return lib;
  	hasRequiredLib = 1;
  	var dom = requireDom();
  	lib.DOMImplementation = dom.DOMImplementation;
  	lib.XMLSerializer = dom.XMLSerializer;
  	lib.DOMParser = requireDomParser().DOMParser;
  	return lib;
  }

  var hasRequiredDOMParser;

  function requireDOMParser () {
  	if (hasRequiredDOMParser) return DOMParser$1;
  	hasRequiredDOMParser = 1;

  	Object.defineProperty(DOMParser$1, "__esModule", {
  	  value: true
  	});
  	DOMParser$1.default = void 0;
  	/**
  	 * @file DOMnode
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/* eslint-disable no-undef */
  	DOMParser$1.default = typeof window !== 'undefined' && window.DOMParser ? window.DOMParser : requireLib().DOMParser;
  	return DOMParser$1;
  }

  var path2contours = {};

  var getArc = {};

  var hasRequiredGetArc;

  function requireGetArc () {
  	if (hasRequiredGetArc) return getArc;
  	hasRequiredGetArc = 1;

  	Object.defineProperty(getArc, "__esModule", {
  	  value: true
  	});
  	getArc.default = getArc$1;
  	var _bezierCubic2Q = _interopRequireDefault(requireBezierCubic2Q2());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file svg arc
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * modify from:
  	 * https://github.com/fontello/svgpath/blob/master/lib/a2c.js
  	 * references:
  	 * http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
  	 */

  	var TAU = Math.PI * 2;
  	function vectorAngle(ux, uy, vx, vy) {
  	  // Calculate an angle between two vectors
  	  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  	  var umag = Math.sqrt(ux * ux + uy * uy);
  	  var vmag = Math.sqrt(ux * ux + uy * uy);
  	  var dot = ux * vx + uy * vy;
  	  var div = dot / (umag * vmag);
  	  if (div > 1 || div < -1) {
  	    // rounding errors, e.g. -1.0000000000000002 can screw up this
  	    div = Math.max(div, -1);
  	    div = Math.min(div, 1);
  	  }
  	  return sign * Math.acos(div);
  	}
  	function correctRadii(midx, midy, rx, ry) {
  	  // Correction of out-of-range radii
  	  rx = Math.abs(rx);
  	  ry = Math.abs(ry);
  	  var  = midx * midx / (rx * rx) + midy * midy / (ry * ry);
  	  if ( > 1) {
  	    rx *= Math.sqrt();
  	    ry *= Math.sqrt();
  	  }
  	  return [rx, ry];
  	}
  	function getArcCenter(x1, y1, x2, y2, fa, fs, rx, ry, sin_, cos_) {
  	  // Convert from endpoint to center parameterization,
  	  // see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes

  	  // Step 1.
  	  //
  	  // Moving an ellipse so origin will be the middlepoint between our two
  	  // points. After that, rotate it to line up ellipse axes with coordinate
  	  // axes.
  	  //
  	  var x1p = cos_ * (x1 - x2) / 2 + sin_ * (y1 - y2) / 2;
  	  var y1p = -sin_ * (x1 - x2) / 2 + cos_ * (y1 - y2) / 2;
  	  var rx_sq = rx * rx;
  	  var ry_sq = ry * ry;
  	  var x1p_sq = x1p * x1p;
  	  var y1p_sq = y1p * y1p;

  	  // Step 2.
  	  //
  	  // Compute coordinates of the centre of this ellipse (cx', cy')
  	  // in the new coordinate system.
  	  //
  	  var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;
  	  if (radicant < 0) {
  	    // due to rounding errors it might be e.g. -1.3877787807814457e-17
  	    radicant = 0;
  	  }
  	  radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;
  	  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);
  	  var cxp = radicant * rx / ry * y1p;
  	  var cyp = radicant * -ry / rx * x1p;

  	  // Step 3.
  	  //
  	  // Transform back to get centre coordinates (cx, cy) in the original
  	  // coordinate system.
  	  //
  	  var cx = cos_ * cxp - sin_ * cyp + (x1 + x2) / 2;
  	  var cy = sin_ * cxp + cos_ * cyp + (y1 + y2) / 2;

  	  // Step 4.
  	  //
  	  // Compute angles (1, ).
  	  //
  	  var v1x = (x1p - cxp) / rx;
  	  var v1y = (y1p - cyp) / ry;
  	  var v2x = (-x1p - cxp) / rx;
  	  var v2y = (-y1p - cyp) / ry;
  	  var 1 = vectorAngle(1, 0, v1x, v1y);
  	  var  = vectorAngle(v1x, v1y, v2x, v2y);
  	  if (fs === 0 &&  > 0) {
  	     -= TAU;
  	  }
  	  if (fs === 1 &&  < 0) {
  	     += TAU;
  	  }
  	  return [cx, cy, 1, ];
  	}
  	function approximateUnitArc(1, ) {
  	  // Approximate one unit arc segment with bzier curves,
  	  // see http://math.stackexchange.com/questions/873224/
  	  //      calculate-control-points-of-cubic-bezier-curve-approximating-a-part-of-a-circle
  	  var  = 4 / 3 * Math.tan( / 4);
  	  var x1 = Math.cos(1);
  	  var y1 = Math.sin(1);
  	  var x2 = Math.cos(1 + );
  	  var y2 = Math.sin(1 + );
  	  return [x1, y1, x1 - y1 * , y1 + x1 * , x2 + y2 * , y2 - x2 * , x2, y2];
  	}
  	function a2c(x1, y1, x2, y2, fa, fs, rx, ry, ) {
  	  var sin_ = Math.sin( * TAU / 360);
  	  var cos_ = Math.cos( * TAU / 360);

  	  // Make sure radii are valid
  	  //
  	  var x1p = cos_ * (x1 - x2) / 2 + sin_ * (y1 - y2) / 2;
  	  var y1p = -sin_ * (x1 - x2) / 2 + cos_ * (y1 - y2) / 2;
  	  if (x1p === 0 && y1p === 0) {
  	    // we're asked to draw line to itself
  	    return [];
  	  }
  	  if (rx === 0 || ry === 0) {
  	    // one of the radii is zero
  	    return [];
  	  }
  	  var radii = correctRadii(x1p, y1p, rx, ry);
  	  rx = radii[0];
  	  ry = radii[1];

  	  // Get center parameters (cx, cy, 1, )
  	  //
  	  var cc = getArcCenter(x1, y1, x2, y2, fa, fs, rx, ry, sin_, cos_);
  	  var result = [];
  	  var 1 = cc[2];
  	  var  = cc[3];

  	  // Split an arc to multiple segments, so each segment
  	  // will be less than /4 (= 90)
  	  //
  	  var segments = Math.max(Math.ceil(Math.abs() / (TAU / 4)), 1);
  	   /= segments;
  	  for (var i = 0; i < segments; i++) {
  	    result.push(approximateUnitArc(1, ));
  	    1 += ;
  	  }

  	  // We have a bezier approximation of a unit circle,
  	  // now need to transform back to the original ellipse
  	  //
  	  return result.map(function (curve) {
  	    for (var _i = 0; _i < curve.length; _i += 2) {
  	      var x = curve[_i + 0];
  	      var y = curve[_i + 1];

  	      // scale
  	      x *= rx;
  	      y *= ry;

  	      // rotate
  	      var xp = cos_ * x - sin_ * y;
  	      var yp = sin_ * x + cos_ * y;

  	      // translate
  	      curve[_i + 0] = xp + cc[0];
  	      curve[_i + 1] = yp + cc[1];
  	    }
  	    return curve;
  	  });
  	}

  	/**
  	 * 
  	 *
  	 * @param {number} rx 
  	 * @param {number} ry 
  	 * @param {number} angle 
  	 * @param {number} largeArc 
  	 * @param {number} sweep 
  	 * @param {Object} p0 1
  	 * @param {Object} p1 2
  	 * @return {Array} 
  	 */
  	function getArc$1(rx, ry, angle, largeArc, sweep, p0, p1) {
  	  var result = a2c(p0.x, p0.y, p1.x, p1.y, largeArc, sweep, rx, ry, angle);
  	  var path = [];
  	  if (result.length) {
  	    path.push({
  	      x: result[0][0],
  	      y: result[0][1],
  	      onCurve: true
  	    });

  	    // 
  	    result.forEach(function (c) {
  	      var q2Array = (0, _bezierCubic2Q.default)({
  	        x: c[0],
  	        y: c[1]
  	      }, {
  	        x: c[2],
  	        y: c[3]
  	      }, {
  	        x: c[4],
  	        y: c[5]
  	      }, {
  	        x: c[6],
  	        y: c[7]
  	      });
  	      q2Array[0][2].onCurve = true;
  	      path.push(q2Array[0][1]);
  	      path.push(q2Array[0][2]);
  	      if (q2Array[1]) {
  	        q2Array[1][2].onCurve = true;
  	        path.push(q2Array[1][1]);
  	        path.push(q2Array[1][2]);
  	      }
  	    });
  	  }
  	  return path;
  	}
  	return getArc;
  }

  var parseParams = {};

  var hasRequiredParseParams;

  function requireParseParams () {
  	if (hasRequiredParseParams) return parseParams;
  	hasRequiredParseParams = 1;

  	Object.defineProperty(parseParams, "__esModule", {
  	  value: true
  	});
  	parseParams.default = _default;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var SEGMENT_REGEX = /-?\d+(?:\.\d+)?(?:e[-+]?\d+)?\b/g;

  	/**
  	 * 
  	 *
  	 * @param  {string} d 
  	 * @return {number}   
  	 */
  	function getSegment(d) {
  	  return +d.trim();
  	}

  	/**
  	 * 
  	 *
  	 * @param  {string} str 
  	 * @return {Array}   
  	 */
  	function _default(str) {
  	  if (!str) {
  	    return [];
  	  }
  	  var matchs = str.match(SEGMENT_REGEX);
  	  return matchs ? matchs.map(getSegment) : [];
  	}
  	return parseParams;
  }

  var hasRequiredPath2contours;

  function requirePath2contours () {
  	if (hasRequiredPath2contours) return path2contours;
  	hasRequiredPath2contours = 1;

  	Object.defineProperty(path2contours, "__esModule", {
  	  value: true
  	});
  	path2contours.default = path2contours$1;
  	var _bezierCubic2Q = _interopRequireDefault(requireBezierCubic2Q2());
  	var _getArc = _interopRequireDefault(requireGetArc());
  	var _parseParams = _interopRequireDefault(requireParseParams());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file svg path
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Array} cubicList 
  	 * @param {Array} contour 
  	 * @return {Array} 
  	 */
  	function cubic2Points(cubicList, contour) {
  	  var i;
  	  var l;
  	  var q2List = [];
  	  cubicList.forEach(function (c) {
  	    var list = (0, _bezierCubic2Q.default)(c[0], c[1], c[2], c[3]);
  	    for (i = 0, l = list.length; i < l; i++) {
  	      q2List.push(list[i]);
  	    }
  	  });
  	  var q2;
  	  var prevq2;
  	  for (i = 0, l = q2List.length; i < l; i++) {
  	    q2 = q2List[i];
  	    if (i === 0) {
  	      contour.push({
  	        x: q2[1].x,
  	        y: q2[1].y
  	      });
  	      contour.push({
  	        x: q2[2].x,
  	        y: q2[2].y,
  	        onCurve: true
  	      });
  	    } else {
  	      prevq2 = q2List[i - 1];
  	      // 
  	      if (prevq2[1].x + q2[1].x === 2 * q2[0].x && prevq2[1].y + q2[1].y === 2 * q2[0].y) {
  	        contour.pop();
  	      }
  	      contour.push({
  	        x: q2[1].x,
  	        y: q2[1].y
  	      });
  	      contour.push({
  	        x: q2[2].x,
  	        y: q2[2].y,
  	        onCurve: true
  	      });
  	    }
  	  }
  	  contour.push({
  	    x: q2[2].x,
  	    y: q2[2].y,
  	    onCurve: true
  	  });
  	  return contour;
  	}

  	/**
  	 * svg 
  	 *
  	 * @param {Array} segments svg 
  	 * @return {Array} 
  	 */
  	function segments2Contours(segments) {
  	  // segments
  	  var contours = [];
  	  var contour = [];
  	  var prevX = 0;
  	  var prevY = 0;
  	  var segment;
  	  var args;
  	  var cmd;
  	  var relative;
  	  var q;
  	  var ql;
  	  var px;
  	  var py;
  	  var cubicList;
  	  var p1;
  	  var p2;
  	  var c1;
  	  var c2;
  	  var prevCubicC1; // `s`

  	  for (var i = 0, l = segments.length; i < l; i++) {
  	    segment = segments[i];
  	    cmd = segment.cmd;
  	    relative = segment.relative;
  	    args = segment.args;
  	    if (args && !args.length && cmd !== 'Z') {
  	      console.warn('`' + cmd + '` command args empty!');
  	      continue;
  	    }
  	    if (cmd === 'Z') {
  	      contours.push(contour);
  	      contour = [];
  	    } else if (cmd === 'M' || cmd === 'L') {
  	      if (args.length % 2) {
  	        throw new Error('`M` command error:' + args.join(','));
  	      }

  	      // 
  	      if (relative) {
  	        px = prevX;
  	        py = prevY;
  	      } else {
  	        px = 0;
  	        py = 0;
  	      }
  	      for (q = 0, ql = args.length; q < ql; q += 2) {
  	        if (relative) {
  	          px += args[q];
  	          py += args[q + 1];
  	        } else {
  	          px = args[q];
  	          py = args[q + 1];
  	        }
  	        contour.push({
  	          x: px,
  	          y: py,
  	          onCurve: true
  	        });
  	      }
  	      prevX = px;
  	      prevY = py;
  	    } else if (cmd === 'H') {
  	      if (relative) {
  	        prevX += args[0];
  	      } else {
  	        prevX = args[0];
  	      }
  	      contour.push({
  	        x: prevX,
  	        y: prevY,
  	        onCurve: true
  	      });
  	    } else if (cmd === 'V') {
  	      if (relative) {
  	        prevY += args[0];
  	      } else {
  	        prevY = args[0];
  	      }
  	      contour.push({
  	        x: prevX,
  	        y: prevY,
  	        onCurve: true
  	      });
  	    }
  	    // 
  	    else if (cmd === 'Q') {
  	      // 
  	      if (relative) {
  	        px = prevX;
  	        py = prevY;
  	      } else {
  	        px = 0;
  	        py = 0;
  	      }
  	      for (q = 0, ql = args.length; q < ql; q += 4) {
  	        contour.push({
  	          x: px + args[q],
  	          y: py + args[q + 1]
  	        });
  	        contour.push({
  	          x: px + args[q + 2],
  	          y: py + args[q + 3],
  	          onCurve: true
  	        });
  	        if (relative) {
  	          px += args[q + 2];
  	          py += args[q + 3];
  	        } else {
  	          px = 0;
  	          py = 0;
  	        }
  	      }
  	      if (relative) {
  	        prevX = px;
  	        prevY = py;
  	      } else {
  	        prevX = args[ql - 2];
  	        prevY = args[ql - 1];
  	      }
  	    }
  	    // 
  	    else if (cmd === 'T') {
  	      // 
  	      var last = contour.pop();
  	      var pc = contour[contour.length - 1];
  	      if (!pc) {
  	        pc = last;
  	      }
  	      contour.push(pc = {
  	        x: 2 * last.x - pc.x,
  	        y: 2 * last.y - pc.y
  	      });
  	      px = prevX;
  	      py = prevY;
  	      for (q = 0, ql = args.length - 2; q < ql; q += 2) {
  	        if (relative) {
  	          px += args[q];
  	          py += args[q + 1];
  	        } else {
  	          px = args[q];
  	          py = args[q + 1];
  	        }
  	        last = {
  	          x: px,
  	          y: py
  	        };
  	        contour.push(pc = {
  	          x: 2 * last.x - pc.x,
  	          y: 2 * last.y - pc.y
  	        });
  	      }
  	      if (relative) {
  	        prevX = px + args[ql];
  	        prevY = py + args[ql + 1];
  	      } else {
  	        prevX = args[ql];
  	        prevY = args[ql + 1];
  	      }
  	      contour.push({
  	        x: prevX,
  	        y: prevY,
  	        onCurve: true
  	      });
  	    }
  	    // 
  	    else if (cmd === 'C') {
  	      if (args.length % 6) {
  	        throw new Error('`C` command params error:' + args.join(','));
  	      }

  	      // 
  	      cubicList = [];
  	      if (relative) {
  	        px = prevX;
  	        py = prevY;
  	      } else {
  	        px = 0;
  	        py = 0;
  	      }
  	      p1 = {
  	        x: prevX,
  	        y: prevY
  	      };
  	      for (q = 0, ql = args.length; q < ql; q += 6) {
  	        c1 = {
  	          x: px + args[q],
  	          y: py + args[q + 1]
  	        };
  	        c2 = {
  	          x: px + args[q + 2],
  	          y: py + args[q + 3]
  	        };
  	        p2 = {
  	          x: px + args[q + 4],
  	          y: py + args[q + 5]
  	        };
  	        cubicList.push([p1, c1, c2, p2]);
  	        p1 = p2;
  	        if (relative) {
  	          px += args[q + 4];
  	          py += args[q + 5];
  	        } else {
  	          px = 0;
  	          py = 0;
  	        }
  	      }
  	      if (relative) {
  	        prevX = px;
  	        prevY = py;
  	      } else {
  	        prevX = args[ql - 2];
  	        prevY = args[ql - 1];
  	      }
  	      cubic2Points(cubicList, contour);
  	      prevCubicC1 = cubicList[cubicList.length - 1][2];
  	    }
  	    // 
  	    else if (cmd === 'S') {
  	      if (args.length % 4) {
  	        throw new Error('`S` command params error:' + args.join(','));
  	      }

  	      // 
  	      cubicList = [];
  	      if (relative) {
  	        px = prevX;
  	        py = prevY;
  	      } else {
  	        px = 0;
  	        py = 0;
  	      }

  	      // 
  	      p1 = contour.pop();
  	      if (!prevCubicC1) {
  	        prevCubicC1 = p1;
  	      }
  	      c1 = {
  	        x: 2 * p1.x - prevCubicC1.x,
  	        y: 2 * p1.y - prevCubicC1.y
  	      };
  	      for (q = 0, ql = args.length; q < ql; q += 4) {
  	        c2 = {
  	          x: px + args[q],
  	          y: py + args[q + 1]
  	        };
  	        p2 = {
  	          x: px + args[q + 2],
  	          y: py + args[q + 3]
  	        };
  	        cubicList.push([p1, c1, c2, p2]);
  	        p1 = p2;
  	        c1 = {
  	          x: 2 * p1.x - c2.x,
  	          y: 2 * p1.y - c2.y
  	        };
  	        if (relative) {
  	          px += args[q + 2];
  	          py += args[q + 3];
  	        } else {
  	          px = 0;
  	          py = 0;
  	        }
  	      }
  	      if (relative) {
  	        prevX = px;
  	        prevY = py;
  	      } else {
  	        prevX = args[ql - 2];
  	        prevY = args[ql - 1];
  	      }
  	      cubic2Points(cubicList, contour);
  	      prevCubicC1 = cubicList[cubicList.length - 1][2];
  	    }
  	    // , rx, ry, angle, largeArc, sweep, ex, ey
  	    else if (cmd === 'A') {
  	      if (args.length % 7) {
  	        throw new Error('arc command params error:' + args.join(','));
  	      }
  	      for (q = 0, ql = args.length; q < ql; q += 7) {
  	        var ex = args[q + 5];
  	        var ey = args[q + 6];
  	        if (relative) {
  	          ex = prevX + ex;
  	          ey = prevY + ey;
  	        }
  	        var path = (0, _getArc.default)(args[q], args[q + 1], args[q + 2], args[q + 3], args[q + 4], {
  	          x: prevX,
  	          y: prevY
  	        }, {
  	          x: ex,
  	          y: ey
  	        });
  	        if (path && path.length > 1) {
  	          for (var r = 1, rl = path.length; r < rl; r++) {
  	            contour.push(path[r]);
  	          }
  	        }
  	        prevX = ex;
  	        prevY = ey;
  	      }
  	    }
  	  }
  	  return contours;
  	}

  	/**
  	 * svg path
  	 *
  	 * @param {string} path svgpath
  	 * @return {Array} 
  	 */
  	function path2contours$1(path) {
  	  if (!path || !path.length) {
  	    return null;
  	  }
  	  path = path.trim();

  	  // `m`
  	  if (path[0] !== 'M' && path[0] !== 'm') {
  	    path = 'M 0 0' + path;
  	  }

  	  // `z`
  	  path = path.replace(/(\d+)\s*(m|$)/gi, '$1z$2');

  	  // segments
  	  var segments = [];
  	  var cmd;
  	  var relative = false;
  	  var lastIndex;
  	  var args;
  	  for (var i = 0, l = path.length; i < l; i++) {
  	    var c = path[i].toUpperCase();
  	    var r = c !== path[i];
  	    switch (c) {
  	      case 'M':
  	        /* jshint -W086 */
  	        if (i === 0) {
  	          cmd = c;
  	          lastIndex = 1;
  	          break;
  	        }
  	      // eslint-disable-next-line no-fallthrough
  	      case 'Q':
  	      case 'T':
  	      case 'C':
  	      case 'S':
  	      case 'H':
  	      case 'V':
  	      case 'L':
  	      case 'A':
  	      case 'Z':
  	        if (cmd === 'Z') {
  	          segments.push({
  	            cmd: 'Z'
  	          });
  	        } else {
  	          args = path.slice(lastIndex, i);
  	          segments.push({
  	            cmd: cmd,
  	            relative: relative,
  	            args: (0, _parseParams.default)(args)
  	          });
  	        }
  	        cmd = c;
  	        relative = r;
  	        lastIndex = i + 1;
  	        break;
  	    }
  	  }
  	  segments.push({
  	    cmd: 'Z'
  	  });
  	  return segments2Contours(segments);
  	}
  	return path2contours;
  }

  var svgnode2contours = {};

  var oval2contour = {};

  var circle = {};

  var hasRequiredCircle;

  function requireCircle () {
  	if (hasRequiredCircle) return circle;
  	hasRequiredCircle = 1;

  	Object.defineProperty(circle, "__esModule", {
  	  value: true
  	});
  	circle.default = void 0;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	circle.default = [{
  	  x: 582,
  	  y: 0
  	}, {
  	  x: 758,
  	  y: 75
  	}, {
  	  x: 890,
  	  y: 208
  	}, {
  	  x: 965,
  	  y: 384
  	}, {
  	  x: 965,
  	  y: 583
  	}, {
  	  x: 890,
  	  y: 760
  	}, {
  	  x: 758,
  	  y: 891
  	}, {
  	  x: 582,
  	  y: 966
  	}, {
  	  x: 383,
  	  y: 966
  	}, {
  	  x: 207,
  	  y: 891
  	}, {
  	  x: 75,
  	  y: 760
  	}, {
  	  x: 0,
  	  y: 583
  	}, {
  	  x: 0,
  	  y: 384
  	}, {
  	  x: 75,
  	  y: 208
  	}, {
  	  x: 207,
  	  y: 75
  	}, {
  	  x: 383,
  	  y: 0
  	}];
  	return circle;
  }

  var hasRequiredOval2contour;

  function requireOval2contour () {
  	if (hasRequiredOval2contour) return oval2contour;
  	hasRequiredOval2contour = 1;

  	Object.defineProperty(oval2contour, "__esModule", {
  	  value: true
  	});
  	oval2contour.default = oval2contour$1;
  	var _computeBoundingBox = requireComputeBoundingBox();
  	var _pathAdjust = _interopRequireDefault(requirePathAdjust());
  	var _circle = _interopRequireDefault(requireCircle());
  	var _lang = requireLang();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {number} cx x
  	 * @param {number} cy y
  	 * @param {number} rx x
  	 * @param {number} ry y
  	 * @return {Array} 
  	 */
  	function oval2contour$1(cx, cy, rx, ry) {
  	  if (undefined === ry) {
  	    ry = rx;
  	  }
  	  var bound = (0, _computeBoundingBox.computePath)(_circle.default);
  	  var scaleX = +rx * 2 / bound.width;
  	  var scaleY = +ry * 2 / bound.height;
  	  var centerX = bound.width * scaleX / 2;
  	  var centerY = bound.height * scaleY / 2;
  	  var contour = (0, _lang.clone)(_circle.default);
  	  (0, _pathAdjust.default)(contour, scaleX, scaleY);
  	  (0, _pathAdjust.default)(contour, 1, 1, +cx - centerX, +cy - centerY);
  	  return contour;
  	}
  	return oval2contour;
  }

  var polygon2contour = {};

  var hasRequiredPolygon2contour;

  function requirePolygon2contour () {
  	if (hasRequiredPolygon2contour) return polygon2contour;
  	hasRequiredPolygon2contour = 1;

  	Object.defineProperty(polygon2contour, "__esModule", {
  	  value: true
  	});
  	polygon2contour.default = polygon2contour$1;
  	var _parseParams = _interopRequireDefault(requireParseParams());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {Array} points 
  	 * @return {Array} contours
  	 */
  	function polygon2contour$1(points) {
  	  if (!points || !points.length) {
  	    return null;
  	  }
  	  var contours = [];
  	  var segments = (0, _parseParams.default)(points);
  	  for (var i = 0, l = segments.length; i < l; i += 2) {
  	    contours.push({
  	      x: segments[i],
  	      y: segments[i + 1],
  	      onCurve: true
  	    });
  	  }
  	  return contours;
  	}
  	return polygon2contour;
  }

  var rect2contour = {};

  var hasRequiredRect2contour;

  function requireRect2contour () {
  	if (hasRequiredRect2contour) return rect2contour;
  	hasRequiredRect2contour = 1;

  	Object.defineProperty(rect2contour, "__esModule", {
  	  value: true
  	});
  	rect2contour.default = rect2contour$1;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param {number} x x
  	 * @param {number} y y
  	 * @param {number} width 
  	 * @param {number} height 
  	 * @return {Array} 
  	 */
  	function rect2contour$1(x, y, width, height) {
  	  x = +x;
  	  y = +y;
  	  width = +width;
  	  height = +height;
  	  return [{
  	    x: x,
  	    y: y,
  	    onCurve: true
  	  }, {
  	    x: x + width,
  	    y: y,
  	    onCurve: true
  	  }, {
  	    x: x + width,
  	    y: y + height,
  	    onCurve: true
  	  }, {
  	    x: x,
  	    y: y + height,
  	    onCurve: true
  	  }];
  	}
  	return rect2contour;
  }

  var parseTransform = {};

  var hasRequiredParseTransform;

  function requireParseTransform () {
  	if (hasRequiredParseTransform) return parseTransform;
  	hasRequiredParseTransform = 1;

  	Object.defineProperty(parseTransform, "__esModule", {
  	  value: true
  	});
  	parseTransform.default = parseTransform$1;
  	var _parseParams = _interopRequireDefault(requireParseParams());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file transform
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var TRANSFORM_REGEX = /(\w+)\s*\(([\d-.,\s]*)\)/g;

  	/**
  	 * transform
  	 *
  	 * @param {string} str 
  	 * @return {Array} transform, 
  	 *     [
  	 *         {
  	 *             name: 'scale',
  	 *             params: []
  	 *         }
  	 *     ]
  	 */
  	function parseTransform$1(str) {
  	  if (!str) {
  	    return false;
  	  }
  	  TRANSFORM_REGEX.lastIndex = 0;
  	  var transforms = [];
  	  var match;
  	  while (match = TRANSFORM_REGEX.exec(str)) {
  	    transforms.push({
  	      name: match[1],
  	      params: (0, _parseParams.default)(match[2])
  	    });
  	  }
  	  return transforms;
  	}
  	return parseTransform;
  }

  var contoursTransform = {};

  var matrix = {};

  var hasRequiredMatrix;

  function requireMatrix () {
  	if (hasRequiredMatrix) return matrix;
  	hasRequiredMatrix = 1;

  	Object.defineProperty(matrix, "__esModule", {
  	  value: true
  	});
  	matrix.mul = mul;
  	matrix.multiply = multiply;
  	/**
  	 * @file matrix
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * 
  	 *
  	 * @param  {Array=} matrix1 1
  	 * @param  {Array=} matrix2 2
  	 * @return {Array}         
  	 */
  	function mul() {
  	  var matrix1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [1, 0, 0, 1];
  	  var matrix2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 0, 0, 1];
  	  //  4 
  	  if (matrix1.length === 4) {
  	    return [matrix1[0] * matrix2[0] + matrix1[2] * matrix2[1], matrix1[1] * matrix2[0] + matrix1[3] * matrix2[1], matrix1[0] * matrix2[2] + matrix1[2] * matrix2[3], matrix1[1] * matrix2[2] + matrix1[3] * matrix2[3]];
  	  }
  	  // , 6 

  	  return [matrix1[0] * matrix2[0] + matrix1[2] * matrix2[1], matrix1[1] * matrix2[0] + matrix1[3] * matrix2[1], matrix1[0] * matrix2[2] + matrix1[2] * matrix2[3], matrix1[1] * matrix2[2] + matrix1[3] * matrix2[3], matrix1[0] * matrix2[4] + matrix1[2] * matrix2[5] + matrix1[4], matrix1[1] * matrix2[4] + matrix1[3] * matrix2[5] + matrix1[5]];
  	}

  	/**
  	 * 
  	 *
  	 * @param {...Array} matrixs matrix array
  	 * @return {Array}         
  	 */
  	function multiply() {
  	  var result = arguments.length <= 0 ? undefined : arguments[0];
  	  for (var i = 1, matrix; matrix = i < 0 || arguments.length <= i ? undefined : arguments[i]; i++) {
  	    result = mul(result, matrix);
  	  }
  	  return result;
  	}
  	return matrix;
  }

  var hasRequiredContoursTransform;

  function requireContoursTransform () {
  	if (hasRequiredContoursTransform) return contoursTransform;
  	hasRequiredContoursTransform = 1;

  	Object.defineProperty(contoursTransform, "__esModule", {
  	  value: true
  	});
  	contoursTransform.default = contoursTransform$1;
  	var _matrix = requireMatrix();
  	var _pathTransform = _interopRequireDefault(requirePathTransform());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file transform
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * transform
  	 *
  	 * @param {Array} contours 
  	 * @param {Array} transforms 
  	 *     transforms = [{
  	 *         name: 'scale'
  	 *         params: [3,4]
  	 *     }]
  	 *
  	 * @return {Array} 
  	 */
  	function contoursTransform$1(contours, transforms) {
  	  if (!contours || !contours.length || !transforms || !transforms.length) {
  	    return contours;
  	  }
  	  var matrix = [1, 0, 0, 1, 0, 0];
  	  for (var i = 0, l = transforms.length; i < l; i++) {
  	    var transform = transforms[i];
  	    var params = transform.params;
  	    var radian = null;
  	    switch (transform.name) {
  	      case 'translate':
  	        matrix = (0, _matrix.mul)(matrix, [1, 0, 0, 1, params[0], params[1]]);
  	        break;
  	      case 'scale':
  	        matrix = (0, _matrix.mul)(matrix, [params[0], 0, 0, params[1], 0, 0]);
  	        break;
  	      case 'matrix':
  	        matrix = (0, _matrix.mul)(matrix, [params[0], params[1], params[2], params[3], params[4], params[5]]);
  	        break;
  	      case 'rotate':
  	        radian = params[0] * Math.PI / 180;
  	        if (params.length > 1) {
  	          matrix = (0, _matrix.multiply)(matrix, [1, 0, 0, 1, -params[1], -params[2]], [Math.cos(radian), Math.sin(radian), -Math.sin(radian), Math.cos(radian), 0, 0], [1, 0, 0, 1, params[1], params[2]]);
  	        } else {
  	          matrix = (0, _matrix.mul)(matrix, [Math.cos(radian), Math.sin(radian), -Math.sin(radian), Math.cos(radian), 0, 0]);
  	        }
  	        break;
  	      case 'skewX':
  	        matrix = (0, _matrix.mul)(matrix, [1, 0, Math.tan(params[0] * Math.PI / 180), 1, 0, 0]);
  	        break;
  	      case 'skewY':
  	        matrix = (0, _matrix.mul)(matrix, [1, Math.tan(params[0] * Math.PI / 180), 0, 1, 0, 0]);
  	        break;
  	    }
  	  }
  	  contours.forEach(function (p) {
  	    (0, _pathTransform.default)(p, matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
  	  });
  	  return contours;
  	}
  	return contoursTransform;
  }

  var hasRequiredSvgnode2contours;

  function requireSvgnode2contours () {
  	if (hasRequiredSvgnode2contours) return svgnode2contours;
  	hasRequiredSvgnode2contours = 1;

  	Object.defineProperty(svgnode2contours, "__esModule", {
  	  value: true
  	});
  	svgnode2contours.default = svgnode2contours$1;
  	var _path2contours = _interopRequireDefault(requirePath2contours());
  	var _oval2contour = _interopRequireDefault(requireOval2contour());
  	var _polygon2contour = _interopRequireDefault(requirePolygon2contour());
  	var _rect2contour = _interopRequireDefault(requireRect2contour());
  	var _parseTransform = _interopRequireDefault(requireParseTransform());
  	var _contoursTransform = _interopRequireDefault(requireContoursTransform());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file svg
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	// 
  	var support = {
  	  path: {
  	    parse: _path2contours.default,
  	    // 
  	    params: ['d'],
  	    // 
  	    contours: true // 
  	  },
  	  circle: {
  	    parse: _oval2contour.default,
  	    params: ['cx', 'cy', 'r']
  	  },
  	  ellipse: {
  	    parse: _oval2contour.default,
  	    params: ['cx', 'cy', 'rx', 'ry']
  	  },
  	  rect: {
  	    parse: _rect2contour.default,
  	    params: ['x', 'y', 'width', 'height']
  	  },
  	  polygon: {
  	    parse: _polygon2contour.default,
  	    params: ['points']
  	  },
  	  polyline: {
  	    parse: _polygon2contour.default,
  	    params: ['points']
  	  }
  	};

  	/**
  	 * svg
  	 *
  	 * @param {Array} xmlNodes xml
  	 * @return {Array|false} 
  	 */
  	function svgnode2contours$1(xmlNodes) {
  	  var i;
  	  var length;
  	  var j;
  	  var jlength;
  	  var segment; // 
  	  var parsedSegments = []; // 

  	  if (xmlNodes.length) {
  	    var _loop = function _loop() {
  	      var node = xmlNodes[i];
  	      var name = node.tagName;
  	      if (support[name]) {
  	        var supportParams = support[name].params;
  	        var params = [];
  	        for (j = 0, jlength = supportParams.length; j < jlength; j++) {
  	          params.push(node.getAttribute(supportParams[j]));
  	        }
  	        segment = {
  	          name: name,
  	          params: params,
  	          transform: (0, _parseTransform.default)(node.getAttribute('transform'))
  	        };
  	        if (node.parentNode) {
  	          var curNode = node.parentNode;
  	          var transforms = segment.transform || [];
  	          var transAttr;
  	          var iterator = function iterator(t) {
  	            transforms.unshift(t);
  	          };
  	          while (curNode !== null && curNode.tagName !== 'svg') {
  	            transAttr = curNode.getAttribute('transform');
  	            if (transAttr) {
  	              (0, _parseTransform.default)(transAttr).reverse().forEach(iterator);
  	            }
  	            curNode = curNode.parentNode;
  	          }
  	          segment.transform = transforms.length ? transforms : null;
  	        }
  	        parsedSegments.push(segment);
  	      }
  	    };
  	    for (i = 0, length = xmlNodes.length; i < length; i++) {
  	      _loop();
  	    }
  	  }
  	  if (parsedSegments.length) {
  	    var result = [];
  	    for (i = 0, length = parsedSegments.length; i < length; i++) {
  	      segment = parsedSegments[i];
  	      var parser = support[segment.name];
  	      var contour = parser.parse.apply(null, segment.params);
  	      if (contour && contour.length) {
  	        var contours = parser.contours ? contour : [contour];

  	        // 
  	        if (segment.transform) {
  	          contours = (0, _contoursTransform.default)(contours, segment.transform);
  	        }
  	        for (j = 0, jlength = contours.length; j < jlength; j++) {
  	          result.push(contours[j]);
  	        }
  	      }
  	    }
  	    return result;
  	  }
  	  return false;
  	}
  	return svgnode2contours;
  }

  var pathsUtil = {};

  var pathRotate = {};

  var hasRequiredPathRotate;

  function requirePathRotate () {
  	if (hasRequiredPathRotate) return pathRotate;
  	hasRequiredPathRotate = 1;

  	Object.defineProperty(pathRotate, "__esModule", {
  	  value: true
  	});
  	pathRotate.default = pathRotate$1;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * path
  	 *
  	 * @param {Object} contour 
  	 * @param {number} angle 
  	 * @param {number} centerX x
  	 * @param {number} centerY y
  	 *
  	 * @return {Object} contour 
  	 */
  	function pathRotate$1(contour, angle, centerX, centerY) {
  	  angle = angle === undefined ? 0 : angle;
  	  var x = centerX || 0;
  	  var y = centerY || 0;
  	  var cos = Math.cos(angle);
  	  var sin = Math.sin(angle);
  	  var px;
  	  var py;
  	  var p;

  	  // x1=cos(angle)*x-sin(angle)*y;
  	  // y1=cos(angle)*y+sin(angle)*x;
  	  for (var i = 0, l = contour.length; i < l; i++) {
  	    p = contour[i];
  	    px = cos * (p.x - x) - sin * (p.y - y);
  	    py = cos * (p.y - y) + sin * (p.x - x);
  	    p.x = px + x;
  	    p.y = py + y;
  	  }
  	  return contour;
  	}
  	return pathRotate;
  }

  var hasRequiredPathsUtil;

  function requirePathsUtil () {
  	if (hasRequiredPathsUtil) return pathsUtil;
  	hasRequiredPathsUtil = 1;

  	Object.defineProperty(pathsUtil, "__esModule", {
  	  value: true
  	});
  	pathsUtil.default = void 0;
  	var _computeBoundingBox = requireComputeBoundingBox();
  	var _pathAdjust = _interopRequireDefault(requirePathAdjust());
  	var _pathRotate = _interopRequireDefault(requirePathRotate());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
  	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
  	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
  	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/**
  	 * 
  	 *
  	 * @param {Array} paths 
  	 * @param {number} xScale x
  	 * @param {number} yScale y
  	 * @return {Array} 
  	 */
  	function mirrorPaths(paths, xScale, yScale) {
  	  var _computePath = _computeBoundingBox.computePath.apply(void 0, _toConsumableArray(paths)),
  	    x = _computePath.x,
  	    y = _computePath.y,
  	    width = _computePath.width,
  	    height = _computePath.height;
  	  if (xScale === -1) {
  	    paths.forEach(function (p) {
  	      (0, _pathAdjust.default)(p, -1, 1, -x, 0);
  	      (0, _pathAdjust.default)(p, 1, 1, x + width, 0);
  	      p.reverse();
  	    });
  	  }
  	  if (yScale === -1) {
  	    paths.forEach(function (p) {
  	      (0, _pathAdjust.default)(p, 1, -1, 0, -y);
  	      (0, _pathAdjust.default)(p, 1, 1, 0, y + height);
  	      p.reverse();
  	    });
  	  }
  	  return paths;
  	}
  	pathsUtil.default = {
  	  /**
  	   * 
  	   *
  	   * @param {Array} paths 
  	   * @param {number} angle 
  	   * @return {Array} 
  	   */
  	  rotate: function rotate(paths, angle) {
  	    if (!angle) {
  	      return paths;
  	    }
  	    var bound = _computeBoundingBox.computePath.apply(void 0, _toConsumableArray(paths));
  	    var cx = bound.x + bound.width / 2;
  	    var cy = bound.y + bound.height / 2;
  	    paths.forEach(function (p) {
  	      (0, _pathRotate.default)(p, angle, cx, cy);
  	    });
  	    return paths;
  	  },
  	  /**
  	   * 
  	   *
  	   * @param {Array} paths 
  	   * @param {number} x x 
  	   * @param {number} y y 
  	   * @return {Array} 
  	   */
  	  move: function move(paths, x, y) {
  	    var bound = _computeBoundingBox.computePath.apply(void 0, _toConsumableArray(paths));
  	    paths.forEach(function (path) {
  	      (0, _pathAdjust.default)(path, 1, 1, x - bound.x, y - bound.y);
  	    });
  	    return paths;
  	  },
  	  mirror: function mirror(paths) {
  	    return mirrorPaths(paths, -1, 1);
  	  },
  	  flip: function flip(paths) {
  	    return mirrorPaths(paths, 1, -1);
  	  }
  	};
  	return pathsUtil;
  }

  var hasRequiredSvg2ttfobject;

  function requireSvg2ttfobject () {
  	if (hasRequiredSvg2ttfobject) return svg2ttfobject;
  	hasRequiredSvg2ttfobject = 1;

  	Object.defineProperty(svg2ttfobject, "__esModule", {
  	  value: true
  	});
  	svg2ttfobject.default = svg2ttfObject;
  	var _string = _interopRequireDefault(requireString());
  	var _DOMParser = _interopRequireDefault(requireDOMParser());
  	var _path2contours = _interopRequireDefault(requirePath2contours());
  	var _svgnode2contours = _interopRequireDefault(requireSvgnode2contours());
  	var _computeBoundingBox = requireComputeBoundingBox();
  	var _pathsUtil = _interopRequireDefault(requirePathsUtil());
  	var _glyfAdjust = _interopRequireDefault(requireGlyfAdjust());
  	var _error = _interopRequireDefault(requireError());
  	var _getEmptyttfObject = _interopRequireDefault(requireGetEmptyttfObject());
  	var _reduceGlyf = _interopRequireDefault(requireReduceGlyf());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
  	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
  	function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  	function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
  	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
  	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /**
  	 * @file svgttfObject
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	/**
  	 * xml
  	 *
  	 * @param {string} xml xml
  	 * @return {Document}
  	 */
  	function loadXML(xml) {
  	  if (_DOMParser.default) {
  	    try {
  	      var domParser = new _DOMParser.default();
  	      var xmlDoc = domParser.parseFromString(xml, 'text/xml');
  	      return xmlDoc;
  	    } catch (exp) {
  	      _error.default.raise(10103);
  	    }
  	  }
  	  _error.default.raise(10004);
  	}

  	/**
  	 * xml
  	 *
  	 * @param  {string} svg svg
  	 * @return {string} 
  	 */
  	function resolveSVG(svg) {
  	  // xmlnsxmlnssvg
  	  svg = svg.replace(/\s+xmlns(?::[\w-]+)?=("|')[^"']*\1/g, ' ').replace(/<defs[>\s][\s\S]+?\/defs>/g, function (text) {
  	    if (text.indexOf('</font>') >= 0) {
  	      return text;
  	    }
  	    return '';
  	  }).replace(/<use[>\s][\s\S]+?\/use>/g, '');
  	  return svg;
  	}

  	/**
  	 * ttf
  	 *
  	 * @return {Object} ttfObject
  	 */
  	function getEmptyTTF() {
  	  var ttf = (0, _getEmptyttfObject.default)();
  	  ttf.head.unitsPerEm = 0; // unitsPerEm
  	  ttf.from = 'svgfont';
  	  return ttf;
  	}

  	/**
  	 * ttf
  	 *
  	 * @return {Object} ttfObject
  	 */
  	function getEmptyObject() {
  	  return {
  	    'from': 'svg',
  	    'OS/2': {},
  	    'name': {},
  	    'hhea': {},
  	    'head': {},
  	    'post': {},
  	    'glyf': []
  	  };
  	}

  	/**
  	 * unitsPerEm
  	 *
  	 * @param {number} xMin x
  	 * @param {number} xMax x
  	 * @param {number} yMin y
  	 * @param {number} yMax y
  	 * @return {number}
  	 */
  	function getUnitsPerEm(xMin, xMax, yMin, yMax) {
  	  var seed = Math.ceil(Math.min(yMax - yMin, xMax - xMin));
  	  if (!seed) {
  	    return 1024;
  	  }
  	  if (seed <= 128) {
  	    return seed;
  	  }

  	  // unitsPerEm
  	  var unitsPerEm = 128;
  	  while (unitsPerEm < 16384) {
  	    if (seed <= 1.2 * unitsPerEm) {
  	      return unitsPerEm;
  	    }
  	    unitsPerEm <<= 1;
  	  }
  	  return 1024;
  	}

  	/**
  	 * ttfObject
  	 *
  	 * @param {Object} ttf ttfObject
  	 * @return {Object} ttfObject
  	 */
  	function resolve(ttf) {
  	  // svg
  	  // svg
  	  if (ttf.from === 'svgfont' && ttf.head.unitsPerEm > 128) {
  	    ttf.glyf.forEach(function (g) {
  	      if (g.contours) {
  	        (0, _glyfAdjust.default)(g);
  	        (0, _reduceGlyf.default)(g);
  	      }
  	    });
  	  }
  	  // 1024em
  	  else {
  	    var xMin = 16384;
  	    var xMax = -16384;
  	    var yMin = 16384;
  	    var yMax = -16384;
  	    ttf.glyf.forEach(function (g) {
  	      if (g.contours) {
  	        var bound = _computeBoundingBox.computePathBox.apply(void 0, _toConsumableArray(g.contours));
  	        if (bound) {
  	          xMin = Math.min(xMin, bound.x);
  	          xMax = Math.max(xMax, bound.x + bound.width);
  	          yMin = Math.min(yMin, bound.y);
  	          yMax = Math.max(yMax, bound.y + bound.height);
  	        }
  	      }
  	    });
  	    var unitsPerEm = getUnitsPerEm(xMin, xMax, yMin, yMax);
  	    var scale = 1024 / unitsPerEm;
  	    ttf.glyf.forEach(function (g) {
  	      (0, _glyfAdjust.default)(g, scale, scale);
  	      (0, _reduceGlyf.default)(g);
  	    });
  	    ttf.head.unitsPerEm = 1024;
  	  }
  	  return ttf;
  	}

  	/**
  	 * 
  	 *
  	 * @param {Document} xmlDoc XML
  	 * @param {Object} ttf ttf
  	 * @return {Object} ttf
  	 */
  	function parseFont(xmlDoc, ttf) {
  	  var metaNode = xmlDoc.getElementsByTagName('metadata')[0];
  	  var fontNode = xmlDoc.getElementsByTagName('font')[0];
  	  var fontFaceNode = xmlDoc.getElementsByTagName('font-face')[0];
  	  if (metaNode && metaNode.textContent) {
  	    ttf.metadata = _string.default.decodeHTML(metaNode.textContent.trim());
  	  }

  	  // fontfontsvg
  	  if (fontNode) {
  	    ttf.id = fontNode.getAttribute('id') || '';
  	    ttf.hhea.advanceWidthMax = +(fontNode.getAttribute('horiz-adv-x') || 0);
  	    ttf.from = 'svgfont';
  	  }
  	  if (fontFaceNode) {
  	    var OS2 = ttf['OS/2'];
  	    ttf.name.fontFamily = fontFaceNode.getAttribute('font-family') || '';
  	    OS2.usWeightClass = +(fontFaceNode.getAttribute('font-weight') || 0);
  	    ttf.head.unitsPerEm = +(fontFaceNode.getAttribute('units-per-em') || 0);

  	    // panose, eg: 2 0 6 3 0 0 0 0 0 0
  	    var panose = (fontFaceNode.getAttribute('panose-1') || '').split(' ');
  	    ['bFamilyType', 'bSerifStyle', 'bWeight', 'bProportion', 'bContrast', 'bStrokeVariation', 'bArmStyle', 'bLetterform', 'bMidline', 'bXHeight'].forEach(function (name, i) {
  	      OS2[name] = +(panose[i] || 0);
  	    });
  	    ttf.hhea.ascent = +(fontFaceNode.getAttribute('ascent') || 0);
  	    ttf.hhea.descent = +(fontFaceNode.getAttribute('descent') || 0);
  	    OS2.bXHeight = +(fontFaceNode.getAttribute('x-height') || 0);

  	    // bounding
  	    var box = (fontFaceNode.getAttribute('bbox') || '').split(' ');
  	    ['xMin', 'yMin', 'xMax', 'yMax'].forEach(function (name, i) {
  	      ttf.head[name] = +(box[i] || '');
  	    });
  	    ttf.post.underlineThickness = +(fontFaceNode.getAttribute('underline-thickness') || 0);
  	    ttf.post.underlinePosition = +(fontFaceNode.getAttribute('underline-position') || 0);

  	    // unicode range
  	    var unicodeRange = fontFaceNode.getAttribute('unicode-range');
  	    if (unicodeRange) {
  	      unicodeRange.replace(/u\+([0-9A-Z]+)(-[0-9A-Z]+)?/i, function ($0, a, b) {
  	        OS2.usFirstCharIndex = Number('0x' + a);
  	        OS2.usLastCharIndex = b ? Number('0x' + b.slice(1)) : 0xFFFFFFFF;
  	      });
  	    }
  	  }
  	  return ttf;
  	}

  	/**
  	 * 
  	 *
  	 * @param {Document} xmlDoc XML
  	 * @param {Object} ttf ttf
  	 * @return {Object} ttf
  	 */
  	function parseGlyf(xmlDoc, ttf) {
  	  var missingNode = xmlDoc.getElementsByTagName('missing-glyph')[0];

  	  // glyf
  	  var d;
  	  var unicode;
  	  if (missingNode) {
  	    var missing = {
  	      name: '.notdef'
  	    };
  	    if (missingNode.getAttribute('horiz-adv-x')) {
  	      missing.advanceWidth = +missingNode.getAttribute('horiz-adv-x');
  	    }
  	    if (d = missingNode.getAttribute('d')) {
  	      missing.contours = (0, _path2contours.default)(d);
  	    }

  	    // 
  	    if (ttf.glyf[0] && ttf.glyf[0].name === '.notdef') {
  	      ttf.glyf.splice(0, 1);
  	    }
  	    ttf.glyf.unshift(missing);
  	  }
  	  var glyfNodes = xmlDoc.getElementsByTagName('glyph');
  	  if (glyfNodes.length) {
  	    for (var i = 0, l = glyfNodes.length; i < l; i++) {
  	      var node = glyfNodes[i];
  	      var glyf = {
  	        name: node.getAttribute('glyph-name') || node.getAttribute('name') || ''
  	      };
  	      if (node.getAttribute('horiz-adv-x')) {
  	        glyf.advanceWidth = +node.getAttribute('horiz-adv-x');
  	      }
  	      if (unicode = node.getAttribute('unicode')) {
  	        var nextUnicode = [];
  	        var totalCodePoints = 0;
  	        for (var ui = 0; ui < unicode.length; ui++) {
  	          var ucp = unicode.codePointAt(ui);
  	          nextUnicode.push(ucp);
  	          ui = ucp > 0xffff ? ui + 1 : ui;
  	          totalCodePoints += 1;
  	        }
  	        if (totalCodePoints === 1) {
  	          // TTF can't handle ligatures
  	          glyf.unicode = nextUnicode;
  	          if (d = node.getAttribute('d')) {
  	            glyf.contours = (0, _path2contours.default)(d);
  	          }
  	          ttf.glyf.push(glyf);
  	        }
  	      }
  	    }
  	  }
  	  return ttf;
  	}

  	/**
  	 * 
  	 *
  	 * @param {Document} xmlDoc XML
  	 * @param {Object} ttf ttf
  	 */
  	function parsePath(xmlDoc, ttf) {
  	  // pathglfy
  	  var contours;
  	  var glyf;
  	  var node;
  	  var pathNodes = xmlDoc.getElementsByTagName('path');
  	  if (pathNodes.length) {
  	    for (var i = 0, l = pathNodes.length; i < l; i++) {
  	      node = pathNodes[i];
  	      glyf = {
  	        name: node.getAttribute('name') || ''
  	      };
  	      contours = (0, _svgnode2contours.default)([node]);
  	      glyf.contours = contours;
  	      ttf.glyf.push(glyf);
  	    }
  	  }

  	  // svgglyf
  	  contours = (0, _svgnode2contours.default)(Array.prototype.slice.call(xmlDoc.getElementsByTagName('*')).filter(function (node) {
  	    return node.tagName !== 'path';
  	  }));
  	  if (contours) {
  	    glyf = {
  	      name: ''
  	    };
  	    glyf.contours = contours;
  	    ttf.glyf.push(glyf);
  	  }
  	}

  	/**
  	 * xml
  	 *
  	 * @param {Document} xmlDoc XML
  	 * @param {Object} options 
  	 *
  	 * @return {Object} 
  	 */
  	function parseXML(xmlDoc, options) {
  	  if (!xmlDoc.getElementsByTagName('svg').length) {
  	    _error.default.raise(10106);
  	  }
  	  var ttf;

  	  // svgglyfpath
  	  if (xmlDoc.getElementsByTagName('font')[0]) {
  	    ttf = getEmptyTTF();
  	    parseFont(xmlDoc, ttf);
  	    parseGlyf(xmlDoc, ttf);
  	  } else {
  	    ttf = getEmptyObject();
  	    parsePath(xmlDoc, ttf);
  	  }
  	  if (!ttf.glyf.length) {
  	    _error.default.raise(10201);
  	  }
  	  if (ttf.from === 'svg') {
  	    var glyf = ttf.glyf;
  	    var i;
  	    var l;
  	    // 
  	    if (options.combinePath) {
  	      var combined = [];
  	      for (i = 0, l = glyf.length; i < l; i++) {
  	        var contours = glyf[i].contours;
  	        for (var index = 0, length = contours.length; index < length; index++) {
  	          combined.push(contours[index]);
  	        }
  	      }
  	      glyf[0].contours = combined;
  	      glyf.splice(1);
  	    }

  	    // 
  	    for (i = 0, l = glyf.length; i < l; i++) {
  	      // aisvg
  	      glyf[i].contours = _pathsUtil.default.flip(glyf[i].contours);
  	    }
  	  }
  	  return ttf;
  	}

  	/**
  	 * svgttfObject
  	 *
  	 * @param {string|Document} svg svg
  	 * @param {Object=} options 
  	 * @param {boolean} options.combinePath svg
  	 * @return {Object} ttfObject
  	 */
  	function svg2ttfObject(svg) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
  	    combinePath: false
  	  };
  	  var xmlDoc = svg;
  	  if (typeof svg === 'string') {
  	    svg = resolveSVG(svg);
  	    xmlDoc = loadXML(svg);
  	  }
  	  var ttf = parseXML(xmlDoc, options);
  	  return resolve(ttf);
  	}
  	return svg2ttfobject;
  }

  var ttfreader = {};

  var support = {};

  var loca = {};

  var hasRequiredLoca;

  function requireLoca () {
  	if (hasRequiredLoca) return loca;
  	hasRequiredLoca = 1;

  	Object.defineProperty(loca, "__esModule", {
  	  value: true
  	});
  	loca.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file loca
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	loca.default = _table.default.create('loca', [], {
  	  read: function read(reader, ttf) {
  	    var offset = this.offset;
  	    var indexToLocFormat = ttf.head.indexToLocFormat;
  	    // indexToLocFormat24
  	    var type = _struct.default.names[indexToLocFormat === 0 ? _struct.default.Uint16 : _struct.default.Uint32];
  	    var size = indexToLocFormat === 0 ? 2 : 4; // 
  	    var sizeRatio = indexToLocFormat === 0 ? 2 : 1; // 
  	    var wordOffset = [];
  	    reader.seek(offset);
  	    var numGlyphs = ttf.maxp.numGlyphs;
  	    for (var i = 0; i < numGlyphs; ++i) {
  	      wordOffset.push(reader.read(type, offset, false) * sizeRatio);
  	      offset += size;
  	    }
  	    return wordOffset;
  	  },
  	  write: function write(writer, ttf) {
  	    var glyfSupport = ttf.support.glyf;
  	    var offset = ttf.support.glyf.offset || 0;
  	    var indexToLocFormat = ttf.head.indexToLocFormat;
  	    var sizeRatio = indexToLocFormat === 0 ? 0.5 : 1;
  	    var numGlyphs = ttf.glyf.length;
  	    for (var i = 0; i < numGlyphs; ++i) {
  	      if (indexToLocFormat) {
  	        writer.writeUint32(offset);
  	      } else {
  	        writer.writeUint16(offset);
  	      }
  	      offset += glyfSupport[i].size * sizeRatio;
  	    }

  	    // write extra
  	    if (indexToLocFormat) {
  	      writer.writeUint32(offset);
  	    } else {
  	      writer.writeUint16(offset);
  	    }
  	    return writer;
  	  },
  	  size: function size(ttf) {
  	    var locaCount = ttf.glyf.length + 1;
  	    return ttf.head.indexToLocFormat ? locaCount * 4 : locaCount * 2;
  	  }
  	});
  	return loca;
  }

  var glyf = {};

  var parse = {};

  var glyFlag = {};

  var hasRequiredGlyFlag;

  function requireGlyFlag () {
  	if (hasRequiredGlyFlag) return glyFlag;
  	hasRequiredGlyFlag = 1;

  	Object.defineProperty(glyFlag, "__esModule", {
  	  value: true
  	});
  	glyFlag.default = void 0;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * see:
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html
  	 */
  	glyFlag.default = {
  	  ONCURVE: 0x01,
  	  // on curve ,off curve
  	  XSHORT: 0x02,
  	  // x-Short Vector
  	  YSHORT: 0x04,
  	  // y-Short Vector
  	  REPEAT: 0x08,
  	  // next byte is flag repeat count
  	  XSAME: 0x10,
  	  // This x is same (Positive x-Short vector)
  	  YSAME: 0x20,
  	  // This y is same (Positive y-Short vector)
  	  Reserved1: 0x40,
  	  Reserved2: 0x80
  	};
  	return glyFlag;
  }

  var componentFlag = {};

  var hasRequiredComponentFlag;

  function requireComponentFlag () {
  	if (hasRequiredComponentFlag) return componentFlag;
  	hasRequiredComponentFlag = 1;

  	Object.defineProperty(componentFlag, "__esModule", {
  	  value: true
  	});
  	componentFlag.default = void 0;
  	/**
  	 * @file 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * 
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html
  	 */
  	componentFlag.default = {
  	  ARG_1_AND_2_ARE_WORDS: 0x01,
  	  ARGS_ARE_XY_VALUES: 0x02,
  	  ROUND_XY_TO_GRID: 0x04,
  	  WE_HAVE_A_SCALE: 0x08,
  	  RESERVED: 0x10,
  	  MORE_COMPONENTS: 0x20,
  	  WE_HAVE_AN_X_AND_Y_SCALE: 0x40,
  	  WE_HAVE_A_TWO_BY_TWO: 0x80,
  	  WE_HAVE_INSTRUCTIONS: 0x100,
  	  USE_MY_METRICS: 0x200,
  	  OVERLAP_COMPOUND: 0x400,
  	  SCALED_COMPONENT_OFFSET: 0x800,
  	  UNSCALED_COMPONENT_OFFSET: 0x1000
  	};
  	return componentFlag;
  }

  var hasRequiredParse;

  function requireParse () {
  	if (hasRequiredParse) return parse;
  	hasRequiredParse = 1;

  	Object.defineProperty(parse, "__esModule", {
  	  value: true
  	});
  	parse.default = parseGlyf;
  	var _glyFlag = _interopRequireDefault(requireGlyFlag());
  	var _componentFlag = _interopRequireDefault(requireComponentFlag());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file glyf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	var MAX_INSTRUCTION_LENGTH = 5000; // instructions
  	var MAX_NUMBER_OF_COORDINATES = 20000; // glyf

  	/**
  	 * 
  	 *
  	 * @param {Reader} reader Reader
  	 * @param {Object} glyf glyf
  	 * @return {Object} glyf
  	 */
  	function parseSimpleGlyf(reader, glyf) {
  	  var offset = reader.offset;

  	  // 
  	  var numberOfCoordinates = glyf.endPtsOfContours[glyf.endPtsOfContours.length - 1] + 1;

  	  // 
  	  if (numberOfCoordinates > MAX_NUMBER_OF_COORDINATES) {
  	    console.warn('error read glyf coordinates:' + offset);
  	    return glyf;
  	  }

  	  // flag
  	  var i;
  	  var length;
  	  var flags = [];
  	  var flag;
  	  i = 0;
  	  while (i < numberOfCoordinates) {
  	    flag = reader.readUint8();
  	    flags.push(flag);
  	    i++;

  	    // 3flag
  	    if (flag & _glyFlag.default.REPEAT && i < numberOfCoordinates) {
  	      // 
  	      var repeat = reader.readUint8();
  	      for (var j = 0; j < repeat; j++) {
  	        flags.push(flag);
  	        i++;
  	      }
  	    }
  	  }

  	  // 
  	  var coordinates = [];
  	  var prevX = 0;
  	  var x;
  	  for (i = 0, length = flags.length; i < length; ++i) {
  	    x = 0;
  	    flag = flags[i];

  	    // 1
  	    // If set, the corresponding y-coordinate is 1 byte long, not 2
  	    if (flag & _glyFlag.default.XSHORT) {
  	      x = reader.readUint8();

  	      // 5
  	      x = flag & _glyFlag.default.XSAME ? x : -1 * x;
  	    }
  	    // 
  	    else if (flag & _glyFlag.default.XSAME) {
  	      x = 0;
  	    }
  	    // 
  	    else {
  	      x = reader.readInt16();
  	    }
  	    prevX += x;
  	    coordinates[i] = {
  	      x: prevX,
  	      y: 0
  	    };
  	    if (flag & _glyFlag.default.ONCURVE) {
  	      coordinates[i].onCurve = true;
  	    }
  	  }
  	  var prevY = 0;
  	  var y;
  	  for (i = 0, length = flags.length; i < length; i++) {
  	    y = 0;
  	    flag = flags[i];
  	    if (flag & _glyFlag.default.YSHORT) {
  	      y = reader.readUint8();
  	      y = flag & _glyFlag.default.YSAME ? y : -1 * y;
  	    } else if (flag & _glyFlag.default.YSAME) {
  	      y = 0;
  	    } else {
  	      y = reader.readInt16();
  	    }
  	    prevY += y;
  	    if (coordinates[i]) {
  	      coordinates[i].y = prevY;
  	    }
  	  }

  	  // 
  	  if (coordinates.length) {
  	    var endPtsOfContours = glyf.endPtsOfContours;
  	    var contours = [];
  	    contours.push(coordinates.slice(0, endPtsOfContours[0] + 1));
  	    for (i = 1, length = endPtsOfContours.length; i < length; i++) {
  	      contours.push(coordinates.slice(endPtsOfContours[i - 1] + 1, endPtsOfContours[i] + 1));
  	    }
  	    glyf.contours = contours;
  	  }
  	  return glyf;
  	}

  	/**
  	 * 
  	 *
  	 * @param {Reader} reader Reader
  	 * @param {Object} glyf glyf
  	 * @return {Object} glyf
  	 */
  	function parseCompoundGlyf(reader, glyf) {
  	  glyf.compound = true;
  	  glyf.glyfs = [];
  	  var flags;
  	  var g;

  	  // 
  	  do {
  	    flags = reader.readUint16();
  	    g = {};
  	    g.flags = flags;
  	    g.glyphIndex = reader.readUint16();
  	    var arg1 = 0;
  	    var arg2 = 0;
  	    var scaleX = 16384;
  	    var scaleY = 16384;
  	    var scale01 = 0;
  	    var scale10 = 0;
  	    if (_componentFlag.default.ARG_1_AND_2_ARE_WORDS & flags) {
  	      arg1 = reader.readInt16();
  	      arg2 = reader.readInt16();
  	    } else {
  	      arg1 = reader.readInt8();
  	      arg2 = reader.readInt8();
  	    }
  	    if (_componentFlag.default.ROUND_XY_TO_GRID & flags) {
  	      arg1 = Math.round(arg1);
  	      arg2 = Math.round(arg2);
  	    }
  	    if (_componentFlag.default.WE_HAVE_A_SCALE & flags) {
  	      scaleX = reader.readInt16();
  	      scaleY = scaleX;
  	    } else if (_componentFlag.default.WE_HAVE_AN_X_AND_Y_SCALE & flags) {
  	      scaleX = reader.readInt16();
  	      scaleY = reader.readInt16();
  	    } else if (_componentFlag.default.WE_HAVE_A_TWO_BY_TWO & flags) {
  	      scaleX = reader.readInt16();
  	      scale01 = reader.readInt16();
  	      scale10 = reader.readInt16();
  	      scaleY = reader.readInt16();
  	    }
  	    if (_componentFlag.default.ARGS_ARE_XY_VALUES & flags) {
  	      g.useMyMetrics = !!flags & _componentFlag.default.USE_MY_METRICS;
  	      g.overlapCompound = !!flags & _componentFlag.default.OVERLAP_COMPOUND;
  	      g.transform = {
  	        a: Math.round(10000 * scaleX / 16384) / 10000,
  	        b: Math.round(10000 * scale01 / 16384) / 10000,
  	        c: Math.round(10000 * scale10 / 16384) / 10000,
  	        d: Math.round(10000 * scaleY / 16384) / 10000,
  	        e: arg1,
  	        f: arg2
  	      };
  	    } else {
  	      g.points = [arg1, arg2];
  	      g.transform = {
  	        a: Math.round(10000 * scaleX / 16384) / 10000,
  	        b: Math.round(10000 * scale01 / 16384) / 10000,
  	        c: Math.round(10000 * scale10 / 16384) / 10000,
  	        d: Math.round(10000 * scaleY / 16384) / 10000,
  	        e: 0,
  	        f: 0
  	      };
  	    }
  	    glyf.glyfs.push(g);
  	  } while (_componentFlag.default.MORE_COMPONENTS & flags);
  	  if (_componentFlag.default.WE_HAVE_INSTRUCTIONS & flags) {
  	    var length = reader.readUint16();
  	    if (length < MAX_INSTRUCTION_LENGTH) {
  	      var instructions = [];
  	      for (var i = 0; i < length; ++i) {
  	        instructions.push(reader.readUint8());
  	      }
  	      glyf.instructions = instructions;
  	    } else {
  	      console.warn(length);
  	    }
  	  }
  	  return glyf;
  	}

  	/**
  	 * glyf
  	 *
  	 * @param  {Reader} reader 
  	 * @param  {Object} ttf    ttf
  	 * @param  {number=} offset 
  	 * @return {Object}        glyf
  	 */
  	function parseGlyf(reader, ttf, offset) {
  	  if (null != offset) {
  	    reader.seek(offset);
  	  }
  	  var glyf = {};
  	  var i;
  	  var length;
  	  var instructions;

  	  // 
  	  var numberOfContours = reader.readInt16();
  	  glyf.xMin = reader.readInt16();
  	  glyf.yMin = reader.readInt16();
  	  glyf.xMax = reader.readInt16();
  	  glyf.yMax = reader.readInt16();

  	  // 
  	  if (numberOfContours >= 0) {
  	    // endPtsOfConturs
  	    glyf.endPtsOfContours = [];
  	    if (numberOfContours > 0) {
  	      for (i = 0; i < numberOfContours; i++) {
  	        glyf.endPtsOfContours.push(reader.readUint16());
  	      }
  	    } else {
  	      delete glyf.xMin;
  	      delete glyf.yMin;
  	      delete glyf.xMax;
  	      delete glyf.yMax;
  	    }

  	    // instructions
  	    length = reader.readUint16();
  	    if (length) {
  	      // range
  	      if (length < MAX_INSTRUCTION_LENGTH) {
  	        instructions = [];
  	        for (i = 0; i < length; ++i) {
  	          instructions.push(reader.readUint8());
  	        }
  	        glyf.instructions = instructions;
  	      } else {
  	        console.warn(length);
  	      }
  	    }
  	    parseSimpleGlyf(reader, glyf);
  	    delete glyf.endPtsOfContours;
  	  } else {
  	    parseCompoundGlyf(reader, glyf);
  	  }
  	  return glyf;
  	}
  	return parse;
  }

  var write = {};

  var hasRequiredWrite;

  function requireWrite () {
  	if (hasRequiredWrite) return write;
  	hasRequiredWrite = 1;

  	Object.defineProperty(write, "__esModule", {
  	  value: true
  	});
  	write.default = write$1;
  	var _componentFlag = _interopRequireDefault(requireComponentFlag());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file glyf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * glyf
  	 *
  	 * @param  {Object} writer 
  	 * @param  {Object} ttf    ttf
  	 * @return {Object}        
  	 */
  	function write$1(writer, ttf) {
  	  var hinting = ttf.writeOptions ? ttf.writeOptions.hinting : false;
  	  var writeZeroContoursGlyfData = ttf.writeOptions ? ttf.writeOptions.writeZeroContoursGlyfData : false;
  	  ttf.glyf.forEach(function (glyf, index) {
  	    // 
  	    if (!glyf.compound && !writeZeroContoursGlyfData && (!glyf.contours || !glyf.contours.length)) {
  	      return;
  	    }
  	    // header
  	    writer.writeInt16(glyf.compound ? -1 : (glyf.contours || []).length);
  	    writer.writeInt16(glyf.xMin);
  	    writer.writeInt16(glyf.yMin);
  	    writer.writeInt16(glyf.xMax);
  	    writer.writeInt16(glyf.yMax);
  	    var i;
  	    var l;
  	    var flags;

  	    // 
  	    if (glyf.compound) {
  	      for (i = 0, l = glyf.glyfs.length; i < l; i++) {
  	        var g = glyf.glyfs[i];
  	        flags = g.points ? 0 : _componentFlag.default.ARGS_ARE_XY_VALUES + _componentFlag.default.ROUND_XY_TO_GRID; // xy values

  	        // more components
  	        if (i < l - 1) {
  	          flags += _componentFlag.default.MORE_COMPONENTS;
  	        }

  	        // use my metrics
  	        flags += g.useMyMetrics ? _componentFlag.default.USE_MY_METRICS : 0;
  	        // overlap compound
  	        flags += g.overlapCompound ? _componentFlag.default.OVERLAP_COMPOUND : 0;
  	        var transform = g.transform;
  	        var a = transform.a;
  	        var b = transform.b;
  	        var c = transform.c;
  	        var d = transform.d;
  	        var e = g.points ? g.points[0] : transform.e;
  	        var f = g.points ? g.points[1] : transform.f;

  	        // xy values or points
  	        // int 8 int16
  	        if (e < 0 || e > 0x7F || f < 0 || f > 0x7F) {
  	          flags += _componentFlag.default.ARG_1_AND_2_ARE_WORDS;
  	        }
  	        if (b || c) {
  	          flags += _componentFlag.default.WE_HAVE_A_TWO_BY_TWO;
  	        } else if ((a !== 1 || d !== 1) && a === d) {
  	          flags += _componentFlag.default.WE_HAVE_A_SCALE;
  	        } else if (a !== 1 || d !== 1) {
  	          flags += _componentFlag.default.WE_HAVE_AN_X_AND_Y_SCALE;
  	        }
  	        writer.writeUint16(flags);
  	        writer.writeUint16(g.glyphIndex);
  	        if (_componentFlag.default.ARG_1_AND_2_ARE_WORDS & flags) {
  	          writer.writeInt16(e);
  	          writer.writeInt16(f);
  	        } else {
  	          writer.writeUint8(e);
  	          writer.writeUint8(f);
  	        }
  	        if (_componentFlag.default.WE_HAVE_A_SCALE & flags) {
  	          writer.writeInt16(Math.round(a * 16384));
  	        } else if (_componentFlag.default.WE_HAVE_AN_X_AND_Y_SCALE & flags) {
  	          writer.writeInt16(Math.round(a * 16384));
  	          writer.writeInt16(Math.round(d * 16384));
  	        } else if (_componentFlag.default.WE_HAVE_A_TWO_BY_TWO & flags) {
  	          writer.writeInt16(Math.round(a * 16384));
  	          writer.writeInt16(Math.round(b * 16384));
  	          writer.writeInt16(Math.round(c * 16384));
  	          writer.writeInt16(Math.round(d * 16384));
  	        }
  	      }
  	    } else {
  	      var endPtsOfContours = -1;
  	      (glyf.contours || []).forEach(function (contour) {
  	        endPtsOfContours += contour.length;
  	        writer.writeUint16(endPtsOfContours);
  	      });

  	      // instruction
  	      if (hinting && glyf.instructions) {
  	        var instructions = glyf.instructions;
  	        writer.writeUint16(instructions.length);
  	        for (i = 0, l = instructions.length; i < l; i++) {
  	          writer.writeUint8(instructions[i]);
  	        }
  	      } else {
  	        writer.writeUint16(0);
  	      }

  	      // flags
  	      flags = ttf.support.glyf[index].flags || [];
  	      for (i = 0, l = flags.length; i < l; i++) {
  	        writer.writeUint8(flags[i]);
  	      }
  	      var xCoord = ttf.support.glyf[index].xCoord || [];
  	      for (i = 0, l = xCoord.length; i < l; i++) {
  	        if (0 <= xCoord[i] && xCoord[i] <= 0xFF) {
  	          writer.writeUint8(xCoord[i]);
  	        } else {
  	          writer.writeInt16(xCoord[i]);
  	        }
  	      }
  	      var yCoord = ttf.support.glyf[index].yCoord || [];
  	      for (i = 0, l = yCoord.length; i < l; i++) {
  	        if (0 <= yCoord[i] && yCoord[i] <= 0xFF) {
  	          writer.writeUint8(yCoord[i]);
  	        } else {
  	          writer.writeInt16(yCoord[i]);
  	        }
  	      }
  	    }

  	    // 4
  	    var glyfSize = ttf.support.glyf[index].glyfSize;
  	    if (glyfSize % 4) {
  	      writer.writeEmpty(4 - glyfSize % 4);
  	    }
  	  });
  	  return writer;
  	}
  	return write;
  }

  var sizeof = {};

  var hasRequiredSizeof;

  function requireSizeof () {
  	if (hasRequiredSizeof) return sizeof;
  	hasRequiredSizeof = 1;

  	Object.defineProperty(sizeof, "__esModule", {
  	  value: true
  	});
  	sizeof.default = sizeof$1;
  	var _glyFlag = _interopRequireDefault(requireGlyFlag());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file glyfglyf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * glyf
  	 *
  	 * @param {Object} glyf glyf
  	 * @param {Object} glyfSupport glyf
  	 * @param {boolean} hinting hints
  	 * @param {boolean} writeZeroContoursGlyfData  glyph
  	 * @return {number} size
  	 */
  	function sizeofSimple(glyf, glyfSupport, hinting, writeZeroContoursGlyfData) {
  	  if (!writeZeroContoursGlyfData && (!glyf.contours || !glyf.contours.length)) {
  	    return 0;
  	  }

  	  // fixed header + endPtsOfContours
  	  var result = 12 + (glyf.contours || []).length * 2 + (glyfSupport.flags || []).length;
  	  (glyfSupport.xCoord || []).forEach(function (x) {
  	    result += 0 <= x && x <= 0xFF ? 1 : 2;
  	  });
  	  (glyfSupport.yCoord || []).forEach(function (y) {
  	    result += 0 <= y && y <= 0xFF ? 1 : 2;
  	  });
  	  return result + (hinting && glyf.instructions ? glyf.instructions.length : 0);
  	}

  	/**
  	 * size
  	 *
  	 * @param {Object} glyf glyf
  	 * @param {boolean} hinting hints, compound hinting
  	 * @return {number} size
  	 */
  	// eslint-disable-next-line no-unused-vars
  	function sizeofCompound(glyf, hinting) {
  	  var size = 10;
  	  var transform;
  	  glyf.glyfs.forEach(function (g) {
  	    transform = g.transform;
  	    // flags + glyfIndex
  	    size += 4;

  	    // a, b, c, d, e
  	    // xy values or points
  	    if (transform.e < 0 || transform.e > 0x7F || transform.f < 0 || transform.f > 0x7F) {
  	      size += 4;
  	    } else {
  	      size += 2;
  	    }

  	    // 01 , 10
  	    if (transform.b || transform.c) {
  	      size += 8;
  	    }
  	    // scale
  	    else if (transform.a !== 1 || transform.d !== 1) {
  	      size += transform.a === transform.d ? 2 : 4;
  	    }
  	  });
  	  return size;
  	}

  	/**
  	 * flags
  	 *
  	 * @param {Object} glyf glyf
  	 * @param {Object} glyfSupport glyf
  	 * @return {Array}
  	 */
  	function getFlags(glyf, glyfSupport) {
  	  if (!glyf.contours || 0 === glyf.contours.length) {
  	    return glyfSupport;
  	  }
  	  var flags = [];
  	  var xCoord = [];
  	  var yCoord = [];
  	  var contours = glyf.contours;
  	  var contour;
  	  var prev;
  	  var first = true;
  	  for (var j = 0, cl = contours.length; j < cl; j++) {
  	    contour = contours[j];
  	    for (var i = 0, l = contour.length; i < l; i++) {
  	      var point = contour[i];
  	      if (first) {
  	        xCoord.push(point.x);
  	        yCoord.push(point.y);
  	        first = false;
  	      } else {
  	        xCoord.push(point.x - prev.x);
  	        yCoord.push(point.y - prev.y);
  	      }
  	      flags.push(point.onCurve ? _glyFlag.default.ONCURVE : 0);
  	      prev = point;
  	    }
  	  }

  	  // compress
  	  var flagsC = [];
  	  var xCoordC = [];
  	  var yCoordC = [];
  	  var x;
  	  var y;
  	  var prevFlag;
  	  var repeatPoint = -1;
  	  flags.forEach(function (flag, index) {
  	    x = xCoord[index];
  	    y = yCoord[index];

  	    // 
  	    if (index === 0) {
  	      if (-0xFF <= x && x <= 0xFF) {
  	        flag += _glyFlag.default.XSHORT;
  	        if (x >= 0) {
  	          flag += _glyFlag.default.XSAME;
  	        }
  	        x = Math.abs(x);
  	      }
  	      if (-0xFF <= y && y <= 0xFF) {
  	        flag += _glyFlag.default.YSHORT;
  	        if (y >= 0) {
  	          flag += _glyFlag.default.YSAME;
  	        }
  	        y = Math.abs(y);
  	      }
  	      flagsC.push(prevFlag = flag);
  	      xCoordC.push(x);
  	      yCoordC.push(y);
  	    }
  	    // 
  	    else {
  	      if (x === 0) {
  	        flag += _glyFlag.default.XSAME;
  	      } else {
  	        if (-0xFF <= x && x <= 0xFF) {
  	          flag += _glyFlag.default.XSHORT;
  	          if (x > 0) {
  	            flag += _glyFlag.default.XSAME;
  	          }
  	          x = Math.abs(x);
  	        }
  	        xCoordC.push(x);
  	      }
  	      if (y === 0) {
  	        flag += _glyFlag.default.YSAME;
  	      } else {
  	        if (-0xFF <= y && y <= 0xFF) {
  	          flag += _glyFlag.default.YSHORT;
  	          if (y > 0) {
  	            flag += _glyFlag.default.YSAME;
  	          }
  	          y = Math.abs(y);
  	        }
  	        yCoordC.push(y);
  	      }

  	      // repeat
  	      if (flag === prevFlag) {
  	        // 
  	        if (-1 === repeatPoint) {
  	          repeatPoint = flagsC.length - 1;
  	          flagsC[repeatPoint] |= _glyFlag.default.REPEAT;
  	          flagsC.push(1);
  	        } else {
  	          ++flagsC[repeatPoint + 1];
  	        }
  	      } else {
  	        repeatPoint = -1;
  	        flagsC.push(prevFlag = flag);
  	      }
  	    }
  	  });
  	  glyfSupport.flags = flagsC;
  	  glyfSupport.xCoord = xCoordC;
  	  glyfSupport.yCoord = yCoordC;
  	  return glyfSupport;
  	}

  	/**
  	 * glyf
  	 *
  	 * @param  {Object} ttf ttf
  	 * @return {number} 
  	 */
  	function sizeof$1(ttf) {
  	  ttf.support.glyf = [];
  	  var tableSize = 0;
  	  var hinting = ttf.writeOptions ? ttf.writeOptions.hinting : false;
  	  var writeZeroContoursGlyfData = ttf.writeOptions ? ttf.writeOptions.writeZeroContoursGlyfData : false;
  	  ttf.glyf.forEach(function (glyf) {
  	    var glyfSupport = {};
  	    glyfSupport = glyf.compound ? glyfSupport : getFlags(glyf, glyfSupport);
  	    var glyfSize = glyf.compound ? sizeofCompound(glyf) : sizeofSimple(glyf, glyfSupport, hinting, writeZeroContoursGlyfData);
  	    var size = glyfSize;

  	    // 4
  	    if (size % 4) {
  	      size += 4 - size % 4;
  	    }
  	    glyfSupport.glyfSize = glyfSize;
  	    glyfSupport.size = size;
  	    ttf.support.glyf.push(glyfSupport);
  	    tableSize += size;
  	  });
  	  ttf.support.glyf.tableSize = tableSize;

  	  // headerindexToLocFormat
  	  ttf.head.indexToLocFormat = tableSize > 65536 ? 1 : 0;
  	  return ttf.support.glyf.tableSize;
  	}
  	return sizeof;
  }

  var hasRequiredGlyf;

  function requireGlyf () {
  	if (hasRequiredGlyf) return glyf;
  	hasRequiredGlyf = 1;

  	Object.defineProperty(glyf, "__esModule", {
  	  value: true
  	});
  	glyf.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	var _parse = _interopRequireDefault(requireParse());
  	var _write = _interopRequireDefault(requireWrite());
  	var _sizeof = _interopRequireDefault(requireSizeof());
  	var _lang = requireLang();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file glyf
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html
  	 */
  	glyf.default = _table.default.create('glyf', [], {
  	  read: function read(reader, ttf) {
  	    var startOffset = this.offset;
  	    var loca = ttf.loca;
  	    var numGlyphs = ttf.maxp.numGlyphs;
  	    var glyphs = [];
  	    reader.seek(startOffset);

  	    // subset
  	    var subset = ttf.readOptions.subset;
  	    if (subset && subset.length > 0) {
  	      var subsetMap = {
  	        0: true // .notdef
  	      };
  	      subsetMap[0] = true;
  	      // subset map
  	      var cmap = ttf.cmap;

  	      // unicode to index
  	      Object.keys(cmap).forEach(function (c) {
  	        if (subset.indexOf(+c) > -1) {
  	          var _i = cmap[c];
  	          subsetMap[_i] = true;
  	        }
  	      });
  	      ttf.subsetMap = subsetMap;
  	      var parsedGlyfMap = {};
  	      // subsetglyf
  	      var travelsParse = function travels(subsetMap) {
  	        var newSubsetMap = {};
  	        Object.keys(subsetMap).forEach(function (i) {
  	          var index = +i;
  	          parsedGlyfMap[index] = true;
  	          // 
  	          if (loca[index] === loca[index + 1]) {
  	            glyphs[index] = {
  	              contours: []
  	            };
  	          } else {
  	            glyphs[index] = (0, _parse.default)(reader, ttf, startOffset + loca[index]);
  	          }
  	          if (glyphs[index].compound) {
  	            glyphs[index].glyfs.forEach(function (g) {
  	              if (!parsedGlyfMap[g.glyphIndex]) {
  	                newSubsetMap[g.glyphIndex] = true;
  	              }
  	            });
  	          }
  	        });
  	        if (!(0, _lang.isEmptyObject)(newSubsetMap)) {
  	          travels(newSubsetMap);
  	        }
  	      };
  	      travelsParse(subsetMap);
  	      return glyphs;
  	    }

  	    // , n-1
  	    var i;
  	    var l;
  	    for (i = 0, l = numGlyphs - 1; i < l; i++) {
  	      // 
  	      if (loca[i] === loca[i + 1]) {
  	        glyphs[i] = {
  	          contours: []
  	        };
  	      } else {
  	        glyphs[i] = (0, _parse.default)(reader, ttf, startOffset + loca[i]);
  	      }
  	    }

  	    // 
  	    if (ttf.tables.glyf.length - loca[i] < 5) {
  	      glyphs[i] = {
  	        contours: []
  	      };
  	    } else {
  	      glyphs[i] = (0, _parse.default)(reader, ttf, startOffset + loca[i]);
  	    }
  	    return glyphs;
  	  },
  	  write: _write.default,
  	  size: _sizeof.default
  	});
  	return glyf;
  }

  var fpgm = {};

  var hasRequiredFpgm;

  function requireFpgm () {
  	if (hasRequiredFpgm) return fpgm;
  	hasRequiredFpgm = 1;

  	Object.defineProperty(fpgm, "__esModule", {
  	  value: true
  	});
  	fpgm.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file fpgm 
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fpgm.html
  	 */
  	fpgm.default = _table.default.create('fpgm', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.fpgm.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.fpgm) {
  	      writer.writeBytes(ttf.fpgm, ttf.fpgm.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.fpgm ? ttf.fpgm.length : 0;
  	  }
  	});
  	return fpgm;
  }

  var cvt = {};

  var hasRequiredCvt;

  function requireCvt () {
  	if (hasRequiredCvt) return cvt;
  	hasRequiredCvt = 1;

  	Object.defineProperty(cvt, "__esModule", {
  	  value: true
  	});
  	cvt.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file cvt
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * @reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6cvt.html
  	 */
  	cvt.default = _table.default.create('cvt', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.cvt.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.cvt) {
  	      writer.writeBytes(ttf.cvt, ttf.cvt.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.cvt ? ttf.cvt.length : 0;
  	  }
  	});
  	return cvt;
  }

  var prep = {};

  var hasRequiredPrep;

  function requirePrep () {
  	if (hasRequiredPrep) return prep;
  	hasRequiredPrep = 1;

  	Object.defineProperty(prep, "__esModule", {
  	  value: true
  	});
  	prep.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file prep
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * @reference: http://www.microsoft.com/typography/otspec140/prep.htm
  	 */
  	prep.default = _table.default.create('prep', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.prep.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.prep) {
  	      writer.writeBytes(ttf.prep, ttf.prep.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.prep ? ttf.prep.length : 0;
  	  }
  	});
  	return prep;
  }

  var gasp = {};

  var hasRequiredGasp;

  function requireGasp () {
  	if (hasRequiredGasp) return gasp;
  	hasRequiredGasp = 1;

  	Object.defineProperty(gasp, "__esModule", {
  	  value: true
  	});
  	gasp.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file gasp 
  	 * hinting
  	 * @author mengke01(kekee000@gmail.com)
  	 * reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gasp.html
  	 */
  	gasp.default = _table.default.create('gasp', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.gasp.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.gasp) {
  	      writer.writeBytes(ttf.gasp, ttf.gasp.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.gasp ? ttf.gasp.length : 0;
  	  }
  	});
  	return gasp;
  }

  var kerx = {};

  var hasRequiredKerx;

  function requireKerx () {
  	if (hasRequiredKerx) return kerx;
  	hasRequiredKerx = 1;

  	Object.defineProperty(kerx, "__esModule", {
  	  value: true
  	});
  	kerx.default = void 0;
  	var _table = _interopRequireDefault(requireTable());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file kerx
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * @reference: https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kerx.html
  	 */
  	kerx.default = _table.default.create('kerx', [], {
  	  read: function read(reader, ttf) {
  	    var length = ttf.tables.kerx.length;
  	    return reader.readBytes(this.offset, length);
  	  },
  	  write: function write(writer, ttf) {
  	    if (ttf.kerx) {
  	      writer.writeBytes(ttf.kerx, ttf.kerx.length);
  	    }
  	  },
  	  size: function size(ttf) {
  	    return ttf.kerx ? ttf.kerx.length : 0;
  	  }
  	});
  	return kerx;
  }

  var hasRequiredSupport;

  function requireSupport () {
  	if (hasRequiredSupport) return support;
  	hasRequiredSupport = 1;

  	Object.defineProperty(support, "__esModule", {
  	  value: true
  	});
  	support.default = void 0;
  	var _head = _interopRequireDefault(requireHead());
  	var _maxp = _interopRequireDefault(requireMaxp());
  	var _loca = _interopRequireDefault(requireLoca());
  	var _cmap = _interopRequireDefault(requireCmap());
  	var _glyf = _interopRequireDefault(requireGlyf());
  	var _name = _interopRequireDefault(requireName());
  	var _hhea = _interopRequireDefault(requireHhea());
  	var _hmtx = _interopRequireDefault(requireHmtx());
  	var _post = _interopRequireDefault(requirePost());
  	var _OS = _interopRequireDefault(requireOS2());
  	var _fpgm = _interopRequireDefault(requireFpgm());
  	var _cvt = _interopRequireDefault(requireCvt());
  	var _prep = _interopRequireDefault(requirePrep());
  	var _gasp = _interopRequireDefault(requireGasp());
  	var _GPOS = _interopRequireDefault(requireGPOS());
  	var _kern = _interopRequireDefault(requireKern());
  	var _kerx = _interopRequireDefault(requireKerx());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	support.default = {
  	  head: _head.default,
  	  maxp: _maxp.default,
  	  loca: _loca.default,
  	  cmap: _cmap.default,
  	  glyf: _glyf.default,
  	  name: _name.default,
  	  hhea: _hhea.default,
  	  hmtx: _hmtx.default,
  	  post: _post.default,
  	  'OS/2': _OS.default,
  	  fpgm: _fpgm.default,
  	  cvt: _cvt.default,
  	  prep: _prep.default,
  	  gasp: _gasp.default,
  	  GPOS: _GPOS.default,
  	  kern: _kern.default,
  	  kerx: _kerx.default
  	};
  	return support;
  }

  var hasRequiredTtfreader;

  function requireTtfreader () {
  	if (hasRequiredTtfreader) return ttfreader;
  	hasRequiredTtfreader = 1;

  	Object.defineProperty(ttfreader, "__esModule", {
  	  value: true
  	});
  	ttfreader.default = void 0;
  	var _directory = _interopRequireDefault(requireDirectory());
  	var _support = _interopRequireDefault(requireSupport());
  	var _reader = _interopRequireDefault(requireReader());
  	var _postName = _interopRequireDefault(requirePostName());
  	var _error = _interopRequireDefault(requireError());
  	var _compound2simpleglyf = _interopRequireDefault(requireCompound2simpleglyf());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * thanks to
  	 * ynakajima/ttf.js
  	 * https://github.com/ynakajima/ttf.js
  	 */
  	ttfreader.default = /*#__PURE__*/function () {
  	  /**
  	   * ttf
  	   *
  	   * @param {Object} options 
  	   * @param {boolean} options.hinting hinting
  	   * @param {boolean} options.compound2simple 
  	   * @constructor
  	   */
  	  function TTFReader() {
  	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	    _classCallCheck(this, TTFReader);
  	    options.subset = options.subset || []; // 
  	    options.hinting = options.hinting || false; //  hints 
  	    options.kerning = options.kerning || false; //  kerning 
  	    options.compound2simple = options.compound2simple || false; // 
  	    this.options = options;
  	  }

  	  /**
  	   * 
  	   *
  	   * @param {ArrayBuffer} buffer buffer
  	   * @return {Object} ttf
  	   */
  	  return _createClass(TTFReader, [{
  	    key: "readBuffer",
  	    value: function readBuffer(buffer) {
  	      var reader = new _reader.default(buffer, 0, buffer.byteLength, false);
  	      var ttf = {};

  	      // version
  	      ttf.version = reader.readFixed(0);
  	      if (ttf.version !== 0x1) {
  	        _error.default.raise(10101);
  	      }

  	      // num tables
  	      ttf.numTables = reader.readUint16();
  	      if (ttf.numTables <= 0 || ttf.numTables > 100) {
  	        _error.default.raise(10101);
  	      }

  	      // searchRange
  	      ttf.searchRange = reader.readUint16();

  	      // entrySelector
  	      ttf.entrySelector = reader.readUint16();

  	      // rangeShift
  	      ttf.rangeShift = reader.readUint16();
  	      ttf.tables = new _directory.default(reader.offset).read(reader, ttf);
  	      if (!ttf.tables.glyf || !ttf.tables.head || !ttf.tables.cmap || !ttf.tables.hmtx) {
  	        _error.default.raise(10204);
  	      }
  	      ttf.readOptions = this.options;

  	      // 
  	      Object.keys(_support.default).forEach(function (tableName) {
  	        if (ttf.tables[tableName]) {
  	          var offset = ttf.tables[tableName].offset;
  	          ttf[tableName] = new _support.default[tableName](offset).read(reader, ttf);
  	        }
  	      });
  	      if (!ttf.glyf) {
  	        _error.default.raise(10201);
  	      }
  	      reader.dispose();
  	      return ttf;
  	    }

  	    /**
  	     * glyf
  	     *
  	     * @param {Object} ttf ttf
  	     */
  	  }, {
  	    key: "resolveGlyf",
  	    value: function resolveGlyf(ttf) {
  	      var codes = ttf.cmap;
  	      var glyf = ttf.glyf;
  	      var subsetMap = ttf.readOptions.subset ? ttf.subsetMap : null; // ttf

  	      // unicode
  	      Object.keys(codes).forEach(function (c) {
  	        var i = codes[c];
  	        if (subsetMap && !subsetMap[i]) {
  	          return;
  	        }
  	        if (!glyf[i].unicode) {
  	          glyf[i].unicode = [];
  	        }
  	        glyf[i].unicode.push(+c);
  	      });

  	      // advanceWidth
  	      ttf.hmtx.forEach(function (item, i) {
  	        if (subsetMap && !subsetMap[i]) {
  	          return;
  	        }
  	        glyf[i].advanceWidth = item.advanceWidth;
  	        glyf[i].leftSideBearing = item.leftSideBearing;
  	      });

  	      // format = 2 postglyf name
  	      if (ttf.post && 2 === ttf.post.format) {
  	        var nameIndex = ttf.post.nameIndex;
  	        var names = ttf.post.names;
  	        nameIndex.forEach(function (nameIndex, i) {
  	          if (subsetMap && !subsetMap[i]) {
  	            return;
  	          }
  	          if (nameIndex <= 257) {
  	            glyf[i].name = _postName.default[nameIndex];
  	          } else {
  	            glyf[i].name = names[nameIndex - 258] || '';
  	          }
  	        });
  	      }

  	      // subsetMapsubset
  	      // 
  	      if (subsetMap) {
  	        var subGlyf = [];
  	        Object.keys(subsetMap).forEach(function (i) {
  	          i = +i;
  	          if (glyf[i].compound) {
  	            (0, _compound2simpleglyf.default)(i, ttf, true);
  	          }
  	          subGlyf.push(glyf[i]);
  	        });
  	        ttf.glyf = subGlyf;
  	        // 
  	        ttf.maxp.maxComponentElements = 0;
  	        ttf.maxp.maxComponentDepth = 0;
  	      }
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Object} ttf ttf
  	     */
  	  }, {
  	    key: "cleanTables",
  	    value: function cleanTables(ttf) {
  	      delete ttf.readOptions;
  	      delete ttf.tables;
  	      delete ttf.hmtx;
  	      delete ttf.loca;
  	      if (ttf.post) {
  	        delete ttf.post.nameIndex;
  	        delete ttf.post.names;
  	      }
  	      delete ttf.subsetMap;

  	      // hintinghint
  	      if (!this.options.hinting) {
  	        delete ttf.fpgm;
  	        delete ttf.cvt;
  	        delete ttf.prep;
  	        ttf.glyf.forEach(function (glyf) {
  	          delete glyf.instructions;
  	        });
  	      }
  	      if (!this.options.hinting && !this.options.kerning) {
  	        delete ttf.GPOS;
  	        delete ttf.kern;
  	        delete ttf.kerx;
  	      }

  	      // 
  	      if (this.options.compound2simple && ttf.maxp.maxComponentElements) {
  	        ttf.glyf.forEach(function (glyf, index) {
  	          if (glyf.compound) {
  	            (0, _compound2simpleglyf.default)(index, ttf, true);
  	          }
  	        });
  	        ttf.maxp.maxComponentElements = 0;
  	        ttf.maxp.maxComponentDepth = 0;
  	      }
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @param {ArrayBuffer} buffer buffer
  	     * @return {Object} ttf
  	     */
  	  }, {
  	    key: "read",
  	    value: function read(buffer) {
  	      this.ttf = this.readBuffer(buffer);
  	      this.resolveGlyf(this.ttf);
  	      this.cleanTables(this.ttf);
  	      return this.ttf;
  	    }

  	    /**
  	     * 
  	     */
  	  }, {
  	    key: "dispose",
  	    value: function dispose() {
  	      delete this.ttf;
  	      delete this.options;
  	    }
  	  }]);
  	}();
  	return ttfreader;
  }

  var ttfwriter = {};

  var checkSum = {};

  var hasRequiredCheckSum;

  function requireCheckSum () {
  	if (hasRequiredCheckSum) return checkSum;
  	hasRequiredCheckSum = 1;

  	Object.defineProperty(checkSum, "__esModule", {
  	  value: true
  	});
  	checkSum.default = checkSum$1;
  	/**
  	 * @file ttf table
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	function checkSumArrayBuffer(buffer) {
  	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  	  var length = arguments.length > 2 ? arguments[2] : undefined;
  	  length = length == null ? buffer.byteLength : length;
  	  if (offset + length > buffer.byteLength) {
  	    throw new Error('check sum out of bound');
  	  }
  	  var nLongs = Math.floor(length / 4);
  	  var view = new DataView(buffer, offset, length);
  	  var sum = 0;
  	  var i = 0;
  	  while (i < nLongs) {
  	    sum += view.getUint32(4 * i++, false);
  	  }
  	  var leftBytes = length - nLongs * 4;
  	  if (leftBytes) {
  	    offset = nLongs * 4;
  	    while (leftBytes > 0) {
  	      sum += view.getUint8(offset, false) << leftBytes * 8;
  	      offset++;
  	      leftBytes--;
  	    }
  	  }
  	  return sum % 0x100000000;
  	}
  	function checkSumArray(buffer) {
  	  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  	  var length = arguments.length > 2 ? arguments[2] : undefined;
  	  length = length || buffer.length;
  	  if (offset + length > buffer.length) {
  	    throw new Error('check sum out of bound');
  	  }
  	  var nLongs = Math.floor(length / 4);
  	  var sum = 0;
  	  var i = 0;
  	  while (i < nLongs) {
  	    sum += (buffer[i++] << 24) + (buffer[i++] << 16) + (buffer[i++] << 8) + buffer[i++];
  	  }
  	  var leftBytes = length - nLongs * 4;
  	  if (leftBytes) {
  	    offset = nLongs * 4;
  	    while (leftBytes > 0) {
  	      sum += buffer[offset] << leftBytes * 8;
  	      offset++;
  	      leftBytes--;
  	    }
  	  }
  	  return sum % 0x100000000;
  	}

  	/**
  	 * table
  	 *
  	 * @param {ArrayBuffer|Array} buffer 
  	 * @param {number=} offset 
  	 * @param {number=} length 
  	 *
  	 * @return {number} 
  	 */
  	function checkSum$1(buffer, offset, length) {
  	  if (buffer instanceof ArrayBuffer) {
  	    return checkSumArrayBuffer(buffer, offset, length);
  	  } else if (buffer instanceof Array) {
  	    return checkSumArray(buffer, offset, length);
  	  }
  	  throw new Error('not support checksum buffer type');
  	}
  	return checkSum;
  }

  var hasRequiredTtfwriter;

  function requireTtfwriter () {
  	if (hasRequiredTtfwriter) return ttfwriter;
  	hasRequiredTtfwriter = 1;

  	Object.defineProperty(ttfwriter, "__esModule", {
  	  value: true
  	});
  	ttfwriter.default = void 0;
  	var _writer = _interopRequireDefault(requireWriter());
  	var _directory = _interopRequireDefault(requireDirectory());
  	var _support = _interopRequireDefault(requireSupport());
  	var _checkSum = _interopRequireDefault(requireCheckSum());
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
  	 * @file ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	// , 
  	var SUPPORT_TABLES = ['OS/2', 'cmap', 'glyf', 'head', 'hhea', 'hmtx', 'loca', 'maxp', 'name', 'post'];
  	ttfwriter.default = /*#__PURE__*/function () {
  	  function TTFWriter() {
  	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	    _classCallCheck(this, TTFWriter);
  	    this.options = {
  	      writeZeroContoursGlyfData: options.writeZeroContoursGlyfData || false,
  	      //  glyf 
  	      hinting: options.hinting || false,
  	      // hints
  	      kerning: options.kerning || false,
  	      //  kernings space 
  	      support: options.support // 
  	    };
  	  }

  	  /**
  	   * ttf
  	   *
  	   * @param {ttfObject} ttf ttf
  	   */
  	  return _createClass(TTFWriter, [{
  	    key: "resolveTTF",
  	    value: function resolveTTF(ttf) {
  	      // 
  	      ttf.version = ttf.version || 0x1;
  	      ttf.numTables = ttf.writeOptions.tables.length;
  	      ttf.entrySelector = Math.floor(Math.log(ttf.numTables) / Math.LN2);
  	      ttf.searchRange = Math.pow(2, ttf.entrySelector) * 16;
  	      ttf.rangeShift = ttf.numTables * 16 - ttf.searchRange;

  	      // 
  	      ttf.head.checkSumAdjustment = 0;
  	      ttf.head.magickNumber = 0x5F0F3CF5;
  	      if (typeof ttf.head.created === 'string') {
  	        ttf.head.created = /^\d+$/.test(ttf.head.created) ? +ttf.head.created : Date.parse(ttf.head.created);
  	      }
  	      if (typeof ttf.head.modified === 'string') {
  	        ttf.head.modified = /^\d+$/.test(ttf.head.modified) ? +ttf.head.modified : Date.parse(ttf.head.modified);
  	      }
  	      // 
  	      if (!ttf.head.created) {
  	        ttf.head.created = Date.now();
  	      }
  	      if (!ttf.head.modified) {
  	        ttf.head.modified = ttf.head.created;
  	      }
  	      var checkUnicodeRepeat = {}; // 

  	      // glyf
  	      ttf.glyf.forEach(function (glyf, index) {
  	        if (glyf.unicode) {
  	          glyf.unicode = glyf.unicode.sort();
  	          glyf.unicode.forEach(function (u) {
  	            if (checkUnicodeRepeat[u]) {
  	              _error.default.raise({
  	                number: 10200,
  	                data: index
  	              }, index);
  	            } else {
  	              checkUnicodeRepeat[u] = true;
  	            }
  	          });
  	        }
  	      });
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @param {ttfObject} ttf ttf
  	     * @return {ArrayBuffer} 
  	     */
  	  }, {
  	    key: "dump",
  	    value: function dump(ttf) {
  	      // 
  	      ttf.support = Object.assign({}, this.options.support);

  	      // head + directory
  	      var ttfSize = 12 + ttf.numTables * 16;
  	      var ttfHeadOffset = 0; // head

  	      // tables
  	      ttf.support.tables = [];
  	      ttf.writeOptions.tables.forEach(function (tableName) {
  	        var offset = ttfSize;
  	        var TableClass = _support.default[tableName];
  	        var tableSize = new TableClass().size(ttf); // 
  	        var size = tableSize; // 

  	        if (tableName === 'head') {
  	          ttfHeadOffset = offset;
  	        }

  	        // 4
  	        if (size % 4) {
  	          size += 4 - size % 4;
  	        }
  	        ttf.support.tables.push({
  	          name: tableName,
  	          checkSum: 0,
  	          offset: offset,
  	          length: tableSize,
  	          size: size
  	        });
  	        ttfSize += size;
  	      });
  	      var writer = new _writer.default(new ArrayBuffer(ttfSize));

  	      // 
  	      writer.writeFixed(ttf.version);
  	      writer.writeUint16(ttf.numTables);
  	      writer.writeUint16(ttf.searchRange);
  	      writer.writeUint16(ttf.entrySelector);
  	      writer.writeUint16(ttf.rangeShift);

  	      // 
  	      new _directory.default().write(writer, ttf);

  	      // 
  	      ttf.support.tables.forEach(function (table) {
  	        var tableStart = writer.offset;
  	        var TableClass = _support.default[table.name];
  	        new TableClass().write(writer, ttf);
  	        if (table.length % 4) {
  	          // 
  	          writer.writeEmpty(4 - table.length % 4);
  	        }

  	        // 
  	        table.checkSum = (0, _checkSum.default)(writer.getBuffer(), tableStart, table.size);
  	      });

  	      // 
  	      ttf.support.tables.forEach(function (table, index) {
  	        var offset = 12 + index * 16 + 4;
  	        writer.writeUint32(table.checkSum, offset);
  	      });

  	      // 
  	      var ttfCheckSum = (0xB1B0AFBA - (0, _checkSum.default)(writer.getBuffer()) + 0x100000000) % 0x100000000;
  	      writer.writeUint32(ttfCheckSum, ttfHeadOffset + 8);
  	      delete ttf.writeOptions;
  	      delete ttf.support;
  	      var buffer = writer.getBuffer();
  	      writer.dispose();
  	      return buffer;
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @param  {Object} ttf ttf
  	     */
  	  }, {
  	    key: "prepareDump",
  	    value: function prepareDump(ttf) {
  	      if (!ttf.glyf || ttf.glyf.length === 0) {
  	        _error.default.raise(10201);
  	      }
  	      if (!ttf['OS/2'] || !ttf.head || !ttf.name) {
  	        _error.default.raise(10204);
  	      }
  	      var tables = SUPPORT_TABLES.slice(0);
  	      ttf.writeOptions = {};
  	      // hinting tables direct copy
  	      if (this.options.hinting) {
  	        ['cvt', 'fpgm', 'prep', 'gasp', 'GPOS', 'kern', 'kerx'].forEach(function (table) {
  	          if (ttf[table]) {
  	            tables.push(table);
  	          }
  	        });
  	      }
  	      // copy kerning space table
  	      if (this.options.kerning) {
  	        ['GPOS', 'kern', 'kerx'].forEach(function (table) {
  	          if (ttf[table]) {
  	            tables.push(table);
  	          }
  	        });
  	      }
  	      ttf.writeOptions.writeZeroContoursGlyfData = !!this.options.writeZeroContoursGlyfData;
  	      ttf.writeOptions.hinting = !!this.options.hinting;
  	      ttf.writeOptions.kerning = !!this.options.kerning;
  	      ttf.writeOptions.tables = tables.sort();
  	    }

  	    /**
  	     * ttf
  	     *
  	     * @param {Object} ttf ttf
  	     * @return {ArrayBuffer} 
  	     */
  	  }, {
  	    key: "write",
  	    value: function write(ttf) {
  	      this.prepareDump(ttf);
  	      this.resolveTTF(ttf);
  	      var buffer = this.dump(ttf);
  	      return buffer;
  	    }

  	    /**
  	     * 
  	     */
  	  }, {
  	    key: "dispose",
  	    value: function dispose() {
  	      delete this.options;
  	    }
  	  }]);
  	}();
  	return ttfwriter;
  }

  var ttf2eot = {};

  var hasRequiredTtf2eot;

  function requireTtf2eot () {
  	if (hasRequiredTtf2eot) return ttf2eot;
  	hasRequiredTtf2eot = 1;

  	Object.defineProperty(ttf2eot, "__esModule", {
  	  value: true
  	});
  	ttf2eot.default = ttf2eot$1;
  	var _reader = _interopRequireDefault(requireReader());
  	var _writer = _interopRequireDefault(requireWriter());
  	var _string = _interopRequireDefault(requireString$1());
  	var _error = _interopRequireDefault(requireError());
  	var _table = _interopRequireDefault(requireTable());
  	var _struct = _interopRequireDefault(requireStruct());
  	var _name = _interopRequireDefault(requireName());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttfeot
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * reference:
  	 * http://www.w3.org/Submission/EOT/
  	 * https://github.com/fontello/ttf2eot/blob/master/index.js
  	 */

  	var EotHead = _table.default.create('head', [['EOTSize', _struct.default.Uint32], ['FontDataSize', _struct.default.Uint32], ['Version', _struct.default.Uint32], ['Flags', _struct.default.Uint32], ['PANOSE', _struct.default.Bytes, 10], ['Charset', _struct.default.Uint8], ['Italic', _struct.default.Uint8], ['Weight', _struct.default.Uint32], ['fsType', _struct.default.Uint16], ['MagicNumber', _struct.default.Uint16], ['UnicodeRange', _struct.default.Bytes, 16], ['CodePageRange', _struct.default.Bytes, 8], ['CheckSumAdjustment', _struct.default.Uint32], ['Reserved', _struct.default.Bytes, 16], ['Padding1', _struct.default.Uint16]]);

  	/**
  	 * ttfeot
  	 *
  	 * @param {ArrayBuffer} ttfBuffer ttf
  	 * @param {Object} options 
  	 * @return {ArrayBuffer} eotbyte
  	 */
  	// eslint-disable-next-line no-unused-vars
  	function ttf2eot$1(ttfBuffer) {
  	  // eot
  	  var eotHead = new EotHead();
  	  var eotHeaderSize = eotHead.size();
  	  var eot = {};
  	  eot.head = eotHead.read(new _reader.default(new ArrayBuffer(eotHeaderSize)));

  	  // set fields
  	  eot.head.FontDataSize = ttfBuffer.byteLength || ttfBuffer.length;
  	  eot.head.Version = 0x20001;
  	  eot.head.Flags = 0;
  	  eot.head.Charset = 0x1;
  	  eot.head.MagicNumber = 0x504C;
  	  eot.head.Padding1 = 0;
  	  var ttfReader = new _reader.default(ttfBuffer);
  	  // ttf
  	  var numTables = ttfReader.readUint16(4);
  	  if (numTables <= 0 || numTables > 100) {
  	    _error.default.raise(10101);
  	  }

  	  // ttf
  	  ttfReader.seek(12);
  	  // 33byte
  	  var tblReaded = 0;
  	  for (var i = 0; i < numTables && tblReaded !== 0x7; ++i) {
  	    var tableEntry = {
  	      tag: ttfReader.readString(ttfReader.offset, 4),
  	      checkSum: ttfReader.readUint32(),
  	      offset: ttfReader.readUint32(),
  	      length: ttfReader.readUint32()
  	    };
  	    var entryOffset = ttfReader.offset;
  	    if (tableEntry.tag === 'head') {
  	      eot.head.CheckSumAdjustment = ttfReader.readUint32(tableEntry.offset + 8);
  	      tblReaded += 0x1;
  	    } else if (tableEntry.tag === 'OS/2') {
  	      eot.head.PANOSE = ttfReader.readBytes(tableEntry.offset + 32, 10);
  	      eot.head.Italic = ttfReader.readUint16(tableEntry.offset + 62);
  	      eot.head.Weight = ttfReader.readUint16(tableEntry.offset + 4);
  	      eot.head.fsType = ttfReader.readUint16(tableEntry.offset + 8);
  	      eot.head.UnicodeRange = ttfReader.readBytes(tableEntry.offset + 42, 16);
  	      eot.head.CodePageRange = ttfReader.readBytes(tableEntry.offset + 78, 8);
  	      tblReaded += 0x2;
  	    }

  	    // 
  	    else if (tableEntry.tag === 'name') {
  	      var names = new _name.default(tableEntry.offset).read(ttfReader);
  	      eot.FamilyName = _string.default.toUCS2Bytes(names.fontFamily || '');
  	      eot.FamilyNameSize = eot.FamilyName.length;
  	      eot.StyleName = _string.default.toUCS2Bytes(names.fontStyle || '');
  	      eot.StyleNameSize = eot.StyleName.length;
  	      eot.VersionName = _string.default.toUCS2Bytes(names.version || '');
  	      eot.VersionNameSize = eot.VersionName.length;
  	      eot.FullName = _string.default.toUCS2Bytes(names.fullName || '');
  	      eot.FullNameSize = eot.FullName.length;
  	      tblReaded += 0x3;
  	    }
  	    ttfReader.seek(entryOffset);
  	  }

  	  // size
  	  eot.head.EOTSize = eotHeaderSize + 4 + eot.FamilyNameSize + 4 + eot.StyleNameSize + 4 + eot.VersionNameSize + 4 + eot.FullNameSize + 2 + eot.head.FontDataSize;

  	  // 
  	  var eotWriter = new _writer.default(new ArrayBuffer(eot.head.EOTSize), 0, eot.head.EOTSize, true);

  	  // write head
  	  eotHead.write(eotWriter, eot);

  	  // write names
  	  eotWriter.writeUint16(eot.FamilyNameSize);
  	  eotWriter.writeBytes(eot.FamilyName, eot.FamilyNameSize);
  	  eotWriter.writeUint16(0);
  	  eotWriter.writeUint16(eot.StyleNameSize);
  	  eotWriter.writeBytes(eot.StyleName, eot.StyleNameSize);
  	  eotWriter.writeUint16(0);
  	  eotWriter.writeUint16(eot.VersionNameSize);
  	  eotWriter.writeBytes(eot.VersionName, eot.VersionNameSize);
  	  eotWriter.writeUint16(0);
  	  eotWriter.writeUint16(eot.FullNameSize);
  	  eotWriter.writeBytes(eot.FullName, eot.FullNameSize);
  	  eotWriter.writeUint16(0);

  	  // write rootstring
  	  eotWriter.writeUint16(0);
  	  eotWriter.writeBytes(ttfBuffer, eot.head.FontDataSize);
  	  return eotWriter.getBuffer();
  	}
  	return ttf2eot;
  }

  var ttf2woff = {};

  var hasRequiredTtf2woff;

  function requireTtf2woff () {
  	if (hasRequiredTtf2woff) return ttf2woff;
  	hasRequiredTtf2woff = 1;

  	Object.defineProperty(ttf2woff, "__esModule", {
  	  value: true
  	});
  	ttf2woff.default = ttf2woff$1;
  	var _reader = _interopRequireDefault(requireReader());
  	var _writer = _interopRequireDefault(requireWriter());
  	var _string = _interopRequireDefault(requireString());
  	var _string2 = _interopRequireDefault(requireString$1());
  	var _error = _interopRequireDefault(requireError());
  	var _default = _interopRequireDefault(require_default());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttfwoff
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * woff format:
  	 * http://www.w3.org/TR/2012/REC-WOFF-20121213/
  	 *
  	 * references:
  	 * https://github.com/fontello/ttf2woff
  	 * https://github.com/nodeca/pako
  	 */
  	/* eslint-disable no-multi-spaces */

  	/**
  	 * metadata XML
  	 *
  	 * @param {Object} metadata metadata
  	 *
  	 * @example
  	 * metadata json:
  	 *
  	 *    {
  	 *        "uniqueid": "",
  	 *        "vendor": {
  	 *            "name": "",
  	 *            "url": ""
  	 *        },
  	 *        "credit": [
  	 *            {
  	 *                "name": "",
  	 *                "url": "",
  	 *                "role": ""
  	 *            }
  	 *        ],
  	 *        "description": "",
  	 *        "license": {
  	 *            "id": "",
  	 *            "url": "",
  	 *            "text": ""
  	 *        },
  	 *        "copyright": "",
  	 *        "trademark": "",
  	 *        "licensee": ""
  	 *    }
  	 *
  	 * @return {string} xml
  	 */
  	function metadata2xml(metadata) {
  	  var xml = '' + '<?xml version="1.0" encoding="UTF-8"?>' + '<metadata version="1.0">';
  	  metadata.uniqueid = metadata.uniqueid || _default.default.fontId + '.' + Date.now();
  	  xml += '<uniqueid id="' + _string.default.encodeHTML(metadata.uniqueid) + '" />';
  	  if (metadata.vendor) {
  	    xml += '<vendor name="' + _string.default.encodeHTML(metadata.vendor.name) + '"' + ' url="' + _string.default.encodeHTML(metadata.vendor.url) + '" />';
  	  }
  	  if (metadata.credit) {
  	    xml += '<credits>';
  	    var credits = metadata.credit instanceof Array ? metadata.credit : [metadata.credit];
  	    credits.forEach(function (credit) {
  	      xml += '<credit name="' + _string.default.encodeHTML(credit.name) + '"' + ' url="' + _string.default.encodeHTML(credit.url) + '"' + ' role="' + _string.default.encodeHTML(credit.role || 'Contributor') + '" />';
  	    });
  	    xml += '</credits>';
  	  }
  	  if (metadata.description) {
  	    xml += '<description><text xml:lang="en">' + _string.default.encodeHTML(metadata.description) + '</text></description>';
  	  }
  	  if (metadata.license) {
  	    xml += '<license url="' + _string.default.encodeHTML(metadata.license.url) + '"' + ' id="' + _string.default.encodeHTML(metadata.license.id) + '"><text xml:lang="en">';
  	    xml += _string.default.encodeHTML(metadata.license.text);
  	    xml += '</text></license>';
  	  }
  	  if (metadata.copyright) {
  	    xml += '<copyright><text xml:lang="en">';
  	    xml += _string.default.encodeHTML(metadata.copyright);
  	    xml += '</text></copyright>';
  	  }
  	  if (metadata.trademark) {
  	    xml += '<trademark><text xml:lang="en">' + _string.default.encodeHTML(metadata.trademark) + '</text></trademark>';
  	  }
  	  if (metadata.licensee) {
  	    xml += '<licensee name="' + _string.default.encodeHTML(metadata.licensee) + '"/>';
  	  }
  	  xml += '</metadata>';
  	  return xml;
  	}

  	/**
  	 * ttfwoff
  	 *
  	 * @param {ArrayBuffer} ttfBuffer ttf
  	 * @param {Object} options 
  	 * @param {Object} options.metadata 
  	 * @param {Object} options.deflate 
  	 *
  	 * @return {ArrayBuffer} woffbyte
  	 */
  	function ttf2woff$1(ttfBuffer) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  // woff 
  	  var woffHeader = {
  	    signature: 0x774F4646,
  	    // for woff
  	    flavor: 0x10000,
  	    // for ttf
  	    length: 0,
  	    numTables: 0,
  	    reserved: 0,
  	    totalSfntSize: 0,
  	    majorVersion: 0,
  	    minorVersion: 0,
  	    metaOffset: 0,
  	    metaLength: 0,
  	    metaOrigLength: 0,
  	    privOffset: 0,
  	    privLength: 0
  	  };
  	  var ttfReader = new _reader.default(ttfBuffer);
  	  var tableEntries = [];
  	  var numTables = ttfReader.readUint16(4); // ttf
  	  var tableEntry;
  	  var deflatedData;
  	  var i;
  	  var l;
  	  if (numTables <= 0 || numTables > 100) {
  	    _error.default.raise(10101);
  	  }

  	  // ttf
  	  ttfReader.seek(12);
  	  for (i = 0; i < numTables; ++i) {
  	    tableEntry = {
  	      tag: ttfReader.readString(ttfReader.offset, 4),
  	      checkSum: ttfReader.readUint32(),
  	      offset: ttfReader.readUint32(),
  	      length: ttfReader.readUint32()
  	    };
  	    var entryOffset = ttfReader.offset;
  	    if (tableEntry.tag === 'head') {
  	      // font revision
  	      woffHeader.majorVersion = ttfReader.readUint16(tableEntry.offset + 4);
  	      woffHeader.minorVersion = ttfReader.readUint16(tableEntry.offset + 6);
  	    }

  	    // ttf 
  	    var sfntData = ttfReader.readBytes(tableEntry.offset, tableEntry.length);

  	    // 
  	    if (options.deflate) {
  	      deflatedData = options.deflate(sfntData);

  	      // 
  	      if (deflatedData.length < sfntData.length) {
  	        tableEntry.data = deflatedData;
  	        tableEntry.deflated = true;
  	      } else {
  	        tableEntry.data = sfntData;
  	      }
  	    } else {
  	      tableEntry.data = sfntData;
  	    }
  	    tableEntry.compLength = tableEntry.data.length;
  	    tableEntries.push(tableEntry);
  	    ttfReader.seek(entryOffset);
  	  }
  	  if (!tableEntries.length) {
  	    _error.default.raise(10204);
  	  }

  	  // table
  	  tableEntries = tableEntries.sort(function (a, b) {
  	    return a.tag === b.tag ? 0 : a.tag < b.tag ? -1 : 1;
  	  });

  	  // offset woff size
  	  var woffSize = 44 + 20 * numTables; // header size + table entries
  	  var ttfSize = 12 + 16 * numTables;
  	  for (i = 0, l = tableEntries.length; i < l; ++i) {
  	    tableEntry = tableEntries[i];
  	    tableEntry.offset = woffSize;
  	    // 4
  	    woffSize += tableEntry.compLength + (tableEntry.compLength % 4 ? 4 - tableEntry.compLength % 4 : 0);
  	    ttfSize += tableEntry.length + (tableEntry.length % 4 ? 4 - tableEntry.length % 4 : 0);
  	  }

  	  // metaData
  	  var metadata = null;
  	  if (options.metadata) {
  	    var xml = _string2.default.toUTF8Bytes(metadata2xml(options.metadata));
  	    if (options.deflate) {
  	      deflatedData = options.deflate(xml);
  	      if (deflatedData.length < xml.length) {
  	        metadata = deflatedData;
  	      } else {
  	        metadata = xml;
  	      }
  	    } else {
  	      metadata = xml;
  	    }
  	    woffHeader.metaLength = metadata.length;
  	    woffHeader.metaOrigLength = xml.length;
  	    woffHeader.metaOffset = woffSize;
  	    // metadata header + length
  	    woffSize += woffHeader.metaLength + (woffHeader.metaLength % 4 ? 4 - woffHeader.metaLength % 4 : 0);
  	  }
  	  woffHeader.numTables = tableEntries.length;
  	  woffHeader.length = woffSize;
  	  woffHeader.totalSfntSize = ttfSize;

  	  // woff
  	  var woffWriter = new _writer.default(new ArrayBuffer(woffSize));

  	  // woff
  	  woffWriter.writeUint32(woffHeader.signature);
  	  woffWriter.writeUint32(woffHeader.flavor);
  	  woffWriter.writeUint32(woffHeader.length);
  	  woffWriter.writeUint16(woffHeader.numTables);
  	  woffWriter.writeUint16(woffHeader.reserved);
  	  woffWriter.writeUint32(woffHeader.totalSfntSize);
  	  woffWriter.writeUint16(woffHeader.majorVersion);
  	  woffWriter.writeUint16(woffHeader.minorVersion);
  	  woffWriter.writeUint32(woffHeader.metaOffset);
  	  woffWriter.writeUint32(woffHeader.metaLength);
  	  woffWriter.writeUint32(woffHeader.metaOrigLength);
  	  woffWriter.writeUint32(woffHeader.privOffset);
  	  woffWriter.writeUint32(woffHeader.privLength);

  	  // woff
  	  for (i = 0, l = tableEntries.length; i < l; ++i) {
  	    tableEntry = tableEntries[i];
  	    woffWriter.writeString(tableEntry.tag);
  	    woffWriter.writeUint32(tableEntry.offset);
  	    woffWriter.writeUint32(tableEntry.compLength);
  	    woffWriter.writeUint32(tableEntry.length);
  	    woffWriter.writeUint32(tableEntry.checkSum);
  	  }

  	  // 
  	  for (i = 0, l = tableEntries.length; i < l; ++i) {
  	    tableEntry = tableEntries[i];
  	    woffWriter.writeBytes(tableEntry.data);
  	    if (tableEntry.compLength % 4) {
  	      woffWriter.writeEmpty(4 - tableEntry.compLength % 4);
  	    }
  	  }

  	  // metadata
  	  if (metadata) {
  	    woffWriter.writeBytes(metadata);
  	    if (woffHeader.metaLength % 4) {
  	      woffWriter.writeEmpty(4 - woffHeader.metaLength % 4);
  	    }
  	  }
  	  return woffWriter.getBuffer();
  	}
  	return ttf2woff;
  }

  var ttf2svg = {};

  var contours2svg = {};

  var contour2svg = {};

  var hasRequiredContour2svg;

  function requireContour2svg () {
  	if (hasRequiredContour2svg) return contour2svg;
  	hasRequiredContour2svg = 1;

  	Object.defineProperty(contour2svg, "__esModule", {
  	  value: true
  	});
  	contour2svg.default = contour2svg$1;
  	/**
  	 * @file ttfsvg`d`
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * svg
  	 *
  	 * @param {Array} contour 
  	 * @param {number} precision 
  	 * @return {string} 
  	 */
  	function contour2svg$1(contour) {
  	  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  	  if (!contour.length) {
  	    return '';
  	  }
  	  var ceil = function ceil(number) {
  	    return +number.toFixed(precision);
  	  };
  	  var pathArr = [];
  	  var curPoint;
  	  var prevPoint;
  	  var nextPoint;
  	  var x; // x
  	  var y; // y
  	  for (var i = 0, l = contour.length; i < l; i++) {
  	    curPoint = contour[i];
  	    prevPoint = i === 0 ? contour[l - 1] : contour[i - 1];
  	    nextPoint = i === l - 1 ? contour[0] : contour[i + 1];

  	    // 
  	    if (i === 0) {
  	      if (curPoint.onCurve) {
  	        x = curPoint.x;
  	        y = curPoint.y;
  	        pathArr.push('M' + ceil(x) + ' ' + ceil(y));
  	      } else if (prevPoint.onCurve) {
  	        x = prevPoint.x;
  	        y = prevPoint.y;
  	        pathArr.push('M' + ceil(x) + ' ' + ceil(y));
  	      } else {
  	        x = (prevPoint.x + curPoint.x) / 2;
  	        y = (prevPoint.y + curPoint.y) / 2;
  	        pathArr.push('M' + ceil(x) + ' ' + ceil(y));
  	      }
  	    }

  	    // 
  	    if (curPoint.onCurve && nextPoint.onCurve) {
  	      pathArr.push('l' + ceil(nextPoint.x - x) + ' ' + ceil(nextPoint.y - y));
  	      x = nextPoint.x;
  	      y = nextPoint.y;
  	    } else if (!curPoint.onCurve) {
  	      if (nextPoint.onCurve) {
  	        pathArr.push('q' + ceil(curPoint.x - x) + ' ' + ceil(curPoint.y - y) + ' ' + ceil(nextPoint.x - x) + ' ' + ceil(nextPoint.y - y));
  	        x = nextPoint.x;
  	        y = nextPoint.y;
  	      } else {
  	        var x1 = (curPoint.x + nextPoint.x) / 2;
  	        var y1 = (curPoint.y + nextPoint.y) / 2;
  	        pathArr.push('q' + ceil(curPoint.x - x) + ' ' + ceil(curPoint.y - y) + ' ' + ceil(x1 - x) + ' ' + ceil(y1 - y));
  	        x = x1;
  	        y = y1;
  	      }
  	    }
  	  }
  	  pathArr.push('Z');
  	  return pathArr.join(' ');
  	}
  	return contour2svg;
  }

  var hasRequiredContours2svg;

  function requireContours2svg () {
  	if (hasRequiredContours2svg) return contours2svg;
  	hasRequiredContours2svg = 1;

  	Object.defineProperty(contours2svg, "__esModule", {
  	  value: true
  	});
  	contours2svg.default = contours2svg$1;
  	var _contour2svg = _interopRequireDefault(requireContour2svg());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttfsvg`d`
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * contourssvgpath
  	 *
  	 * @param {Array} contours list
  	 * @param {number} precision 
  	 * @return {string} path
  	 */
  	function contours2svg$1(contours, precision) {
  	  if (!contours.length) {
  	    return '';
  	  }
  	  return contours.map(function (contour) {
  	    return (0, _contour2svg.default)(contour, precision);
  	  }).join('');
  	}
  	return contours2svg;
  }

  var unicode2xml = {};

  var hasRequiredUnicode2xml;

  function requireUnicode2xml () {
  	if (hasRequiredUnicode2xml) return unicode2xml;
  	hasRequiredUnicode2xml = 1;

  	Object.defineProperty(unicode2xml, "__esModule", {
  	  value: true
  	});
  	unicode2xml.default = unicode2xml$1;
  	var _string = _interopRequireDefault(requireString());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file unicodexml
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * unicode xml
  	 *
  	 * @param {Array.<number>} unicodeList unicode
  	 * @return {string} xml
  	 */
  	function unicode2xml$1(unicodeList) {
  	  if (typeof unicodeList === 'number') {
  	    unicodeList = [unicodeList];
  	  }
  	  return unicodeList.map(function (u) {
  	    if (u < 0x20) {
  	      return '';
  	    }
  	    return u >= 0x20 && u <= 255 ? _string.default.encodeHTML(String.fromCharCode(u)) : '&#x' + u.toString(16) + ';';
  	  }).join('');
  	}
  	return unicode2xml;
  }

  var hasRequiredTtf2svg;

  function requireTtf2svg () {
  	if (hasRequiredTtf2svg) return ttf2svg;
  	hasRequiredTtf2svg = 1;

  	Object.defineProperty(ttf2svg, "__esModule", {
  	  value: true
  	});
  	ttf2svg.default = ttf2svg$1;
  	var _string = _interopRequireDefault(requireString());
  	var _string2 = _interopRequireDefault(requireString$1());
  	var _ttfreader = _interopRequireDefault(requireTtfreader());
  	var _contours2svg = _interopRequireDefault(requireContours2svg());
  	var _unicode2xml = _interopRequireDefault(requireUnicode2xml());
  	var _error = _interopRequireDefault(requireError());
  	var _default = _interopRequireDefault(require_default());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttfsvg
  	 * @author mengke01(kekee000@gmail.com)
  	 *
  	 * references:
  	 * http://www.w3.org/TR/SVG11/fonts.html
  	 */

  	// svg font id
  	var SVG_FONT_ID = _default.default.fontId;

  	// xml 
  	/* eslint-disable no-multi-spaces */
  	var XML_TPL = '' + '<?xml version="1.0" standalone="no"?>' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" >' + '<svg xmlns="http://www.w3.org/2000/svg">' + '<metadata>${metadata}</metadata>' + '<defs><font id="${id}" horiz-adv-x="${advanceWidth}">' + '<font-face font-family="${fontFamily}" font-weight="${fontWeight}" font-stretch="normal"' + ' units-per-em="${unitsPerEm}" panose-1="${panose}" ascent="${ascent}" descent="${descent}"' + ' x-height="${xHeight}" bbox="${bbox}" underline-thickness="${underlineThickness}"' + ' underline-position="${underlinePosition}" unicode-range="${unicodeRange}" />' + '<missing-glyph horiz-adv-x="${missing.advanceWidth}" ${missing.d} />' + '${glyphList}' + '</font></defs>' + '</svg>';
  	/* eslint-enable no-multi-spaces */
  	// glyph 
  	var GLYPH_TPL = '<glyph glyph-name="${name}" unicode="${unicode}" d="${d}" />';

  	/**
  	 * ttfsvg
  	 *
  	 * @param {ttfObject} ttf ttfObject
  	 * @param {Object} options 
  	 * @param {string} options.metadata 
  	 * @return {string} svg
  	 */
  	function ttfobject2svg(ttf, options) {
  	  var OS2 = ttf['OS/2'];

  	  // xml
  	  var xmlObject = {
  	    id: ttf.name.uniqueSubFamily || SVG_FONT_ID,
  	    metadata: _string.default.encodeHTML(options.metadata || ''),
  	    advanceWidth: ttf.hhea.advanceWidthMax,
  	    fontFamily: ttf.name.fontFamily,
  	    fontWeight: OS2.usWeightClass,
  	    unitsPerEm: ttf.head.unitsPerEm,
  	    panose: [OS2.bFamilyType, OS2.bSerifStyle, OS2.bWeight, OS2.bProportion, OS2.bContrast, OS2.bStrokeVariation, OS2.bArmStyle, OS2.bLetterform, OS2.bMidline, OS2.bXHeight].join(' '),
  	    ascent: ttf.hhea.ascent,
  	    descent: ttf.hhea.descent,
  	    xHeight: OS2.bXHeight,
  	    bbox: [ttf.head.xMin, ttf.head.yMin, ttf.head.xMax, ttf.head.yMax].join(' '),
  	    underlineThickness: ttf.post.underlineThickness,
  	    underlinePosition: ttf.post.underlinePosition,
  	    unicodeRange: 'U+' + _string.default.pad(OS2.usFirstCharIndex.toString(16), 4) + '-' + _string.default.pad(OS2.usLastCharIndex.toString(16), 4)
  	  };

  	  // glyf missing glyph
  	  xmlObject.missing = {};
  	  xmlObject.missing.advanceWidth = ttf.glyf[0].advanceWidth || 0;
  	  xmlObject.missing.d = ttf.glyf[0].contours && ttf.glyf[0].contours.length ? 'd="' + (0, _contours2svg.default)(ttf.glyf[0].contours) + '"' : '';

  	  // glyf 
  	  var glyphList = '';
  	  for (var i = 1, l = ttf.glyf.length; i < l; i++) {
  	    var glyf = ttf.glyf[i];

  	    // 
  	    if (!glyf.compound && glyf.contours && glyf.unicode && glyf.unicode.length) {
  	      var glyfObject = {
  	        name: _string2.default.escape(glyf.name),
  	        unicode: (0, _unicode2xml.default)(glyf.unicode),
  	        d: (0, _contours2svg.default)(glyf.contours)
  	      };
  	      glyphList += _string.default.format(GLYPH_TPL, glyfObject);
  	    }
  	  }
  	  xmlObject.glyphList = glyphList;
  	  return _string.default.format(XML_TPL, xmlObject);
  	}

  	/**
  	 * ttfsvg
  	 *
  	 * @param {ArrayBuffer|ttfObject} ttfBuffer ttfttfObject
  	 * @param {Object} options 
  	 * @param {Object} options.metadata 
  	 *
  	 * @return {string} svg
  	 */
  	function ttf2svg$1(ttfBuffer) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  // ttf
  	  if (ttfBuffer instanceof ArrayBuffer) {
  	    var reader = new _ttfreader.default();
  	    var ttfObject = reader.read(ttfBuffer);
  	    reader.dispose();
  	    return ttfobject2svg(ttfObject, options);
  	  }
  	  // ttfObject
  	  else if (ttfBuffer.version && ttfBuffer.glyf) {
  	    return ttfobject2svg(ttfBuffer, options);
  	  }
  	  _error.default.raise(10109);
  	}
  	return ttf2svg;
  }

  var ttf2symbol = {};

  var hasRequiredTtf2symbol;

  function requireTtf2symbol () {
  	if (hasRequiredTtf2symbol) return ttf2symbol;
  	hasRequiredTtf2symbol = 1;

  	Object.defineProperty(ttf2symbol, "__esModule", {
  	  value: true
  	});
  	ttf2symbol.default = ttf2symbol$1;
  	ttf2symbol.getSymbolId = getSymbolId;
  	var _string = _interopRequireDefault(requireString());
  	var _ttfreader = _interopRequireDefault(requireTtfreader());
  	var _contours2svg = _interopRequireDefault(requireContours2svg());
  	var _pathsUtil = _interopRequireDefault(requirePathsUtil());
  	var _error = _interopRequireDefault(requireError());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf  svg symbol
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	// xml 
  	var XML_TPL = '' + '<svg style="position: absolute; width: 0; height: 0;" width="0" height="0" version="1.1"' + ' xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + '<defs>${symbolList}</defs>' + '</svg>';

  	// symbol 
  	var SYMBOL_TPL = '' + '<symbol id="${id}" viewBox="0 ${descent} ${unitsPerEm} ${unitsPerEm}">' + '<path d="${d}"></path>' + '</symbol>';

  	/**
  	 *  glyf  symbo 
  	 * 1.  `name`  name 
  	 * 2.  `unicode`  unicode : 'uni' + unicode
  	 * 3.  id: 'symbol' + index
  	 *
  	 * @param  {Object} glyf  glyf 
  	 * @param  {number} index glyf 
  	 * @return {string}
  	 */
  	function getSymbolId(glyf, index) {
  	  if (glyf.name) {
  	    return glyf.name;
  	  }
  	  if (glyf.unicode && glyf.unicode.length) {
  	    return 'uni-' + glyf.unicode[0];
  	  }
  	  return 'symbol-' + index;
  	}

  	/**
  	 * ttfsvg
  	 *
  	 * @param {ttfObject} ttf ttfObject
  	 * @param {Object} options 
  	 * @param {Object} options.metadata 
  	 * @return {string} svg
  	 */
  	// eslint-disable-next-line no-unused-vars
  	function ttfobject2symbol(ttf) {
  	  var xmlObject = {};
  	  var unitsPerEm = ttf.head.unitsPerEm;
  	  var descent = ttf.hhea.descent;
  	  // glyf 
  	  var symbolList = '';
  	  for (var i = 1, l = ttf.glyf.length; i < l; i++) {
  	    var glyf = ttf.glyf[i];
  	    // 
  	    if (!glyf.compound && glyf.contours) {
  	      var contours = _pathsUtil.default.flip(glyf.contours);
  	      var glyfObject = {
  	        descent: descent,
  	        unitsPerEm: unitsPerEm,
  	        id: getSymbolId(glyf, i),
  	        d: (0, _contours2svg.default)(contours)
  	      };
  	      symbolList += _string.default.format(SYMBOL_TPL, glyfObject);
  	    }
  	  }
  	  xmlObject.symbolList = symbolList;
  	  return _string.default.format(XML_TPL, xmlObject);
  	}

  	/**
  	 * ttfsvg
  	 *
  	 * @param {ArrayBuffer|ttfObject} ttfBuffer ttfttfObject
  	 * @param {Object} options 
  	 * @param {Object} options.metadata 
  	 *
  	 * @return {string} svg
  	 */
  	function ttf2symbol$1(ttfBuffer) {
  	  // ttf
  	  if (ttfBuffer instanceof ArrayBuffer) {
  	    var reader = new _ttfreader.default();
  	    var ttfObject = reader.read(ttfBuffer);
  	    reader.dispose();
  	    return ttfobject2symbol(ttfObject);
  	  }
  	  // ttfObject
  	  else if (ttfBuffer.version && ttfBuffer.glyf) {
  	    return ttfobject2symbol(ttfBuffer);
  	  }
  	  _error.default.raise(10112);
  	}
  	return ttf2symbol;
  }

  var ttftowoff2 = {};

  var __dirname$1 = '/Contributions/dom-to-pptx';

  var __dirname = '/Contributions/dom-to-pptx';

  var woff2$1 = {exports: {}};

  woff2$1.exports;

  var hasRequiredWoff2$1;

  function requireWoff2$1 () {
  	if (hasRequiredWoff2$1) return woff2$1.exports;
  	hasRequiredWoff2$1 = 1;
  	(function (module, exports) {
  		var Module = (function() {
  		  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  		  return (
  		function(Module) {
  		  Module = Module || {};
  var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key];}}var quit_=function(status,toThrow){throw toThrow};var ENVIRONMENT_IS_WEB=false;var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=false;var ENVIRONMENT_HAS_NODE=false;var ENVIRONMENT_IS_SHELL=false;ENVIRONMENT_IS_WEB=typeof window==="object";ENVIRONMENT_IS_WORKER=typeof importScripts==="function";ENVIRONMENT_HAS_NODE=typeof browser$1==="object"&&typeof browser$1.versions==="object"&&typeof browser$1.versions.node==="string";ENVIRONMENT_IS_NODE=ENVIRONMENT_HAS_NODE&&!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;if(Module["ENVIRONMENT"]){throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)")}var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readBinary;if(ENVIRONMENT_IS_NODE){scriptDirectory=__dirname+"/";var nodeFS;var nodePath;read_=function shell_read(filename,binary){var ret;if(!nodeFS)nodeFS=commonjsRequire(["fs"].join());if(!nodePath)nodePath=commonjsRequire(["path"].join());filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename);return binary?ret:ret.toString()};readBinary=function readBinary(filename){var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret);}assert(ret.buffer);return ret};if(browser$1["argv"].length>1){browser$1["argv"][1].replace(/\\/g,"/");}browser$1["argv"].slice(2);browser$1["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});browser$1["on"]("unhandledRejection",abort);quit_=function(status){browser$1["exit"](status);};Module["inspect"]=function(){return "[Emscripten Module object]"};}else if(ENVIRONMENT_IS_SHELL){if(typeof read!="undefined"){read_=function shell_read(f){return read(f)};}readBinary=function readBinary(f){var data;if(typeof readbuffer==="function"){return new Uint8Array(readbuffer(f))}data=read(f,"binary");assert(typeof data==="object");return data};if(typeof scriptArgs!="undefined"){scriptArgs;}if(typeof quit==="function"){quit_=function(status){quit(status);};}if(typeof print!=="undefined"){if(typeof console==="undefined")console={};console.log=print;console.warn=console.error=typeof printErr!=="undefined"?printErr:print;}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href;}else if(document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.lastIndexOf("/")+1);}else {scriptDirectory="";}read_=function shell_read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=function readBinary(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)};}}else {throw new Error("environment detection error")}var out=Module["print"]||function(){};var err=Module["printErr"]||function(){};for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key];}}moduleOverrides=null;if(Module["arguments"])Module["arguments"];if(!Object.getOwnPropertyDescriptor(Module,"arguments"))Object.defineProperty(Module,"arguments",{configurable:true,get:function(){abort("Module.arguments has been replaced with plain arguments_");}});if(Module["thisProgram"])Module["thisProgram"];if(!Object.getOwnPropertyDescriptor(Module,"thisProgram"))Object.defineProperty(Module,"thisProgram",{configurable:true,get:function(){abort("Module.thisProgram has been replaced with plain thisProgram");}});if(Module["quit"])quit_=Module["quit"];if(!Object.getOwnPropertyDescriptor(Module,"quit"))Object.defineProperty(Module,"quit",{configurable:true,get:function(){abort("Module.quit has been replaced with plain quit_");}});assert(typeof Module["memoryInitializerPrefixURL"]==="undefined","Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["pthreadMainPrefixURL"]==="undefined","Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["cdInitializerPrefixURL"]==="undefined","Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["filePackagePrefixURL"]==="undefined","Module.filePackagePrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["read"]==="undefined","Module.read option was removed (modify read_ in JS)");assert(typeof Module["readAsync"]==="undefined","Module.readAsync option was removed (modify readAsync in JS)");assert(typeof Module["readBinary"]==="undefined","Module.readBinary option was removed (modify readBinary in JS)");assert(typeof Module["setWindowTitle"]==="undefined","Module.setWindowTitle option was removed (modify setWindowTitle in JS)");if(!Object.getOwnPropertyDescriptor(Module,"read"))Object.defineProperty(Module,"read",{configurable:true,get:function(){abort("Module.read has been replaced with plain read_");}});if(!Object.getOwnPropertyDescriptor(Module,"readAsync"))Object.defineProperty(Module,"readAsync",{configurable:true,get:function(){abort("Module.readAsync has been replaced with plain readAsync");}});if(!Object.getOwnPropertyDescriptor(Module,"readBinary"))Object.defineProperty(Module,"readBinary",{configurable:true,get:function(){abort("Module.readBinary has been replaced with plain readBinary");}});stackSave=stackRestore=stackAlloc=function(){abort("cannot use the stack before compiled code is ready to run, and has provided stack access");};function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text);}}var asm2wasmImports={"f64-rem":function(x,y){return x%y},"debugger":function(){debugger}};new Array(0);var setTempRet0=function(value){};var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];if(!Object.getOwnPropertyDescriptor(Module,"wasmBinary"))Object.defineProperty(Module,"wasmBinary",{configurable:true,get:function(){abort("Module.wasmBinary has been replaced with plain wasmBinary");}});var noExitRuntime;if(Module["noExitRuntime"])noExitRuntime=Module["noExitRuntime"];if(!Object.getOwnPropertyDescriptor(Module,"noExitRuntime"))Object.defineProperty(Module,"noExitRuntime",{configurable:true,get:function(){abort("Module.noExitRuntime has been replaced with plain noExitRuntime");}});if(typeof WebAssembly!=="object"){abort("No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.");}var wasmMemory;var wasmTable=new WebAssembly.Table({"initial":352,"maximum":352,"element":"anyfunc"});var ABORT=false;function assert(condition,text){if(!condition){abort("Assertion failed: "+text);}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len);}return ret},"array":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string")return UTF8ToString(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;assert(returnType!=="array",'Return type should not be "array".');if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i]);}else {cArgs[i]=args[i];}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}function cwrap(ident,returnType,argTypes,opts){return function(){return ccall(ident,returnType,argTypes,arguments)}}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else {var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {if((u0&248)!=240)warnOnce("Invalid UTF-8 leading byte 0x"+u0.toString(16)+" encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!");u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;if(u>=2097152)warnOnce("Invalid Unicode code point 0x"+u.toString(16)+" encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).");outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63;}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){assert(typeof maxBytesToWrite=="number","stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4;}return len}typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function writeArrayToMemory(array,buffer){assert(array.length>=0,"writeArrayToMemory array must have a length (should be an array or typed array)");HEAP8.set(array,buffer);}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple;}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf);}var STACK_BASE=434112,STACK_MAX=5676992,DYNAMIC_BASE=5676992,DYNAMICTOP_PTR=433920;assert(STACK_BASE%16===0,"stack must start aligned");assert(DYNAMIC_BASE%16===0,"heap must start aligned");var TOTAL_STACK=5242880;if(Module["TOTAL_STACK"])assert(TOTAL_STACK===Module["TOTAL_STACK"],"the stack size can no longer be determined at runtime");var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(!Object.getOwnPropertyDescriptor(Module,"TOTAL_MEMORY"))Object.defineProperty(Module,"TOTAL_MEMORY",{configurable:true,get:function(){abort("Module.TOTAL_MEMORY has been replaced with plain INITIAL_TOTAL_MEMORY");}});assert(INITIAL_TOTAL_MEMORY>=TOTAL_STACK,"TOTAL_MEMORY should be larger than TOTAL_STACK, was "+INITIAL_TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&Int32Array.prototype.subarray!==undefined&&Int32Array.prototype.set!==undefined,"JS engine does not provide full typed array support");if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else {wasmMemory=new WebAssembly.Memory({"initial":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE});}if(wasmMemory){buffer=wasmMemory.buffer;}INITIAL_TOTAL_MEMORY=buffer.byteLength;assert(INITIAL_TOTAL_MEMORY%WASM_PAGE_SIZE===0);updateGlobalBufferAndViews(buffer);HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function writeStackCookie(){assert((STACK_MAX&3)==0);HEAPU32[(STACK_MAX>>2)-1]=34821223;HEAPU32[(STACK_MAX>>2)-2]=2310721022;HEAP32[0]=1668509029;}function checkStackCookie(){var cookie1=HEAPU32[(STACK_MAX>>2)-1];var cookie2=HEAPU32[(STACK_MAX>>2)-2];if(cookie1!=34821223||cookie2!=2310721022){abort("Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x"+cookie2.toString(16)+" "+cookie1.toString(16));}if(HEAP32[0]!==1668509029)abort("Runtime error: The application has corrupted its heap memory area (address zero)!");}function abortStackOverflow(allocSize){abort("Stack overflow! Attempted to allocate "+allocSize+" bytes on the stack, but stack has only "+(STACK_MAX-stackSave()+allocSize)+" bytes available!");}(function(){var h16=new Int16Array(1);var h8=new Int8Array(h16.buffer);h16[0]=25459;if(h8[0]!==115||h8[1]!==99)throw "Runtime error: expected the system to be little-endian!"})();function abortFnPtrError(ptr,sig){abort("Invalid function pointer "+ptr+" called with signature '"+sig+"'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). Build with ASSERTIONS=2 for more info.");}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func);}else {Module["dynCall_vi"](func,callback.arg);}}else {func(callback.arg===undefined?null:callback.arg);}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){checkStackCookie();assert(!runtimeInitialized);runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__);}function preMain(){checkStackCookie();callRuntimeCallbacks(__ATMAIN__);}function exitRuntime(){checkStackCookie();runtimeExited=true;}function postRun(){checkStackCookie();if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}assert(Math.imul,"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.fround,"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.clz32,"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.trunc,"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;var runDependencyTracking={};function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(id){assert(!runDependencyTracking[id]);runDependencyTracking[id]=1;if(runDependencyWatcher===null&&typeof setInterval!=="undefined"){runDependencyWatcher=setInterval(function(){if(ABORT){clearInterval(runDependencyWatcher);runDependencyWatcher=null;return}var shown=false;for(var dep in runDependencyTracking){if(!shown){shown=true;err("still waiting on run dependencies:");}err("dependency: "+dep);}if(shown){err("(end of list)");}},1e4);}}else {err("warning: run dependency added without ID");}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(id){assert(runDependencyTracking[id]);delete runDependencyTracking[id];}else {err("warning: run dependency removed without ID");}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null;}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what+="";out(what);err(what);ABORT=true;var extra="";var output="abort("+what+") at "+stackTrace()+extra;throw output}var FS={error:function(){abort("Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1");},init:function(){FS.error();},createDataFile:function(){FS.error();},createPreloadedFile:function(){FS.error();},createLazyFile:function(){FS.error();},open:function(){FS.error();},mkdev:function(){FS.error();},registerDevice:function(){FS.error();},analyzePath:function(){FS.error();},loadFilesFromDB:function(){FS.error();},ErrnoError:function ErrnoError(){FS.error();}};Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile="woff2.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(){try{if(wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(wasmBinaryFile)}else {throw "both async and sync fetching of the wasm failed"}}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)&&typeof fetch==="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary()})}return new Promise(function(resolve,reject){resolve(getBinary());})}function createWasm(){var info={"env":asmLibraryArg,"wasi_unstable":asmLibraryArg,"global":{"NaN":NaN,Infinity:Infinity},"global.Math":Math,"asm2wasm":asm2wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;removeRunDependency("wasm-instantiate");}addRunDependency("wasm-instantiate");var trueModule=Module;function receiveInstantiatedSource(output){assert(Module===trueModule,"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");trueModule=null;receiveInstance(output["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming==="function"&&!isDataURI(wasmBinaryFile)&&typeof fetch==="function"&&typeof browser$1==="object"&&browser$1.versions&&browser$1.versions.node&&+browser$1.versions.node.split('.')[0]<17){fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiatedSource,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");instantiateArrayBuffer(receiveInstantiatedSource);})});}else {return instantiateArrayBuffer(receiveInstantiatedSource)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync();return {}}Module["asm"]=createWasm;__ATINIT__.push({func:function(){globalCtors();}});var tempDoublePtr=434096;assert(tempDoublePtr%8==0);function demangle(func){var __cxa_demangle_func=Module["___cxa_demangle"]||Module["__cxa_demangle"];assert(__cxa_demangle_func);try{var s=func;if(s.startsWith("__Z"))s=s.substr(1);var len=lengthBytesUTF8(s)+1;var buf=_malloc(len);stringToUTF8(s,buf,len);var status=_malloc(4);var ret=__cxa_demangle_func(buf,0,0,status);if(HEAP32[status>>2]===0&&ret){return UTF8ToString(ret)}}catch(e){}finally{if(buf)_free(buf);if(status)_free(status);if(ret)_free(ret);}return func}function demangleAll(text){var regex=/\b__Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e;}if(!err.stack){return "(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}function ___assert_fail(condition,filename,line,func){abort("Assertion failed: "+UTF8ToString(condition)+", at: "+[filename?UTF8ToString(filename):"unknown filename",line,func?UTF8ToString(func):"unknown function"]);}function ___cxa_allocate_exception(size){return _malloc(size)}function ___cxa_throw(ptr,type,destructor){if(!("uncaught_exception"in __ZSt18uncaught_exceptionv)){__ZSt18uncaught_exceptionv.uncaught_exceptions=1;}else {__ZSt18uncaught_exceptionv.uncaught_exceptions++;}throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch."}function ___lock(){}function ___unlock(){}var SYSCALLS={buffers:[null,[],[]],printChar:function(stream,curr){var buffer=SYSCALLS.buffers[stream];assert(buffer);if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0;}else {buffer.push(curr);}},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low},getZero:function(){assert(SYSCALLS.get()===0);}};function _fd_close(fd){try{abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function ___wasi_fd_close(){return _fd_close.apply(null,arguments)}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function ___wasi_fd_seek(){return _fd_seek.apply(null,arguments)}function flush_NO_FILESYSTEM(){var fflush=Module["_fflush"];if(fflush)fflush(0);var buffers=SYSCALLS.buffers;if(buffers[1].length)SYSCALLS.printChar(1,10);if(buffers[2].length)SYSCALLS.printChar(2,10);}function _fd_write(fd,iov,iovcnt,pnum){try{var num=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];for(var j=0;j<len;j++){SYSCALLS.printChar(fd,HEAPU8[ptr+j]);}num+=len;}HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return e.errno}}function ___wasi_fd_write(){return _fd_write.apply(null,arguments)}function getShiftFromSize(size){switch(size){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+size)}}function embind_init_charCodes(){var codes=new Array(256);for(var i=0;i<256;++i){codes[i]=String.fromCharCode(i);}embind_charCodes=codes;}var embind_charCodes=undefined;function readLatin1String(ptr){var ret="";var c=ptr;while(HEAPU8[c]){ret+=embind_charCodes[HEAPU8[c++]];}return ret}var awaitingDependencies={};var registeredTypes={};var typeDependencies={};var char_0=48;var char_9=57;function makeLegalFunctionName(name){if(undefined===name){return "_unknown"}name=name.replace(/[^a-zA-Z0-9_]/g,"$");var f=name.charCodeAt(0);if(f>=char_0&&f<=char_9){return "_"+name}else {return name}}function createNamedFunction(name,body){name=makeLegalFunctionName(name);return new Function("body","return function "+name+"() {\n"+'    "use strict";'+"    return body.apply(this, arguments);\n"+"};\n")(body)}function extendError(baseErrorType,errorName){var errorClass=createNamedFunction(errorName,function(message){this.name=errorName;this.message=message;var stack=new Error(message).stack;if(stack!==undefined){this.stack=this.toString()+"\n"+stack.replace(/^Error(:[^\n]*)?\n/,"");}});errorClass.prototype=Object.create(baseErrorType.prototype);errorClass.prototype.constructor=errorClass;errorClass.prototype.toString=function(){if(this.message===undefined){return this.name}else {return this.name+": "+this.message}};return errorClass}var BindingError=undefined;function throwBindingError(message){throw new BindingError(message)}var InternalError=undefined;function throwInternalError(message){throw new InternalError(message)}function whenDependentTypesAreResolved(myTypes,dependentTypes,getTypeConverters){myTypes.forEach(function(type){typeDependencies[type]=dependentTypes;});function onComplete(typeConverters){var myTypeConverters=getTypeConverters(typeConverters);if(myTypeConverters.length!==myTypes.length){throwInternalError("Mismatched type converter count");}for(var i=0;i<myTypes.length;++i){registerType(myTypes[i],myTypeConverters[i]);}}var typeConverters=new Array(dependentTypes.length);var unregisteredTypes=[];var registered=0;dependentTypes.forEach(function(dt,i){if(registeredTypes.hasOwnProperty(dt)){typeConverters[i]=registeredTypes[dt];}else {unregisteredTypes.push(dt);if(!awaitingDependencies.hasOwnProperty(dt)){awaitingDependencies[dt]=[];}awaitingDependencies[dt].push(function(){typeConverters[i]=registeredTypes[dt];++registered;if(registered===unregisteredTypes.length){onComplete(typeConverters);}});}});if(0===unregisteredTypes.length){onComplete(typeConverters);}}function registerType(rawType,registeredInstance,options){options=options||{};if(!("argPackAdvance"in registeredInstance)){throw new TypeError("registerType registeredInstance requires argPackAdvance")}var name=registeredInstance.name;if(!rawType){throwBindingError('type "'+name+'" must have a positive integer typeid pointer');}if(registeredTypes.hasOwnProperty(rawType)){if(options.ignoreDuplicateRegistrations){return}else {throwBindingError("Cannot register type '"+name+"' twice");}}registeredTypes[rawType]=registeredInstance;delete typeDependencies[rawType];if(awaitingDependencies.hasOwnProperty(rawType)){var callbacks=awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(function(cb){cb();});}}function __embind_register_bool(rawType,name,size,trueValue,falseValue){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(wt){return !!wt},"toWireType":function(destructors,o){return o?trueValue:falseValue},"argPackAdvance":8,"readValueFromPointer":function(pointer){var heap;if(size===1){heap=HEAP8;}else if(size===2){heap=HEAP16;}else if(size===4){heap=HEAP32;}else {throw new TypeError("Unknown boolean type size: "+name)}return this["fromWireType"](heap[pointer>>shift])},destructorFunction:null});}function ClassHandle_isAliasOf(other){if(!(this instanceof ClassHandle)){return false}if(!(other instanceof ClassHandle)){return false}var leftClass=this.$$.ptrType.registeredClass;var left=this.$$.ptr;var rightClass=other.$$.ptrType.registeredClass;var right=other.$$.ptr;while(leftClass.baseClass){left=leftClass.upcast(left);leftClass=leftClass.baseClass;}while(rightClass.baseClass){right=rightClass.upcast(right);rightClass=rightClass.baseClass;}return leftClass===rightClass&&left===right}function shallowCopyInternalPointer(o){return {count:o.count,deleteScheduled:o.deleteScheduled,preservePointerOnDelete:o.preservePointerOnDelete,ptr:o.ptr,ptrType:o.ptrType,smartPtr:o.smartPtr,smartPtrType:o.smartPtrType}}function throwInstanceAlreadyDeleted(obj){function getInstanceTypeName(handle){return handle.$$.ptrType.registeredClass.name}throwBindingError(getInstanceTypeName(obj)+" instance already deleted");}var finalizationGroup=false;function detachFinalizer(handle){}function runDestructor($$){if($$.smartPtr){$$.smartPtrType.rawDestructor($$.smartPtr);}else {$$.ptrType.registeredClass.rawDestructor($$.ptr);}}function releaseClassHandle($$){$$.count.value-=1;var toDelete=0===$$.count.value;if(toDelete){runDestructor($$);}}function attachFinalizer(handle){if("undefined"===typeof FinalizationGroup){attachFinalizer=function(handle){return handle};return handle}finalizationGroup=new FinalizationGroup(function(iter){for(var result=iter.next();!result.done;result=iter.next()){var $$=result.value;if(!$$.ptr){console.warn("object already deleted: "+$$.ptr);}else {releaseClassHandle($$);}}});attachFinalizer=function(handle){finalizationGroup.register(handle,handle.$$,handle.$$);return handle};detachFinalizer=function(handle){finalizationGroup.unregister(handle.$$);};return attachFinalizer(handle)}function ClassHandle_clone(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.preservePointerOnDelete){this.$$.count.value+=1;return this}else {var clone=attachFinalizer(Object.create(Object.getPrototypeOf(this),{$$:{value:shallowCopyInternalPointer(this.$$)}}));clone.$$.count.value+=1;clone.$$.deleteScheduled=false;return clone}}function ClassHandle_delete(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}detachFinalizer(this);releaseClassHandle(this.$$);if(!this.$$.preservePointerOnDelete){this.$$.smartPtr=undefined;this.$$.ptr=undefined;}}function ClassHandle_isDeleted(){return !this.$$.ptr}var delayFunction=undefined;var deletionQueue=[];function flushPendingDeletes(){while(deletionQueue.length){var obj=deletionQueue.pop();obj.$$.deleteScheduled=false;obj["delete"]();}}function ClassHandle_deleteLater(){if(!this.$$.ptr){throwInstanceAlreadyDeleted(this);}if(this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete){throwBindingError("Object already scheduled for deletion");}deletionQueue.push(this);if(deletionQueue.length===1&&delayFunction){delayFunction(flushPendingDeletes);}this.$$.deleteScheduled=true;return this}function init_ClassHandle(){ClassHandle.prototype["isAliasOf"]=ClassHandle_isAliasOf;ClassHandle.prototype["clone"]=ClassHandle_clone;ClassHandle.prototype["delete"]=ClassHandle_delete;ClassHandle.prototype["isDeleted"]=ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"]=ClassHandle_deleteLater;}function ClassHandle(){}var registeredPointers={};function ensureOverloadTable(proto,methodName,humanName){if(undefined===proto[methodName].overloadTable){var prevFunc=proto[methodName];proto[methodName]=function(){if(!proto[methodName].overloadTable.hasOwnProperty(arguments.length)){throwBindingError("Function '"+humanName+"' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+proto[methodName].overloadTable+")!");}return proto[methodName].overloadTable[arguments.length].apply(this,arguments)};proto[methodName].overloadTable=[];proto[methodName].overloadTable[prevFunc.argCount]=prevFunc;}}function exposePublicSymbol(name,value,numArguments){if(Module.hasOwnProperty(name)){if(undefined===numArguments||undefined!==Module[name].overloadTable&&undefined!==Module[name].overloadTable[numArguments]){throwBindingError("Cannot register public name '"+name+"' twice");}ensureOverloadTable(Module,name,name);if(Module.hasOwnProperty(numArguments)){throwBindingError("Cannot register multiple overloads of a function with the same number of arguments ("+numArguments+")!");}Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;if(undefined!==numArguments){Module[name].numArguments=numArguments;}}}function RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast){this.name=name;this.constructor=constructor;this.instancePrototype=instancePrototype;this.rawDestructor=rawDestructor;this.baseClass=baseClass;this.getActualType=getActualType;this.upcast=upcast;this.downcast=downcast;this.pureVirtualFunctions=[];}function upcastPointer(ptr,ptrClass,desiredClass){while(ptrClass!==desiredClass){if(!ptrClass.upcast){throwBindingError("Expected null or instance of "+desiredClass.name+", got an instance of "+ptrClass.name);}ptr=ptrClass.upcast(ptr);ptrClass=ptrClass.baseClass;}return ptr}function constNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function genericPointerToWireType(destructors,handle){var ptr;if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}if(this.isSmartPointer){ptr=this.rawConstructor();if(destructors!==null){destructors.push(this.rawDestructor,ptr);}return ptr}else {return 0}}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(!this.isConst&&handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);if(this.isSmartPointer){if(undefined===handle.$$.smartPtr){throwBindingError("Passing raw pointer to smart pointer is illegal");}switch(this.sharingPolicy){case 0:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else {throwBindingError("Cannot convert argument of type "+(handle.$$.smartPtrType?handle.$$.smartPtrType.name:handle.$$.ptrType.name)+" to parameter type "+this.name);}break;case 1:ptr=handle.$$.smartPtr;break;case 2:if(handle.$$.smartPtrType===this){ptr=handle.$$.smartPtr;}else {var clonedHandle=handle["clone"]();ptr=this.rawShare(ptr,__emval_register(function(){clonedHandle["delete"]();}));if(destructors!==null){destructors.push(this.rawDestructor,ptr);}}break;default:throwBindingError("Unsupporting sharing policy");}}return ptr}function nonConstNoSmartPtrRawPointerToWireType(destructors,handle){if(handle===null){if(this.isReference){throwBindingError("null is not a valid "+this.name);}return 0}if(!handle.$$){throwBindingError('Cannot pass "'+_embind_repr(handle)+'" as a '+this.name);}if(!handle.$$.ptr){throwBindingError("Cannot pass deleted object as a pointer of type "+this.name);}if(handle.$$.ptrType.isConst){throwBindingError("Cannot convert argument of type "+handle.$$.ptrType.name+" to parameter type "+this.name);}var handleClass=handle.$$.ptrType.registeredClass;var ptr=upcastPointer(handle.$$.ptr,handleClass,this.registeredClass);return ptr}function simpleReadValueFromPointer(pointer){return this["fromWireType"](HEAPU32[pointer>>2])}function RegisteredPointer_getPointee(ptr){if(this.rawGetPointee){ptr=this.rawGetPointee(ptr);}return ptr}function RegisteredPointer_destructor(ptr){if(this.rawDestructor){this.rawDestructor(ptr);}}function RegisteredPointer_deleteObject(handle){if(handle!==null){handle["delete"]();}}function downcastPointer(ptr,ptrClass,desiredClass){if(ptrClass===desiredClass){return ptr}if(undefined===desiredClass.baseClass){return null}var rv=downcastPointer(ptr,ptrClass,desiredClass.baseClass);if(rv===null){return null}return desiredClass.downcast(rv)}function getInheritedInstanceCount(){return Object.keys(registeredInstances).length}function getLiveInheritedInstances(){var rv=[];for(var k in registeredInstances){if(registeredInstances.hasOwnProperty(k)){rv.push(registeredInstances[k]);}}return rv}function setDelayFunction(fn){delayFunction=fn;if(deletionQueue.length&&delayFunction){delayFunction(flushPendingDeletes);}}function init_embind(){Module["getInheritedInstanceCount"]=getInheritedInstanceCount;Module["getLiveInheritedInstances"]=getLiveInheritedInstances;Module["flushPendingDeletes"]=flushPendingDeletes;Module["setDelayFunction"]=setDelayFunction;}var registeredInstances={};function getBasestPointer(class_,ptr){if(ptr===undefined){throwBindingError("ptr should not be undefined");}while(class_.baseClass){ptr=class_.upcast(ptr);class_=class_.baseClass;}return ptr}function getInheritedInstance(class_,ptr){ptr=getBasestPointer(class_,ptr);return registeredInstances[ptr]}function makeClassHandle(prototype,record){if(!record.ptrType||!record.ptr){throwInternalError("makeClassHandle requires ptr and ptrType");}var hasSmartPtrType=!!record.smartPtrType;var hasSmartPtr=!!record.smartPtr;if(hasSmartPtrType!==hasSmartPtr){throwInternalError("Both smartPtrType and smartPtr must be specified");}record.count={value:1};return attachFinalizer(Object.create(prototype,{$$:{value:record}}))}function RegisteredPointer_fromWireType(ptr){var rawPointer=this.getPointee(ptr);if(!rawPointer){this.destructor(ptr);return null}var registeredInstance=getInheritedInstance(this.registeredClass,rawPointer);if(undefined!==registeredInstance){if(0===registeredInstance.$$.count.value){registeredInstance.$$.ptr=rawPointer;registeredInstance.$$.smartPtr=ptr;return registeredInstance["clone"]()}else {var rv=registeredInstance["clone"]();this.destructor(ptr);return rv}}function makeDefaultHandle(){if(this.isSmartPointer){return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:rawPointer,smartPtrType:this,smartPtr:ptr})}else {return makeClassHandle(this.registeredClass.instancePrototype,{ptrType:this,ptr:ptr})}}var actualType=this.registeredClass.getActualType(rawPointer);var registeredPointerRecord=registeredPointers[actualType];if(!registeredPointerRecord){return makeDefaultHandle.call(this)}var toType;if(this.isConst){toType=registeredPointerRecord.constPointerType;}else {toType=registeredPointerRecord.pointerType;}var dp=downcastPointer(rawPointer,this.registeredClass,toType.registeredClass);if(dp===null){return makeDefaultHandle.call(this)}if(this.isSmartPointer){return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp,smartPtrType:this,smartPtr:ptr})}else {return makeClassHandle(toType.registeredClass.instancePrototype,{ptrType:toType,ptr:dp})}}function init_RegisteredPointer(){RegisteredPointer.prototype.getPointee=RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor=RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"]=8;RegisteredPointer.prototype["readValueFromPointer"]=simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"]=RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"]=RegisteredPointer_fromWireType;}function RegisteredPointer(name,registeredClass,isReference,isConst,isSmartPointer,pointeeType,sharingPolicy,rawGetPointee,rawConstructor,rawShare,rawDestructor){this.name=name;this.registeredClass=registeredClass;this.isReference=isReference;this.isConst=isConst;this.isSmartPointer=isSmartPointer;this.pointeeType=pointeeType;this.sharingPolicy=sharingPolicy;this.rawGetPointee=rawGetPointee;this.rawConstructor=rawConstructor;this.rawShare=rawShare;this.rawDestructor=rawDestructor;if(!isSmartPointer&&registeredClass.baseClass===undefined){if(isConst){this["toWireType"]=constNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}else {this["toWireType"]=nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction=null;}}else {this["toWireType"]=genericPointerToWireType;}}function replacePublicSymbol(name,value,numArguments){if(!Module.hasOwnProperty(name)){throwInternalError("Replacing nonexistant public symbol");}if(undefined!==Module[name].overloadTable&&undefined!==numArguments){Module[name].overloadTable[numArguments]=value;}else {Module[name]=value;Module[name].argCount=numArguments;}}function embind__requireFunction(signature,rawFunction){signature=readLatin1String(signature);function makeDynCaller(dynCall){var args=[];for(var i=1;i<signature.length;++i){args.push("a"+i);}var name="dynCall_"+signature+"_"+rawFunction;var body="return function "+name+"("+args.join(", ")+") {\n";body+="    return dynCall(rawFunction"+(args.length?", ":"")+args.join(", ")+");\n";body+="};\n";return new Function("dynCall","rawFunction",body)(dynCall,rawFunction)}var fp;if(Module["FUNCTION_TABLE_"+signature]!==undefined){fp=Module["FUNCTION_TABLE_"+signature][rawFunction];}else if(typeof FUNCTION_TABLE!=="undefined"){fp=FUNCTION_TABLE[rawFunction];}else {var dc=Module["dynCall_"+signature];if(dc===undefined){dc=Module["dynCall_"+signature.replace(/f/g,"d")];if(dc===undefined){throwBindingError("No dynCall invoker for signature: "+signature);}}fp=makeDynCaller(dc);}if(typeof fp!=="function"){throwBindingError("unknown function pointer with signature "+signature+": "+rawFunction);}return fp}var UnboundTypeError=undefined;function getTypeName(type){var ptr=___getTypeName(type);var rv=readLatin1String(ptr);_free(ptr);return rv}function throwUnboundTypeError(message,types){var unboundTypes=[];var seen={};function visit(type){if(seen[type]){return}if(registeredTypes[type]){return}if(typeDependencies[type]){typeDependencies[type].forEach(visit);return}unboundTypes.push(type);seen[type]=true;}types.forEach(visit);throw new UnboundTypeError(message+": "+unboundTypes.map(getTypeName).join([", "]))}function __embind_register_class(rawType,rawPointerType,rawConstPointerType,baseClassRawType,getActualTypeSignature,getActualType,upcastSignature,upcast,downcastSignature,downcast,name,destructorSignature,rawDestructor){name=readLatin1String(name);getActualType=embind__requireFunction(getActualTypeSignature,getActualType);if(upcast){upcast=embind__requireFunction(upcastSignature,upcast);}if(downcast){downcast=embind__requireFunction(downcastSignature,downcast);}rawDestructor=embind__requireFunction(destructorSignature,rawDestructor);var legalFunctionName=makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName,function(){throwUnboundTypeError("Cannot construct "+name+" due to unbound types",[baseClassRawType]);});whenDependentTypesAreResolved([rawType,rawPointerType,rawConstPointerType],baseClassRawType?[baseClassRawType]:[],function(base){base=base[0];var baseClass;var basePrototype;if(baseClassRawType){baseClass=base.registeredClass;basePrototype=baseClass.instancePrototype;}else {basePrototype=ClassHandle.prototype;}var constructor=createNamedFunction(legalFunctionName,function(){if(Object.getPrototypeOf(this)!==instancePrototype){throw new BindingError("Use 'new' to construct "+name)}if(undefined===registeredClass.constructor_body){throw new BindingError(name+" has no accessible constructor")}var body=registeredClass.constructor_body[arguments.length];if(undefined===body){throw new BindingError("Tried to invoke ctor of "+name+" with invalid number of parameters ("+arguments.length+") - expected ("+Object.keys(registeredClass.constructor_body).toString()+") parameters instead!")}return body.apply(this,arguments)});var instancePrototype=Object.create(basePrototype,{constructor:{value:constructor}});constructor.prototype=instancePrototype;var registeredClass=new RegisteredClass(name,constructor,instancePrototype,rawDestructor,baseClass,getActualType,upcast,downcast);var referenceConverter=new RegisteredPointer(name,registeredClass,true,false,false);var pointerConverter=new RegisteredPointer(name+"*",registeredClass,false,false,false);var constPointerConverter=new RegisteredPointer(name+" const*",registeredClass,false,true,false);registeredPointers[rawType]={pointerType:pointerConverter,constPointerType:constPointerConverter};replacePublicSymbol(legalFunctionName,constructor);return [referenceConverter,pointerConverter,constPointerConverter]});}function heap32VectorToArray(count,firstElement){var array=[];for(var i=0;i<count;i++){array.push(HEAP32[(firstElement>>2)+i]);}return array}function runDestructors(destructors){while(destructors.length){var ptr=destructors.pop();var del=destructors.pop();del(ptr);}}function __embind_register_class_constructor(rawClassType,argCount,rawArgTypesAddr,invokerSignature,invoker,rawConstructor){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);invoker=embind__requireFunction(invokerSignature,invoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName="constructor "+classType.name;if(undefined===classType.registeredClass.constructor_body){classType.registeredClass.constructor_body=[];}if(undefined!==classType.registeredClass.constructor_body[argCount-1]){throw new BindingError("Cannot register multiple constructors with identical number of parameters ("+(argCount-1)+") for class '"+classType.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!")}classType.registeredClass.constructor_body[argCount-1]=function unboundTypeHandler(){throwUnboundTypeError("Cannot construct "+classType.name+" due to unbound types",rawArgTypes);};whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){classType.registeredClass.constructor_body[argCount-1]=function constructor_body(){if(arguments.length!==argCount-1){throwBindingError(humanName+" called with "+arguments.length+" arguments, expected "+(argCount-1));}var destructors=[];var args=new Array(argCount);args[0]=rawConstructor;for(var i=1;i<argCount;++i){args[i]=argTypes[i]["toWireType"](destructors,arguments[i-1]);}var ptr=invoker.apply(null,args);runDestructors(destructors);return argTypes[0]["fromWireType"](ptr)};return []});return []});}function new_(constructor,argumentList){if(!(constructor instanceof Function)){throw new TypeError("new_ called with constructor type "+typeof constructor+" which is not a function")}var dummy=createNamedFunction(constructor.name||"unknownFunctionName",function(){});dummy.prototype=constructor.prototype;var obj=new dummy;var r=constructor.apply(obj,argumentList);return r instanceof Object?r:obj}function craftInvokerFunction(humanName,argTypes,classType,cppInvokerFunc,cppTargetFunc){var argCount=argTypes.length;if(argCount<2){throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");}var isClassMethodFunc=argTypes[1]!==null&&classType!==null;var needsDestructorStack=false;for(var i=1;i<argTypes.length;++i){if(argTypes[i]!==null&&argTypes[i].destructorFunction===undefined){needsDestructorStack=true;break}}var returns=argTypes[0].name!=="void";var argsList="";var argsListWired="";for(var i=0;i<argCount-2;++i){argsList+=(i!==0?", ":"")+"arg"+i;argsListWired+=(i!==0?", ":"")+"arg"+i+"Wired";}var invokerFnBody="return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n"+"if (arguments.length !== "+(argCount-2)+") {\n"+"throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount-2)+" args!');\n"+"}\n";if(needsDestructorStack){invokerFnBody+="var destructors = [];\n";}var dtorStack=needsDestructorStack?"destructors":"null";var args1=["throwBindingError","invoker","fn","runDestructors","retType","classParam"];var args2=[throwBindingError,cppInvokerFunc,cppTargetFunc,runDestructors,argTypes[0],argTypes[1]];if(isClassMethodFunc){invokerFnBody+="var thisWired = classParam.toWireType("+dtorStack+", this);\n";}for(var i=0;i<argCount-2;++i){invokerFnBody+="var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";args1.push("argType"+i);args2.push(argTypes[i+2]);}if(isClassMethodFunc){argsListWired="thisWired"+(argsListWired.length>0?", ":"")+argsListWired;}invokerFnBody+=(returns?"var rv = ":"")+"invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";if(needsDestructorStack){invokerFnBody+="runDestructors(destructors);\n";}else {for(var i=isClassMethodFunc?1:2;i<argTypes.length;++i){var paramName=i===1?"thisWired":"arg"+(i-2)+"Wired";if(argTypes[i].destructorFunction!==null){invokerFnBody+=paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";args1.push(paramName+"_dtor");args2.push(argTypes[i].destructorFunction);}}}if(returns){invokerFnBody+="var ret = retType.fromWireType(rv);\n"+"return ret;\n";}invokerFnBody+="}\n";args1.push(invokerFnBody);var invokerFunction=new_(Function,args1).apply(null,args2);return invokerFunction}function __embind_register_class_function(rawClassType,methodName,argCount,rawArgTypesAddr,invokerSignature,rawInvoker,context,isPureVirtual){var rawArgTypes=heap32VectorToArray(argCount,rawArgTypesAddr);methodName=readLatin1String(methodName);rawInvoker=embind__requireFunction(invokerSignature,rawInvoker);whenDependentTypesAreResolved([],[rawClassType],function(classType){classType=classType[0];var humanName=classType.name+"."+methodName;if(isPureVirtual){classType.registeredClass.pureVirtualFunctions.push(methodName);}function unboundTypesHandler(){throwUnboundTypeError("Cannot call "+humanName+" due to unbound types",rawArgTypes);}var proto=classType.registeredClass.instancePrototype;var method=proto[methodName];if(undefined===method||undefined===method.overloadTable&&method.className!==classType.name&&method.argCount===argCount-2){unboundTypesHandler.argCount=argCount-2;unboundTypesHandler.className=classType.name;proto[methodName]=unboundTypesHandler;}else {ensureOverloadTable(proto,methodName,humanName);proto[methodName].overloadTable[argCount-2]=unboundTypesHandler;}whenDependentTypesAreResolved([],rawArgTypes,function(argTypes){var memberFunction=craftInvokerFunction(humanName,argTypes,classType,rawInvoker,context);if(undefined===proto[methodName].overloadTable){memberFunction.argCount=argCount-2;proto[methodName]=memberFunction;}else {proto[methodName].overloadTable[argCount-2]=memberFunction;}return []});return []});}var emval_free_list=[];var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle){if(handle>4&&0===--emval_handle_array[handle].refcount){emval_handle_array[handle]=undefined;emval_free_list.push(handle);}}function count_emval_handles(){var count=0;for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){++count;}}return count}function get_first_emval(){for(var i=5;i<emval_handle_array.length;++i){if(emval_handle_array[i]!==undefined){return emval_handle_array[i]}}return null}function init_emval(){Module["count_emval_handles"]=count_emval_handles;Module["get_first_emval"]=get_first_emval;}function __emval_register(value){switch(value){case undefined:{return 1}case null:{return 2}case true:{return 3}case false:{return 4}default:{var handle=emval_free_list.length?emval_free_list.pop():emval_handle_array.length;emval_handle_array[handle]={refcount:1,value:value};return handle}}}function __embind_register_emval(rawType,name){name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(handle){var rv=emval_handle_array[handle].value;__emval_decref(handle);return rv},"toWireType":function(destructors,value){return __emval_register(value)},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:null});}function _embind_repr(v){if(v===null){return "null"}var t=typeof v;if(t==="object"||t==="array"||t==="function"){return v.toString()}else {return ""+v}}function floatReadValueFromPointer(name,shift){switch(shift){case 2:return function(pointer){return this["fromWireType"](HEAPF32[pointer>>2])};case 3:return function(pointer){return this["fromWireType"](HEAPF64[pointer>>3])};default:throw new TypeError("Unknown float type: "+name)}}function __embind_register_float(rawType,name,size){var shift=getShiftFromSize(size);name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":function(value){return value},"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}return value},"argPackAdvance":8,"readValueFromPointer":floatReadValueFromPointer(name,shift),destructorFunction:null});}function __embind_register_function(name,argCount,rawArgTypesAddr,signature,rawInvoker,fn){var argTypes=heap32VectorToArray(argCount,rawArgTypesAddr);name=readLatin1String(name);rawInvoker=embind__requireFunction(signature,rawInvoker);exposePublicSymbol(name,function(){throwUnboundTypeError("Cannot call "+name+" due to unbound types",argTypes);},argCount-1);whenDependentTypesAreResolved([],argTypes,function(argTypes){var invokerArgsArray=[argTypes[0],null].concat(argTypes.slice(1));replacePublicSymbol(name,craftInvokerFunction(name,invokerArgsArray,null,rawInvoker,fn),argCount-1);return []});}function integerReadValueFromPointer(name,shift,signed){switch(shift){case 0:return signed?function readS8FromPointer(pointer){return HEAP8[pointer]}:function readU8FromPointer(pointer){return HEAPU8[pointer]};case 1:return signed?function readS16FromPointer(pointer){return HEAP16[pointer>>1]}:function readU16FromPointer(pointer){return HEAPU16[pointer>>1]};case 2:return signed?function readS32FromPointer(pointer){return HEAP32[pointer>>2]}:function readU32FromPointer(pointer){return HEAPU32[pointer>>2]};default:throw new TypeError("Unknown integer type: "+name)}}function __embind_register_integer(primitiveType,name,size,minRange,maxRange){name=readLatin1String(name);if(maxRange===-1){maxRange=4294967295;}var shift=getShiftFromSize(size);var fromWireType=function(value){return value};if(minRange===0){var bitshift=32-8*size;fromWireType=function(value){return value<<bitshift>>>bitshift};}var isUnsignedType=name.indexOf("unsigned")!=-1;registerType(primitiveType,{name:name,"fromWireType":fromWireType,"toWireType":function(destructors,value){if(typeof value!=="number"&&typeof value!=="boolean"){throw new TypeError('Cannot convert "'+_embind_repr(value)+'" to '+this.name)}if(value<minRange||value>maxRange){throw new TypeError('Passing a number "'+_embind_repr(value)+'" from JS side to C/C++ side to an argument of type "'+name+'", which is outside the valid range ['+minRange+", "+maxRange+"]!")}return isUnsignedType?value>>>0:value|0},"argPackAdvance":8,"readValueFromPointer":integerReadValueFromPointer(name,shift,minRange!==0),destructorFunction:null});}function __embind_register_memory_view(rawType,dataTypeIndex,name){var typeMapping=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array];var TA=typeMapping[dataTypeIndex];function decodeMemoryView(handle){handle=handle>>2;var heap=HEAPU32;var size=heap[handle];var data=heap[handle+1];return new TA(heap["buffer"],data,size)}name=readLatin1String(name);registerType(rawType,{name:name,"fromWireType":decodeMemoryView,"argPackAdvance":8,"readValueFromPointer":decodeMemoryView},{ignoreDuplicateRegistrations:true});}function __embind_register_std_string(rawType,name){name=readLatin1String(name);var stdStringIsUTF8=name==="std::string";registerType(rawType,{name:name,"fromWireType":function(value){var length=HEAPU32[value>>2];var str;if(stdStringIsUTF8){var endChar=HEAPU8[value+4+length];var endCharSwap=0;if(endChar!=0){endCharSwap=endChar;HEAPU8[value+4+length]=0;}var decodeStartPtr=value+4;for(var i=0;i<=length;++i){var currentBytePtr=value+4+i;if(HEAPU8[currentBytePtr]==0){var stringSegment=UTF8ToString(decodeStartPtr);if(str===undefined)str=stringSegment;else {str+=String.fromCharCode(0);str+=stringSegment;}decodeStartPtr=currentBytePtr+1;}}if(endCharSwap!=0)HEAPU8[value+4+length]=endCharSwap;}else {var a=new Array(length);for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAPU8[value+4+i]);}str=a.join("");}_free(value);return str},"toWireType":function(destructors,value){if(value instanceof ArrayBuffer){value=new Uint8Array(value);}var getLength;var valueIsOfTypeString=typeof value==="string";if(!(valueIsOfTypeString||value instanceof Uint8Array||value instanceof Uint8ClampedArray||value instanceof Int8Array)){throwBindingError("Cannot pass non-string to std::string");}if(stdStringIsUTF8&&valueIsOfTypeString){getLength=function(){return lengthBytesUTF8(value)};}else {getLength=function(){return value.length};}var length=getLength();var ptr=_malloc(4+length+1);HEAPU32[ptr>>2]=length;if(stdStringIsUTF8&&valueIsOfTypeString){stringToUTF8(value,ptr+4,length+1);}else {if(valueIsOfTypeString){for(var i=0;i<length;++i){var charCode=value.charCodeAt(i);if(charCode>255){_free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");}HEAPU8[ptr+4+i]=charCode;}}else {for(var i=0;i<length;++i){HEAPU8[ptr+4+i]=value[i];}}}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_std_wstring(rawType,charSize,name){name=readLatin1String(name);var getHeap,shift;if(charSize===2){getHeap=function(){return HEAPU16};shift=1;}else if(charSize===4){getHeap=function(){return HEAPU32};shift=2;}registerType(rawType,{name:name,"fromWireType":function(value){var HEAP=getHeap();var length=HEAPU32[value>>2];var a=new Array(length);var start=value+4>>shift;for(var i=0;i<length;++i){a[i]=String.fromCharCode(HEAP[start+i]);}_free(value);return a.join("")},"toWireType":function(destructors,value){var length=value.length;var ptr=_malloc(4+length*charSize);var HEAP=getHeap();HEAPU32[ptr>>2]=length;var start=ptr+4>>shift;for(var i=0;i<length;++i){HEAP[start+i]=value.charCodeAt(i);}if(destructors!==null){destructors.push(_free,ptr);}return ptr},"argPackAdvance":8,"readValueFromPointer":simpleReadValueFromPointer,destructorFunction:function(ptr){_free(ptr);}});}function __embind_register_void(rawType,name){name=readLatin1String(name);registerType(rawType,{isVoid:true,name:name,"argPackAdvance":0,"fromWireType":function(){return undefined},"toWireType":function(destructors,o){return undefined}});}function __emval_incref(handle){if(handle>4){emval_handle_array[handle].refcount+=1;}}function requireRegisteredType(rawType,humanName){var impl=registeredTypes[rawType];if(undefined===impl){throwBindingError(humanName+" has unknown type "+getTypeName(rawType));}return impl}function __emval_take_value(type,argv){type=requireRegisteredType(type,"_emval_take_value");var v=type["readValueFromPointer"](argv);return __emval_register(v)}function _abort(){abort();}function _emscripten_get_heap_size(){return HEAP8.length}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){console.error("emscripten_realloc_buffer: Attempted to grow heap from "+buffer.byteLength+" bytes to "+size+" bytes, but got error: "+e);}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();assert(requestedSize>oldSize);var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){err("Cannot enlarge memory, asked to go up to "+requestedSize+" bytes, but the limit is "+LIMIT+" bytes!");return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE);}else {newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);}if(newSize===oldSize){warnOnce("Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only "+HEAP8.length);}}var replacement=emscripten_realloc_buffer(newSize);if(!replacement){err("Failed to grow the heap from "+oldSize+" bytes to "+newSize+" bytes, not enough memory!");return false}return true}function _exit(status){exit(status);}function _llvm_log2_f32(x){return Math.log(x)/Math.LN2}function _llvm_log2_f64(a0){return _llvm_log2_f32(a0)}function _llvm_trap(){abort("trap!");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);}embind_init_charCodes();BindingError=Module["BindingError"]=extendError(Error,"BindingError");InternalError=Module["InternalError"]=extendError(Error,"InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError=Module["UnboundTypeError"]=extendError(Error,"UnboundTypeError");init_emval();function nullFunc_i(x){abortFnPtrError(x,"i");}function nullFunc_ii(x){abortFnPtrError(x,"ii");}function nullFunc_iidiiii(x){abortFnPtrError(x,"iidiiii");}function nullFunc_iii(x){abortFnPtrError(x,"iii");}function nullFunc_iiii(x){abortFnPtrError(x,"iiii");}function nullFunc_iiiii(x){abortFnPtrError(x,"iiiii");}function nullFunc_jiji(x){abortFnPtrError(x,"jiji");}function nullFunc_v(x){abortFnPtrError(x,"v");}function nullFunc_vi(x){abortFnPtrError(x,"vi");}function nullFunc_vii(x){abortFnPtrError(x,"vii");}function nullFunc_viii(x){abortFnPtrError(x,"viii");}function nullFunc_viiii(x){abortFnPtrError(x,"viiii");}function nullFunc_viiiii(x){abortFnPtrError(x,"viiiii");}function nullFunc_viiiiii(x){abortFnPtrError(x,"viiiiii");}var asmGlobalArg={};var asmLibraryArg={"___assert_fail":___assert_fail,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_throw":___cxa_throw,"___lock":___lock,"___unlock":___unlock,"___wasi_fd_close":___wasi_fd_close,"___wasi_fd_seek":___wasi_fd_seek,"___wasi_fd_write":___wasi_fd_write,"__embind_register_bool":__embind_register_bool,"__embind_register_class":__embind_register_class,"__embind_register_class_constructor":__embind_register_class_constructor,"__embind_register_class_function":__embind_register_class_function,"__embind_register_emval":__embind_register_emval,"__embind_register_float":__embind_register_float,"__embind_register_function":__embind_register_function,"__embind_register_integer":__embind_register_integer,"__embind_register_memory_view":__embind_register_memory_view,"__embind_register_std_string":__embind_register_std_string,"__embind_register_std_wstring":__embind_register_std_wstring,"__embind_register_void":__embind_register_void,"__emval_decref":__emval_decref,"__emval_incref":__emval_incref,"__emval_take_value":__emval_take_value,"__memory_base":1024,"__table_base":0,"_abort":_abort,"_emscripten_get_heap_size":_emscripten_get_heap_size,"_emscripten_memcpy_big":_emscripten_memcpy_big,"_emscripten_resize_heap":_emscripten_resize_heap,"_exit":_exit,"_llvm_log2_f64":_llvm_log2_f64,"_llvm_trap":_llvm_trap,"abortStackOverflow":abortStackOverflow,"memory":wasmMemory,"nullFunc_i":nullFunc_i,"nullFunc_ii":nullFunc_ii,"nullFunc_iidiiii":nullFunc_iidiiii,"nullFunc_iii":nullFunc_iii,"nullFunc_iiii":nullFunc_iiii,"nullFunc_iiiii":nullFunc_iiiii,"nullFunc_jiji":nullFunc_jiji,"nullFunc_v":nullFunc_v,"nullFunc_vi":nullFunc_vi,"nullFunc_vii":nullFunc_vii,"nullFunc_viii":nullFunc_viii,"nullFunc_viiii":nullFunc_viiii,"nullFunc_viiiii":nullFunc_viiiii,"nullFunc_viiiiii":nullFunc_viiiiii,"setTempRet0":setTempRet0,"table":wasmTable};var asm=Module["asm"](asmGlobalArg,asmLibraryArg,buffer);Module["asm"]=asm;var __ZSt18uncaught_exceptionv=Module["__ZSt18uncaught_exceptionv"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["__ZSt18uncaught_exceptionv"].apply(null,arguments)};Module["___cxa_demangle"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["___cxa_demangle"].apply(null,arguments)};Module["___embind_register_native_and_builtin_types"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["___embind_register_native_and_builtin_types"].apply(null,arguments)};var ___getTypeName=Module["___getTypeName"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["___getTypeName"].apply(null,arguments)};Module["_fflush"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["_fflush"].apply(null,arguments)};var _free=Module["_free"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["_free"].apply(null,arguments)};var _malloc=Module["_malloc"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["_malloc"].apply(null,arguments)};Module["establishStackSpace"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["establishStackSpace"].apply(null,arguments)};var globalCtors=Module["globalCtors"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["globalCtors"].apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["stackAlloc"].apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["stackRestore"].apply(null,arguments)};var stackSave=Module["stackSave"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["stackSave"].apply(null,arguments)};Module["dynCall_i"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_i"].apply(null,arguments)};Module["dynCall_ii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_ii"].apply(null,arguments)};Module["dynCall_iidiiii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_iidiiii"].apply(null,arguments)};Module["dynCall_iii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_iii"].apply(null,arguments)};Module["dynCall_iiii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_iiii"].apply(null,arguments)};Module["dynCall_iiiii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_iiiii"].apply(null,arguments)};Module["dynCall_jiji"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_jiji"].apply(null,arguments)};Module["dynCall_v"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_v"].apply(null,arguments)};Module["dynCall_vi"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_vi"].apply(null,arguments)};Module["dynCall_vii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_vii"].apply(null,arguments)};Module["dynCall_viii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_viii"].apply(null,arguments)};Module["dynCall_viiii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_viiii"].apply(null,arguments)};Module["dynCall_viiiii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_viiiii"].apply(null,arguments)};Module["dynCall_viiiiii"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return Module["asm"]["dynCall_viiiiii"].apply(null,arguments)};Module["asm"]=asm;if(!Object.getOwnPropertyDescriptor(Module,"intArrayFromString"))Module["intArrayFromString"]=function(){abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"intArrayToString"))Module["intArrayToString"]=function(){abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};Module["ccall"]=ccall;Module["cwrap"]=cwrap;if(!Object.getOwnPropertyDescriptor(Module,"setValue"))Module["setValue"]=function(){abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getValue"))Module["getValue"]=function(){abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"allocate"))Module["allocate"]=function(){abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getMemory"))Module["getMemory"]=function(){abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"AsciiToString"))Module["AsciiToString"]=function(){abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stringToAscii"))Module["stringToAscii"]=function(){abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"UTF8ArrayToString"))Module["UTF8ArrayToString"]=function(){abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"UTF8ToString"))Module["UTF8ToString"]=function(){abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stringToUTF8Array"))Module["stringToUTF8Array"]=function(){abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};Module["stringToUTF8"]=stringToUTF8;if(!Object.getOwnPropertyDescriptor(Module,"lengthBytesUTF8"))Module["lengthBytesUTF8"]=function(){abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"UTF16ToString"))Module["UTF16ToString"]=function(){abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stringToUTF16"))Module["stringToUTF16"]=function(){abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"lengthBytesUTF16"))Module["lengthBytesUTF16"]=function(){abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"UTF32ToString"))Module["UTF32ToString"]=function(){abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stringToUTF32"))Module["stringToUTF32"]=function(){abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"lengthBytesUTF32"))Module["lengthBytesUTF32"]=function(){abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"allocateUTF8"))Module["allocateUTF8"]=function(){abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stackTrace"))Module["stackTrace"]=function(){abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addOnPreRun"))Module["addOnPreRun"]=function(){abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addOnInit"))Module["addOnInit"]=function(){abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addOnPreMain"))Module["addOnPreMain"]=function(){abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addOnExit"))Module["addOnExit"]=function(){abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addOnPostRun"))Module["addOnPostRun"]=function(){abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"writeStringToMemory"))Module["writeStringToMemory"]=function(){abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"writeArrayToMemory"))Module["writeArrayToMemory"]=function(){abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"writeAsciiToMemory"))Module["writeAsciiToMemory"]=function(){abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addRunDependency"))Module["addRunDependency"]=function(){abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"removeRunDependency"))Module["removeRunDependency"]=function(){abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"ENV"))Module["ENV"]=function(){abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"FS"))Module["FS"]=function(){abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createFolder"))Module["FS_createFolder"]=function(){abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createPath"))Module["FS_createPath"]=function(){abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createDataFile"))Module["FS_createDataFile"]=function(){abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createPreloadedFile"))Module["FS_createPreloadedFile"]=function(){abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createLazyFile"))Module["FS_createLazyFile"]=function(){abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createLink"))Module["FS_createLink"]=function(){abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_createDevice"))Module["FS_createDevice"]=function(){abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"FS_unlink"))Module["FS_unlink"]=function(){abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");};if(!Object.getOwnPropertyDescriptor(Module,"GL"))Module["GL"]=function(){abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"dynamicAlloc"))Module["dynamicAlloc"]=function(){abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"loadDynamicLibrary"))Module["loadDynamicLibrary"]=function(){abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"loadWebAssemblyModule"))Module["loadWebAssemblyModule"]=function(){abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getLEB"))Module["getLEB"]=function(){abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getFunctionTables"))Module["getFunctionTables"]=function(){abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"alignFunctionTables"))Module["alignFunctionTables"]=function(){abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"registerFunctions"))Module["registerFunctions"]=function(){abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"addFunction"))Module["addFunction"]=function(){abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"removeFunction"))Module["removeFunction"]=function(){abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getFuncWrapper"))Module["getFuncWrapper"]=function(){abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"prettyPrint"))Module["prettyPrint"]=function(){abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"makeBigInt"))Module["makeBigInt"]=function(){abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"dynCall"))Module["dynCall"]=function(){abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getCompilerSetting"))Module["getCompilerSetting"]=function(){abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stackSave"))Module["stackSave"]=function(){abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stackRestore"))Module["stackRestore"]=function(){abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"stackAlloc"))Module["stackAlloc"]=function(){abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"establishStackSpace"))Module["establishStackSpace"]=function(){abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"print"))Module["print"]=function(){abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"printErr"))Module["printErr"]=function(){abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"getTempRet0"))Module["getTempRet0"]=function(){abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"setTempRet0"))Module["setTempRet0"]=function(){abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"callMain"))Module["callMain"]=function(){abort("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"abort"))Module["abort"]=function(){abort("'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"Pointer_stringify"))Module["Pointer_stringify"]=function(){abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};if(!Object.getOwnPropertyDescriptor(Module,"warnOnce"))Module["warnOnce"]=function(){abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");};Module["writeStackCookie"]=writeStackCookie;Module["checkStackCookie"]=checkStackCookie;Module["abortStackOverflow"]=abortStackOverflow;if(!Object.getOwnPropertyDescriptor(Module,"ALLOC_NORMAL"))Object.defineProperty(Module,"ALLOC_NORMAL",{configurable:true,get:function(){abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");}});if(!Object.getOwnPropertyDescriptor(Module,"ALLOC_STACK"))Object.defineProperty(Module,"ALLOC_STACK",{configurable:true,get:function(){abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");}});if(!Object.getOwnPropertyDescriptor(Module,"ALLOC_DYNAMIC"))Object.defineProperty(Module,"ALLOC_DYNAMIC",{configurable:true,get:function(){abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");}});if(!Object.getOwnPropertyDescriptor(Module,"ALLOC_NONE"))Object.defineProperty(Module,"ALLOC_NONE",{configurable:true,get:function(){abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)");}});if(!Object.getOwnPropertyDescriptor(Module,"calledRun"))Object.defineProperty(Module,"calledRun",{configurable:true,get:function(){abort("'calledRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you");}});var calledRun;Module["then"]=function(func){if(calledRun){func(Module);}else {var old=Module["onRuntimeInitialized"];Module["onRuntimeInitialized"]=function(){if(old)old();func(Module);};}return Module};function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status;}dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(args){if(runDependencies>0){return}writeStackCookie();preRun();if(runDependencies>0)return;function doRun(){if(calledRun)return;calledRun=true;if(ABORT)return;initRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();assert(!Module["_main"],'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}checkStackCookie();}Module["run"]=run;function checkUnflushedContent(){var print=out;var printErr=err;var has=false;out=err=function(x){has=true;};try{var flush=flush_NO_FILESYSTEM;if(flush)flush(0);}catch(e){}out=print;err=printErr;if(has){warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");warnOnce("(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)");}}function exit(status,implicit){checkUnflushedContent();if(implicit&&noExitRuntime&&status===0){return}if(noExitRuntime){if(!implicit){err("program exited (with status: "+status+"), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)");}}else {ABORT=true;exitRuntime();if(Module["onExit"])Module["onExit"](status);}quit_(status,new ExitStatus(status));}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}noExitRuntime=true;run();


  		  return Module
  		}
  		);
  		})();
  		module.exports = Module; 
  	} (woff2$1, woff2$1.exports));
  	return woff2$1.exports;
  }

  var woff2;
  var hasRequiredWoff2;

  function requireWoff2 () {
  	if (hasRequiredWoff2) return woff2;
  	hasRequiredWoff2 = 1;
  	// Require the woff2 module
  	const woff2ModuleLoader = requireWoff2$1();

  	function convertFromVecToUint8Array(vector) {
  	    const arr = [];
  	    for (let i = 0, l = vector.size(); i < l; i++) {
  	        arr.push(vector.get(i));
  	    }
  	    return new Uint8Array(arr);
  	}

  	// Define as a named object that can be exported with CommonJS
  	const woff2Module = {
  	    woff2Module: null,

  	    /**
  	     * 
  	     *
  	     * @return {boolean}
  	     */
  	    isInited() {
  	        return (
  	            this.woff2Module && this.woff2Module.woff2Enc && this.woff2Module.woff2Dec
  	        );
  	    },

  	    /**
  	     *  woff 
  	     *
  	     * @param {string|ArrayBuffer} wasmUrl woff2.wasm file url
  	     * @return {Promise}
  	     */
  	    init(wasmUrl) {
  	        return new Promise((resolve) => {
  	            if (this.woff2Module) {
  	                resolve(this);
  	                return;
  	            }

  	            let moduleLoaderConfig = null;
  	            if (typeof window !== 'undefined') {
  	                moduleLoaderConfig = {
  	                    locateFile(path) {
  	                        if (path.endsWith('.wasm')) {
  	                            return wasmUrl;
  	                        }
  	                        return path;
  	                    },
  	                };
  	            }
  	            // for nodejs
  	            else {
  	                // Use path resolution that works in both ESM and CommonJS
  	                let wasmPath = './woff2.wasm';
  	                // If running in Node.js with __dirname available (CommonJS)
  	                {
  	                    wasmPath = __dirname$1 + '/woff2.wasm';
  	                }

  	                moduleLoaderConfig = {
  	                    wasmBinaryFile: wasmPath,
  	                };
  	            }
  	            const woffModule = woff2ModuleLoader(moduleLoaderConfig);
  	            woffModule.onRuntimeInitialized = () => {
  	                this.woff2Module = woffModule;
  	                resolve(this);
  	            };
  	        });
  	    },

  	    /**
  	     * ttf buffer  woff2 buffer
  	     *
  	     * @param {ArrayBuffer|Buffer|Array} ttfBuffer ttf buffer
  	     * @return {Uint8Array} uint8 array
  	     */
  	    encode(ttfBuffer) {
  	        const buffer = new Uint8Array(ttfBuffer);
  	        const woffbuff = this.woff2Module.woff2Enc(buffer, buffer.byteLength);
  	        return convertFromVecToUint8Array(woffbuff);
  	    },

  	    /**
  	     * woff2 buffer  ttf buffer
  	     *
  	     * @param {ArrayBuffer|Buffer|Array} woff2Buffer woff2 buffer
  	     * @return {Uint8Array} uint8 array
  	     */
  	    decode(woff2Buffer) {
  	        const buffer = new Uint8Array(woff2Buffer);
  	        const ttfbuff = this.woff2Module.woff2Dec(buffer, buffer.byteLength);
  	        return convertFromVecToUint8Array(ttfbuff);
  	    },
  	};

  	// Export for CommonJS
  	woff2 = woff2Module;
  	return woff2;
  }

  var hasRequiredTtftowoff2;

  function requireTtftowoff2 () {
  	if (hasRequiredTtftowoff2) return ttftowoff2;
  	hasRequiredTtftowoff2 = 1;

  	Object.defineProperty(ttftowoff2, "__esModule", {
  	  value: true
  	});
  	ttftowoff2.default = ttftowoff2$1;
  	ttftowoff2.ttftowoff2async = ttftowoff2async;
  	var _index = _interopRequireDefault(requireWoff2());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttf to woff2
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * ttfwoff2
  	 *
  	 * @param {ArrayBuffer} ttfBuffer ttf
  	 * @param {Object} options 
  	 *
  	 * @return {Promise.<ArrayBuffer>} woffbyte
  	 */
  	// eslint-disable-next-line no-unused-vars
  	function ttftowoff2$1(ttfBuffer) {
  	  if (!_index.default.isInited()) {
  	    throw new Error('use woff2.init() to init woff2 module!');
  	  }
  	  var result = _index.default.encode(ttfBuffer);
  	  return result.buffer;
  	}

  	/**
  	 * ttfwoff2
  	 *
  	 * @param {ArrayBuffer} ttfBuffer ttf
  	 * @param {Object} options 
  	 *
  	 * @return {Promise.<ArrayBuffer>} woffbyte
  	 */
  	function ttftowoff2async(ttfBuffer) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  return _index.default.init(options.wasmUrl).then(function () {
  	    var result = _index.default.encode(ttfBuffer);
  	    return result.buffer;
  	  });
  	}
  	return ttftowoff2;
  }

  var woff2tottf = {};

  var hasRequiredWoff2tottf;

  function requireWoff2tottf () {
  	if (hasRequiredWoff2tottf) return woff2tottf;
  	hasRequiredWoff2tottf = 1;

  	Object.defineProperty(woff2tottf, "__esModule", {
  	  value: true
  	});
  	woff2tottf.default = woff2tottf$1;
  	woff2tottf.woff2tottfasync = woff2tottfasync;
  	var _index = _interopRequireDefault(requireWoff2());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file woff2 to ttf
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * ttfwoff2
  	 *
  	 * @param {ArrayBuffer} woff2Buffer ttf
  	 * @param {Object} options 
  	 *
  	 * @return {ArrayBuffer} woffbyte
  	 */
  	// eslint-disable-next-line no-unused-vars
  	function woff2tottf$1(woff2Buffer) {
  	  if (!_index.default.isInited()) {
  	    throw new Error('use woff2.init() to init woff2 module!');
  	  }
  	  var result = _index.default.decode(woff2Buffer);
  	  return result.buffer;
  	}

  	/**
  	 * ttfwoff2
  	 *
  	 * @param {ArrayBuffer} woff2Buffer ttf
  	 * @param {Object} options 
  	 *
  	 * @return {Promise.<ArrayBuffer>} woffbyte
  	 */
  	function woff2tottfasync(woff2Buffer) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  return _index.default.init(options.wasmUrl).then(function () {
  	    var result = _index.default.decode(woff2Buffer);
  	    return result.buffer;
  	  });
  	}
  	return woff2tottf;
  }

  var ttf2base64 = {};

  var bytes2base64 = {};

  var hasRequiredBytes2base64;

  function requireBytes2base64 () {
  	if (hasRequiredBytes2base64) return bytes2base64;
  	hasRequiredBytes2base64 = 1;

  	Object.defineProperty(bytes2base64, "__esModule", {
  	  value: true
  	});
  	bytes2base64.default = bytes2base64$1;
  	/**
  	 * @file bytebase64
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * bytebase64
  	 *
  	 * @param {ArrayBuffer|Array} buffer ArrayBuffer
  	 * @return {string} base64
  	 */
  	function bytes2base64$1(buffer) {
  	  var str = '';
  	  var length;
  	  var i;
  	  // ArrayBuffer
  	  if (buffer instanceof ArrayBuffer) {
  	    length = buffer.byteLength;
  	    var view = new DataView(buffer, 0, length);
  	    for (i = 0; i < length; i++) {
  	      str += String.fromCharCode(view.getUint8(i, false));
  	    }
  	  }
  	  // Array
  	  else if (buffer.length) {
  	    length = buffer.length;
  	    for (i = 0; i < length; i++) {
  	      str += String.fromCharCode(buffer[i]);
  	    }
  	  }
  	  if (!str) {
  	    return '';
  	  }
  	  return typeof btoa !== 'undefined' ? btoa(str) : Buffer.from(str, 'binary').toString('base64');
  	}
  	return bytes2base64;
  }

  var hasRequiredTtf2base64;

  function requireTtf2base64 () {
  	if (hasRequiredTtf2base64) return ttf2base64;
  	hasRequiredTtf2base64 = 1;

  	Object.defineProperty(ttf2base64, "__esModule", {
  	  value: true
  	});
  	ttf2base64.default = ttf2base64$1;
  	var _bytes2base = _interopRequireDefault(requireBytes2base64());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttfbase64
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * ttfbase64
  	 *
  	 * @param {Array} arrayBuffer ArrayBuffer
  	 * @return {string} base64
  	 */
  	function ttf2base64$1(arrayBuffer) {
  	  return 'data:font/ttf;charset=utf-8;base64,' + (0, _bytes2base.default)(arrayBuffer);
  	}
  	return ttf2base64;
  }

  var eot2base64 = {};

  var hasRequiredEot2base64;

  function requireEot2base64 () {
  	if (hasRequiredEot2base64) return eot2base64;
  	hasRequiredEot2base64 = 1;

  	Object.defineProperty(eot2base64, "__esModule", {
  	  value: true
  	});
  	eot2base64.default = eot2base64$1;
  	var _bytes2base = _interopRequireDefault(requireBytes2base64());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file eotbase64
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * eotbase64
  	 *
  	 * @param {Array} arrayBuffer ArrayBuffer
  	 * @return {string} base64
  	 */
  	function eot2base64$1(arrayBuffer) {
  	  return 'data:font/eot;charset=utf-8;base64,' + (0, _bytes2base.default)(arrayBuffer);
  	}
  	return eot2base64;
  }

  var woff2base64 = {};

  var hasRequiredWoff2base64;

  function requireWoff2base64 () {
  	if (hasRequiredWoff2base64) return woff2base64;
  	hasRequiredWoff2base64 = 1;

  	Object.defineProperty(woff2base64, "__esModule", {
  	  value: true
  	});
  	woff2base64.default = woff2base64$1;
  	var _bytes2base = _interopRequireDefault(requireBytes2base64());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file woffbase64
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * woffbase64
  	 *
  	 * @param {Array} arrayBuffer ArrayBuffer
  	 * @return {string} base64
  	 */
  	function woff2base64$1(arrayBuffer) {
  	  return 'data:font/woff;charset=utf-8;base64,' + (0, _bytes2base.default)(arrayBuffer);
  	}
  	return woff2base64;
  }

  var svg2base64 = {};

  var hasRequiredSvg2base64;

  function requireSvg2base64 () {
  	if (hasRequiredSvg2base64) return svg2base64;
  	hasRequiredSvg2base64 = 1;

  	Object.defineProperty(svg2base64, "__esModule", {
  	  value: true
  	});
  	svg2base64.default = svg2base64$1;
  	/**
  	 * @file svgbase64
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * svgbase64
  	 *
  	 * @param {string} svg svg
  	 * @param {string} scheme  
  	 * @return {string} base64
  	 */
  	function svg2base64$1(svg) {
  	  var scheme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'font/svg';
  	  if (typeof btoa === 'undefined') {
  	    return 'data:' + scheme + ';charset=utf-8;base64,' + Buffer.from(svg, 'binary').toString('base64');
  	  }
  	  return 'data:' + scheme + ';charset=utf-8;base64,' + btoa(svg);
  	}
  	return svg2base64;
  }

  var woff2tobase64 = {};

  var hasRequiredWoff2tobase64;

  function requireWoff2tobase64 () {
  	if (hasRequiredWoff2tobase64) return woff2tobase64;
  	hasRequiredWoff2tobase64 = 1;

  	Object.defineProperty(woff2tobase64, "__esModule", {
  	  value: true
  	});
  	woff2tobase64.default = woff2tobase64$1;
  	var _bytes2base = _interopRequireDefault(requireBytes2base64());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file woff2base64
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * woffbase64
  	 *
  	 * @param {Array} arrayBuffer ArrayBuffer
  	 * @return {string} base64
  	 */
  	function woff2tobase64$1(arrayBuffer) {
  	  return 'data:font/woff2;charset=utf-8;base64,' + (0, _bytes2base.default)(arrayBuffer);
  	}
  	return woff2tobase64;
  }

  var hasRequiredFont;

  function requireFont () {
  	if (hasRequiredFont) return font;
  	hasRequiredFont = 1;

  	Object.defineProperty(font, "__esModule", {
  	  value: true
  	});
  	font.Font = void 0;
  	font.createFont = createFont;
  	font.default = void 0;
  	var _buffer = _interopRequireDefault(requireBuffer());
  	var _getEmptyttfObject = _interopRequireDefault(requireGetEmptyttfObject());
  	var _ttf = _interopRequireDefault(requireTtf());
  	var _woff2ttf = _interopRequireDefault(requireWoff2ttf());
  	var _otf2ttfobject = _interopRequireDefault(requireOtf2ttfobject());
  	var _eot2ttf = _interopRequireDefault(requireEot2ttf());
  	var _svg2ttfobject = _interopRequireDefault(requireSvg2ttfobject());
  	var _ttfreader = _interopRequireDefault(requireTtfreader());
  	var _ttfwriter = _interopRequireDefault(requireTtfwriter());
  	var _ttf2eot = _interopRequireDefault(requireTtf2eot());
  	var _ttf2woff = _interopRequireDefault(requireTtf2woff());
  	var _ttf2svg = _interopRequireDefault(requireTtf2svg());
  	var _ttf2symbol = _interopRequireDefault(requireTtf2symbol());
  	var _ttftowoff = _interopRequireDefault(requireTtftowoff2());
  	var _woff2tottf = _interopRequireDefault(requireWoff2tottf());
  	var _ttf2base = _interopRequireDefault(requireTtf2base64());
  	var _eot2base = _interopRequireDefault(requireEot2base64());
  	var _woff2base = _interopRequireDefault(requireWoff2base64());
  	var _svg2base = _interopRequireDefault(requireSvg2base64());
  	var _bytes2base = _interopRequireDefault(requireBytes2base64());
  	var _woff2tobase = _interopRequireDefault(requireWoff2tobase64());
  	var _optimizettf = _interopRequireDefault(requireOptimizettf());
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
  	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
  	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
  	function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
  	function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
  	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); } /**
  	 * @file 
  	 *
  	 * @author mengke01(kekee000@gmail.com)
  	 */
  	// nodejsBufferbuffer
  	var SUPPORT_BUFFER = (typeof browser$1 === "undefined" ? "undefined" : _typeof(browser$1)) === 'object' && _typeof(browser$1.versions) === 'object' && typeof browser$1.versions.node !== 'undefined' && typeof Buffer === 'function';
  	var Font = font.Font = /*#__PURE__*/function () {
  	  /**
  	   * 
  	   *
  	   * @param {ArrayBuffer|Buffer|string|Document} buffer  
  	   * @param {Object} options  
  	   */
  	  function Font(buffer) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
  	      type: 'ttf'
  	    };
  	    _classCallCheck(this, Font);
  	    // 
  	    if (_typeof(buffer) === 'object' && buffer.glyf) {
  	      this.set(buffer);
  	    }
  	    // buffer
  	    else if (buffer) {
  	      this.read(buffer, options);
  	    }
  	    // 
  	    else {
  	      this.readEmpty();
  	    }
  	  }

  	  /**
  	   * Create a Font instance
  	   *
  	   * @param {ArrayBuffer|Buffer|string|Document} buffer  
  	   * @param {Object} options  
  	   * @return {Font}
  	   */
  	  return _createClass(Font, [{
  	    key: "readEmpty",
  	    value:
  	    /**
  	     *  ttfObject 
  	     *
  	     * @return {Font}
  	     */
  	    function readEmpty() {
  	      this.data = (0, _getEmptyttfObject.default)();
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {ArrayBuffer|Buffer|string|Document} buffer  
  	     * @param {Object} options  
  	     * @param {string} options.type 
  	     *
  	     * ttf, woff , eot 
  	     * @param {boolean} options.hinting  hinting 
  	     * @param {boolean} options.kerning  kerning 
  	     * @param {boolean} options.compound2simple 
  	     *
  	     * woff 
  	     * @param {Function} options.inflate 
  	     *
  	     * svg 
  	     * @param {boolean} options.combinePath svg
  	     * @return {Font}
  	     */
  	  }, {
  	    key: "read",
  	    value: function read(buffer, options) {
  	      // nodejs buffer
  	      if (SUPPORT_BUFFER) {
  	        if (buffer instanceof Buffer) {
  	          buffer = _buffer.default.toArrayBuffer(buffer);
  	        }
  	      }
  	      if (options.type === 'ttf') {
  	        this.data = new _ttfreader.default(options).read(buffer);
  	      } else if (options.type === 'otf') {
  	        this.data = (0, _otf2ttfobject.default)(buffer, options);
  	      } else if (options.type === 'eot') {
  	        buffer = (0, _eot2ttf.default)(buffer, options);
  	        this.data = new _ttfreader.default(options).read(buffer);
  	      } else if (options.type === 'woff') {
  	        buffer = (0, _woff2ttf.default)(buffer, options);
  	        this.data = new _ttfreader.default(options).read(buffer);
  	      } else if (options.type === 'woff2') {
  	        buffer = (0, _woff2tottf.default)(buffer, options);
  	        this.data = new _ttfreader.default(options).read(buffer);
  	      } else if (options.type === 'svg') {
  	        this.data = (0, _svg2ttfobject.default)(buffer, options);
  	      } else {
  	        throw new Error('not support font type' + options.type);
  	      }
  	      this.type = options.type;
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param {Object} options  
  	     * @param {string} options.type   ,  ttf
  	     * @param {boolean} options.toBuffer nodejs  Buffer ,  true
  	     *
  	     * ttf 
  	     * @param {boolean} options.hinting  hinting 
  	     * @param {boolean} options.kerning  kerning 
  	     * svg,woff 
  	     * @param {Object} options.metadata 
  	     *
  	     * woff 
  	     * @param {Function} options.deflate 
  	     * @return {Buffer|ArrayBuffer|string}
  	     */
  	  }, {
  	    key: "write",
  	    value: function write() {
  	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	      if (!options.type) {
  	        options.type = this.type;
  	      }
  	      var buffer = null;
  	      if (options.type === 'ttf') {
  	        buffer = new _ttfwriter.default(options).write(this.data);
  	      } else if (options.type === 'eot') {
  	        buffer = new _ttfwriter.default(options).write(this.data);
  	        buffer = (0, _ttf2eot.default)(buffer, options);
  	      } else if (options.type === 'woff') {
  	        buffer = new _ttfwriter.default(options).write(this.data);
  	        buffer = (0, _ttf2woff.default)(buffer, options);
  	      } else if (options.type === 'woff2') {
  	        buffer = new _ttfwriter.default(options).write(this.data);
  	        buffer = (0, _ttftowoff.default)(buffer, options);
  	      } else if (options.type === 'svg') {
  	        buffer = (0, _ttf2svg.default)(this.data, options);
  	      } else if (options.type === 'symbol') {
  	        buffer = (0, _ttf2symbol.default)(this.data, options);
  	      } else {
  	        throw new Error('not support font type' + options.type);
  	      }
  	      if (SUPPORT_BUFFER) {
  	        if (false !== options.toBuffer && buffer instanceof ArrayBuffer) {
  	          buffer = _buffer.default.toBuffer(buffer);
  	        }
  	      }
  	      return buffer;
  	    }

  	    /**
  	     *  base64
  	     *
  	     * @param {Object} options  
  	     * @param {string} options.type   ,  ttf
  	     *  options,  write
  	     * @see write
  	     *
  	     * @param {ArrayBuffer=} buffer  buffer buffer,  font
  	     * @return {string}
  	     */
  	  }, {
  	    key: "toBase64",
  	    value: function toBase64(options, buffer) {
  	      if (!options.type) {
  	        options.type = this.type;
  	      }
  	      if (buffer) {
  	        if (SUPPORT_BUFFER) {
  	          if (buffer instanceof Buffer) {
  	            buffer = _buffer.default.toArrayBuffer(buffer);
  	          }
  	        }
  	      } else {
  	        options.toBuffer = false;
  	        buffer = this.write(options);
  	      }
  	      var base64Str;
  	      if (options.type === 'ttf') {
  	        base64Str = (0, _ttf2base.default)(buffer);
  	      } else if (options.type === 'eot') {
  	        base64Str = (0, _eot2base.default)(buffer);
  	      } else if (options.type === 'woff') {
  	        base64Str = (0, _woff2base.default)(buffer);
  	      } else if (options.type === 'woff2') {
  	        base64Str = (0, _woff2tobase.default)(buffer);
  	      } else if (options.type === 'svg') {
  	        base64Str = (0, _svg2base.default)(buffer);
  	      } else if (options.type === 'symbol') {
  	        base64Str = (0, _svg2base.default)(buffer, 'image/svg+xml');
  	      } else {
  	        throw new Error('not support font type' + options.type);
  	      }
  	      return base64Str;
  	    }

  	    /**
  	     *  font 
  	     *
  	     * @param {Object} data fontttfObject
  	     * @return {this}
  	     */
  	  }, {
  	    key: "set",
  	    value: function set(data) {
  	      this.data = data;
  	      return this;
  	    }

  	    /**
  	     *  font 
  	     *
  	     * @return {Object} ttfObject 
  	     */
  	  }, {
  	    key: "get",
  	    value: function get() {
  	      return this.data;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param  {Object} out  
  	     * @param  {boolean|Object} out.result `true` 
  	     * @return {Font}
  	     */
  	  }, {
  	    key: "optimize",
  	    value: function optimize(out) {
  	      var result = (0, _optimizettf.default)(this.data);
  	      if (out) {
  	        out.result = result;
  	      }
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @return {this}
  	     */
  	  }, {
  	    key: "compound2simple",
  	    value: function compound2simple() {
  	      var ttfHelper = this.getHelper();
  	      ttfHelper.compound2simple();
  	      this.data = ttfHelper.get();
  	      return this;
  	    }

  	    /**
  	     * unicode
  	     *
  	     * @return {this}
  	     */
  	  }, {
  	    key: "sort",
  	    value: function sort() {
  	      var ttfHelper = this.getHelper();
  	      ttfHelper.sortGlyf();
  	      this.data = ttfHelper.get();
  	      return this;
  	    }

  	    /**
  	     * 
  	     *
  	     * @param  {Object} condition 
  	     * @param  {Array|number} condition.unicode unicodeunicode
  	     * @param  {string} condition.name glyf`uniE001`, `uniE`
  	     * @param  {Function} condition.filter 
  	     * @example
  	     *     condition.filter(glyf) {
  	     *         return glyf.name === 'logo';
  	     *     }
  	     * @return {Array}  glyf
  	     */
  	  }, {
  	    key: "find",
  	    value: function find(condition) {
  	      var ttfHelper = this.getHelper();
  	      var indexList = ttfHelper.findGlyf(condition);
  	      return indexList.length ? ttfHelper.getGlyf(indexList) : indexList;
  	    }

  	    /**
  	     *  font  font
  	     *
  	     * @param {Object} font Font 
  	     * @param {Object} options 
  	     * @param {boolean} options.scale 
  	     * @param {boolean} options.adjustGlyf 
  	     *                                     ( options.scale )
  	     *
  	     * @return {Font}
  	     */
  	  }, {
  	    key: "merge",
  	    value: function merge(font, options) {
  	      var ttfHelper = this.getHelper();
  	      ttfHelper.mergeGlyf(font.get(), options);
  	      this.data = ttfHelper.get();
  	      return this;
  	    }

  	    /**
  	     *  TTF helper 
  	     */
  	  }, {
  	    key: "getHelper",
  	    value: function getHelper() {
  	      return new _ttf.default(this.data);
  	    }
  	  }], [{
  	    key: "create",
  	    value: function create(buffer, options) {
  	      return new Font(buffer, options);
  	    }
  	  }]);
  	}();
  	/**
  	 * base64buffer 
  	 *
  	 * @param {ArrayBuffer|Buffer|string} buffer 
  	 * @return {Font}
  	 */
  	Font.toBase64 = function (buffer) {
  	  if (typeof buffer === 'string') {
  	    // node  btoa 
  	    if (typeof btoa === 'undefined') {
  	      return Buffer.from(buffer, 'binary').toString('base64');
  	    }
  	    return btoa(buffer);
  	  }
  	  return (0, _bytes2base.default)(buffer);
  	};
  	function createFont(buffer, options) {
  	  return new Font(buffer, options);
  	}
  	font.default = Font;
  	return font;
  }

  var ttf2icon = {};

  var hasRequiredTtf2icon;

  function requireTtf2icon () {
  	if (hasRequiredTtf2icon) return ttf2icon;
  	hasRequiredTtf2icon = 1;

  	Object.defineProperty(ttf2icon, "__esModule", {
  	  value: true
  	});
  	ttf2icon.default = ttf2icon$1;
  	var _ttfreader = _interopRequireDefault(requireTtfreader());
  	var _error = _interopRequireDefault(requireError());
  	var _default = _interopRequireDefault(require_default());
  	var _ttf2symbol = requireTtf2symbol();
  	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  	/**
  	 * @file ttficon
  	 * @author mengke01(kekee000@gmail.com)
  	 */

  	/**
  	 * listUnicode
  	 *
  	 * @param  {Array} unicode unicode
  	 * @return {string}         unicode string
  	 */
  	function listUnicode(unicode) {
  	  return unicode.map(function (u) {
  	    return '\\' + u.toString(16);
  	  }).join(',');
  	}

  	/**
  	 * ttficon
  	 *
  	 * @param {ttfObject} ttf ttfObject
  	 * @param {Object} options 
  	 * @param {Object} options.metadata 
  	 * @param {Object} options.iconPrefix icon 
  	 * @return {Object} icon obj
  	 */
  	function ttfobject2icon(ttf) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  var glyfList = [];

  	  // glyf 
  	  var filtered = ttf.glyf.filter(function (g) {
  	    return g.name !== '.notdef' && g.name !== '.null' && g.name !== 'nonmarkingreturn' && g.unicode && g.unicode.length;
  	  });
  	  filtered.forEach(function (g, i) {
  	    glyfList.push({
  	      code: '&#x' + g.unicode[0].toString(16) + ';',
  	      codeName: listUnicode(g.unicode),
  	      name: g.name,
  	      id: (0, _ttf2symbol.getSymbolId)(g, i)
  	    });
  	  });
  	  return {
  	    fontFamily: ttf.name.fontFamily || _default.default.name.fontFamily,
  	    iconPrefix: options.iconPrefix || 'icon',
  	    glyfList: glyfList
  	  };
  	}

  	/**
  	 * ttficon
  	 *
  	 * @param {ArrayBuffer|ttfObject} ttfBuffer ttfttfObject
  	 * @param {Object} options 
  	 * @param {Object} options.metadata 
  	 *
  	 * @return {Object} icon object
  	 */
  	function ttf2icon$1(ttfBuffer) {
  	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	  // ttf
  	  if (ttfBuffer instanceof ArrayBuffer) {
  	    var reader = new _ttfreader.default();
  	    var ttfObject = reader.read(ttfBuffer);
  	    reader.dispose();
  	    return ttfobject2icon(ttfObject, options);
  	  }
  	  // ttfObject
  	  else if (ttfBuffer.version && ttfBuffer.glyf) {
  	    return ttfobject2icon(ttfBuffer, options);
  	  }
  	  _error.default.raise(10101);
  	}
  	return ttf2icon;
  }

  var hasRequiredMain_esm;

  function requireMain_esm () {
  	if (hasRequiredMain_esm) return main_esm;
  	hasRequiredMain_esm = 1;
  	(function (exports) {

  		Object.defineProperty(exports, "__esModule", {
  		  value: true
  		});
  		Object.defineProperty(exports, "Font", {
  		  enumerable: true,
  		  get: function get() {
  		    return _font.Font;
  		  }
  		});
  		Object.defineProperty(exports, "OTFReader", {
  		  enumerable: true,
  		  get: function get() {
  		    return _otfreader.default;
  		  }
  		});
  		Object.defineProperty(exports, "Reader", {
  		  enumerable: true,
  		  get: function get() {
  		    return _reader.default;
  		  }
  		});
  		Object.defineProperty(exports, "TTF", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttf.default;
  		  }
  		});
  		Object.defineProperty(exports, "TTFReader", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttfreader.default;
  		  }
  		});
  		Object.defineProperty(exports, "TTFWriter", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttfwriter.default;
  		  }
  		});
  		Object.defineProperty(exports, "Writer", {
  		  enumerable: true,
  		  get: function get() {
  		    return _writer.default;
  		  }
  		});
  		Object.defineProperty(exports, "createFont", {
  		  enumerable: true,
  		  get: function get() {
  		    return _font.createFont;
  		  }
  		});
  		exports.default = void 0;
  		Object.defineProperty(exports, "eot2ttf", {
  		  enumerable: true,
  		  get: function get() {
  		    return _eot2ttf.default;
  		  }
  		});
  		Object.defineProperty(exports, "otf2ttfobject", {
  		  enumerable: true,
  		  get: function get() {
  		    return _otf2ttfobject.default;
  		  }
  		});
  		Object.defineProperty(exports, "svg2ttfobject", {
  		  enumerable: true,
  		  get: function get() {
  		    return _svg2ttfobject.default;
  		  }
  		});
  		exports.toBuffer = exports.toArrayBuffer = void 0;
  		Object.defineProperty(exports, "ttf2base64", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttf2base.default;
  		  }
  		});
  		Object.defineProperty(exports, "ttf2eot", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttf2eot.default;
  		  }
  		});
  		Object.defineProperty(exports, "ttf2icon", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttf2icon.default;
  		  }
  		});
  		Object.defineProperty(exports, "ttf2svg", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttf2svg.default;
  		  }
  		});
  		Object.defineProperty(exports, "ttf2woff", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttf2woff.default;
  		  }
  		});
  		Object.defineProperty(exports, "ttftowoff2", {
  		  enumerable: true,
  		  get: function get() {
  		    return _ttftowoff.default;
  		  }
  		});
  		Object.defineProperty(exports, "woff2", {
  		  enumerable: true,
  		  get: function get() {
  		    return _index.default;
  		  }
  		});
  		Object.defineProperty(exports, "woff2tottf", {
  		  enumerable: true,
  		  get: function get() {
  		    return _woff2tottf.default;
  		  }
  		});
  		Object.defineProperty(exports, "woff2ttf", {
  		  enumerable: true,
  		  get: function get() {
  		    return _woff2ttf.default;
  		  }
  		});
  		var _font = requireFont();
  		var _ttf = _interopRequireDefault(requireTtf());
  		var _ttfreader = _interopRequireDefault(requireTtfreader());
  		var _ttfwriter = _interopRequireDefault(requireTtfwriter());
  		var _ttf2eot = _interopRequireDefault(requireTtf2eot());
  		var _eot2ttf = _interopRequireDefault(requireEot2ttf());
  		var _ttf2woff = _interopRequireDefault(requireTtf2woff());
  		var _woff2ttf = _interopRequireDefault(requireWoff2ttf());
  		var _ttf2svg = _interopRequireDefault(requireTtf2svg());
  		var _svg2ttfobject = _interopRequireDefault(requireSvg2ttfobject());
  		var _reader = _interopRequireDefault(requireReader());
  		var _writer = _interopRequireDefault(requireWriter());
  		var _otfreader = _interopRequireDefault(requireOtfreader());
  		var _otf2ttfobject = _interopRequireDefault(requireOtf2ttfobject());
  		var _ttf2base = _interopRequireDefault(requireTtf2base64());
  		var _ttf2icon = _interopRequireDefault(requireTtf2icon());
  		var _ttftowoff = _interopRequireDefault(requireTtftowoff2());
  		var _woff2tottf = _interopRequireDefault(requireWoff2tottf());
  		var _index = _interopRequireDefault(requireWoff2());
  		var _buffer = _interopRequireDefault(requireBuffer());
  		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
  		/**
  		 * @file 
  		 * @author mengke01(kekee000@gmail.com)
  		 */

  		exports.toArrayBuffer = _buffer.default.toArrayBuffer;
  		exports.toBuffer = _buffer.default.toBuffer;
  		exports.default = {
  		  createFont: _font.createFont,
  		  Font: _font.Font,
  		  TTF: _ttf.default,
  		  TTFReader: _ttfreader.default,
  		  TTFWriter: _ttfwriter.default,
  		  ttf2eot: _ttf2eot.default,
  		  eot2ttf: _eot2ttf.default,
  		  ttf2woff: _ttf2woff.default,
  		  woff2ttf: _woff2ttf.default,
  		  ttf2svg: _ttf2svg.default,
  		  svg2ttfobject: _svg2ttfobject.default,
  		  Reader: _reader.default,
  		  Writer: _writer.default,
  		  OTFReader: _otfreader.default,
  		  otf2ttfobject: _otf2ttfobject.default,
  		  ttf2base64: _ttf2base.default,
  		  ttf2icon: _ttf2icon.default,
  		  ttftowoff2: _ttftowoff.default,
  		  woff2tottf: _woff2tottf.default,
  		  woff2: _index.default,
  		  toArrayBuffer: _buffer.default.toArrayBuffer,
  		  toBuffer: _buffer.default.toBuffer
  		}; 
  	} (main_esm));
  	return main_esm;
  }

  var main_esmExports = requireMain_esm();

  /*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  /* eslint-disable space-unary-ops */

  /* Public constants ==========================================================*/
  /* ===========================================================================*/


  //const Z_FILTERED          = 1;
  //const Z_HUFFMAN_ONLY      = 2;
  //const Z_RLE               = 3;
  const Z_FIXED$1               = 4;
  //const Z_DEFAULT_STRATEGY  = 0;

  /* Possible values of the data_type field (though see inflate()) */
  const Z_BINARY              = 0;
  const Z_TEXT                = 1;
  //const Z_ASCII             = 1; // = Z_TEXT
  const Z_UNKNOWN$1             = 2;

  /*============================================================================*/


  function zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }

  // From zutil.h

  const STORED_BLOCK = 0;
  const STATIC_TREES = 1;
  const DYN_TREES    = 2;
  /* The three kinds of block type */

  const MIN_MATCH$1    = 3;
  const MAX_MATCH$1    = 258;
  /* The minimum and maximum match lengths */

  // From deflate.h
  /* ===========================================================================
   * Internal compression state.
   */

  const LENGTH_CODES$1  = 29;
  /* number of length codes, not counting the special END_BLOCK code */

  const LITERALS$1      = 256;
  /* number of literal bytes 0..255 */

  const L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;
  /* number of Literal or Length codes, including the END_BLOCK code */

  const D_CODES$1       = 30;
  /* number of distance codes */

  const BL_CODES$1      = 19;
  /* number of codes used to transfer the bit lengths */

  const HEAP_SIZE$1     = 2 * L_CODES$1 + 1;
  /* maximum heap size */

  const MAX_BITS$1      = 15;
  /* All codes must not exceed MAX_BITS bits */

  const Buf_size      = 16;
  /* size of bit buffer in bi_buf */


  /* ===========================================================================
   * Constants
   */

  const MAX_BL_BITS = 7;
  /* Bit length codes must not exceed MAX_BL_BITS bits */

  const END_BLOCK   = 256;
  /* end of block literal code */

  const REP_3_6     = 16;
  /* repeat previous bit length 3-6 times (2 bits of repeat count) */

  const REPZ_3_10   = 17;
  /* repeat a zero length 3-10 times  (3 bits of repeat count) */

  const REPZ_11_138 = 18;
  /* repeat a zero length 11-138 times  (7 bits of repeat count) */

  /* eslint-disable comma-spacing,array-bracket-spacing */
  const extra_lbits =   /* extra bits for each length code */
    new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);

  const extra_dbits =   /* extra bits for each distance code */
    new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);

  const extra_blbits =  /* extra bits for each bit length code */
    new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);

  const bl_order =
    new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);
  /* eslint-enable comma-spacing,array-bracket-spacing */

  /* The lengths of the bit length codes are sent in order of decreasing
   * probability, to avoid transmitting the lengths for unused bit length codes.
   */

  /* ===========================================================================
   * Local data. These are initialized only once.
   */

  // We pre-fill arrays with 0 to avoid uninitialized gaps

  const DIST_CODE_LEN = 512; /* see definition of array dist_code below */

  // !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
  const static_ltree  = new Array((L_CODES$1 + 2) * 2);
  zero$1(static_ltree);
  /* The static literal tree. Since the bit lengths are imposed, there is no
   * need for the L_CODES extra codes used during heap construction. However
   * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
   * below).
   */

  const static_dtree  = new Array(D_CODES$1 * 2);
  zero$1(static_dtree);
  /* The static distance tree. (Actually a trivial tree since all codes use
   * 5 bits.)
   */

  const _dist_code    = new Array(DIST_CODE_LEN);
  zero$1(_dist_code);
  /* Distance codes. The first 256 values correspond to the distances
   * 3 .. 258, the last 256 values correspond to the top 8 bits of
   * the 15 bit distances.
   */

  const _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
  zero$1(_length_code);
  /* length code for each normalized match length (0 == MIN_MATCH) */

  const base_length   = new Array(LENGTH_CODES$1);
  zero$1(base_length);
  /* First normalized length for each code (0 = MIN_MATCH) */

  const base_dist     = new Array(D_CODES$1);
  zero$1(base_dist);
  /* First normalized distance for each code (0 = distance of 1) */


  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

    this.static_tree  = static_tree;  /* static tree or NULL */
    this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
    this.extra_base   = extra_base;   /* base index for extra_bits */
    this.elems        = elems;        /* max number of elements in the tree */
    this.max_length   = max_length;   /* max bit length for the codes */

    // show if `static_tree` has data or dummy - needed for monomorphic objects
    this.has_stree    = static_tree && static_tree.length;
  }


  let static_l_desc;
  let static_d_desc;
  let static_bl_desc;


  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;     /* the dynamic tree */
    this.max_code = 0;            /* largest code with non zero frequency */
    this.stat_desc = stat_desc;   /* the corresponding static tree */
  }



  const d_code = (dist) => {

    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };


  /* ===========================================================================
   * Output a short LSB first on the stream.
   * IN assertion: there is enough room in pendingBuf.
   */
  const put_short = (s, w) => {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
    s.pending_buf[s.pending++] = (w) & 0xff;
    s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
  };


  /* ===========================================================================
   * Send a value on a given number of bits.
   * IN assertion: length <= 16 and value fits in length bits.
   */
  const send_bits = (s, value, length) => {

    if (s.bi_valid > (Buf_size - length)) {
      s.bi_buf |= (value << s.bi_valid) & 0xffff;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> (Buf_size - s.bi_valid);
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= (value << s.bi_valid) & 0xffff;
      s.bi_valid += length;
    }
  };


  const send_code = (s, c, tree) => {

    send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
  };


  /* ===========================================================================
   * Reverse the first len bits of a code, using straightforward code (a faster
   * method would use a table)
   * IN assertion: 1 <= len <= 15
   */
  const bi_reverse = (code, len) => {

    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  };


  /* ===========================================================================
   * Flush the bit buffer, keeping at most 7 bits in it.
   */
  const bi_flush = (s) => {

    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;

    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 0xff;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  };


  /* ===========================================================================
   * Compute the optimal bit lengths for a tree and update the total bit length
   * for the current block.
   * IN assertion: the fields freq and dad are set, heap[heap_max] and
   *    above are the tree nodes sorted by increasing frequency.
   * OUT assertions: the field len is set to the optimal bit length, the
   *     array bl_count contains the frequencies for each bit length.
   *     The length opt_len is updated; static_len is also updated if stree is
   *     not null.
   */
  const gen_bitlen = (s, desc) => {
  //    deflate_state *s;
  //    tree_desc *desc;    /* the tree descriptor */

    const tree            = desc.dyn_tree;
    const max_code        = desc.max_code;
    const stree           = desc.stat_desc.static_tree;
    const has_stree       = desc.stat_desc.has_stree;
    const extra           = desc.stat_desc.extra_bits;
    const base            = desc.stat_desc.extra_base;
    const max_length      = desc.stat_desc.max_length;
    let h;              /* heap index */
    let n, m;           /* iterate over the tree elements */
    let bits;           /* bit length */
    let xbits;          /* extra bits */
    let f;              /* frequency */
    let overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      s.bl_count[bits] = 0;
    }

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

    for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1]/*.Len*/ = bits;
      /* We overwrite tree[n].Dad which is no longer needed */

      if (n > max_code) { continue; } /* not a leaf node */

      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2]/*.Freq*/;
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
      }
    }
    if (overflow === 0) { return; }

    // Tracev((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) { bits--; }
      s.bl_count[bits]--;      /* move one leaf down the tree */
      s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
      s.bl_count[max_length]--;
      /* The brother of the overflow item also moves one step up,
       * but this does not affect bl_count[max_length]
       */
      overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) { continue; }
        if (tree[m * 2 + 1]/*.Len*/ !== bits) {
          // Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
          s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
          tree[m * 2 + 1]/*.Len*/ = bits;
        }
        n--;
      }
    }
  };


  /* ===========================================================================
   * Generate the codes for a given tree and bit counts (which need not be
   * optimal).
   * IN assertion: the array bl_count contains the bit length statistics for
   * the given tree and the field len is set for all tree elements.
   * OUT assertion: the field code is set for all tree elements of non
   *     zero code length.
   */
  const gen_codes = (tree, max_code, bl_count) => {
  //    ct_data *tree;             /* the tree to decorate */
  //    int max_code;              /* largest code with non zero frequency */
  //    ushf *bl_count;            /* number of codes at each bit length */

    const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */
    let code = 0;              /* running code value */
    let bits;                  /* bit index */
    let n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS$1; bits++) {
      code = (code + bl_count[bits - 1]) << 1;
      next_code[bits] = code;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
    //        "inconsistent bit counts");
    //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
      let len = tree[n * 2 + 1]/*.Len*/;
      if (len === 0) { continue; }
      /* Now reverse the bits */
      tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

      //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
      //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
  };


  /* ===========================================================================
   * Initialize the various 'constant' tables.
   */
  const tr_static_init = () => {

    let n;        /* iterates over tree elements */
    let bits;     /* bit counter */
    let length;   /* length value */
    let code;     /* code value */
    let dist;     /* distance index */
    const bl_count = new Array(MAX_BITS$1 + 1);
    /* number of codes at each bit length for an optimal tree */

    // do check in _tr_init()
    //if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < (1 << extra_lbits[code]); n++) {
        _length_code[length++] = code;
      }
    }
    //Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length - 1] = code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n = 0; n < (1 << extra_dbits[code]); n++) {
        _dist_code[dist++] = code;
      }
    }
    //Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for (; code < D_CODES$1; code++) {
      base_dist[code] = dist << 7;
      for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
        _dist_code[256 + dist++] = code;
      }
    }
    //Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      bl_count[bits] = 0;
    }

    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1]/*.Len*/ = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1]/*.Len*/ = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1]/*.Len*/ = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1]/*.Len*/ = 8;
      n++;
      bl_count[8]++;
    }
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES$1; n++) {
      static_dtree[n * 2 + 1]/*.Len*/ = 5;
      static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
    }

    // Now data ready and we can init static trees
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);

    //static_init_done = true;
  };


  /* ===========================================================================
   * Initialize a new block.
   */
  const init_block = (s) => {

    let n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
    for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
    for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

    s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
    s.opt_len = s.static_len = 0;
    s.sym_next = s.matches = 0;
  };


  /* ===========================================================================
   * Flush the bit buffer and align the output on a byte boundary
   */
  const bi_windup = (s) =>
  {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      //put_byte(s, (Byte)s->bi_buf);
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  };

  /* ===========================================================================
   * Compares to subtrees, using the tree depth as tie breaker when
   * the subtrees have equal frequency. This minimizes the worst case length.
   */
  const smaller = (tree, n, m, depth) => {

    const _n2 = n * 2;
    const _m2 = m * 2;
    return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
           (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
  };

  /* ===========================================================================
   * Restore the heap property by moving down the tree starting at node k,
   * exchanging a node with the smallest of its two sons if necessary, stopping
   * when the heap property is re-established (each father smaller than its
   * two sons).
   */
  const pqdownheap = (s, tree, k) => {
  //    deflate_state *s;
  //    ct_data *tree;  /* the tree to restore */
  //    int k;               /* node to move down */

    const v = s.heap[k];
    let j = k << 1;  /* left son of k */
    while (j <= s.heap_len) {
      /* Set j to the smallest of the two sons: */
      if (j < s.heap_len &&
        smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      /* Exit if v is smaller than both sons */
      if (smaller(tree, v, s.heap[j], s.depth)) { break; }

      /* Exchange v with the smallest son */
      s.heap[k] = s.heap[j];
      k = j;

      /* And continue down the tree, setting j to the left son of k */
      j <<= 1;
    }
    s.heap[k] = v;
  };


  // inlined manually
  // const SMALLEST = 1;

  /* ===========================================================================
   * Send the block data compressed using the given Huffman trees
   */
  const compress_block = (s, ltree, dtree) => {
  //    deflate_state *s;
  //    const ct_data *ltree; /* literal tree */
  //    const ct_data *dtree; /* distance tree */

    let dist;           /* distance of matched string */
    let lc;             /* match length or unmatched char (if dist == 0) */
    let sx = 0;         /* running index in sym_buf */
    let code;           /* the code to send */
    let extra;          /* number of extra bits to send */

    if (s.sym_next !== 0) {
      do {
        dist = s.pending_buf[s.sym_buf + sx++] & 0xff;
        dist += (s.pending_buf[s.sym_buf + sx++] & 0xff) << 8;
        lc = s.pending_buf[s.sym_buf + sx++];
        if (dist === 0) {
          send_code(s, lc, ltree); /* send a literal byte */
          //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
          /* Here, lc is the match length - MIN_MATCH */
          code = _length_code[lc];
          send_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);       /* send the extra length bits */
          }
          dist--; /* dist is now the match distance - 1 */
          code = d_code(dist);
          //Assert (code < D_CODES, "bad d_code");

          send_code(s, code, dtree);       /* send the distance code */
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s, dist, extra);   /* send the extra distance bits */
          }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and sym_buf is ok: */
        //Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");

      } while (sx < s.sym_next);
    }

    send_code(s, END_BLOCK, ltree);
  };


  /* ===========================================================================
   * Construct one Huffman tree and assigns the code bit strings and lengths.
   * Update the total bit length for the current block.
   * IN assertion: the field freq is set for all tree elements.
   * OUT assertions: the fields len and code are set to the optimal bit length
   *     and corresponding code. The length opt_len is updated; static_len is
   *     also updated if stree is not null. The field max_code is set.
   */
  const build_tree = (s, desc) => {
  //    deflate_state *s;
  //    tree_desc *desc; /* the tree descriptor */

    const tree     = desc.dyn_tree;
    const stree    = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems    = desc.stat_desc.elems;
    let n, m;          /* iterate over heap elements */
    let max_code = -1; /* largest code with non zero frequency */
    let node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE$1;

    for (n = 0; n < elems; n++) {
      if (tree[n * 2]/*.Freq*/ !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;

      } else {
        tree[n * 2 + 1]/*.Len*/ = 0;
      }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
      tree[node * 2]/*.Freq*/ = 1;
      s.depth[node] = 0;
      s.opt_len--;

      if (has_stree) {
        s.static_len -= stree[node * 2 + 1]/*.Len*/;
      }
      /* node is 0 or 1 so it does not have extra bits */
    }
    desc.max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
      //pqremove(s, tree, n);  /* n = node of least frequency */
      /*** pqremove ***/
      n = s.heap[1/*SMALLEST*/];
      s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
      pqdownheap(s, tree, 1/*SMALLEST*/);
      /***/

      m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

      s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
      s.heap[--s.heap_max] = m;

      /* Create a new node father of n and m */
      tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
      s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

      /* and insert the new node in the heap */
      s.heap[1/*SMALLEST*/] = node++;
      pqdownheap(s, tree, 1/*SMALLEST*/);

    } while (s.heap_len >= 2);

    s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes(tree, max_code, s.bl_count);
  };


  /* ===========================================================================
   * Scan a literal or distance tree to determine the frequencies of the codes
   * in the bit length tree.
   */
  const scan_tree = (s, tree, max_code) => {
  //    deflate_state *s;
  //    ct_data *tree;   /* the tree to be scanned */
  //    int max_code;    /* and its largest code of non zero frequency */

    let n;                     /* iterates over all tree elements */
    let prevlen = -1;          /* last emitted length */
    let curlen;                /* length of current code */

    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

    let count = 0;             /* repeat count of the current code */
    let max_count = 7;         /* max repeat count */
    let min_count = 4;         /* min repeat count */

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

      if (++count < max_count && curlen === nextlen) {
        continue;

      } else if (count < min_count) {
        s.bl_tree[curlen * 2]/*.Freq*/ += count;

      } else if (curlen !== 0) {

        if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
        s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

      } else {
        s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
      }

      count = 0;
      prevlen = curlen;

      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;

      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;

      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };


  /* ===========================================================================
   * Send a literal or distance tree in compressed form, using the codes in
   * bl_tree.
   */
  const send_tree = (s, tree, max_code) => {
  //    deflate_state *s;
  //    ct_data *tree; /* the tree to be scanned */
  //    int max_code;       /* and its largest code of non zero frequency */

    let n;                     /* iterates over all tree elements */
    let prevlen = -1;          /* last emitted length */
    let curlen;                /* length of current code */

    let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

    let count = 0;             /* repeat count of the current code */
    let max_count = 7;         /* max repeat count */
    let min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }

    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

      if (++count < max_count && curlen === nextlen) {
        continue;

      } else if (count < min_count) {
        do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        //Assert(count >= 3 && count <= 6, " 3_6?");
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);

      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);

      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }

      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;

      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;

      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };


  /* ===========================================================================
   * Construct the Huffman tree for the bit lengths and return the index in
   * bl_order of the last bit length code to send.
   */
  const build_bl_tree = (s) => {

    let max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, s.bl_desc);
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
        break;
      }
    }
    /* Update opt_len to include the bit length tree and counts */
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
    //        s->opt_len, s->static_len));

    return max_blindex;
  };


  /* ===========================================================================
   * Send the header for a block using dynamic Huffman trees: the counts, the
   * lengths of the bit length codes, the literal tree and the distance tree.
   * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
   */
  const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  //    deflate_state *s;
  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */

    let rank;                    /* index in bl_order */

    //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
    //        "too many codes");
    //Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes - 1,   5);
    send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
      //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
    }
    //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
    //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
    //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
  };


  /* ===========================================================================
   * Check if the data type is TEXT or BINARY, using the following algorithm:
   * - TEXT if the two conditions below are satisfied:
   *    a) There are no non-portable control characters belonging to the
   *       "block list" (0..6, 14..25, 28..31).
   *    b) There is at least one printable character belonging to the
   *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
   * - BINARY otherwise.
   * - The following partially-portable control characters form a
   *   "gray list" that is ignored in this detection algorithm:
   *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
   * IN assertion: the fields Freq of dyn_ltree are set.
   */
  const detect_data_type = (s) => {
    /* block_mask is the bit mask of block-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
    let block_mask = 0xf3ffc07f;
    let n;

    /* Check for non-textual ("block-listed") bytes. */
    for (n = 0; n <= 31; n++, block_mask >>>= 1) {
      if ((block_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
        return Z_BINARY;
      }
    }

    /* Check for textual ("allow-listed") bytes. */
    if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
        s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS$1; n++) {
      if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
        return Z_TEXT;
      }
    }

    /* There are no "block-listed" or "allow-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */
    return Z_BINARY;
  };


  let static_init_done = false;

  /* ===========================================================================
   * Initialize the tree data structures for a new zlib stream.
   */
  const _tr_init$1 = (s) =>
  {

    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }

    s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

    s.bi_buf = 0;
    s.bi_valid = 0;

    /* Initialize the first block of the first file: */
    init_block(s);
  };


  /* ===========================================================================
   * Send a stored block
   */
  const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  //DeflateState *s;
  //charf *buf;       /* input block */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */

    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
    bi_windup(s);        /* align on byte boundary */
    put_short(s, stored_len);
    put_short(s, ~stored_len);
    if (stored_len) {
      s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
    }
    s.pending += stored_len;
  };


  /* ===========================================================================
   * Send one empty static block to give enough lookahead for inflate.
   * This takes 10 bits, of which 7 may remain in the bit buffer.
   */
  const _tr_align$1 = (s) => {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  };


  /* ===========================================================================
   * Determine the best encoding for the current block: dynamic trees, static
   * trees or store, and write out the encoded block.
   */
  const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  //DeflateState *s;
  //charf *buf;       /* input block, or NULL if too old */
  //ulg stored_len;   /* length of input block */
  //int last;         /* one if this is the last block for a file */

    let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
    let max_blindex = 0;        /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s.level > 0) {

      /* Check if the file is binary or text */
      if (s.strm.data_type === Z_UNKNOWN$1) {
        s.strm.data_type = detect_data_type(s);
      }

      /* Construct the literal and distance trees */
      build_tree(s, s.l_desc);
      // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
      //        s->static_len));

      build_tree(s, s.d_desc);
      // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
      //        s->static_len));
      /* At this point, opt_len and static_len are the total bit lengths of
       * the compressed block data, excluding the tree representations.
       */

      /* Build the bit length tree for the above two trees, and get the index
       * in bl_order of the last bit length code to send.
       */
      max_blindex = build_bl_tree(s);

      /* Determine the best encoding. Compute the block lengths in bytes. */
      opt_lenb = (s.opt_len + 3 + 7) >>> 3;
      static_lenb = (s.static_len + 3 + 7) >>> 3;

      // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
      //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
      //        s->sym_next / 3));

      if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

    } else {
      // Assert(buf != (char*)0, "lost buf");
      opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

    if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
      /* 4: two words for the lengths */

      /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
       * Otherwise we can't have processed more than WSIZE input bytes since
       * the last block flush, because compression would have been
       * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
       * transform a block into a stored block.
       */
      _tr_stored_block$1(s, buf, stored_len, last);

    } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {

      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);

    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (last) {
      bi_windup(s);
    }
    // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
    //       s->compressed_len-7*last));
  };

  /* ===========================================================================
   * Save the match info and tally the frequency counts. Return true if
   * the current block must be flushed.
   */
  const _tr_tally$1 = (s, dist, lc) => {
  //    deflate_state *s;
  //    unsigned dist;  /* distance of matched string */
  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */

    s.pending_buf[s.sym_buf + s.sym_next++] = dist;
    s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
    s.pending_buf[s.sym_buf + s.sym_next++] = lc;
    if (dist === 0) {
      /* lc is the unmatched char */
      s.dyn_ltree[lc * 2]/*.Freq*/++;
    } else {
      s.matches++;
      /* Here, lc is the match length - MIN_MATCH */
      dist--;             /* dist = match distance - 1 */
      //Assert((ush)dist < (ush)MAX_DIST(s) &&
      //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
      //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

      s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;
      s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
    }

    return (s.sym_next === s.sym_end);
  };

  var _tr_init_1  = _tr_init$1;
  var _tr_stored_block_1 = _tr_stored_block$1;
  var _tr_flush_block_1  = _tr_flush_block$1;
  var _tr_tally_1 = _tr_tally$1;
  var _tr_align_1 = _tr_align$1;

  var trees = {
  	_tr_init: _tr_init_1,
  	_tr_stored_block: _tr_stored_block_1,
  	_tr_flush_block: _tr_flush_block_1,
  	_tr_tally: _tr_tally_1,
  	_tr_align: _tr_align_1
  };

  // Note: adler32 takes 12% for level 0 and 2% for level 6.
  // It isn't worth it to make additional optimizations as in original.
  // Small size is preferable.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const adler32 = (adler, buf, len, pos) => {
    let s1 = (adler & 0xffff) |0,
        s2 = ((adler >>> 16) & 0xffff) |0,
        n = 0;

    while (len !== 0) {
      // Set limit ~ twice less than 5552, to keep
      // s2 in 31-bits, because we force signed ints.
      // in other case %= will fail.
      n = len > 2000 ? 2000 : len;
      len -= n;

      do {
        s1 = (s1 + buf[pos++]) |0;
        s2 = (s2 + s1) |0;
      } while (--n);

      s1 %= 65521;
      s2 %= 65521;
    }

    return (s1 | (s2 << 16)) |0;
  };


  var adler32_1 = adler32;

  // Note: we can't get significant speed boost here.
  // So write code to minimize size - no pregenerated tables
  // and array tools dependencies.

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // Use ordinary array, since untyped makes no boost here
  const makeTable = () => {
    let c, table = [];

    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
      }
      table[n] = c;
    }

    return table;
  };

  // Create table on load. Just 255 signed longs. Not a problem.
  const crcTable = new Uint32Array(makeTable());


  const crc32 = (crc, buf, len, pos) => {
    const t = crcTable;
    const end = pos + len;

    crc ^= -1;

    for (let i = pos; i < end; i++) {
      crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
  };


  var crc32_1 = crc32;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var messages = {
    2:      'need dictionary',     /* Z_NEED_DICT       2  */
    1:      'stream end',          /* Z_STREAM_END      1  */
    0:      '',                    /* Z_OK              0  */
    '-1':   'file error',          /* Z_ERRNO         (-1) */
    '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
    '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
    '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
    '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
    '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  var constants$2 = {

    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH:         0,
    Z_PARTIAL_FLUSH:    1,
    Z_SYNC_FLUSH:       2,
    Z_FULL_FLUSH:       3,
    Z_FINISH:           4,
    Z_BLOCK:            5,
    Z_TREES:            6,

    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK:               0,
    Z_STREAM_END:       1,
    Z_NEED_DICT:        2,
    Z_ERRNO:           -1,
    Z_STREAM_ERROR:    -2,
    Z_DATA_ERROR:      -3,
    Z_MEM_ERROR:       -4,
    Z_BUF_ERROR:       -5,
    //Z_VERSION_ERROR: -6,

    /* compression levels */
    Z_NO_COMPRESSION:         0,
    Z_BEST_SPEED:             1,
    Z_BEST_COMPRESSION:       9,
    Z_DEFAULT_COMPRESSION:   -1,


    Z_FILTERED:               1,
    Z_HUFFMAN_ONLY:           2,
    Z_RLE:                    3,
    Z_FIXED:                  4,
    Z_DEFAULT_STRATEGY:       0,

    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY:                 0,
    Z_TEXT:                   1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN:                2,

    /* The deflate compression method */
    Z_DEFLATED:               8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;




  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,
    Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,
    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
    Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
    Z_UNKNOWN,
    Z_DEFLATED: Z_DEFLATED$2
  } = constants$2;

  /*============================================================================*/


  const MAX_MEM_LEVEL = 9;
  /* Maximum value for memLevel in deflateInit2 */
  const MAX_WBITS$1 = 15;
  /* 32K LZ77 window */
  const DEF_MEM_LEVEL = 8;


  const LENGTH_CODES  = 29;
  /* number of length codes, not counting the special END_BLOCK code */
  const LITERALS      = 256;
  /* number of literal bytes 0..255 */
  const L_CODES       = LITERALS + 1 + LENGTH_CODES;
  /* number of Literal or Length codes, including the END_BLOCK code */
  const D_CODES       = 30;
  /* number of distance codes */
  const BL_CODES      = 19;
  /* number of codes used to transfer the bit lengths */
  const HEAP_SIZE     = 2 * L_CODES + 1;
  /* maximum heap size */
  const MAX_BITS  = 15;
  /* All codes must not exceed MAX_BITS bits */

  const MIN_MATCH = 3;
  const MAX_MATCH = 258;
  const MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

  const PRESET_DICT = 0x20;

  const INIT_STATE    =  42;    /* zlib header -> BUSY_STATE */
  //#ifdef GZIP
  const GZIP_STATE    =  57;    /* gzip header -> BUSY_STATE | EXTRA_STATE */
  //#endif
  const EXTRA_STATE   =  69;    /* gzip extra block -> NAME_STATE */
  const NAME_STATE    =  73;    /* gzip file name -> COMMENT_STATE */
  const COMMENT_STATE =  91;    /* gzip comment -> HCRC_STATE */
  const HCRC_STATE    = 103;    /* gzip header CRC -> BUSY_STATE */
  const BUSY_STATE    = 113;    /* deflate -> FINISH_STATE */
  const FINISH_STATE  = 666;    /* stream complete */

  const BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
  const BS_BLOCK_DONE     = 2; /* block flush performed */
  const BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
  const BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

  const OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

  const err = (strm, errorCode) => {
    strm.msg = messages[errorCode];
    return errorCode;
  };

  const rank = (f) => {
    return ((f) * 2) - ((f) > 4 ? 9 : 0);
  };

  const zero = (buf) => {
    let len = buf.length; while (--len >= 0) { buf[len] = 0; }
  };

  /* ===========================================================================
   * Slide the hash table when sliding the window down (could be avoided with 32
   * bit values at the expense of memory usage). We slide even when level == 0 to
   * keep the hash table consistent if we switch back to level > 0 later.
   */
  const slide_hash = (s) => {
    let n, m;
    let p;
    let wsize = s.w_size;

    n = s.hash_size;
    p = n;
    do {
      m = s.head[--p];
      s.head[p] = (m >= wsize ? m - wsize : 0);
    } while (--n);
    n = wsize;
  //#ifndef FASTEST
    p = n;
    do {
      m = s.prev[--p];
      s.prev[p] = (m >= wsize ? m - wsize : 0);
      /* If n is not on any hash chain, prev[n] is garbage but
       * its value will never be used.
       */
    } while (--n);
  //#endif
  };

  /* eslint-disable new-cap */
  let HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;
  // This hash causes less collisions, https://github.com/nodeca/pako/issues/135
  // But breaks binary compatibility
  //let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;
  let HASH = HASH_ZLIB;


  /* =========================================================================
   * Flush as much pending output as possible. All deflate() output, except for
   * some deflate_stored() output, goes through this function so some
   * applications may wish to modify it to avoid allocating a large
   * strm->next_out buffer and copying into it. (See also read_buf()).
   */
  const flush_pending = (strm) => {
    const s = strm.state;

    //_tr_flush_bits(s);
    let len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) { return; }

    strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
    strm.next_out  += len;
    s.pending_out  += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending      -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  };


  const flush_block_only = (s, last) => {
    _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  };


  const put_byte = (s, b) => {
    s.pending_buf[s.pending++] = b;
  };


  /* =========================================================================
   * Put a short in the pending buffer. The 16-bit value is put in MSB order.
   * IN assertion: the stream state is correct and there is enough room in
   * pending_buf.
   */
  const putShortMSB = (s, b) => {

    //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
    s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
    s.pending_buf[s.pending++] = b & 0xff;
  };


  /* ===========================================================================
   * Read a new buffer from the current input stream, update the adler32
   * and total number of bytes read.  All deflate() input goes through
   * this function so some applications may wish to modify it to avoid
   * allocating a large strm->input buffer and copying from it.
   * (See also flush_pending()).
   */
  const read_buf = (strm, buf, start, size) => {

    let len = strm.avail_in;

    if (len > size) { len = size; }
    if (len === 0) { return 0; }

    strm.avail_in -= len;

    // zmemcpy(buf, strm->next_in, len);
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32_1(strm.adler, buf, len, start);
    }

    else if (strm.state.wrap === 2) {
      strm.adler = crc32_1(strm.adler, buf, len, start);
    }

    strm.next_in += len;
    strm.total_in += len;

    return len;
  };


  /* ===========================================================================
   * Set match_start to the longest match starting at the given string and
   * return its length. Matches shorter or equal to prev_length are discarded,
   * in which case the result is equal to prev_length and match_start is
   * garbage.
   * IN assertions: cur_match is the head of the hash chain for the current
   *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
   * OUT assertion: the match length is not greater than s->lookahead.
   */
  const longest_match = (s, cur_match) => {

    let chain_length = s.max_chain_length;      /* max hash chain length */
    let scan = s.strstart; /* current string */
    let match;                       /* matched string */
    let len;                           /* length of current match */
    let best_len = s.prev_length;              /* best match length so far */
    let nice_match = s.nice_match;             /* stop if match long enough */
    const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

    const _win = s.window; // shortcut

    const wmask = s.w_mask;
    const prev  = s.prev;

    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */

    const strend = s.strstart + MAX_MATCH;
    let scan_end1  = _win[scan + best_len - 1];
    let scan_end   = _win[scan + best_len];

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if (nice_match > s.lookahead) { nice_match = s.lookahead; }

    // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
      // Assert(cur_match < s->strstart, "no future");
      match = cur_match;

      /* Skip to next match if the match length cannot increase
       * or if the match length is less than 2.  Note that the checks below
       * for insufficient lookahead only occur occasionally for performance
       * reasons.  Therefore uninitialized memory will be accessed, and
       * conditional jumps will be made that depend on those values.
       * However the length of the match is limited to the lookahead, so
       * the output of deflate is not affected by the uninitialized values.
       */

      if (_win[match + best_len]     !== scan_end  ||
          _win[match + best_len - 1] !== scan_end1 ||
          _win[match]                !== _win[scan] ||
          _win[++match]              !== _win[scan + 1]) {
        continue;
      }

      /* The check at best_len-1 can be removed because it will be made
       * again later. (This heuristic is not always a win.)
       * It is not necessary to compare scan[2] and match[2] since they
       * are always equal when the other bytes match, given that
       * the hash keys are equal and that HASH_BITS >= 8.
       */
      scan += 2;
      match++;
      // Assert(*scan == *match, "match[2]?");

      /* We check for insufficient lookahead only every 8th comparison;
       * the 256th check will be made at strstart+258.
       */
      do {
        /*jshint noempty:false*/
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
               _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
               scan < strend);

      // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;

      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1  = _win[scan + best_len - 1];
        scan_end   = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  };


  /* ===========================================================================
   * Fill the window when the lookahead becomes insufficient.
   * Updates strstart and lookahead.
   *
   * IN assertion: lookahead < MIN_LOOKAHEAD
   * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
   *    At least one byte has been read, or avail_in == 0; reads are
   *    performed for at least two bytes (required for the zip translate_eol
   *    option -- not supported here).
   */
  const fill_window = (s) => {

    const _w_size = s.w_size;
    let n, more, str;

    //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

    do {
      more = s.window_size - s.lookahead - s.strstart;

      // JS ints have 32 bit, block below not needed
      /* Deal with !@#$% 64K limit: */
      //if (sizeof(int) <= 2) {
      //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
      //        more = wsize;
      //
      //  } else if (more == (unsigned)(-1)) {
      //        /* Very unlikely, but possible on 16 bit machine if
      //         * strstart == 0 && lookahead == 1 (input done a byte at time)
      //         */
      //        more--;
      //    }
      //}


      /* If the window is almost full and there is insufficient lookahead,
       * move the upper half to the lower one to make room in the upper half.
       */
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

        s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        /* we now have strstart >= MAX_DIST */
        s.block_start -= _w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
        slide_hash(s);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }

      /* If there was no sliding:
       *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
       *    more == window_size - lookahead - strstart
       * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
       * => more >= window_size - 2*WSIZE + 2
       * In the BIG_MEM or MMAP case (not yet supported),
       *   window_size == input_size + MIN_LOOKAHEAD  &&
       *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
       * Otherwise, window_size == 2*WSIZE so more >= 2.
       * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
       */
      //Assert(more >= 2, "more < 2");
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;

      /* Initialize the hash value now that we have some input: */
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];

        /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
  //#if MIN_MATCH != 3
  //        Call update_hash() MIN_MATCH-3 more times
  //#endif
        while (s.insert) {
          /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
      /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
       * but this is not important since only literal bytes will be emitted.
       */

    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

    /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
  //  if (s.high_water < s.window_size) {
  //    const curr = s.strstart + s.lookahead;
  //    let init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");
  };

  /* ===========================================================================
   * Copy without compression as much as possible from the input stream, return
   * the current block state.
   *
   * In case deflateParams() is used to later switch to a non-zero compression
   * level, s->matches (otherwise unused when storing) keeps track of the number
   * of hash table slides to perform. If s->matches is 1, then one hash table
   * slide will be done when switching. If s->matches is 2, the maximum value
   * allowed here, then the hash table will be cleared, since two or more slides
   * is the same as a clear.
   *
   * deflate_stored() is written to minimize the number of times an input byte is
   * copied. It is most efficient with large input and output buffers, which
   * maximizes the opportunites to have a single copy from next_in to next_out.
   */
  const deflate_stored = (s, flush) => {

    /* Smallest worthy block size when not flushing or finishing. By default
     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
     * large input and output buffers, the stored block size will be larger.
     */
    let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;

    /* Copy as many min_block or larger stored blocks directly to next_out as
     * possible. If flushing, copy the remaining available input to next_out as
     * stored blocks, if there is enough space.
     */
    let len, left, have, last = 0;
    let used = s.strm.avail_in;
    do {
      /* Set len to the maximum size block that we can copy directly with the
       * available input data and output space. Set left to how much of that
       * would be copied from what's left in the window.
       */
      len = 65535/* MAX_STORED */;     /* maximum deflate stored block length */
      have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
      if (s.strm.avail_out < have) {         /* need room for header */
        break;
      }
        /* maximum stored block length that will fit in avail_out: */
      have = s.strm.avail_out - have;
      left = s.strstart - s.block_start;  /* bytes left in window */
      if (len > left + s.strm.avail_in) {
        len = left + s.strm.avail_in;   /* limit len to the input */
      }
      if (len > have) {
        len = have;             /* limit len to the output */
      }

      /* If the stored block would be less than min_block in length, or if
       * unable to copy all of the available input when flushing, then try
       * copying to the window and the pending buffer instead. Also don't
       * write an empty block when flushing -- deflate() does that.
       */
      if (len < min_block && ((len === 0 && flush !== Z_FINISH$3) ||
                          flush === Z_NO_FLUSH$2 ||
                          len !== left + s.strm.avail_in)) {
        break;
      }

      /* Make a dummy stored block in pending to get the header bytes,
       * including any pending bits. This also updates the debugging counts.
       */
      last = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
      _tr_stored_block(s, 0, 0, last);

      /* Replace the lengths in the dummy stored block with len. */
      s.pending_buf[s.pending - 4] = len;
      s.pending_buf[s.pending - 3] = len >> 8;
      s.pending_buf[s.pending - 2] = ~len;
      s.pending_buf[s.pending - 1] = ~len >> 8;

      /* Write the stored block header bytes. */
      flush_pending(s.strm);

  //#ifdef ZLIB_DEBUG
  //    /* Update debugging counts for the data about to be copied. */
  //    s->compressed_len += len << 3;
  //    s->bits_sent += len << 3;
  //#endif

      /* Copy uncompressed bytes from the window to next_out. */
      if (left) {
        if (left > len) {
          left = len;
        }
        //zmemcpy(s->strm->next_out, s->window + s->block_start, left);
        s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
        s.strm.next_out += left;
        s.strm.avail_out -= left;
        s.strm.total_out += left;
        s.block_start += left;
        len -= left;
      }

      /* Copy uncompressed bytes directly from next_in to next_out, updating
       * the check value.
       */
      if (len) {
        read_buf(s.strm, s.strm.output, s.strm.next_out, len);
        s.strm.next_out += len;
        s.strm.avail_out -= len;
        s.strm.total_out += len;
      }
    } while (last === 0);

    /* Update the sliding window with the last s->w_size bytes of the copied
     * data, or append all of the copied data to the existing window if less
     * than s->w_size bytes were copied. Also update the number of bytes to
     * insert in the hash tables, in the event that deflateParams() switches to
     * a non-zero compression level.
     */
    used -= s.strm.avail_in;    /* number of input bytes directly copied */
    if (used) {
      /* If any input was used, then no unused input remains in the window,
       * therefore s->block_start == s->strstart.
       */
      if (used >= s.w_size) {  /* supplant the previous history */
        s.matches = 2;     /* clear hash */
        //zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
        s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
        s.strstart = s.w_size;
        s.insert = s.strstart;
      }
      else {
        if (s.window_size - s.strstart <= used) {
          /* Slide the window down. */
          s.strstart -= s.w_size;
          //zmemcpy(s->window, s->window + s->w_size, s->strstart);
          s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
          if (s.matches < 2) {
            s.matches++;   /* add a pending slide_hash() */
          }
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
        }
        //zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
        s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
        s.strstart += used;
        s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
      }
      s.block_start = s.strstart;
    }
    if (s.high_water < s.strstart) {
      s.high_water = s.strstart;
    }

    /* If the last block was written to next_out, then done. */
    if (last) {
      return BS_FINISH_DONE;
    }

    /* If flushing and all input has been consumed, then done. */
    if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 &&
      s.strm.avail_in === 0 && s.strstart === s.block_start) {
      return BS_BLOCK_DONE;
    }

    /* Fill the window with any remaining input. */
    have = s.window_size - s.strstart;
    if (s.strm.avail_in > have && s.block_start >= s.w_size) {
      /* Slide the window down. */
      s.block_start -= s.w_size;
      s.strstart -= s.w_size;
      //zmemcpy(s->window, s->window + s->w_size, s->strstart);
      s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
      if (s.matches < 2) {
        s.matches++;       /* add a pending slide_hash() */
      }
      have += s.w_size;      /* more space now */
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
    }
    if (have > s.strm.avail_in) {
      have = s.strm.avail_in;
    }
    if (have) {
      read_buf(s.strm, s.window, s.strstart, have);
      s.strstart += have;
      s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
    }
    if (s.high_water < s.strstart) {
      s.high_water = s.strstart;
    }

    /* There was not enough avail_out to write a complete worthy or flushed
     * stored block to next_out. Write a stored block to pending instead, if we
     * have enough input for a worthy block, or if flushing and there is enough
     * room for the remaining input as a stored block in the pending buffer.
     */
    have = (s.bi_valid + 42) >> 3;     /* number of header bytes */
      /* maximum stored block length that will fit in pending: */
    have = s.pending_buf_size - have > 65535/* MAX_STORED */ ? 65535/* MAX_STORED */ : s.pending_buf_size - have;
    min_block = have > s.w_size ? s.w_size : have;
    left = s.strstart - s.block_start;
    if (left >= min_block ||
       ((left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 &&
       s.strm.avail_in === 0 && left <= have)) {
      len = left > have ? have : left;
      last = flush === Z_FINISH$3 && s.strm.avail_in === 0 &&
           len === left ? 1 : 0;
      _tr_stored_block(s, s.block_start, len, last);
      s.block_start += len;
      flush_pending(s.strm);
    }

    /* We've done all we can with the available input and output. */
    return last ? BS_FINISH_STARTED : BS_NEED_MORE;
  };


  /* ===========================================================================
   * Compress as much as possible from the input stream, return the current
   * block state.
   * This function does not perform lazy evaluation of matches and inserts
   * new strings in the dictionary only for unmatched strings or for short
   * matches. It is used only for the fast compression options.
   */
  const deflate_fast = (s, flush) => {

    let hash_head;        /* head of the hash chain */
    let bflush;           /* set if current block must be flushed */

    for (;;) {
      /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the next match, plus MIN_MATCH bytes to insert the
       * string following the next match.
       */
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break; /* flush the current block */
        }
      }

      /* Insert the string window[strstart .. strstart+2] in the
       * dictionary, and set hash_head to the head of the hash chain:
       */
      hash_head = 0/*NIL*/;
      if (s.lookahead >= MIN_MATCH) {
        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
        /***/
      }

      /* Find the longest match, discarding those <= prev_length.
       * At this point we have always match_length < MIN_MATCH
       */
      if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */
      }
      if (s.match_length >= MIN_MATCH) {
        // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

        /*** _tr_tally_dist(s, s.strstart - s.match_start,
                       s.match_length - MIN_MATCH, bflush); ***/
        bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

        s.lookahead -= s.match_length;

        /* Insert new strings in the hash table only if the match length
         * is not too large. This saves time but degrades compression.
         */
        if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
          s.match_length--; /* string at strstart already in table */
          do {
            s.strstart++;
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
            /* strstart never exceeds WSIZE-MAX_MATCH, so there are
             * always MIN_MATCH bytes ahead.
             */
          } while (--s.match_length !== 0);
          s.strstart++;
        } else
        {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);

  //#if MIN_MATCH != 3
  //                Call UPDATE_HASH() MIN_MATCH-3 more times
  //#endif
          /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
           * matter since it will be recomputed at next deflate call.
           */
        }
      } else {
        /* No match, output a literal byte */
        //Tracevv((stderr,"%c", s.window[s.strstart]));
        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
        bflush = _tr_tally(s, 0, s.window[s.strstart]);

        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    }
    s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
    if (flush === Z_FINISH$3) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    return BS_BLOCK_DONE;
  };

  /* ===========================================================================
   * Same as above, but achieves better compression. We use a lazy
   * evaluation for matches: a match is finally adopted only if there is
   * no better match at the next window position.
   */
  const deflate_slow = (s, flush) => {

    let hash_head;          /* head of hash chain */
    let bflush;              /* set if current block must be flushed */

    let max_insert;

    /* Process the input block. */
    for (;;) {
      /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the next match, plus MIN_MATCH bytes to insert the
       * string following the next match.
       */
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) { break; } /* flush the current block */
      }

      /* Insert the string window[strstart .. strstart+2] in the
       * dictionary, and set hash_head to the head of the hash chain:
       */
      hash_head = 0/*NIL*/;
      if (s.lookahead >= MIN_MATCH) {
        /*** INSERT_STRING(s, s.strstart, hash_head); ***/
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
        /***/
      }

      /* Find the longest match, discarding those <= prev_length.
       */
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;

      if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
          s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 &&
           (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
      /* If there was a match at the previous step and the current
       * match is not better, output the previous match:
       */
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        /* Do not insert strings in hash table beyond this. */

        //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

        /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                       s.prev_length - MIN_MATCH, bflush);***/
        bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        /* Insert in hash table all strings up to the end of the match.
         * strstart-1 and strstart are already inserted. If there is not
         * enough lookahead, the last two strings are not inserted in
         * the hash table.
         */
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            /*** INSERT_STRING(s, s.strstart, hash_head); ***/
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
            /***/
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;

        if (bflush) {
          /*** FLUSH_BLOCK(s, 0); ***/
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
          /***/
        }

      } else if (s.match_available) {
        /* If there was no match at the previous position, output a
         * single literal. If there was a match but the current match
         * is longer, truncate the previous match to a single literal.
         */
        //Tracevv((stderr,"%c", s->window[s->strstart-1]));
        /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

        if (bflush) {
          /*** FLUSH_BLOCK_ONLY(s, 0) ***/
          flush_block_only(s, false);
          /***/
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        /* There is no previous match to compare with, wait for
         * the next step to decide.
         */
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    //Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s.match_available) {
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);

      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }

    return BS_BLOCK_DONE;
  };


  /* ===========================================================================
   * For Z_RLE, simply look for runs of bytes, generate matches only of distance
   * one.  Do not maintain a hash table.  (It will be regenerated if this run of
   * deflate switches away from Z_RLE.)
   */
  const deflate_rle = (s, flush) => {

    let bflush;            /* set if current block must be flushed */
    let prev;              /* byte at distance one to match */
    let scan, strend;      /* scan goes up to strend for length of run */

    const _win = s.window;

    for (;;) {
      /* Make sure that we always have enough lookahead, except
       * at the end of the input file. We need MAX_MATCH bytes
       * for the longest run, plus one for the unrolled loop.
       */
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) { break; } /* flush the current block */
      }

      /* See how many times the previous byte repeats */
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
            /*jshint noempty:false*/
          } while (prev === _win[++scan] && prev === _win[++scan] &&
                   prev === _win[++scan] && prev === _win[++scan] &&
                   prev === _win[++scan] && prev === _win[++scan] &&
                   prev === _win[++scan] && prev === _win[++scan] &&
                   scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
        //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
      }

      /* Emit match if have run of MIN_MATCH or longer, else emit literal */
      if (s.match_length >= MIN_MATCH) {
        //check_match(s, s.strstart, s.strstart - 1, s.match_length);

        /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
        bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);

        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        /* No match, output a literal byte */
        //Tracevv((stderr,"%c", s->window[s->strstart]));
        /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
        bflush = _tr_tally(s, 0, s.window[s.strstart]);

        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    return BS_BLOCK_DONE;
  };

  /* ===========================================================================
   * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
   * (It will be regenerated if this run of deflate switches away from Huffman.)
   */
  const deflate_huff = (s, flush) => {

    let bflush;             /* set if current block must be flushed */

    for (;;) {
      /* Make sure that we have a literal to write. */
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          break;      /* flush the current block */
        }
      }

      /* Output a literal byte */
      s.match_length = 0;
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH$3) {
      /*** FLUSH_BLOCK(s, 1); ***/
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      /***/
      return BS_FINISH_DONE;
    }
    if (s.sym_next) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
    return BS_BLOCK_DONE;
  };

  /* Values for max_lazy_match, good_match and max_chain_length, depending on
   * the desired pack level (0..9). The values given below have been tuned to
   * exclude worst case performance for pathological files. Better values may be
   * found for specific files.
   */
  function Config(good_length, max_lazy, nice_length, max_chain, func) {

    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }

  const configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

    new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
  ];


  /* ===========================================================================
   * Initialize the "longest match" routines for a new zlib stream
   */
  const lm_init = (s) => {

    s.window_size = 2 * s.w_size;

    /*** CLEAR_HASH(s); ***/
    zero(s.head); // Fill with NIL (= 0);

    /* Set the default configuration parameters:
     */
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;

    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  };


  function DeflateState() {
    this.strm = null;            /* pointer back to this zlib stream */
    this.status = 0;            /* as the name implies */
    this.pending_buf = null;      /* output still pending */
    this.pending_buf_size = 0;  /* size of pending_buf */
    this.pending_out = 0;       /* next pending byte to output to the stream */
    this.pending = 0;           /* nb of bytes in the pending buffer */
    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
    this.gzhead = null;         /* gzip header information to write */
    this.gzindex = 0;           /* where in extra, name, or comment */
    this.method = Z_DEFLATED$2; /* can only be DEFLATED */
    this.last_flush = -1;   /* value of flush param for previous deflate call */

    this.w_size = 0;  /* LZ77 window size (32K by default) */
    this.w_bits = 0;  /* log2(w_size)  (8..16) */
    this.w_mask = 0;  /* w_size - 1 */

    this.window = null;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size.
     */

    this.window_size = 0;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    this.prev = null;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    this.head = null;   /* Heads of the hash chains or NIL. */

    this.ins_h = 0;       /* hash index of string to be inserted */
    this.hash_size = 0;   /* number of elements in hash table */
    this.hash_bits = 0;   /* log2(hash_size) */
    this.hash_mask = 0;   /* hash_size-1 */

    this.hash_shift = 0;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    this.block_start = 0;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    this.match_length = 0;      /* length of best match */
    this.prev_match = 0;        /* previous match */
    this.match_available = 0;   /* set if previous match exists */
    this.strstart = 0;          /* start of string to insert */
    this.match_start = 0;       /* start of matching string */
    this.lookahead = 0;         /* number of valid bytes ahead in window */

    this.prev_length = 0;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    this.max_chain_length = 0;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    this.max_lazy_match = 0;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
    // That's alias to max_lazy_match, don't use directly
    //this.max_insert_length = 0;
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    this.level = 0;     /* compression level (1..9) */
    this.strategy = 0;  /* favor or force Huffman coding*/

    this.good_match = 0;
    /* Use a faster search when the previous match is longer than this */

    this.nice_match = 0; /* Stop searching when current match exceeds this */

                /* used by trees.c: */

    /* Didn't use ct_data typedef below to suppress compiler warning */

    // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    // Use flat array of DOUBLE size, with interleaved fata,
    // because JS does not support effective
    this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);

    this.l_desc   = null;         /* desc. for literal tree */
    this.d_desc   = null;         /* desc. for distance tree */
    this.bl_desc  = null;         /* desc. for bit length tree */

    //ush bl_count[MAX_BITS+1];
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    /* number of codes at each bit length for an optimal tree */

    //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
    zero(this.heap);

    this.heap_len = 0;               /* number of elements in the heap */
    this.heap_max = 0;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
    zero(this.depth);
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    this.sym_buf = 0;        /* buffer for distances and literals/lengths */

    this.lit_bufsize = 0;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    this.sym_next = 0;      /* running index in sym_buf */
    this.sym_end = 0;       /* symbol table full when sym_next reaches this */

    this.opt_len = 0;       /* bit length of current block with optimal trees */
    this.static_len = 0;    /* bit length of current block with static trees */
    this.matches = 0;       /* number of string matches in current block */
    this.insert = 0;        /* bytes at end of window left to insert */


    this.bi_buf = 0;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    this.bi_valid = 0;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

    // Used for window memory init. We safely ignore it for JS. That makes
    // sense only for pointers and memory check tools.
    //this.high_water = 0;
    /* High water mark offset in window for initialized bytes -- bytes above
     * this are set to zero in order to avoid memory check warnings when
     * longest match routines access bytes past the input.  This is then
     * updated to the new high water mark.
     */
  }


  /* =========================================================================
   * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
   */
  const deflateStateCheck = (strm) => {

    if (!strm) {
      return 1;
    }
    const s = strm.state;
    if (!s || s.strm !== strm || (s.status !== INIT_STATE &&
  //#ifdef GZIP
                                  s.status !== GZIP_STATE &&
  //#endif
                                  s.status !== EXTRA_STATE &&
                                  s.status !== NAME_STATE &&
                                  s.status !== COMMENT_STATE &&
                                  s.status !== HCRC_STATE &&
                                  s.status !== BUSY_STATE &&
                                  s.status !== FINISH_STATE)) {
      return 1;
    }
    return 0;
  };


  const deflateResetKeep = (strm) => {

    if (deflateStateCheck(strm)) {
      return err(strm, Z_STREAM_ERROR$2);
    }

    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;

    const s = strm.state;
    s.pending = 0;
    s.pending_out = 0;

    if (s.wrap < 0) {
      s.wrap = -s.wrap;
      /* was made negative by deflate(..., Z_FINISH); */
    }
    s.status =
  //#ifdef GZIP
      s.wrap === 2 ? GZIP_STATE :
  //#endif
      s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = (s.wrap === 2) ?
      0  // crc32(0, Z_NULL, 0)
    :
      1; // adler32(0, Z_NULL, 0)
    s.last_flush = -2;
    _tr_init(s);
    return Z_OK$3;
  };


  const deflateReset = (strm) => {

    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
      lm_init(strm.state);
    }
    return ret;
  };


  const deflateSetHeader = (strm, head) => {

    if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
      return Z_STREAM_ERROR$2;
    }
    strm.state.gzhead = head;
    return Z_OK$3;
  };


  const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {

    if (!strm) { // === Z_NULL
      return Z_STREAM_ERROR$2;
    }
    let wrap = 1;

    if (level === Z_DEFAULT_COMPRESSION$1) {
      level = 6;
    }

    if (windowBits < 0) { /* suppress zlib wrapper */
      wrap = 0;
      windowBits = -windowBits;
    }

    else if (windowBits > 15) {
      wrap = 2;           /* write gzip wrapper instead */
      windowBits -= 16;
    }


    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||
      windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
      strategy < 0 || strategy > Z_FIXED || (windowBits === 8 && wrap !== 1)) {
      return err(strm, Z_STREAM_ERROR$2);
    }


    if (windowBits === 8) {
      windowBits = 9;
    }
    /* until 256-byte window bug fixed */

    const s = new DeflateState();

    strm.state = s;
    s.strm = strm;
    s.status = INIT_STATE;     /* to pass state test in deflateReset() */

    s.wrap = wrap;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;

    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

    s.window = new Uint8Array(s.w_size * 2);
    s.head = new Uint16Array(s.hash_size);
    s.prev = new Uint16Array(s.w_size);

    // Don't need mem init magic for JS.
    //s.high_water = 0;  /* nothing written to s->window yet */

    s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    /* We overlay pending_buf and sym_buf. This works since the average size
     * for length/distance pairs over any compressed block is assured to be 31
     * bits or less.
     *
     * Analysis: The longest fixed codes are a length code of 8 bits plus 5
     * extra bits, for lengths 131 to 257. The longest fixed distance codes are
     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
     * possible fixed-codes length/distance pair is then 31 bits total.
     *
     * sym_buf starts one-fourth of the way into pending_buf. So there are
     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
     * in sym_buf is three bytes -- two for the distance and one for the
     * literal/length. As each symbol is consumed, the pointer to the next
     * sym_buf value to read moves forward three bytes. From that symbol, up to
     * 31 bits are written to pending_buf. The closest the written pending_buf
     * bits gets to the next sym_buf symbol to read is just before the last
     * code is written. At that time, 31*(n-2) bits have been written, just
     * after 24*(n-2) bits have been consumed from sym_buf. sym_buf starts at
     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n-1
     * symbols are written.) The closest the writing gets to what is unread is
     * then n+14 bits. Here n is lit_bufsize, which is 16384 by default, and
     * can range from 128 to 32768.
     *
     * Therefore, at a minimum, there are 142 bits of space between what is
     * written and what is read in the overlain buffers, so the symbols cannot
     * be overwritten by the compressed data. That space is actually 139 bits,
     * due to the three-bit fixed-code block header.
     *
     * That covers the case where either Z_FIXED is specified, forcing fixed
     * codes, or when the use of fixed codes is chosen, because that choice
     * results in a smaller compressed block than dynamic codes. That latter
     * condition then assures that the above analysis also covers all dynamic
     * blocks. A dynamic-code block will only be chosen to be emitted if it has
     * fewer bits than a fixed-code block would for the same set of symbols.
     * Therefore its average symbol length is assured to be less than 31. So
     * the compressed data for a dynamic block also cannot overwrite the
     * symbols from which it is being constructed.
     */

    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new Uint8Array(s.pending_buf_size);

    // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
    //s->sym_buf = s->pending_buf + s->lit_bufsize;
    s.sym_buf = s.lit_bufsize;

    //s->sym_end = (s->lit_bufsize - 1) * 3;
    s.sym_end = (s.lit_bufsize - 1) * 3;
    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */

    s.level = level;
    s.strategy = strategy;
    s.method = method;

    return deflateReset(strm);
  };

  const deflateInit = (strm, level) => {

    return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
  };


  /* ========================================================================= */
  const deflate$2 = (strm, flush) => {

    if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }

    const s = strm.state;

    if (!strm.output ||
        (strm.avail_in !== 0 && !strm.input) ||
        (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {
      return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }

    const old_flush = s.last_flush;
    s.last_flush = flush;

    /* Flush as much pending output as possible */
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        /* Since avail_out is 0, deflate will be called again with
         * more output space, but possibly with both pending and
         * avail_in equal to zero. There won't be anything to do,
         * but this is not an error situation so make sure we
         * return OK instead of BUF_ERROR at next call of deflate:
         */
        s.last_flush = -1;
        return Z_OK$3;
      }

      /* Make sure there is something to do and avoid duplicate consecutive
       * flushes. For repeated and useless calls with Z_FINISH, we keep
       * returning Z_STREAM_END instead of Z_BUF_ERROR.
       */
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
      flush !== Z_FINISH$3) {
      return err(strm, Z_BUF_ERROR$1);
    }

    /* User must not provide more input after the first FINISH: */
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR$1);
    }

    /* Write the header */
    if (s.status === INIT_STATE && s.wrap === 0) {
      s.status = BUSY_STATE;
    }
    if (s.status === INIT_STATE) {
      /* zlib header */
      let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;
      let level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  //#ifdef GZIP
    if (s.status === GZIP_STATE) {
      /* gzip header */
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;

        /* Compression must start with an empty pending buffer */
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra/* != Z_NULL*/) {
        let beg = s.pending;   /* start of bytes to update crc */
        let left = (s.gzhead.extra.length & 0xffff) - s.gzindex;
        while (s.pending + left > s.pending_buf_size) {
          let copy = s.pending_buf_size - s.pending;
          // zmemcpy(s.pending_buf + s.pending,
          //    s.gzhead.extra + s.gzindex, copy);
          s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
          s.pending = s.pending_buf_size;
          //--- HCRC_UPDATE(beg) ---//
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          //---//
          s.gzindex += copy;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
          left -= copy;
        }
        // JS specific: s.gzhead.extra may be TypedArray or Array for backward compatibility
        //              TypedArray.slice and TypedArray.from don't exist in IE10-IE11
        let gzhead_extra = new Uint8Array(s.gzhead.extra);
        // zmemcpy(s->pending_buf + s->pending,
        //     s->gzhead->extra + s->gzindex, left);
        s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
        s.pending += left;
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex = 0;
      }
      s.status = NAME_STATE;
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name/* != Z_NULL*/) {
        let beg = s.pending;   /* start of bytes to update crc */
        let val;
        do {
          if (s.pending === s.pending_buf_size) {
            //--- HCRC_UPDATE(beg) ---//
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            //---//
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
        s.gzindex = 0;
      }
      s.status = COMMENT_STATE;
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment/* != Z_NULL*/) {
        let beg = s.pending;   /* start of bytes to update crc */
        let val;
        do {
          if (s.pending === s.pending_buf_size) {
            //--- HCRC_UPDATE(beg) ---//
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            //---//
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          // JS specific: little magic to add zero terminator to end of string
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        //--- HCRC_UPDATE(beg) ---//
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        //---//
      }
      s.status = HCRC_STATE;
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
        }
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
      }
      s.status = BUSY_STATE;

      /* Compression must start with an empty pending buffer */
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  //#endif

    /* Start a new block or continue the current one.
     */
    if (strm.avail_in !== 0 || s.lookahead !== 0 ||
      (flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {
      let bstate = s.level === 0 ? deflate_stored(s, flush) :
                   s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                   s.strategy === Z_RLE ? deflate_rle(s, flush) :
                   configuration_table[s.level].func(s, flush);

      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          /* avoid BUF_ERROR next call, see above */
        }
        return Z_OK$3;
        /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
         * of deflate should use the same flush parameter to make sure
         * that the flush is complete. So we don't have to output an
         * empty block here, this will be done at next call. This also
         * ensures that for a very small output buffer, we emit at most
         * one empty block.
         */
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          _tr_align(s);
        }
        else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */

          _tr_stored_block(s, 0, 0, false);
          /* For a full flush, this empty block will be recognized
           * as a special marker by inflate_sync().
           */
          if (flush === Z_FULL_FLUSH$1) {
            /*** CLEAR_HASH(s); ***/             /* forget history */
            zero(s.head); // Fill with NIL (= 0);

            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
          return Z_OK$3;
        }
      }
    }

    if (flush !== Z_FINISH$3) { return Z_OK$3; }
    if (s.wrap <= 0) { return Z_STREAM_END$3; }

    /* Write the trailer */
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 0xff);
      put_byte(s, (strm.adler >> 8) & 0xff);
      put_byte(s, (strm.adler >> 16) & 0xff);
      put_byte(s, (strm.adler >> 24) & 0xff);
      put_byte(s, strm.total_in & 0xff);
      put_byte(s, (strm.total_in >> 8) & 0xff);
      put_byte(s, (strm.total_in >> 16) & 0xff);
      put_byte(s, (strm.total_in >> 24) & 0xff);
    }
    else
    {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 0xffff);
    }

    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    if (s.wrap > 0) { s.wrap = -s.wrap; }
    /* write the trailer only once! */
    return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
  };


  const deflateEnd = (strm) => {

    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }

    const status = strm.state.status;

    strm.state = null;

    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
  };


  /* =========================================================================
   * Initializes the compression dictionary from the given byte
   * sequence without producing any compressed output.
   */
  const deflateSetDictionary = (strm, dictionary) => {

    let dictLength = dictionary.length;

    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }

    const s = strm.state;
    const wrap = s.wrap;

    if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
      return Z_STREAM_ERROR$2;
    }

    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
    if (wrap === 1) {
      /* adler32(strm->adler, dictionary, dictLength); */
      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }

    s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

    /* if dictionary would fill window, just replace the history */
    if (dictLength >= s.w_size) {
      if (wrap === 0) {            /* already empty otherwise */
        /*** CLEAR_HASH(s); ***/
        zero(s.head); // Fill with NIL (= 0);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      /* use the tail */
      // dictionary = dictionary.slice(dictLength - s.w_size);
      let tmpDict = new Uint8Array(s.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    /* insert dictionary into window and hash */
    const avail = strm.avail_in;
    const next = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      let str = s.strstart;
      let n = s.lookahead - (MIN_MATCH - 1);
      do {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);

        s.prev[str & s.w_mask] = s.head[s.ins_h];

        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap;
    return Z_OK$3;
  };


  var deflateInit_1 = deflateInit;
  var deflateInit2_1 = deflateInit2;
  var deflateReset_1 = deflateReset;
  var deflateResetKeep_1 = deflateResetKeep;
  var deflateSetHeader_1 = deflateSetHeader;
  var deflate_2$1 = deflate$2;
  var deflateEnd_1 = deflateEnd;
  var deflateSetDictionary_1 = deflateSetDictionary;
  var deflateInfo = 'pako deflate (from Nodeca project)';

  /* Not implemented
  module.exports.deflateBound = deflateBound;
  module.exports.deflateCopy = deflateCopy;
  module.exports.deflateGetDictionary = deflateGetDictionary;
  module.exports.deflateParams = deflateParams;
  module.exports.deflatePending = deflatePending;
  module.exports.deflatePrime = deflatePrime;
  module.exports.deflateTune = deflateTune;
  */

  var deflate_1$2 = {
  	deflateInit: deflateInit_1,
  	deflateInit2: deflateInit2_1,
  	deflateReset: deflateReset_1,
  	deflateResetKeep: deflateResetKeep_1,
  	deflateSetHeader: deflateSetHeader_1,
  	deflate: deflate_2$1,
  	deflateEnd: deflateEnd_1,
  	deflateSetDictionary: deflateSetDictionary_1,
  	deflateInfo: deflateInfo
  };

  const _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };

  var assign = function (obj /*from1, from2, from3, ...*/) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) { continue; }

      if (typeof source !== 'object') {
        throw new TypeError(source + 'must be non-object');
      }

      for (const p in source) {
        if (_has(source, p)) {
          obj[p] = source[p];
        }
      }
    }

    return obj;
  };


  // Join array of chunks to single array.
  var flattenChunks = (chunks) => {
    // calculate data length
    let len = 0;

    for (let i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    const result = new Uint8Array(len);

    for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
      let chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  };

  var common = {
  	assign: assign,
  	flattenChunks: flattenChunks
  };

  // String encode/decode helpers


  // Quick check if we can use fast array to bin string conversion
  //
  // - apply(Array) can fail on Android 2.2
  // - apply(Uint8Array) can fail on iOS 5.1 Safari
  //
  let STR_APPLY_UIA_OK = true;

  try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


  // Table with utf8 lengths (calculated by first byte of sequence)
  // Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
  // because max possible codepoint is 0x10ffff
  const _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
  }
  _utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


  // convert string to array (typed, when possible)
  var string2buf = (str) => {
    if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str);
    }

    let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }
      buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    buf = new Uint8Array(buf_len);

    // convert
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 0xfc00) === 0xdc00) {
          c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
          m_pos++;
        }
      }
      if (c < 0x80) {
        /* one byte */
        buf[i++] = c;
      } else if (c < 0x800) {
        /* two bytes */
        buf[i++] = 0xC0 | (c >>> 6);
        buf[i++] = 0x80 | (c & 0x3f);
      } else if (c < 0x10000) {
        /* three bytes */
        buf[i++] = 0xE0 | (c >>> 12);
        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
        buf[i++] = 0x80 | (c & 0x3f);
      } else {
        /* four bytes */
        buf[i++] = 0xf0 | (c >>> 18);
        buf[i++] = 0x80 | (c >>> 12 & 0x3f);
        buf[i++] = 0x80 | (c >>> 6 & 0x3f);
        buf[i++] = 0x80 | (c & 0x3f);
      }
    }

    return buf;
  };

  // Helper
  const buf2binstring = (buf, len) => {
    // On Chrome, the arguments in a function call that are allowed is `65534`.
    // If the length of the buffer is smaller than that, we can use this optimization,
    // otherwise we will take a slower path.
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }

    let result = '';
    for (let i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  };


  // convert array to string
  var buf2string = (buf, max) => {
    const len = max || buf.length;

    if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }

    let i, out;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    const utf16buf = new Array(len * 2);

    for (out = 0, i = 0; i < len;) {
      let c = buf[i++];
      // quick process ascii
      if (c < 0x80) { utf16buf[out++] = c; continue; }

      let c_len = _utf8len[c];
      // skip 5 & 6 byte codes
      if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

      // apply mask on first byte
      c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
      // join the rest
      while (c_len > 1 && i < len) {
        c = (c << 6) | (buf[i++] & 0x3f);
        c_len--;
      }

      // terminated by end of string?
      if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

      if (c < 0x10000) {
        utf16buf[out++] = c;
      } else {
        c -= 0x10000;
        utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
        utf16buf[out++] = 0xdc00 | (c & 0x3ff);
      }
    }

    return buf2binstring(utf16buf, out);
  };


  // Calculate max possible position in utf8 buffer,
  // that will not break sequence. If that's not possible
  // - (very small limits) return max size as is.
  //
  // buf[] - utf8 bytes array
  // max   - length limit (mandatory);
  var utf8border = (buf, max) => {

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means buffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
  };

  var strings = {
  	string2buf: string2buf,
  	buf2string: buf2string,
  	utf8border: utf8border
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function ZStream() {
    /* next input byte */
    this.input = null; // JS specific, because we have no pointers
    this.next_in = 0;
    /* number of bytes available at input */
    this.avail_in = 0;
    /* total number of input bytes read so far */
    this.total_in = 0;
    /* next output byte should be put there */
    this.output = null; // JS specific, because we have no pointers
    this.next_out = 0;
    /* remaining free space at output */
    this.avail_out = 0;
    /* total number of bytes output so far */
    this.total_out = 0;
    /* last error message, NULL if no error */
    this.msg = ''/*Z_NULL*/;
    /* not visible by applications */
    this.state = null;
    /* best guess about the data type: binary or text */
    this.data_type = 2/*Z_UNKNOWN*/;
    /* adler32 value of the uncompressed data */
    this.adler = 0;
  }

  var zstream = ZStream;

  const toString$1 = Object.prototype.toString;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,
    Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,
    Z_DEFAULT_COMPRESSION,
    Z_DEFAULT_STRATEGY,
    Z_DEFLATED: Z_DEFLATED$1
  } = constants$2;

  /* ===========================================================================*/


  /**
   * class Deflate
   *
   * Generic JS-style wrapper for zlib calls. If you don't need
   * streaming behaviour - use more simple functions: [[deflate]],
   * [[deflateRaw]] and [[gzip]].
   **/

  /* internal
   * Deflate.chunks -> Array
   *
   * Chunks of output data, if [[Deflate#onData]] not overridden.
   **/

  /**
   * Deflate.result -> Uint8Array
   *
   * Compressed result, generated by default [[Deflate#onData]]
   * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
   * (call [[Deflate#push]] with `Z_FINISH` / `true` param).
   **/

  /**
   * Deflate.err -> Number
   *
   * Error code after deflate finished. 0 (Z_OK) on success.
   * You will not need it in real life, because deflate errors
   * are possible only on wrong options or bad `onData` / `onEnd`
   * custom handlers.
   **/

  /**
   * Deflate.msg -> String
   *
   * Error message, if [[Deflate.err]] != 0
   **/


  /**
   * new Deflate(options)
   * - options (Object): zlib deflate options.
   *
   * Creates new deflator instance with specified params. Throws exception
   * on bad params. Supported options:
   *
   * - `level`
   * - `windowBits`
   * - `memLevel`
   * - `strategy`
   * - `dictionary`
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Additional options, for internal needs:
   *
   * - `chunkSize` - size of generated data chunks (16K by default)
   * - `raw` (Boolean) - do raw deflate
   * - `gzip` (Boolean) - create gzip wrapper
   * - `header` (Object) - custom header for gzip
   *   - `text` (Boolean) - true if compressed data believed to be text
   *   - `time` (Number) - modification time, unix timestamp
   *   - `os` (Number) - operation system code
   *   - `extra` (Array) - array of bytes with extra data (max 65536)
   *   - `name` (String) - file name (binary string)
   *   - `comment` (String) - comment (binary string)
   *   - `hcrc` (Boolean) - true if header crc should be added
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
   *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
   *
   * const deflate = new pako.Deflate({ level: 3});
   *
   * deflate.push(chunk1, false);
   * deflate.push(chunk2, true);  // true -> last chunk
   *
   * if (deflate.err) { throw new Error(deflate.err); }
   *
   * console.log(deflate.result);
   * ```
   **/
  function Deflate$1(options) {
    this.options = common.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED$1,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY
    }, options || {});

    let opt = this.options;

    if (opt.raw && (opt.windowBits > 0)) {
      opt.windowBits = -opt.windowBits;
    }

    else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
      opt.windowBits += 16;
    }

    this.err    = 0;      // error code, if happens (0 = Z_OK)
    this.msg    = '';     // error message
    this.ended  = false;  // used to avoid multiple onEnd() calls
    this.chunks = [];     // chunks of compressed data

    this.strm = new zstream();
    this.strm.avail_out = 0;

    let status = deflate_1$2.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );

    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }

    if (opt.header) {
      deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }

    if (opt.dictionary) {
      let dict;
      // Convert data if needed
      if (typeof opt.dictionary === 'string') {
        // If we need to compress text, change encoding to utf8.
        dict = strings.string2buf(opt.dictionary);
      } else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }

      status = deflate_1$2.deflateSetDictionary(this.strm, dict);

      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }

      this._dict_set = true;
    }
  }

  /**
   * Deflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be
   *   converted to utf8 byte sequence.
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
   *
   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
   * new compressed chunks. Returns `true` on success. The last data block must
   * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending
   * buffers and call [[Deflate#onEnd]].
   *
   * On fail call [[Deflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/
  Deflate$1.prototype.push = function (data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;

    if (this.ended) { return false; }

    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;

    // Convert data if needed
    if (typeof data === 'string') {
      // If we need to compress text, change encoding to utf8.
      strm.input = strings.string2buf(data);
    } else if (toString$1.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    for (;;) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      // Make sure avail_out > 6 to avoid repeating markers
      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }

      status = deflate_1$2.deflate(strm, _flush_mode);

      // Ended => flush and finish
      if (status === Z_STREAM_END$2) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = deflate_1$2.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK$2;
      }

      // Flush if out buffer full
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }

      // Flush if requested and has data
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }

      if (strm.avail_in === 0) break;
    }

    return true;
  };


  /**
   * Deflate#onData(chunk) -> Void
   * - chunk (Uint8Array): output data.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/
  Deflate$1.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };


  /**
   * Deflate#onEnd(status) -> Void
   * - status (Number): deflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called once after you tell deflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/
  Deflate$1.prototype.onEnd = function (status) {
    // On success - join
    if (status === Z_OK$2) {
      this.result = common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };


  /**
   * deflate(data[, options]) -> Uint8Array
   * - data (Uint8Array|ArrayBuffer|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * Compress `data` with deflate algorithm and `options`.
   *
   * Supported options are:
   *
   * - level
   * - windowBits
   * - memLevel
   * - strategy
   * - dictionary
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);
   *
   * console.log(pako.deflate(data));
   * ```
   **/
  function deflate$1(input, options) {
    const deflator = new Deflate$1(options);

    deflator.push(input, true);

    // That will never happens, if you don't cheat with options :)
    if (deflator.err) { throw deflator.msg || messages[deflator.err]; }

    return deflator.result;
  }


  /**
   * deflateRaw(data[, options]) -> Uint8Array
   * - data (Uint8Array|ArrayBuffer|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * The same as [[deflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/
  function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
  }


  /**
   * gzip(data[, options]) -> Uint8Array
   * - data (Uint8Array|ArrayBuffer|String): input data to compress.
   * - options (Object): zlib deflate options.
   *
   * The same as [[deflate]], but create gzip wrapper instead of
   * deflate one.
   **/
  function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
  }


  var Deflate_1$1 = Deflate$1;
  var deflate_2 = deflate$1;
  var deflateRaw_1$1 = deflateRaw$1;
  var gzip_1$1 = gzip$1;
  var constants$1 = constants$2;

  var deflate_1$1 = {
  	Deflate: Deflate_1$1,
  	deflate: deflate_2,
  	deflateRaw: deflateRaw_1$1,
  	gzip: gzip_1$1,
  	constants: constants$1
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  // See state defs from inflate.js
  const BAD$1 = 16209;       /* got a data error -- remain here until reset */
  const TYPE$1 = 16191;      /* i: waiting for type bits, including last-flag bit */

  /*
     Decode literal, length, and distance codes and write out the resulting
     literal and match bytes until either not enough input or output is
     available, an end-of-block is encountered, or a data error is encountered.
     When large enough input and output buffers are supplied to inflate(), for
     example, a 16K input buffer and a 64K output buffer, more than 95% of the
     inflate execution time is spent in this routine.

     Entry assumptions:

          state.mode === LEN
          strm.avail_in >= 6
          strm.avail_out >= 258
          start >= strm.avail_out
          state.bits < 8

     On return, state.mode is one of:

          LEN -- ran out of enough output space or enough available input
          TYPE -- reached end of block code, inflate() to interpret next block
          BAD -- error in block data

     Notes:

      - The maximum input bits used by a length/distance pair is 15 bits for the
        length code, 5 bits for the length extra, 15 bits for the distance code,
        and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
        Therefore if strm.avail_in >= 6, then there is enough input to avoid
        checking for available input while decoding.

      - The maximum bytes that a single length/distance pair can output is 258
        bytes, which is the maximum length that can be coded.  inflate_fast()
        requires strm.avail_out >= 258 for each loop to avoid checking for
        output space.
   */
  var inffast = function inflate_fast(strm, start) {
    let _in;                    /* local strm.input */
    let last;                   /* have enough input while in < last */
    let _out;                   /* local strm.output */
    let beg;                    /* inflate()'s initial strm.output */
    let end;                    /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT
    let dmax;                   /* maximum distance from zlib header */
  //#endif
    let wsize;                  /* window size or zero if not using window */
    let whave;                  /* valid bytes in the window */
    let wnext;                  /* window write index */
    // Use `s_window` instead `window`, avoid conflict with instrumentation tools
    let s_window;               /* allocated sliding window, if wsize != 0 */
    let hold;                   /* local strm.hold */
    let bits;                   /* local strm.bits */
    let lcode;                  /* local strm.lencode */
    let dcode;                  /* local strm.distcode */
    let lmask;                  /* mask for first level of length codes */
    let dmask;                  /* mask for first level of distance codes */
    let here;                   /* retrieved table entry */
    let op;                     /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    let len;                    /* match length, unused bytes */
    let dist;                   /* match distance */
    let from;                   /* where to copy match from */
    let from_source;


    let input, output; // JS specific, because we have no pointers

    /* copy state to local variables */
    const state = strm.state;
    //here = state.here;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
  //#ifdef INFLATE_STRICT
    dmax = state.dmax;
  //#endif
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;


    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */

    top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }

      here = lcode[hold & lmask];

      dolen:
      for (;;) { // Goto emulation
        op = here >>> 24/*here.bits*/;
        hold >>>= op;
        bits -= op;
        op = (here >>> 16) & 0xff/*here.op*/;
        if (op === 0) {                          /* literal */
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          output[_out++] = here & 0xffff/*here.val*/;
        }
        else if (op & 16) {                     /* length base */
          len = here & 0xffff/*here.val*/;
          op &= 15;                           /* number of extra bits */
          if (op) {
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
            }
            len += hold & ((1 << op) - 1);
            hold >>>= op;
            bits -= op;
          }
          //Tracevv((stderr, "inflate:         length %u\n", len));
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = dcode[hold & dmask];

          dodist:
          for (;;) { // goto emulation
            op = here >>> 24/*here.bits*/;
            hold >>>= op;
            bits -= op;
            op = (here >>> 16) & 0xff/*here.op*/;

            if (op & 16) {                      /* distance base */
              dist = here & 0xffff/*here.val*/;
              op &= 15;                       /* number of extra bits */
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
              }
              dist += hold & ((1 << op) - 1);
  //#ifdef INFLATE_STRICT
              if (dist > dmax) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD$1;
                break top;
              }
  //#endif
              hold >>>= op;
              bits -= op;
              //Tracevv((stderr, "inflate:         distance %u\n", dist));
              op = _out - beg;                /* max distance in output */
              if (dist > op) {                /* see if copy from window */
                op = dist - op;               /* distance back in window */
                if (op > whave) {
                  if (state.sane) {
                    strm.msg = 'invalid distance too far back';
                    state.mode = BAD$1;
                    break top;
                  }

  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  //                if (len <= op - whave) {
  //                  do {
  //                    output[_out++] = 0;
  //                  } while (--len);
  //                  continue top;
  //                }
  //                len -= op - whave;
  //                do {
  //                  output[_out++] = 0;
  //                } while (--op > whave);
  //                if (op === 0) {
  //                  from = _out - dist;
  //                  do {
  //                    output[_out++] = output[from++];
  //                  } while (--len);
  //                  continue top;
  //                }
  //#endif
                }
                from = 0; // window index
                from_source = s_window;
                if (wnext === 0) {           /* very common case */
                  from += wsize - op;
                  if (op < len) {         /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;  /* rest from output */
                    from_source = output;
                  }
                }
                else if (wnext < op) {      /* wrap around window */
                  from += wsize + wnext - op;
                  op -= wnext;
                  if (op < len) {         /* some from end of window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = 0;
                    if (wnext < len) {  /* some from start of window */
                      op = wnext;
                      len -= op;
                      do {
                        output[_out++] = s_window[from++];
                      } while (--op);
                      from = _out - dist;      /* rest from output */
                      from_source = output;
                    }
                  }
                }
                else {                      /* contiguous in window */
                  from += wnext - op;
                  if (op < len) {         /* some from window */
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;  /* rest from output */
                    from_source = output;
                  }
                }
                while (len > 2) {
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  output[_out++] = from_source[from++];
                  len -= 3;
                }
                if (len) {
                  output[_out++] = from_source[from++];
                  if (len > 1) {
                    output[_out++] = from_source[from++];
                  }
                }
              }
              else {
                from = _out - dist;          /* copy direct from output */
                do {                        /* minimum length is three */
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  output[_out++] = output[from++];
                  len -= 3;
                } while (len > 2);
                if (len) {
                  output[_out++] = output[from++];
                  if (len > 1) {
                    output[_out++] = output[from++];
                  }
                }
              }
            }
            else if ((op & 64) === 0) {          /* 2nd level distance code */
              here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
              continue dodist;
            }
            else {
              strm.msg = 'invalid distance code';
              state.mode = BAD$1;
              break top;
            }

            break; // need to emulate goto via "continue"
          }
        }
        else if ((op & 64) === 0) {              /* 2nd level length code */
          here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
          continue dolen;
        }
        else if (op & 32) {                     /* end-of-block */
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.mode = TYPE$1;
          break top;
        }
        else {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD$1;
          break top;
        }

        break; // need to emulate goto via "continue"
      }
    } while (_in < last && _out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;

    /* update state and return */
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
    state.hold = hold;
    state.bits = bits;
    return;
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  const MAXBITS = 15;
  const ENOUGH_LENS$1 = 852;
  const ENOUGH_DISTS$1 = 592;
  //const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

  const CODES$1 = 0;
  const LENS$1 = 1;
  const DISTS$1 = 2;

  const lbase = new Uint16Array([ /* Length codes 257..285 base */
    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ]);

  const lext = new Uint8Array([ /* Length codes 257..285 extra */
    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
    19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
  ]);

  const dbase = new Uint16Array([ /* Distance codes 0..29 base */
    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    8193, 12289, 16385, 24577, 0, 0
  ]);

  const dext = new Uint8Array([ /* Distance codes 0..29 extra */
    16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
    23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
    28, 28, 29, 29, 64, 64
  ]);

  const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>
  {
    const bits = opts.bits;
        //here = opts.here; /* table entry for duplication */

    let len = 0;               /* a code's length in bits */
    let sym = 0;               /* index of code symbols */
    let min = 0, max = 0;          /* minimum and maximum code lengths */
    let root = 0;              /* number of index bits for root table */
    let curr = 0;              /* number of index bits for current table */
    let drop = 0;              /* code bits to drop for sub-table */
    let left = 0;                   /* number of prefix codes available */
    let used = 0;              /* code entries in table used */
    let huff = 0;              /* Huffman code */
    let incr;              /* for incrementing code, index */
    let fill;              /* index for replicating entries */
    let low;               /* low bits for current root entry */
    let mask;              /* mask for low root bits */
    let next;             /* next available space in table */
    let base = null;     /* base value table to use */
  //  let shoextra;    /* extra bits table to use */
    let match;                  /* use base and extra for symbol >= match */
    const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
    const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
    let extra = null;

    let here_bits, here_op, here_val;

    /*
     Process a set of code lengths to create a canonical Huffman code.  The
     code lengths are lens[0..codes-1].  Each length corresponds to the
     symbols 0..codes-1.  The Huffman code is generated by first sorting the
     symbols by length from short to long, and retaining the symbol order
     for codes with equal lengths.  Then the code starts with all zero bits
     for the first code of the shortest length, and the codes are integer
     increments for the same length, and zeros are appended as the length
     increases.  For the deflate format, these bits are stored backwards
     from their more natural integer increment ordering, and so when the
     decoding tables are built in the large loop below, the integer codes
     are incremented backwards.

     This routine assumes, but does not check, that all of the entries in
     lens[] are in the range 0..MAXBITS.  The caller must assure this.
     1..MAXBITS is interpreted as that code length.  zero means that that
     symbol does not occur in this code.

     The codes are sorted by computing a count of codes for each length,
     creating from that a table of starting indices for each length in the
     sorted table, and then entering the symbols in order in the sorted
     table.  The sorted table is work[], with that space being provided by
     the caller.

     The length counts are used for other purposes as well, i.e. finding
     the minimum and maximum length codes, determining if there are any
     codes at all, checking for a valid set of lengths, and looking ahead
     at length counts to determine sub-table sizes when building the
     decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }

    /* bound code lengths, force root to be within code lengths */
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) { break; }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {                     /* no symbols to code at all */
      //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
      //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
      //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
      table[table_index++] = (1 << 24) | (64 << 16) | 0;


      //table.op[opts.table_index] = 64;
      //table.bits[opts.table_index] = 1;
      //table.val[opts.table_index++] = 0;
      table[table_index++] = (1 << 24) | (64 << 16) | 0;

      opts.bits = 1;
      return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) { break; }
    }
    if (root < min) {
      root = min;
    }

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }        /* over-subscribed */
    }
    if (left > 0 && (type === CODES$1 || max !== 1)) {
      return -1;                      /* incomplete set */
    }

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }

    /*
     Create and fill in decoding tables.  In this loop, the table being
     filled is at next and has curr index bits.  The code being used is huff
     with length len.  That code is converted to an index by dropping drop
     bits off of the bottom.  For codes where len is less than drop + curr,
     those top drop + curr - len bits are incremented through all values to
     fill the table with replicated entries.

     root is the number of index bits for the root table.  When len exceeds
     root, sub-tables are created pointed to by the root entry with an index
     of the low root bits of huff.  This is saved in low to check for when a
     new sub-table should be started.  drop is zero when the root table is
     being filled, and drop is root when sub-tables are being filled.

     When a new sub-table is needed, it is necessary to look ahead in the
     code lengths to determine what size sub-table is needed.  The length
     counts are used for this, and so count[] is decremented as codes are
     entered in the tables.

     used keeps track of how many table entries have been allocated from the
     provided *table space.  It is checked for LENS and DIST tables against
     the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
     the initial root table size constants.  See the comments in inftrees.h
     for more information.

     sym increments through all symbols, and the loop terminates when
     all codes of length max, i.e. all codes, have been processed.  This
     routine permits incomplete codes, so another loop after this one fills
     in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    // poor man optimization - use if-else instead of switch,
    // to avoid deopts in old v8
    if (type === CODES$1) {
      base = extra = work;    /* dummy value--not used */
      match = 20;

    } else if (type === LENS$1) {
      base = lbase;
      extra = lext;
      match = 257;

    } else {                    /* DISTS */
      base = dbase;
      extra = dext;
      match = 0;
    }

    /* initialize opts for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = table_index;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = -1;                   /* trigger new sub-table when len > root */
    used = 1 << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
      (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
      return 1;
    }

    /* process all codes and make table entries */
    for (;;) {
      /* create table entry */
      here_bits = len - drop;
      if (work[sym] + 1 < match) {
        here_op = 0;
        here_val = work[sym];
      }
      else if (work[sym] >= match) {
        here_op = extra[work[sym] - match];
        here_val = base[work[sym] - match];
      }
      else {
        here_op = 32 + 64;         /* end of block */
        here_val = 0;
      }

      /* replicate for those indices with low len bits equal to huff */
      incr = 1 << (len - drop);
      fill = 1 << curr;
      min = fill;                 /* save offset to next table */
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
      } while (fill !== 0);

      /* backwards increment the len-bit code huff */
      incr = 1 << (len - 1);
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }

      /* go to next symbol, update count, len */
      sym++;
      if (--count[len] === 0) {
        if (len === max) { break; }
        len = lens[lens_index + work[sym]];
      }

      /* create new sub-table if needed */
      if (len > root && (huff & mask) !== low) {
        /* if first time, transition to sub-tables */
        if (drop === 0) {
          drop = root;
        }

        /* increment past last table */
        next += min;            /* here min is 1 << curr */

        /* determine length of next table */
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) { break; }
          curr++;
          left <<= 1;
        }

        /* check for enough space */
        used += 1 << curr;
        if ((type === LENS$1 && used > ENOUGH_LENS$1) ||
          (type === DISTS$1 && used > ENOUGH_DISTS$1)) {
          return 1;
        }

        /* point entry in root table to sub-table */
        low = huff & mask;
        /*table.op[low] = curr;
        table.bits[low] = root;
        table.val[low] = next - opts.table_index;*/
        table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
      }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
     at most one remaining entry, since if the code is incomplete, the
     maximum code length that was allowed to get this far is one bit) */
    if (huff !== 0) {
      //table.op[next + huff] = 64;            /* invalid code marker */
      //table.bits[next + huff] = len - drop;
      //table.val[next + huff] = 0;
      table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
    }

    /* set return parameters */
    //opts.table_index += used;
    opts.bits = root;
    return 0;
  };


  var inftrees = inflate_table;

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.






  const CODES = 0;
  const LENS = 1;
  const DISTS = 2;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,
    Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$2;


  /* STATES ====================================================================*/
  /* ===========================================================================*/


  const    HEAD = 16180;       /* i: waiting for magic header */
  const    FLAGS = 16181;      /* i: waiting for method and flags (gzip) */
  const    TIME = 16182;       /* i: waiting for modification time (gzip) */
  const    OS = 16183;         /* i: waiting for extra flags and operating system (gzip) */
  const    EXLEN = 16184;      /* i: waiting for extra length (gzip) */
  const    EXTRA = 16185;      /* i: waiting for extra bytes (gzip) */
  const    NAME = 16186;       /* i: waiting for end of file name (gzip) */
  const    COMMENT = 16187;    /* i: waiting for end of comment (gzip) */
  const    HCRC = 16188;       /* i: waiting for header crc (gzip) */
  const    DICTID = 16189;    /* i: waiting for dictionary check value */
  const    DICT = 16190;      /* waiting for inflateSetDictionary() call */
  const        TYPE = 16191;      /* i: waiting for type bits, including last-flag bit */
  const        TYPEDO = 16192;    /* i: same, but skip check to exit inflate on new block */
  const        STORED = 16193;    /* i: waiting for stored size (length and complement) */
  const        COPY_ = 16194;     /* i/o: same as COPY below, but only first time in */
  const        COPY = 16195;      /* i/o: waiting for input or output to copy stored block */
  const        TABLE = 16196;     /* i: waiting for dynamic block table lengths */
  const        LENLENS = 16197;   /* i: waiting for code length code lengths */
  const        CODELENS = 16198;  /* i: waiting for length/lit and distance code lengths */
  const            LEN_ = 16199;      /* i: same as LEN below, but only first time in */
  const            LEN = 16200;       /* i: waiting for length/lit/eob code */
  const            LENEXT = 16201;    /* i: waiting for length extra bits */
  const            DIST = 16202;      /* i: waiting for distance code */
  const            DISTEXT = 16203;   /* i: waiting for distance extra bits */
  const            MATCH = 16204;     /* o: waiting for output space to copy string */
  const            LIT = 16205;       /* o: waiting for output space to write literal */
  const    CHECK = 16206;     /* i: waiting for 32-bit check value */
  const    LENGTH = 16207;    /* i: waiting for 32-bit length (gzip) */
  const    DONE = 16208;      /* finished check, done -- remain here until reset */
  const    BAD = 16209;       /* got a data error -- remain here until reset */
  const    MEM = 16210;       /* got an inflate() memory error -- remain here until reset */
  const    SYNC = 16211;      /* looking for synchronization bytes to restart inflate() */

  /* ===========================================================================*/



  const ENOUGH_LENS = 852;
  const ENOUGH_DISTS = 592;
  //const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

  const MAX_WBITS = 15;
  /* 32K LZ77 window */
  const DEF_WBITS = MAX_WBITS;


  const zswap32 = (q) => {

    return  (((q >>> 24) & 0xff) +
            ((q >>> 8) & 0xff00) +
            ((q & 0xff00) << 8) +
            ((q & 0xff) << 24));
  };


  function InflateState() {
    this.strm = null;           /* pointer back to this zlib stream */
    this.mode = 0;              /* current inflate mode */
    this.last = false;          /* true if processing last block */
    this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip,
                                   bit 2 true to validate check value */
    this.havedict = false;      /* true if dictionary provided */
    this.flags = 0;             /* gzip header method and flags (0 if zlib), or
                                   -1 if raw or no header yet */
    this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
    this.check = 0;             /* protected copy of check value */
    this.total = 0;             /* protected copy of output count */
    // TODO: may be {}
    this.head = null;           /* where to save gzip header information */

    /* sliding window */
    this.wbits = 0;             /* log base 2 of requested window size */
    this.wsize = 0;             /* window size or zero if not using window */
    this.whave = 0;             /* valid bytes in the window */
    this.wnext = 0;             /* window write index */
    this.window = null;         /* allocated sliding window, if needed */

    /* bit accumulator */
    this.hold = 0;              /* input bit accumulator */
    this.bits = 0;              /* number of bits in "in" */

    /* for string and stored block copying */
    this.length = 0;            /* literal or length of data to copy */
    this.offset = 0;            /* distance back to copy string from */

    /* for table and code decoding */
    this.extra = 0;             /* extra bits needed */

    /* fixed and dynamic code tables */
    this.lencode = null;          /* starting table for length/literal codes */
    this.distcode = null;         /* starting table for distance codes */
    this.lenbits = 0;           /* index bits for lencode */
    this.distbits = 0;          /* index bits for distcode */

    /* dynamic table building */
    this.ncode = 0;             /* number of code length code lengths */
    this.nlen = 0;              /* number of length code lengths */
    this.ndist = 0;             /* number of distance code lengths */
    this.have = 0;              /* number of code lengths in lens[] */
    this.next = null;              /* next available space in codes[] */

    this.lens = new Uint16Array(320); /* temporary storage for code lengths */
    this.work = new Uint16Array(288); /* work area for code table building */

    /*
     because we don't have pointers in js, we use lencode and distcode directly
     as buffers so we don't need codes
    */
    //this.codes = new Int32Array(ENOUGH);       /* space for code tables */
    this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
    this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
    this.sane = 0;                   /* if false, allow invalid distance too far */
    this.back = 0;                   /* bits back of last unprocessed length/lit */
    this.was = 0;                    /* initial length of match */
  }


  const inflateStateCheck = (strm) => {

    if (!strm) {
      return 1;
    }
    const state = strm.state;
    if (!state || state.strm !== strm ||
      state.mode < HEAD || state.mode > SYNC) {
      return 1;
    }
    return 0;
  };


  const inflateResetKeep = (strm) => {

    if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = ''; /*Z_NULL*/
    if (state.wrap) {       /* to support ill-conceived Java test suite */
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.flags = -1;
    state.dmax = 32768;
    state.head = null/*Z_NULL*/;
    state.hold = 0;
    state.bits = 0;
    //state.lencode = state.distcode = state.next = state.codes;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);

    state.sane = 1;
    state.back = -1;
    //Tracev((stderr, "inflate: reset\n"));
    return Z_OK$1;
  };


  const inflateReset = (strm) => {

    if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);

  };


  const inflateReset2 = (strm, windowBits) => {
    let wrap;

    /* get the state */
    if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
    const state = strm.state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    }
    else {
      wrap = (windowBits >> 4) + 5;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }

    /* update state and reset the rest of it */
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };


  const inflateInit2 = (strm, windowBits) => {

    if (!strm) { return Z_STREAM_ERROR$1; }
    //strm.msg = Z_NULL;                 /* in case we return an error */

    const state = new InflateState();

    //if (state === Z_NULL) return Z_MEM_ERROR;
    //Tracev((stderr, "inflate: allocated\n"));
    strm.state = state;
    state.strm = strm;
    state.window = null/*Z_NULL*/;
    state.mode = HEAD;     /* to pass state test in inflateReset2() */
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null/*Z_NULL*/;
    }
    return ret;
  };


  const inflateInit = (strm) => {

    return inflateInit2(strm, DEF_WBITS);
  };


  /*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
   */
  let virgin = true;

  let lenfix, distfix; // We have no pointers in JS, so keep tables separate


  const fixedtables = (state) => {

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);

      /* literal/length table */
      let sym = 0;
      while (sym < 144) { state.lens[sym++] = 8; }
      while (sym < 256) { state.lens[sym++] = 9; }
      while (sym < 280) { state.lens[sym++] = 7; }
      while (sym < 288) { state.lens[sym++] = 8; }

      inftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

      /* distance table */
      sym = 0;
      while (sym < 32) { state.lens[sym++] = 5; }

      inftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

      /* do this just once */
      virgin = false;
    }

    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };


  /*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
   */
  const updatewindow = (strm, src, end, copy) => {

    let dist;
    const state = strm.state;

    /* if it hasn't been done already, allocate space for the window */
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;

      state.window = new Uint8Array(state.wsize);
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    }
    else {
      dist = state.wsize - state.wnext;
      if (dist > copy) {
        dist = copy;
      }
      //zmemcpy(state->window + state->wnext, end - copy, dist);
      state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
      copy -= dist;
      if (copy) {
        //zmemcpy(state->window, end - copy, copy);
        state.window.set(src.subarray(end - copy, end), 0);
        state.wnext = copy;
        state.whave = state.wsize;
      }
      else {
        state.wnext += dist;
        if (state.wnext === state.wsize) { state.wnext = 0; }
        if (state.whave < state.wsize) { state.whave += dist; }
      }
    }
    return 0;
  };


  const inflate$2 = (strm, flush) => {

    let state;
    let input, output;          // input/output buffers
    let next;                   /* next input INDEX */
    let put;                    /* next output INDEX */
    let have, left;             /* available input and output */
    let hold;                   /* bit buffer */
    let bits;                   /* bits in bit buffer */
    let _in, _out;              /* save starting available input and output */
    let copy;                   /* number of stored or match bytes to copy */
    let from;                   /* where to copy match bytes from */
    let from_source;
    let here = 0;               /* current decoding table entry */
    let here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
    //let last;                   /* parent table entry */
    let last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
    let len;                    /* length to copy for repeats, bits to drop */
    let ret;                    /* return code */
    const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */
    let opts;

    let n; // temporary variable for NEED_BITS

    const order = /* permutation of code lengths */
      new Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);


    if (inflateStateCheck(strm) || !strm.output ||
        (!strm.input && strm.avail_in !== 0)) {
      return Z_STREAM_ERROR$1;
    }

    state = strm.state;
    if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


    //--- LOAD() ---
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    //---

    _in = have;
    _out = left;
    ret = Z_OK$1;

    inf_leave: // goto emulation
    for (;;) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          //=== NEEDBITS(16);
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0/*crc32(0L, Z_NULL, 0)*/;
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//

            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) ||   /* check if zlib header allowed */
            (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
            strm.msg = 'incorrect header check';
            state.mode = BAD;
            break;
          }
          if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }
          //--- DROPBITS(4) ---//
          hold >>>= 4;
          bits -= 4;
          //---//
          len = (hold & 0x0f)/*BITS(4)*/ + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = 'invalid window size';
            state.mode = BAD;
            break;
          }

          // !!! pako patch. Force use `options.windowBits` if passed.
          // Required to always use max window size by default.
          state.dmax = 1 << state.wbits;
          //state.dmax = 1 << len;

          state.flags = 0;               /* indicate zlib header */
          //Tracev((stderr, "inflate:   zlib header ok\n"));
          strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
          state.mode = hold & 0x200 ? DICTID : TYPE;
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          break;
        case FLAGS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.flags = hold;
          if ((state.flags & 0xff) !== Z_DEFLATED) {
            strm.msg = 'unknown compression method';
            state.mode = BAD;
            break;
          }
          if (state.flags & 0xe000) {
            strm.msg = 'unknown header flags set';
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = ((hold >> 8) & 1);
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = TIME;
          /* falls through */
        case TIME:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.head) {
            state.head.time = hold;
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC4(state.check, hold)
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            hbuf[2] = (hold >>> 16) & 0xff;
            hbuf[3] = (hold >>> 24) & 0xff;
            state.check = crc32_1(state.check, hbuf, 4, 0);
            //===
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = OS;
          /* falls through */
        case OS:
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (state.head) {
            state.head.xflags = (hold & 0xff);
            state.head.os = (hold >> 8);
          }
          if ((state.flags & 0x0200) && (state.wrap & 4)) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = EXLEN;
          /* falls through */
        case EXLEN:
          if (state.flags & 0x0400) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              //=== CRC2(state.check, hold);
              hbuf[0] = hold & 0xff;
              hbuf[1] = (hold >>> 8) & 0xff;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              //===//
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
          }
          else if (state.head) {
            state.head.extra = null/*Z_NULL*/;
          }
          state.mode = EXTRA;
          /* falls through */
        case EXTRA:
          if (state.flags & 0x0400) {
            copy = state.length;
            if (copy > have) { copy = have; }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  // Use untyped array for more convenient processing later
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
                //zmemcpy(state.head.extra + len, next,
                //        len + copy > state.head.extra_max ?
                //        state.head.extra_max - len : copy);
              }
              if ((state.flags & 0x0200) && (state.wrap & 4)) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) { break inf_leave; }
          }
          state.length = 0;
          state.mode = NAME;
          /* falls through */
        case NAME:
          if (state.flags & 0x0800) {
            if (have === 0) { break inf_leave; }
            copy = 0;
            do {
              // TODO: 2 or 1 bytes?
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */
              if (state.head && len &&
                  (state.length < 65536 /*state.head.name_max*/)) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);

            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) { break inf_leave; }
          }
          else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
          /* falls through */
        case COMMENT:
          if (state.flags & 0x1000) {
            if (have === 0) { break inf_leave; }
            copy = 0;
            do {
              len = input[next + copy++];
              /* use constant limit because in js we should not preallocate memory */
              if (state.head && len &&
                  (state.length < 65536 /*state.head.comm_max*/)) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if ((state.flags & 0x0200) && (state.wrap & 4)) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) { break inf_leave; }
          }
          else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
          /* falls through */
        case HCRC:
          if (state.flags & 0x0200) {
            //=== NEEDBITS(16); */
            while (bits < 16) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if ((state.wrap & 4) && hold !== (state.check & 0xffff)) {
              strm.msg = 'header crc mismatch';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
          }
          if (state.head) {
            state.head.hcrc = ((state.flags >> 9) & 1);
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          strm.adler = state.check = zswap32(hold);
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = DICT;
          /* falls through */
        case DICT:
          if (state.havedict === 0) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
          state.mode = TYPE;
          /* falls through */
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case TYPEDO:
          if (state.last) {
            //--- BYTEBITS() ---//
            hold >>>= bits & 7;
            bits -= bits & 7;
            //---//
            state.mode = CHECK;
            break;
          }
          //=== NEEDBITS(3); */
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.last = (hold & 0x01)/*BITS(1)*/;
          //--- DROPBITS(1) ---//
          hold >>>= 1;
          bits -= 1;
          //---//

          switch ((hold & 0x03)/*BITS(2)*/) {
            case 0:                             /* stored block */
              //Tracev((stderr, "inflate:     stored block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = STORED;
              break;
            case 1:                             /* fixed block */
              fixedtables(state);
              //Tracev((stderr, "inflate:     fixed codes block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = LEN_;             /* decode codes */
              if (flush === Z_TREES) {
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2;
                //---//
                break inf_leave;
              }
              break;
            case 2:                             /* dynamic block */
              //Tracev((stderr, "inflate:     dynamic codes block%s\n",
              //        state.last ? " (last)" : ""));
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = 'invalid block type';
              state.mode = BAD;
          }
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break;
        case STORED:
          //--- BYTEBITS() ---// /* go to byte boundary */
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          //=== NEEDBITS(32); */
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
            strm.msg = 'invalid stored block lengths';
            state.mode = BAD;
            break;
          }
          state.length = hold & 0xffff;
          //Tracev((stderr, "inflate:       stored length %u\n",
          //        state.length));
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = COPY_;
          if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case COPY_:
          state.mode = COPY;
          /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) { copy = have; }
            if (copy > left) { copy = left; }
            if (copy === 0) { break inf_leave; }
            //--- zmemcpy(put, next, copy); ---
            output.set(input.subarray(next, next + copy), put);
            //---//
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          //Tracev((stderr, "inflate:       stored end\n"));
          state.mode = TYPE;
          break;
        case TABLE:
          //=== NEEDBITS(14); */
          while (bits < 14) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
          //--- DROPBITS(5) ---//
          hold >>>= 5;
          bits -= 5;
          //---//
          state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
          //--- DROPBITS(5) ---//
          hold >>>= 5;
          bits -= 5;
          //---//
          state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
          //--- DROPBITS(4) ---//
          hold >>>= 4;
          bits -= 4;
          //---//
  //#ifndef PKZIP_BUG_WORKAROUND
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = 'too many length or distance symbols';
            state.mode = BAD;
            break;
          }
  //#endif
          //Tracev((stderr, "inflate:       table sizes ok\n"));
          state.have = 0;
          state.mode = LENLENS;
          /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            //=== NEEDBITS(3);
            while (bits < 3) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          // We have separate tables & no pointers. 2 commented lines below not needed.
          //state.next = state.codes;
          //state.lencode = state.next;
          // Switch to use dynamic table
          state.lencode = state.lendyn;
          state.lenbits = 7;

          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;

          if (ret) {
            strm.msg = 'invalid code lengths set';
            state.mode = BAD;
            break;
          }
          //Tracev((stderr, "inflate:       code lengths ok\n"));
          state.have = 0;
          state.mode = CODELENS;
          /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;;) {
              here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            if (here_val < 16) {
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              state.lens[state.have++] = here_val;
            }
            else {
              if (here_val === 16) {
                //=== NEEDBITS(here.bits + 2);
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                if (state.have === 0) {
                  strm.msg = 'invalid bit length repeat';
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 0x03);//BITS(2);
                //--- DROPBITS(2) ---//
                hold >>>= 2;
                bits -= 2;
                //---//
              }
              else if (here_val === 17) {
                //=== NEEDBITS(here.bits + 3);
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                len = 0;
                copy = 3 + (hold & 0x07);//BITS(3);
                //--- DROPBITS(3) ---//
                hold >>>= 3;
                bits -= 3;
                //---//
              }
              else {
                //=== NEEDBITS(here.bits + 7);
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) { break inf_leave; }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                //===//
                //--- DROPBITS(here.bits) ---//
                hold >>>= here_bits;
                bits -= here_bits;
                //---//
                len = 0;
                copy = 11 + (hold & 0x7f);//BITS(7);
                //--- DROPBITS(7) ---//
                hold >>>= 7;
                bits -= 7;
                //---//
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }

          /* handle error breaks in while */
          if (state.mode === BAD) { break; }

          /* check for end-of-block code (better have one) */
          if (state.lens[256] === 0) {
            strm.msg = 'invalid code -- missing end-of-block';
            state.mode = BAD;
            break;
          }

          /* build code tables -- note: do not change the lenbits or distbits
             values here (9 and 6) without reading the comments in inftrees.h
             concerning the ENOUGH constants, which depend on those values */
          state.lenbits = 9;

          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;
          state.lenbits = opts.bits;
          // state.lencode = state.next;

          if (ret) {
            strm.msg = 'invalid literal/lengths set';
            state.mode = BAD;
            break;
          }

          state.distbits = 6;
          //state.distcode.copy(state.codes);
          // Switch to use dynamic table
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          // We have separate tables & no pointers. 2 commented lines below not needed.
          // state.next_index = opts.table_index;
          state.distbits = opts.bits;
          // state.distcode = state.next;

          if (ret) {
            strm.msg = 'invalid distances set';
            state.mode = BAD;
            break;
          }
          //Tracev((stderr, 'inflate:       codes ok\n'));
          state.mode = LEN_;
          if (flush === Z_TREES) { break inf_leave; }
          /* falls through */
        case LEN_:
          state.mode = LEN;
          /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            //--- RESTORE() ---
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            //---
            inffast(strm, _out);
            //--- LOAD() ---
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            //---

            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_op && (here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;;) {
              here = state.lencode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((last_bits + here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            //--- DROPBITS(last.bits) ---//
            hold >>>= last_bits;
            bits -= last_bits;
            //---//
            state.back += last_bits;
          }
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
            //        "inflate:         literal '%c'\n" :
            //        "inflate:         literal 0x%02x\n", here.val));
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            //Tracevv((stderr, "inflate:         end of block\n"));
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = 'invalid literal/length code';
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
          /* falls through */
        case LENEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
            //--- DROPBITS(state.extra) ---//
            hold >>>= state.extra;
            bits -= state.extra;
            //---//
            state.back += state.extra;
          }
          //Tracevv((stderr, "inflate:         length %u\n", state.length));
          state.was = state.length;
          state.mode = DIST;
          /* falls through */
        case DIST:
          for (;;) {
            here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if ((here_op & 0xf0) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;;) {
              here = state.distcode[last_val +
                      ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
              here_bits = here >>> 24;
              here_op = (here >>> 16) & 0xff;
              here_val = here & 0xffff;

              if ((last_bits + here_bits) <= bits) { break; }
              //--- PULLBYTE() ---//
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
              //---//
            }
            //--- DROPBITS(last.bits) ---//
            hold >>>= last_bits;
            bits -= last_bits;
            //---//
            state.back += last_bits;
          }
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = (here_op) & 15;
          state.mode = DISTEXT;
          /* falls through */
        case DISTEXT:
          if (state.extra) {
            //=== NEEDBITS(state.extra);
            n = state.extra;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
            //--- DROPBITS(state.extra) ---//
            hold >>>= state.extra;
            bits -= state.extra;
            //---//
            state.back += state.extra;
          }
  //#ifdef INFLATE_STRICT
          if (state.offset > state.dmax) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
  //#endif
          //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
          state.mode = MATCH;
          /* falls through */
        case MATCH:
          if (left === 0) { break inf_leave; }
          copy = _out - left;
          if (state.offset > copy) {         /* copy from window */
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = 'invalid distance too far back';
                state.mode = BAD;
                break;
              }
  // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  //          Trace((stderr, "inflate.c too far\n"));
  //          copy -= state.whave;
  //          if (copy > state.length) { copy = state.length; }
  //          if (copy > left) { copy = left; }
  //          left -= copy;
  //          state.length -= copy;
  //          do {
  //            output[put++] = 0;
  //          } while (--copy);
  //          if (state.length === 0) { state.mode = LEN; }
  //          break;
  //#endif
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            }
            else {
              from = state.wnext - copy;
            }
            if (copy > state.length) { copy = state.length; }
            from_source = state.window;
          }
          else {                              /* copy from output */
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) { copy = left; }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) { state.mode = LEN; }
          break;
        case LIT:
          if (left === 0) { break inf_leave; }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              // Use '|' instead of '+' to make sure that result is signed
              hold |= input[next++] << bits;
              bits += 8;
            }
            //===//
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if ((state.wrap & 4) && _out) {
              strm.adler = state.check =
                  /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  (state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));

            }
            _out = left;
            // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
            if ((state.wrap & 4) && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = 'incorrect data check';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            //Tracev((stderr, "inflate:   check matches trailer\n"));
          }
          state.mode = LENGTH;
          /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            //=== NEEDBITS(32);
            while (bits < 32) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            if ((state.wrap & 4) && hold !== (state.total & 0xffffffff)) {
              strm.msg = 'incorrect length check';
              state.mode = BAD;
              break;
            }
            //=== INITBITS();
            hold = 0;
            bits = 0;
            //===//
            //Tracev((stderr, "inflate:   length matches trailer\n"));
          }
          state.mode = DONE;
          /* falls through */
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
          /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }

    // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */

    //--- RESTORE() ---
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    //---

    if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                        (state.mode < CHECK || flush !== Z_FINISH$1))) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if ((state.wrap & 4) && _out) {
      strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) +
                      (state.mode === TYPE ? 128 : 0) +
                      (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };


  const inflateEnd = (strm) => {

    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }

    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };


  const inflateGetHeader = (strm, head) => {

    /* check state */
    if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
    const state = strm.state;
    if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }

    /* save header structure */
    state.head = head;
    head.done = false;
    return Z_OK$1;
  };


  const inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;

    let state;
    let dictid;
    let ret;

    /* check state */
    if (inflateStateCheck(strm)) { return Z_STREAM_ERROR$1; }
    state = strm.state;

    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }

    /* check for correct dictionary identifier */
    if (state.mode === DICT) {
      dictid = 1; /* adler32(0, null, 0)*/
      /* dictid = adler32(dictid, dictionary, dictLength); */
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    /* copy dictionary to window using updatewindow(), which will amend the
     existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    // Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK$1;
  };


  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$2;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = 'pako inflate (from Nodeca project)';

  /* Not implemented
  module.exports.inflateCodesUsed = inflateCodesUsed;
  module.exports.inflateCopy = inflateCopy;
  module.exports.inflateGetDictionary = inflateGetDictionary;
  module.exports.inflateMark = inflateMark;
  module.exports.inflatePrime = inflatePrime;
  module.exports.inflateSync = inflateSync;
  module.exports.inflateSyncPoint = inflateSyncPoint;
  module.exports.inflateUndermine = inflateUndermine;
  module.exports.inflateValidate = inflateValidate;
  */

  var inflate_1$2 = {
  	inflateReset: inflateReset_1,
  	inflateReset2: inflateReset2_1,
  	inflateResetKeep: inflateResetKeep_1,
  	inflateInit: inflateInit_1,
  	inflateInit2: inflateInit2_1,
  	inflate: inflate_2$1,
  	inflateEnd: inflateEnd_1,
  	inflateGetHeader: inflateGetHeader_1,
  	inflateSetDictionary: inflateSetDictionary_1,
  	inflateInfo: inflateInfo
  };

  // (C) 1995-2013 Jean-loup Gailly and Mark Adler
  // (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
  //
  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.
  //
  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:
  //
  // 1. The origin of this software must not be misrepresented; you must not
  //   claim that you wrote the original software. If you use this software
  //   in a product, an acknowledgment in the product documentation would be
  //   appreciated but is not required.
  // 2. Altered source versions must be plainly marked as such, and must not be
  //   misrepresented as being the original software.
  // 3. This notice may not be removed or altered from any source distribution.

  function GZheader() {
    /* true if compressed data believed to be text */
    this.text       = 0;
    /* modification time */
    this.time       = 0;
    /* extra flags (not used when writing a gzip file) */
    this.xflags     = 0;
    /* operating system */
    this.os         = 0;
    /* pointer to extra field or Z_NULL if none */
    this.extra      = null;
    /* extra field length (valid if extra != Z_NULL) */
    this.extra_len  = 0; // Actually, we don't need it in JS,
                         // but leave for few code modifications

    //
    // Setup limits is not necessary because in js we should not preallocate memory
    // for inflate use constant limit in 65536 bytes
    //

    /* space at extra (only when reading header) */
    // this.extra_max  = 0;
    /* pointer to zero-terminated file name or Z_NULL */
    this.name       = '';
    /* space at name (only when reading header) */
    // this.name_max   = 0;
    /* pointer to zero-terminated comment or Z_NULL */
    this.comment    = '';
    /* space at comment (only when reading header) */
    // this.comm_max   = 0;
    /* true if there was or will be a header crc */
    this.hcrc       = 0;
    /* true when done reading gzip header (not used when writing a gzip file) */
    this.done       = false;
  }

  var gzheader = GZheader;

  const toString$2 = Object.prototype.toString;

  /* Public constants ==========================================================*/
  /* ===========================================================================*/

  const {
    Z_NO_FLUSH, Z_FINISH,
    Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR
  } = constants$2;

  /* ===========================================================================*/


  /**
   * class Inflate
   *
   * Generic JS-style wrapper for zlib calls. If you don't need
   * streaming behaviour - use more simple functions: [[inflate]]
   * and [[inflateRaw]].
   **/

  /* internal
   * inflate.chunks -> Array
   *
   * Chunks of output data, if [[Inflate#onData]] not overridden.
   **/

  /**
   * Inflate.result -> Uint8Array|String
   *
   * Uncompressed result, generated by default [[Inflate#onData]]
   * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
   * (call [[Inflate#push]] with `Z_FINISH` / `true` param).
   **/

  /**
   * Inflate.err -> Number
   *
   * Error code after inflate finished. 0 (Z_OK) on success.
   * Should be checked if broken data possible.
   **/

  /**
   * Inflate.msg -> String
   *
   * Error message, if [[Inflate.err]] != 0
   **/


  /**
   * new Inflate(options)
   * - options (Object): zlib inflate options.
   *
   * Creates new inflator instance with specified params. Throws exception
   * on bad params. Supported options:
   *
   * - `windowBits`
   * - `dictionary`
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information on these.
   *
   * Additional options, for internal needs:
   *
   * - `chunkSize` - size of generated data chunks (16K by default)
   * - `raw` (Boolean) - do raw inflate
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   * By default, when no options set, autodetect deflate/gzip data format via
   * wrapper header.
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako')
   * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])
   * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);
   *
   * const inflate = new pako.Inflate({ level: 3});
   *
   * inflate.push(chunk1, false);
   * inflate.push(chunk2, true);  // true -> last chunk
   *
   * if (inflate.err) { throw new Error(inflate.err); }
   *
   * console.log(inflate.result);
   * ```
   **/
  function Inflate$1(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ''
    }, options || {});

    const opt = this.options;

    // Force window size for `raw` data, if not set directly,
    // because we have no header for autodetect.
    if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) { opt.windowBits = -15; }
    }

    // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
    if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
        !(options && options.windowBits)) {
      opt.windowBits += 32;
    }

    // Gzip header has no info about windows size, we can do autodetect only
    // for deflate. So, if window size not set, force it to max when gzip possible
    if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
      // bit 3 (16) -> gzipped data
      // bit 4 (32) -> autodetect gzip/deflate
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }

    this.err    = 0;      // error code, if happens (0 = Z_OK)
    this.msg    = '';     // error message
    this.ended  = false;  // used to avoid multiple onEnd() calls
    this.chunks = [];     // chunks of compressed data

    this.strm   = new zstream();
    this.strm.avail_out = 0;

    let status  = inflate_1$2.inflateInit2(
      this.strm,
      opt.windowBits
    );

    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }

    this.header = new gzheader();

    inflate_1$2.inflateGetHeader(this.strm, this.header);

    // Setup dictionary
    if (opt.dictionary) {
      // Convert data if needed
      if (typeof opt.dictionary === 'string') {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString$2.call(opt.dictionary) === '[object ArrayBuffer]') {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) { //In raw mode we need to set the dictionary early
        status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }

  /**
   * Inflate#push(data[, flush_mode]) -> Boolean
   * - data (Uint8Array|ArrayBuffer): input data
   * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE
   *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,
   *   `true` means Z_FINISH.
   *
   * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
   * new output chunks. Returns `true` on success. If end of stream detected,
   * [[Inflate#onEnd]] will be called.
   *
   * `flush_mode` is not needed for normal operation, because end of stream
   * detected automatically. You may try to use it for advanced things, but
   * this functionality was not tested.
   *
   * On fail call [[Inflate#onEnd]] with error code and return false.
   *
   * ##### Example
   *
   * ```javascript
   * push(chunk, false); // push one of data chunks
   * ...
   * push(chunk, true);  // push last chunk
   * ```
   **/
  Inflate$1.prototype.push = function (data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;

    if (this.ended) return false;

    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;

    // Convert data if needed
    if (toString$2.call(data) === '[object ArrayBuffer]') {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }

    strm.next_in = 0;
    strm.avail_in = strm.input.length;

    for (;;) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }

      status = inflate_1$2.inflate(strm, _flush_mode);

      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$2.inflateSetDictionary(strm, dictionary);

        if (status === Z_OK) {
          status = inflate_1$2.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          // Replace code with more verbose
          status = Z_NEED_DICT;
        }
      }

      // Skip snyc markers if more data follows and not raw mode
      while (strm.avail_in > 0 &&
             status === Z_STREAM_END &&
             strm.state.wrap > 0 &&
             data[strm.next_in] !== 0)
      {
        inflate_1$2.inflateReset(strm);
        status = inflate_1$2.inflate(strm, _flush_mode);
      }

      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }

      // Remember real `avail_out` value, because we may patch out buffer content
      // to align utf8 strings boundaries.
      last_avail_out = strm.avail_out;

      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {

          if (this.options.to === 'string') {

            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);

            // move tail & realign counters
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);

            this.onData(utf8str);

          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }

      // Must repeat iteration if out buffer is full
      if (status === Z_OK && last_avail_out === 0) continue;

      // Finalize if end of stream reached.
      if (status === Z_STREAM_END) {
        status = inflate_1$2.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }

      if (strm.avail_in === 0) break;
    }

    return true;
  };


  /**
   * Inflate#onData(chunk) -> Void
   * - chunk (Uint8Array|String): output data. When string output requested,
   *   each chunk will be string.
   *
   * By default, stores data blocks in `chunks[]` property and glue
   * those in `onEnd`. Override this handler, if you need another behaviour.
   **/
  Inflate$1.prototype.onData = function (chunk) {
    this.chunks.push(chunk);
  };


  /**
   * Inflate#onEnd(status) -> Void
   * - status (Number): inflate status. 0 (Z_OK) on success,
   *   other if not.
   *
   * Called either after you tell inflate that the input stream is
   * complete (Z_FINISH). By default - join collected chunks,
   * free memory and fill `results` / `err` properties.
   **/
  Inflate$1.prototype.onEnd = function (status) {
    // On success - join
    if (status === Z_OK) {
      if (this.options.to === 'string') {
        this.result = this.chunks.join('');
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };


  /**
   * inflate(data[, options]) -> Uint8Array|String
   * - data (Uint8Array|ArrayBuffer): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Decompress `data` with inflate/ungzip and `options`. Autodetect
   * format via wrapper header by default. That's why we don't provide
   * separate `ungzip` method.
   *
   * Supported options are:
   *
   * - windowBits
   *
   * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
   * for more information.
   *
   * Sugar (options):
   *
   * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
   *   negative windowBits implicitly.
   * - `to` (String) - if equal to 'string', then result will be converted
   *   from utf8 to utf16 (javascript) string. When string output requested,
   *   chunk length can differ from `chunkSize`, depending on content.
   *
   *
   * ##### Example:
   *
   * ```javascript
   * const pako = require('pako');
   * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));
   * let output;
   *
   * try {
   *   output = pako.inflate(input);
   * } catch (err) {
   *   console.log(err);
   * }
   * ```
   **/
  function inflate$1(input, options) {
    const inflator = new Inflate$1(options);

    inflator.push(input);

    // That will never happens, if you don't cheat with options :)
    if (inflator.err) throw inflator.msg || messages[inflator.err];

    return inflator.result;
  }


  /**
   * inflateRaw(data[, options]) -> Uint8Array|String
   * - data (Uint8Array|ArrayBuffer): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * The same as [[inflate]], but creates raw data, without wrapper
   * (header and adler32 crc).
   **/
  function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
  }


  /**
   * ungzip(data[, options]) -> Uint8Array|String
   * - data (Uint8Array|ArrayBuffer): input data to decompress.
   * - options (Object): zlib inflate options.
   *
   * Just shortcut to [[inflate]], because it autodetects format
   * by header.content. Done for convenience.
   **/


  var Inflate_1$1 = Inflate$1;
  var inflate_2 = inflate$1;
  var inflateRaw_1$1 = inflateRaw$1;
  var ungzip$1 = inflate$1;
  var constants = constants$2;

  var inflate_1$1 = {
  	Inflate: Inflate_1$1,
  	inflate: inflate_2,
  	inflateRaw: inflateRaw_1$1,
  	ungzip: ungzip$1,
  	constants: constants
  };

  const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;

  const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;



  var Deflate_1 = Deflate;
  var deflate_1 = deflate;
  var deflateRaw_1 = deflateRaw;
  var gzip_1 = gzip;
  var Inflate_1 = Inflate;
  var inflate_1 = inflate;
  var inflateRaw_1 = inflateRaw;
  var ungzip_1 = ungzip;
  var constants_1 = constants$2;

  var pako = {
  	Deflate: Deflate_1,
  	deflate: deflate_1,
  	deflateRaw: deflateRaw_1,
  	gzip: gzip_1,
  	Inflate: Inflate_1,
  	inflate: inflate_1,
  	inflateRaw: inflateRaw_1,
  	ungzip: ungzip_1,
  	constants: constants_1
  };

  // src/font-utils.js

  /**
   * Converts various font formats to EOT (Embedded OpenType),
   * which is highly compatible with PowerPoint embedding.
   * @param {string} type - 'ttf', 'woff', or 'otf'
   * @param {ArrayBuffer} fontBuffer - The raw font data
   */
  async function fontToEot(type, fontBuffer) {
    const options = {
      type,
      hinting: true,
      // inflate is required for WOFF decoding
      inflate: type === 'woff' ? pako.inflate : undefined,
    };

    const font = main_esmExports.Font.create(fontBuffer, options);

    const eotBuffer = font.write({
      type: 'eot',
      toBuffer: true,
    });

    if (eotBuffer instanceof ArrayBuffer) {
      return eotBuffer;
    }

    // Ensure we return an ArrayBuffer
    return eotBuffer.buffer.slice(eotBuffer.byteOffset, eotBuffer.byteOffset + eotBuffer.byteLength);
  }

  // src/font-embedder.js

  const START_RID = 201314;

  class PPTXEmbedFonts {
    constructor() {
      this.zip = null;
      this.rId = START_RID;
      this.fonts = []; // { name, data, rid }
    }

    async loadZip(zip) {
      this.zip = zip;
    }

    /**
     * Reads the font name from the buffer using opentype.js
     */
    getFontInfo(fontBuffer) {
      try {
        const font = opentype.parse(fontBuffer);
        const names = font.names;
        // Prefer English name, fallback to others
        const fontFamily = names.fontFamily.en || Object.values(names.fontFamily)[0];
        return { name: fontFamily };
      } catch (e) {
        console.warn('Could not parse font info', e);
        return { name: 'Unknown' };
      }
    }

    async addFont(fontFace, fontBuffer, type) {
      // Convert to EOT/fntdata for PPTX compatibility
      const eotData = await fontToEot(type, fontBuffer);
      const rid = this.rId++;
      this.fonts.push({ name: fontFace, data: eotData, rid });
    }

    async updateFiles() {
      await this.updateContentTypesXML();
      await this.updatePresentationXML();
      await this.updateRelsPresentationXML();
      this.updateFontFiles();
    }

    async generateBlob() {
      if (!this.zip) throw new Error('Zip not loaded');
      return this.zip.generateAsync({
        type: 'blob',
        compression: 'DEFLATE',
        compressionOptions: { level: 6 },
      });
    }

    // --- XML Manipulation Methods ---

    async updateContentTypesXML() {
      const file = this.zip.file('[Content_Types].xml');
      if (!file) throw new Error('[Content_Types].xml not found');

      const xmlStr = await file.async('string');
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlStr, 'text/xml');

      const types = doc.getElementsByTagName('Types')[0];
      const defaults = Array.from(doc.getElementsByTagName('Default'));

      const hasFntData = defaults.some((el) => el.getAttribute('Extension') === 'fntdata');

      if (!hasFntData) {
        const el = doc.createElement('Default');
        el.setAttribute('Extension', 'fntdata');
        el.setAttribute('ContentType', 'application/x-fontdata');
        types.insertBefore(el, types.firstChild);
      }

      this.zip.file('[Content_Types].xml', new XMLSerializer().serializeToString(doc));
    }

    async updatePresentationXML() {
      const file = this.zip.file('ppt/presentation.xml');
      if (!file) throw new Error('ppt/presentation.xml not found');

      const xmlStr = await file.async('string');
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlStr, 'text/xml');
      const presentation = doc.getElementsByTagName('p:presentation')[0];

      // Enable embedding flags
      presentation.setAttribute('saveSubsetFonts', 'true');
      presentation.setAttribute('embedTrueTypeFonts', 'true');

      // Find or create embeddedFontLst
      let embeddedFontLst = presentation.getElementsByTagName('p:embeddedFontLst')[0];

      if (!embeddedFontLst) {
        embeddedFontLst = doc.createElement('p:embeddedFontLst');

        // Insert before defaultTextStyle or at end
        const defaultTextStyle = presentation.getElementsByTagName('p:defaultTextStyle')[0];
        if (defaultTextStyle) {
          presentation.insertBefore(embeddedFontLst, defaultTextStyle);
        } else {
          presentation.appendChild(embeddedFontLst);
        }
      }

      // Add font references
      this.fonts.forEach((font) => {
        // Check if already exists
        const existing = Array.from(embeddedFontLst.getElementsByTagName('p:font')).find(
          (node) => node.getAttribute('typeface') === font.name
        );

        if (!existing) {
          const embedFont = doc.createElement('p:embeddedFont');

          const fontNode = doc.createElement('p:font');
          fontNode.setAttribute('typeface', font.name);
          embedFont.appendChild(fontNode);

          const regular = doc.createElement('p:regular');
          regular.setAttribute('r:id', `rId${font.rid}`);
          embedFont.appendChild(regular);

          embeddedFontLst.appendChild(embedFont);
        }
      });

      this.zip.file('ppt/presentation.xml', new XMLSerializer().serializeToString(doc));
    }

    async updateRelsPresentationXML() {
      const file = this.zip.file('ppt/_rels/presentation.xml.rels');
      if (!file) throw new Error('presentation.xml.rels not found');

      const xmlStr = await file.async('string');
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlStr, 'text/xml');
      const relationships = doc.getElementsByTagName('Relationships')[0];

      this.fonts.forEach((font) => {
        const rel = doc.createElement('Relationship');
        rel.setAttribute('Id', `rId${font.rid}`);
        rel.setAttribute('Target', `fonts/${font.rid}.fntdata`);
        rel.setAttribute(
          'Type',
          'http://schemas.openxmlformats.org/officeDocument/2006/relationships/font'
        );
        relationships.appendChild(rel);
      });

      this.zip.file('ppt/_rels/presentation.xml.rels', new XMLSerializer().serializeToString(doc));
    }

    updateFontFiles() {
      this.fonts.forEach((font) => {
        this.zip.file(`ppt/fonts/${font.rid}.fntdata`, font.data);
      });
    }
  }

  // src/utils.js

  // canvas context for color normalization
  let _ctx;
  function getCtx() {
    if (!_ctx) _ctx = document.createElement('canvas').getContext('2d', { willReadFrequently: true });
    return _ctx;
  }

  function getTableBorder(style, side, scale) {
    const widthStr = style[`border${side}Width`];
    const styleStr = style[`border${side}Style`];
    const colorStr = style[`border${side}Color`];

    const width = parseFloat(widthStr) || 0;
    if (width === 0 || styleStr === 'none' || styleStr === 'hidden') {
      return null;
    }

    const color = parseColor(colorStr);
    if (!color.hex || color.opacity === 0) return null;

    let dash = 'solid';
    if (styleStr === 'dashed') dash = 'dash';
    if (styleStr === 'dotted') dash = 'dot';

    return {
      pt: width * 0.75 * scale, // Convert px to pt
      color: color.hex,
      style: dash,
    };
  }

  /**
   * Extracts native table data for PptxGenJS.
   */
  function extractTableData(node, scale) {
    const rows = [];
    const colWidths = [];

    // 1. Calculate Column Widths based on the first row of cells
    // We look at the first <tr>'s children to determine visual column widths.
    // Note: This assumes a fixed grid. Complex colspan/rowspan on the first row
    // might skew widths, but getBoundingClientRect captures the rendered result.
    const firstRow = node.querySelector('tr');
    if (firstRow) {
      const cells = Array.from(firstRow.children);
      cells.forEach((cell) => {
        const rect = cell.getBoundingClientRect();
        const wIn = rect.width * (1 / 96) * scale;
        colWidths.push(wIn);
      });
    }

    // 2. Iterate Rows
    const trList = node.querySelectorAll('tr');
    trList.forEach((tr) => {
      const rowData = [];
      const cellList = Array.from(tr.children).filter((c) =>
        ['TD', 'TH'].includes(c.tagName)
      );

      cellList.forEach((cell) => {
        const style = window.getComputedStyle(cell);
        const cellText = cell.innerText.replace(/[\n\r\t]+/g, ' ').trim();

        // A. Text Style
        const textStyle = getTextStyle(style, scale);

        // B. Cell Background
        const bg = parseColor(style.backgroundColor);
        const fill = (bg.hex && bg.opacity > 0) ? { color: bg.hex } : null;

        // C. Alignment
        let align = 'left';
        if (style.textAlign === 'center') align = 'center';
        if (style.textAlign === 'right' || style.textAlign === 'end') align = 'right';

        let valign = 'top';
        if (style.verticalAlign === 'middle') valign = 'middle';
        if (style.verticalAlign === 'bottom') valign = 'bottom';

        // D. Padding (Margins in PPTX)
        // CSS Padding px -> PPTX Margin pt
        const padding = getPadding(style, scale);
        // getPadding returns [top, right, bottom, left] in inches relative to scale
        // PptxGenJS expects points (pt) for margin: [t, r, b, l]
        // or discrete properties. Let's use discrete for clarity.
        const margin = [
          padding[0] * 72, // top
          padding[1] * 72, // right
          padding[2] * 72, // bottom
          padding[3] * 72  // left
        ];

        // E. Borders
        const borderTop = getTableBorder(style, 'Top', scale);
        const borderRight = getTableBorder(style, 'Right', scale);
        const borderBottom = getTableBorder(style, 'Bottom', scale);
        const borderLeft = getTableBorder(style, 'Left', scale);

        // F. Construct Cell Object
        rowData.push({
          text: cellText,
          options: {
            color: textStyle.color,
            fontFace: textStyle.fontFace,
            fontSize: textStyle.fontSize,
            bold: textStyle.bold,
            italic: textStyle.italic,
            underline: textStyle.underline,

            fill: fill,
            align: align,
            valign: valign,
            margin: margin,

            rowspan: parseInt(cell.getAttribute('rowspan')) || null,
            colspan: parseInt(cell.getAttribute('colspan')) || null,

            border: {
              pt: null, // trigger explicit object structure
              top: borderTop,
              right: borderRight,
              bottom: borderBottom,
              left: borderLeft
            }
          },
        });
      });

      if (rowData.length > 0) {
        rows.push(rowData);
      }
    });

    return { rows, colWidths };
  }

  // Checks if any parent element has overflow: hidden which would clip this element
  function isClippedByParent(node) {
    let parent = node.parentElement;
    while (parent && parent !== document.body) {
      const style = window.getComputedStyle(parent);
      const overflow = style.overflow;
      if (overflow === 'hidden' || overflow === 'clip') {
        return true;
      }
      parent = parent.parentElement;
    }
    return false;
  }

  // Helper to save gradient text
  // Helper to save gradient text: extracts the first color from a gradient string
  function getGradientFallbackColor(bgImage) {
    if (!bgImage || bgImage === 'none') return null;

    // 1. Extract content inside function(...)
    // Handles linear-gradient(...), radial-gradient(...), repeating-linear-gradient(...)
    const match = bgImage.match(/gradient\((.*)\)/);
    if (!match) return null;

    const content = match[1];

    // 2. Split by comma, respecting parentheses (to avoid splitting inside rgb(), oklch(), etc.)
    const parts = [];
    let current = '';
    let parenDepth = 0;

    for (const char of content) {
      if (char === '(') parenDepth++;
      if (char === ')') parenDepth--;
      if (char === ',' && parenDepth === 0) {
        parts.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    if (current) parts.push(current.trim());

    // 3. Find first part that is a color (skip angle/direction)
    for (const part of parts) {
      // Ignore directions (to right) or angles (90deg, 0.5turn)
      if (/^(to\s|[\d\.]+(deg|rad|turn|grad))/.test(part)) continue;

      // Extract color: Remove trailing position (e.g. "red 50%" -> "red")
      // Regex matches whitespace + number + unit at end of string
      const colorPart = part.replace(/\s+(-?[\d\.]+(%|px|em|rem|ch|vh|vw)?)$/, '');

      // Check if it's not just a number (some gradients might have bare numbers? unlikely in standard syntax)
      if (colorPart) return colorPart;
    }

    return null;
  }

  function mapDashType(style) {
    if (style === 'dashed') return 'dash';
    if (style === 'dotted') return 'dot';
    return 'solid';
  }

  /**
   * Analyzes computed border styles and determines the rendering strategy.
   */
  function getBorderInfo(style, scale) {
    const top = {
      width: parseFloat(style.borderTopWidth) || 0,
      style: style.borderTopStyle,
      color: parseColor(style.borderTopColor).hex,
    };
    const right = {
      width: parseFloat(style.borderRightWidth) || 0,
      style: style.borderRightStyle,
      color: parseColor(style.borderRightColor).hex,
    };
    const bottom = {
      width: parseFloat(style.borderBottomWidth) || 0,
      style: style.borderBottomStyle,
      color: parseColor(style.borderBottomColor).hex,
    };
    const left = {
      width: parseFloat(style.borderLeftWidth) || 0,
      style: style.borderLeftStyle,
      color: parseColor(style.borderLeftColor).hex,
    };

    const hasAnyBorder = top.width > 0 || right.width > 0 || bottom.width > 0 || left.width > 0;
    if (!hasAnyBorder) return { type: 'none' };

    // Check if all sides are uniform
    const isUniform =
      top.width === right.width &&
      top.width === bottom.width &&
      top.width === left.width &&
      top.style === right.style &&
      top.style === bottom.style &&
      top.style === left.style &&
      top.color === right.color &&
      top.color === bottom.color &&
      top.color === left.color;

    if (isUniform) {
      return {
        type: 'uniform',
        options: {
          width: top.width * 0.75 * scale,
          color: top.color,
          transparency: (1 - parseColor(style.borderTopColor).opacity) * 100,
          dashType: mapDashType(top.style),
        },
      };
    } else {
      return {
        type: 'composite',
        sides: { top, right, bottom, left },
      };
    }
  }

  /**
   * Generates an SVG image for composite borders that respects border-radius.
   */
  function generateCompositeBorderSVG(w, h, radius, sides) {
    radius = radius / 2; // Adjust for SVG rendering
    const clipId = 'clip_' + Math.random().toString(36).substr(2, 9);
    let borderRects = '';

    if (sides.top.width > 0 && sides.top.color) {
      borderRects += `<rect x="0" y="0" width="${w}" height="${sides.top.width}" fill="#${sides.top.color}" />`;
    }
    if (sides.right.width > 0 && sides.right.color) {
      borderRects += `<rect x="${w - sides.right.width}" y="0" width="${sides.right.width}" height="${h}" fill="#${sides.right.color}" />`;
    }
    if (sides.bottom.width > 0 && sides.bottom.color) {
      borderRects += `<rect x="0" y="${h - sides.bottom.width}" width="${w}" height="${sides.bottom.width}" fill="#${sides.bottom.color}" />`;
    }
    if (sides.left.width > 0 && sides.left.color) {
      borderRects += `<rect x="0" y="0" width="${sides.left.width}" height="${h}" fill="#${sides.left.color}" />`;
    }

    const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
        <defs>
            <clipPath id="${clipId}">
                <rect x="0" y="0" width="${w}" height="${h}" rx="${radius}" ry="${radius}" />
            </clipPath>
        </defs>
        <g clip-path="url(#${clipId})">
            ${borderRects}
        </g>
    </svg>`;

    return 'data:image/svg+xml;base64,' + btoa(svg);
  }

  /**
   * Generates an SVG data URL for a solid shape with non-uniform corner radii.
   */
  function generateCustomShapeSVG(w, h, color, opacity, radii) {
    let { tl, tr, br, bl } = radii;

    // Clamp radii using CSS spec logic (avoid overlap)
    const factor = Math.min(
      w / (tl + tr) || Infinity,
      h / (tr + br) || Infinity,
      w / (br + bl) || Infinity,
      h / (bl + tl) || Infinity
    );

    if (factor < 1) {
      tl *= factor;
      tr *= factor;
      br *= factor;
      bl *= factor;
    }

    const path = `
    M ${tl} 0
    L ${w - tr} 0
    A ${tr} ${tr} 0 0 1 ${w} ${tr}
    L ${w} ${h - br}
    A ${br} ${br} 0 0 1 ${w - br} ${h}
    L ${bl} ${h}
    A ${bl} ${bl} 0 0 1 0 ${h - bl}
    L 0 ${tl}
    A ${tl} ${tl} 0 0 1 ${tl} 0
    Z
  `;

    const svg = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
      <path d="${path}" fill="#${color}" fill-opacity="${opacity}" />
    </svg>`;

    return 'data:image/svg+xml;base64,' + btoa(svg);
  }

  // --- REPLACE THE EXISTING parseColor FUNCTION ---
  function parseColor(str) {
    if (!str || str === 'transparent' || str.trim() === 'rgba(0, 0, 0, 0)') {
      return { hex: null, opacity: 0 };
    }

    const ctx = getCtx();
    ctx.fillStyle = str;
    const computed = ctx.fillStyle;

    // 1. Handle Hex Output (e.g. #ff0000) - Fast Path
    if (computed.startsWith('#')) {
      let hex = computed.slice(1);
      let opacity = 1;
      if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
      if (hex.length === 4) hex = hex.split('').map(c => c + c).join('');
      if (hex.length === 8) {
        opacity = parseInt(hex.slice(6), 16) / 255;
        hex = hex.slice(0, 6);
      }
      return { hex: hex.toUpperCase(), opacity };
    }

    // 2. Handle RGB/RGBA Output (standard) - Fast Path
    if (computed.startsWith('rgb')) {
      const match = computed.match(/[\d.]+/g);
      if (match && match.length >= 3) {
        const r = parseInt(match[0]);
        const g = parseInt(match[1]);
        const b = parseInt(match[2]);
        const a = match.length > 3 ? parseFloat(match[3]) : 1;
        const hex = ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        return { hex, opacity: a };
      }
    }

    // 3. Fallback: Browser returned a format we don't parse (oklch, lab, color(srgb...), etc.)
    // Use Canvas API to convert to sRGB
    ctx.clearRect(0, 0, 1, 1);
    ctx.fillRect(0, 0, 1, 1);
    const data = ctx.getImageData(0, 0, 1, 1).data;
    // data = [r, g, b, a]
    const r = data[0];
    const g = data[1];
    const b = data[2];
    const a = data[3] / 255;

    if (a === 0) return { hex: null, opacity: 0 };

    const hex = ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    return { hex, opacity: a };
  }

  function getPadding(style, scale) {
    const pxToInch = 1 / 96;
    return [
      (parseFloat(style.paddingTop) || 0) * pxToInch * scale,
      (parseFloat(style.paddingRight) || 0) * pxToInch * scale,
      (parseFloat(style.paddingBottom) || 0) * pxToInch * scale,
      (parseFloat(style.paddingLeft) || 0) * pxToInch * scale,
    ];
  }

  function getSoftEdges(filterStr, scale) {
    if (!filterStr || filterStr === 'none') return null;
    const match = filterStr.match(/blur\(([\d.]+)px\)/);
    if (match) return parseFloat(match[1]) * 0.75 * scale;
    return null;
  }

  function getTextStyle(style, scale) {
    let colorObj = parseColor(style.color);

    const bgClip = style.webkitBackgroundClip || style.backgroundClip;
    if (colorObj.opacity === 0 && bgClip === 'text') {
      const fallback = getGradientFallbackColor(style.backgroundImage);
      if (fallback) colorObj = parseColor(fallback);
    }

    let lineSpacing = null;
    const fontSizePx = parseFloat(style.fontSize);
    const lhStr = style.lineHeight;

    if (lhStr && lhStr !== 'normal') {
      let lhPx = parseFloat(lhStr);

      // Edge Case: If browser returns a raw multiplier (e.g. "1.5")
      // we must multiply by font size to get the height in pixels.
      // (Note: getComputedStyle usually returns 'px', but inline styles might differ)
      if (/^[0-9.]+$/.test(lhStr)) {
        lhPx = lhPx * fontSizePx;
      }

      if (!isNaN(lhPx) && lhPx > 0) {
        // Convert Pixel Height to Point Height (1px = 0.75pt)
        // And apply the global layout scale.
        lineSpacing = lhPx * 0.75 * scale;
      }
    }

    // --- Spacing (Margins) ---
    // Convert CSS margins (px) to PPTX Paragraph Spacing (pt).
    let paraSpaceBefore = 0;
    let paraSpaceAfter = 0;

    const mt = parseFloat(style.marginTop) || 0;
    const mb = parseFloat(style.marginBottom) || 0;

    if (mt > 0) paraSpaceBefore = mt * 0.75 * scale;
    if (mb > 0) paraSpaceAfter = mb * 0.75 * scale;

    return {
      color: colorObj.hex || '000000',
      fontFace: style.fontFamily.split(',')[0].replace(/['"]/g, ''),
      fontSize: Math.floor(fontSizePx * 0.75 * scale),
      bold: parseInt(style.fontWeight) >= 600,
      italic: style.fontStyle === 'italic',
      underline: style.textDecoration.includes('underline'),
      // Only add if we have a valid value
      ...(lineSpacing && { lineSpacing }),
      ...(paraSpaceBefore > 0 && { paraSpaceBefore }),
      ...(paraSpaceAfter > 0 && { paraSpaceAfter }),
      // Map background color to highlight if present
      ...(parseColor(style.backgroundColor).hex ? { highlight: parseColor(style.backgroundColor).hex } : {}),
    };
  }

  /**
   * Determines if a given DOM node is primarily a text container.
   * Updated to correctly reject Icon elements so they are rendered as images.
   */
  function isTextContainer(node) {
    const hasText = node.textContent.trim().length > 0;
    if (!hasText) return false;

    const children = Array.from(node.children);
    if (children.length === 0) return true;

    const isSafeInline = (el) => {
      // 1. Reject Web Components / Custom Elements
      if (el.tagName.includes('-')) return false;
      // 2. Reject Explicit Images/SVGs
      if (el.tagName === 'IMG' || el.tagName === 'SVG') return false;

      // 3. Reject Class-based Icons (FontAwesome, Material, Bootstrap, etc.)
      // If an <i> or <span> has icon classes, it is a visual object, not text.
      if (el.tagName === 'I' || el.tagName === 'SPAN') {
        const cls = el.getAttribute('class') || '';
        if (
          cls.includes('fa-') ||
          cls.includes('fas') ||
          cls.includes('far') ||
          cls.includes('fab') ||
          cls.includes('material-icons') ||
          cls.includes('bi-') ||
          cls.includes('icon')
        ) {
          return false;
        }
      }

      const style = window.getComputedStyle(el);
      const display = style.display;

      // 4. Standard Inline Tag Check
      const isInlineTag = ['SPAN', 'B', 'STRONG', 'EM', 'I', 'A', 'SMALL', 'MARK'].includes(
        el.tagName
      );
      const isInlineDisplay = display.includes('inline');

      if (!isInlineTag && !isInlineDisplay) return false;

      // 5. Structural Styling Check
      // If a child has a background or border, it's a layout block, not a simple text span.
      const bgColor = parseColor(style.backgroundColor);
      const hasVisibleBg = bgColor.hex && bgColor.opacity > 0;
      const hasBorder =
        parseFloat(style.borderWidth) > 0 && parseColor(style.borderColor).opacity > 0;

      // 4. Check for empty shapes (visual objects without text, like dots)
      const hasContent = el.textContent.trim().length > 0;
      if (!hasContent && (hasVisibleBg || hasBorder)) {
        return false;
      }

      return true;
    };

    return children.every(isSafeInline);
  }

  function getRotation(transformStr) {
    if (!transformStr || transformStr === 'none') return 0;
    const values = transformStr.split('(')[1].split(')')[0].split(',');
    if (values.length < 4) return 0;
    const a = parseFloat(values[0]);
    const b = parseFloat(values[1]);
    return Math.round(Math.atan2(b, a) * (180 / Math.PI));
  }

  function svgToPng(node) {
    return new Promise((resolve) => {
      const clone = node.cloneNode(true);
      const rect = node.getBoundingClientRect();
      const width = rect.width || 300;
      const height = rect.height || 150;

      function inlineStyles(source, target) {
        const computed = window.getComputedStyle(source);
        const properties = [
          'fill',
          'stroke',
          'stroke-width',
          'stroke-linecap',
          'stroke-linejoin',
          'opacity',
          'font-family',
          'font-size',
          'font-weight',
        ];

        if (computed.fill === 'none') target.setAttribute('fill', 'none');
        else if (computed.fill) target.style.fill = computed.fill;

        if (computed.stroke === 'none') target.setAttribute('stroke', 'none');
        else if (computed.stroke) target.style.stroke = computed.stroke;

        properties.forEach((prop) => {
          if (prop !== 'fill' && prop !== 'stroke') {
            const val = computed[prop];
            if (val && val !== 'auto') target.style[prop] = val;
          }
        });

        for (let i = 0; i < source.children.length; i++) {
          if (target.children[i]) inlineStyles(source.children[i], target.children[i]);
        }
      }

      inlineStyles(node, clone);
      clone.setAttribute('width', width);
      clone.setAttribute('height', height);
      clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

      const xml = new XMLSerializer().serializeToString(clone);
      const svgUrl = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(xml)}`;
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const scale = 3;
        canvas.width = width * scale;
        canvas.height = height * scale;
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);
        ctx.drawImage(img, 0, 0, width, height);
        resolve(canvas.toDataURL('image/png'));
      };
      img.onerror = () => resolve(null);
      img.src = svgUrl;
    });
  }

  function getVisibleShadow(shadowStr, scale) {
    if (!shadowStr || shadowStr === 'none') return null;
    const shadows = shadowStr.split(/,(?![^()]*\))/);
    for (let s of shadows) {
      s = s.trim();
      if (s.startsWith('rgba(0, 0, 0, 0)')) continue;
      const match = s.match(
        /(rgba?\([^)]+\)|#[0-9a-fA-F]+)\s+(-?[\d.]+)px\s+(-?[\d.]+)px\s+([\d.]+)px/
      );
      if (match) {
        const colorStr = match[1];
        const x = parseFloat(match[2]);
        const y = parseFloat(match[3]);
        const blur = parseFloat(match[4]);
        const distance = Math.sqrt(x * x + y * y);
        let angle = Math.atan2(y, x) * (180 / Math.PI);
        if (angle < 0) angle += 360;
        const colorObj = parseColor(colorStr);
        return {
          type: 'outer',
          angle: angle,
          blur: blur * 0.75 * scale,
          offset: distance * 0.75 * scale,
          color: colorObj.hex || '000000',
          opacity: colorObj.opacity,
        };
      }
    }
    return null;
  }

  /**
   * Generates an SVG image for gradients, supporting degrees and keywords.
   */
  function generateGradientSVG(w, h, bgString, radius, border) {
    try {
      const match = bgString.match(/linear-gradient\((.*)\)/);
      if (!match) return null;
      const content = match[1];

      // Split by comma, ignoring commas inside parentheses (e.g. rgba())
      const parts = content.split(/,(?![^()]*\))/).map((p) => p.trim());
      if (parts.length < 2) return null;

      let x1 = '0%',
        y1 = '0%',
        x2 = '0%',
        y2 = '100%';
      let stopsStartIndex = 0;
      const firstPart = parts[0].toLowerCase();

      // 1. Check for Keywords (to right, etc.)
      if (firstPart.startsWith('to ')) {
        stopsStartIndex = 1;
        const direction = firstPart.replace('to ', '').trim();
        switch (direction) {
          case 'top':
            y1 = '100%';
            y2 = '0%';
            break;
          case 'bottom':
            y1 = '0%';
            y2 = '100%';
            break;
          case 'left':
            x1 = '100%';
            x2 = '0%';
            break;
          case 'right':
            x2 = '100%';
            break;
          case 'top right':
            x1 = '0%';
            y1 = '100%';
            x2 = '100%';
            y2 = '0%';
            break;
          case 'top left':
            x1 = '100%';
            y1 = '100%';
            x2 = '0%';
            y2 = '0%';
            break;
          case 'bottom right':
            x2 = '100%';
            y2 = '100%';
            break;
          case 'bottom left':
            x1 = '100%';
            y2 = '100%';
            break;
        }
      }
      // 2. Check for Degrees (45deg, 90deg, etc.)
      else if (firstPart.match(/^-?[\d.]+(deg|rad|turn|grad)$/)) {
        stopsStartIndex = 1;
        const val = parseFloat(firstPart);
        // CSS 0deg is Top (North), 90deg is Right (East), 180deg is Bottom (South)
        // We convert this to SVG coordinates on a unit square (0-100%).
        // Formula: Map angle to perimeter coordinates.
        if (!isNaN(val)) {
          const deg = firstPart.includes('rad') ? val * (180 / Math.PI) : val;
          const cssRad = ((deg - 90) * Math.PI) / 180; // Correct CSS angle offset

          // Calculate standard vector for rectangle center (50, 50)
          const scale = 50; // Distance from center to edge (approx)
          const cos = Math.cos(cssRad); // Y component (reversed in SVG)
          const sin = Math.sin(cssRad); // X component

          // Invert Y for SVG coordinate system
          x1 = (50 - sin * scale).toFixed(1) + '%';
          y1 = (50 + cos * scale).toFixed(1) + '%';
          x2 = (50 + sin * scale).toFixed(1) + '%';
          y2 = (50 - cos * scale).toFixed(1) + '%';
        }
      }

      // 3. Process Color Stops
      let stopsXML = '';
      const stopParts = parts.slice(stopsStartIndex);

      stopParts.forEach((part, idx) => {
        // Parse "Color Position" (e.g., "red 50%")
        // Regex looks for optional space + number + unit at the end of the string
        let color = part;
        let offset = Math.round((idx / (stopParts.length - 1)) * 100) + '%';

        const posMatch = part.match(/^(.*?)\s+(-?[\d.]+(?:%|px)?)$/);
        if (posMatch) {
          color = posMatch[1];
          offset = posMatch[2];
        }

        // Handle RGBA/RGB for SVG compatibility
        let opacity = 1;
        if (color.includes('rgba')) {
          const rgbaMatch = color.match(/[\d.]+/g);
          if (rgbaMatch && rgbaMatch.length >= 4) {
            opacity = rgbaMatch[3];
            color = `rgb(${rgbaMatch[0]},${rgbaMatch[1]},${rgbaMatch[2]})`;
          }
        }

        stopsXML += `<stop offset="${offset}" stop-color="${color.trim()}" stop-opacity="${opacity}"/>`;
      });

      let strokeAttr = '';
      if (border) {
        strokeAttr = `stroke="#${border.color}" stroke-width="${border.width}"`;
      }

      const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
          <defs>
            <linearGradient id="grad" x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}">
              ${stopsXML}
            </linearGradient>
          </defs>
          <rect x="0" y="0" width="${w}" height="${h}" rx="${radius}" ry="${radius}" fill="url(#grad)" ${strokeAttr} />
      </svg>`;

      return 'data:image/svg+xml;base64,' + btoa(svg);
    } catch (e) {
      console.warn('Gradient generation failed:', e);
      return null;
    }
  }

  function generateBlurredSVG(w, h, color, radius, blurPx) {
    const padding = blurPx * 3;
    const fullW = w + padding * 2;
    const fullH = h + padding * 2;
    const x = padding;
    const y = padding;
    let shapeTag = '';
    const isCircle = radius >= Math.min(w, h) / 2 - 1 && Math.abs(w - h) < 2;

    if (isCircle) {
      const cx = x + w / 2;
      const cy = y + h / 2;
      const rx = w / 2;
      const ry = h / 2;
      shapeTag = `<ellipse cx="${cx}" cy="${cy}" rx="${rx}" ry="${ry}" fill="#${color}" filter="url(#f1)" />`;
    } else {
      shapeTag = `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="${radius}" ry="${radius}" fill="#${color}" filter="url(#f1)" />`;
    }

    const svg = `
  <svg xmlns="http://www.w3.org/2000/svg" width="${fullW}" height="${fullH}" viewBox="0 0 ${fullW} ${fullH}">
    <defs>
      <filter id="f1" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="${blurPx}" />
      </filter>
    </defs>
    ${shapeTag}
  </svg>`;

    return {
      data: 'data:image/svg+xml;base64,' + btoa(svg),
      padding: padding,
    };
  }

  // src/utils.js

  // ... (keep all existing exports) ...

  /**
   * Traverses the target DOM and collects all unique font-family names used.
   */
  function getUsedFontFamilies(root) {
    const families = new Set();

    function scan(node) {
      if (node.nodeType === 1) {
        // Element
        const style = window.getComputedStyle(node);
        const fontList = style.fontFamily.split(',');
        // The first font in the stack is the primary one
        const primary = fontList[0].trim().replace(/['"]/g, '');
        if (primary) families.add(primary);
      }
      for (const child of node.childNodes) {
        scan(child);
      }
    }

    // Handle array of roots or single root
    const elements = Array.isArray(root) ? root : [root];
    elements.forEach((el) => {
      const node = typeof el === 'string' ? document.querySelector(el) : el;
      if (node) scan(node);
    });

    return families;
  }

  /**
   * Scans document.styleSheets to find @font-face URLs for the requested families.
   * Returns an array of { name, url } objects.
   */
  async function getAutoDetectedFonts(usedFamilies) {
    const foundFonts = [];
    const processedUrls = new Set();

    // Helper to extract clean URL from CSS src string
    const extractUrl = (srcStr) => {
      // Look for url("...") or url('...') or url(...)
      // Prioritize woff, ttf, otf. Avoid woff2 if possible as handling is harder,
      // but if it's the only one, take it (convert logic handles it best effort).
      const matches = srcStr.match(/url\((['"]?)(.*?)\1\)/g);
      if (!matches) return null;

      // Filter for preferred formats
      let chosenUrl = null;
      for (const match of matches) {
        const urlRaw = match.replace(/url\((['"]?)(.*?)\1\)/, '$2');
        // Skip data URIs for now (unless you want to support base64 embedding)
        if (urlRaw.startsWith('data:')) continue;

        if (urlRaw.includes('.ttf') || urlRaw.includes('.otf') || urlRaw.includes('.woff')) {
          chosenUrl = urlRaw;
          break; // Found a good one
        }
        // Fallback
        if (!chosenUrl) chosenUrl = urlRaw;
      }
      return chosenUrl;
    };

    for (const sheet of Array.from(document.styleSheets)) {
      try {
        // Accessing cssRules on cross-origin sheets (like Google Fonts) might fail
        // if CORS headers aren't set. We wrap in try/catch.
        const rules = sheet.cssRules || sheet.rules;
        if (!rules) continue;

        for (const rule of Array.from(rules)) {
          if (rule.constructor.name === 'CSSFontFaceRule' || rule.type === 5) {
            const familyName = rule.style.getPropertyValue('font-family').replace(/['"]/g, '').trim();

            if (usedFamilies.has(familyName)) {
              const src = rule.style.getPropertyValue('src');
              const url = extractUrl(src);

              if (url && !processedUrls.has(url)) {
                processedUrls.add(url);
                foundFonts.push({ name: familyName, url: url });
              }
            }
          }
        }
      } catch (e) {
        // SecurityError is common for external stylesheets (CORS).
        // We cannot scan those automatically via CSSOM.
        console.warn('error:', e);
        console.warn('Cannot scan stylesheet for fonts (CORS restriction):', sheet.href);
      }
    }

    return foundFonts;
  }

  // src/image-processor.js

  async function getProcessedImage(
    src,
    targetW,
    targetH,
    radius,
    objectFit = 'fill',
    objectPosition = '50% 50%'
  ) {
    return new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = 'Anonymous';

      img.onload = () => {
        const canvas = document.createElement('canvas');
        const scale = 2; // Double resolution
        canvas.width = targetW * scale;
        canvas.height = targetH * scale;
        const ctx = canvas.getContext('2d');
        ctx.scale(scale, scale);

        // Normalize radius
        let r = { tl: 0, tr: 0, br: 0, bl: 0 };
        if (typeof radius === 'number') {
          r = { tl: radius, tr: radius, br: radius, bl: radius };
        } else if (typeof radius === 'object' && radius !== null) {
          r = { ...r, ...radius };
        }

        // 1. Draw Mask
        ctx.beginPath();
        // ... (radius clamping logic remains the same) ...
        const factor = Math.min(
          targetW / (r.tl + r.tr) || Infinity,
          targetH / (r.tr + r.br) || Infinity,
          targetW / (r.br + r.bl) || Infinity,
          targetH / (r.bl + r.tl) || Infinity
        );

        if (factor < 1) {
          r.tl *= factor;
          r.tr *= factor;
          r.br *= factor;
          r.bl *= factor;
        }

        ctx.moveTo(r.tl, 0);
        ctx.lineTo(targetW - r.tr, 0);
        ctx.arcTo(targetW, 0, targetW, r.tr, r.tr);
        ctx.lineTo(targetW, targetH - r.br);
        ctx.arcTo(targetW, targetH, targetW - r.br, targetH, r.br);
        ctx.lineTo(r.bl, targetH);
        ctx.arcTo(0, targetH, 0, targetH - r.bl, r.bl);
        ctx.lineTo(0, r.tl);
        ctx.arcTo(0, 0, r.tl, 0, r.tl);
        ctx.closePath();
        ctx.fillStyle = '#000';
        ctx.fill();

        // 2. Composite Source-In
        ctx.globalCompositeOperation = 'source-in';

        // 3. Draw Image with Object Fit logic
        const wRatio = targetW / img.width;
        const hRatio = targetH / img.height;
        let renderW, renderH;

        if (objectFit === 'contain') {
          const fitScale = Math.min(wRatio, hRatio);
          renderW = img.width * fitScale;
          renderH = img.height * fitScale;
        } else if (objectFit === 'cover') {
          const coverScale = Math.max(wRatio, hRatio);
          renderW = img.width * coverScale;
          renderH = img.height * coverScale;
        } else if (objectFit === 'none') {
          renderW = img.width;
          renderH = img.height;
        } else if (objectFit === 'scale-down') {
          const scaleDown = Math.min(1, Math.min(wRatio, hRatio));
          renderW = img.width * scaleDown;
          renderH = img.height * scaleDown;
        } else {
          // 'fill' (default)
          renderW = targetW;
          renderH = targetH;
        }

        // Handle Object Position (simplified parsing for "x% y%" or keywords)
        let posX = 0.5; // Default center
        let posY = 0.5;

        const posParts = objectPosition.split(' ');
        if (posParts.length > 0) {
          const parsePos = (val) => {
            if (val === 'left' || val === 'top') return 0;
            if (val === 'center') return 0.5;
            if (val === 'right' || val === 'bottom') return 1;
            if (val.includes('%')) return parseFloat(val) / 100;
            return 0.5; // fallback
          };
          posX = parsePos(posParts[0]);
          posY = posParts.length > 1 ? parsePos(posParts[1]) : 0.5;
        }

        const renderX = (targetW - renderW) * posX;
        const renderY = (targetH - renderH) * posY;

        ctx.drawImage(img, renderX, renderY, renderW, renderH);

        resolve(canvas.toDataURL('image/png'));
      };

      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  // src/index.js

  // Normalize import
  const PptxGenJS = PptxGenJS$1 ?? PptxGenJSImport;

  const PPI = 96;
  const PX_TO_INCH = 1 / PPI;

  /**
   * Main export function.
   * @param {HTMLElement | string | Array<HTMLElement | string>} target
   * @param {Object} options
   * @param {string} [options.fileName]
   * @param {boolean} [options.skipDownload=false] - If true, prevents automatic download
   * @param {Object} [options.listConfig] - Config for bullets
   * @returns {Promise<Blob>} - Returns the generated PPTX Blob
   */
  async function exportToPptx(target, options = {}) {
    const resolvePptxConstructor = (pkg) => {
      if (!pkg) return null;
      if (typeof pkg === 'function') return pkg;
      if (pkg && typeof pkg.default === 'function') return pkg.default;
      if (pkg && typeof pkg.PptxGenJS === 'function') return pkg.PptxGenJS;
      if (pkg && pkg.PptxGenJS && typeof pkg.PptxGenJS.default === 'function')
        return pkg.PptxGenJS.default;
      return null;
    };

    const PptxConstructor = resolvePptxConstructor(PptxGenJS);
    if (!PptxConstructor) throw new Error('PptxGenJS constructor not found.');
    const pptx = new PptxConstructor();
    pptx.layout = 'LAYOUT_16x9';

    const elements = Array.isArray(target) ? target : [target];

    for (const el of elements) {
      const root = typeof el === 'string' ? document.querySelector(el) : el;
      if (!root) {
        console.warn('Element not found, skipping slide:', el);
        continue;
      }
      const slide = pptx.addSlide();
      await processSlide(root, slide, pptx, options);
    }

    // 3. Font Embedding Logic
    let finalBlob;
    let fontsToEmbed = options.fonts || [];

    if (options.autoEmbedFonts) {
      // A. Scan DOM for used font families
      const usedFamilies = getUsedFontFamilies(elements);

      // B. Scan CSS for URLs matches
      const detectedFonts = await getAutoDetectedFonts(usedFamilies);

      // C. Merge (Avoid duplicates)
      const explicitNames = new Set(fontsToEmbed.map((f) => f.name));
      for (const autoFont of detectedFonts) {
        if (!explicitNames.has(autoFont.name)) {
          fontsToEmbed.push(autoFont);
        }
      }

      if (detectedFonts.length > 0) {
        console.log(
          'Auto-detected fonts:',
          detectedFonts.map((f) => f.name)
        );
      }
    }

    if (fontsToEmbed.length > 0) {
      // Generate initial PPTX
      const initialBlob = await pptx.write({ outputType: 'blob' });

      // Load into Embedder
      const zip = await JSZip.loadAsync(initialBlob);
      const embedder = new PPTXEmbedFonts();
      await embedder.loadZip(zip);

      // Fetch and Embed
      for (const fontCfg of fontsToEmbed) {
        try {
          const response = await fetch(fontCfg.url);
          if (!response.ok) throw new Error(`Failed to fetch ${fontCfg.url}`);
          const buffer = await response.arrayBuffer();

          // Infer type
          const ext = fontCfg.url.split('.').pop().split(/[?#]/)[0].toLowerCase();
          let type = 'ttf';
          if (['woff', 'otf'].includes(ext)) type = ext;

          await embedder.addFont(fontCfg.name, buffer, type);
        } catch (e) {
          console.warn(`Failed to embed font: ${fontCfg.name} (${fontCfg.url})`, e);
        }
      }

      await embedder.updateFiles();
      finalBlob = await embedder.generateBlob();
    } else {
      // No fonts to embed
      finalBlob = await pptx.write({ outputType: 'blob' });
    }

    // 4. Output Handling
    // If skipDownload is NOT true, proceed with browser download
    if (!options.skipDownload) {
      const fileName = options.fileName || 'export.pptx';
      const url = URL.createObjectURL(finalBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Always return the blob so the caller can use it (e.g. upload to server)
    return finalBlob;
  }

  /**
   * Worker function to process a single DOM element into a single PPTX slide.
   * @param {HTMLElement} root - The root element for this slide.
   * @param {PptxGenJS.Slide} slide - The PPTX slide object to add content to.
   * @param {PptxGenJS} pptx - The main PPTX instance.
   */
  async function processSlide(root, slide, pptx, globalOptions = {}) {
    const rootRect = root.getBoundingClientRect();
    const PPTX_WIDTH_IN = 10;
    const PPTX_HEIGHT_IN = 5.625;

    const contentWidthIn = rootRect.width * PX_TO_INCH;
    const contentHeightIn = rootRect.height * PX_TO_INCH;
    const scale = Math.min(PPTX_WIDTH_IN / contentWidthIn, PPTX_HEIGHT_IN / contentHeightIn);

    const layoutConfig = {
      rootX: rootRect.x,
      rootY: rootRect.y,
      scale: scale,
      offX: (PPTX_WIDTH_IN - contentWidthIn * scale) / 2,
      offY: (PPTX_HEIGHT_IN - contentHeightIn * scale) / 2,
    };

    const renderQueue = [];
    const asyncTasks = []; // Queue for heavy operations (Images, Canvas)
    let domOrderCounter = 0;

    // Sync Traversal Function
    function collect(node, parentZIndex) {
      const order = domOrderCounter++;

      let currentZ = parentZIndex;
      let nodeStyle = null;
      const nodeType = node.nodeType;

      if (nodeType === 1) {
        nodeStyle = window.getComputedStyle(node);
        // Optimization: Skip completely hidden elements immediately
        if (
          nodeStyle.display === 'none' ||
          nodeStyle.visibility === 'hidden' ||
          nodeStyle.opacity === '0'
        ) {
          return;
        }
        if (nodeStyle.zIndex !== 'auto') {
          currentZ = parseInt(nodeStyle.zIndex);
        }
      }

      // Prepare the item. If it needs async work, it returns a 'job'
      const result = prepareRenderItem(
        node,
        { ...layoutConfig, root },
        order,
        pptx,
        currentZ,
        nodeStyle,
        globalOptions
      );

      if (result) {
        if (result.items) {
          // Push items immediately to queue (data might be missing but filled later)
          renderQueue.push(...result.items);
        }
        if (result.job) {
          // Push the promise-returning function to the task list
          asyncTasks.push(result.job);
        }
        if (result.stopRecursion) return;
      }

      // Recurse children synchronously
      const childNodes = node.childNodes;
      for (let i = 0; i < childNodes.length; i++) {
        collect(childNodes[i], currentZ);
      }
    }

    // 1. Traverse and build the structure (Fast)
    collect(root, 0);

    // 2. Execute all heavy tasks in parallel (Fast)
    if (asyncTasks.length > 0) {
      await Promise.all(asyncTasks.map((task) => task()));
    }

    // 3. Cleanup and Sort
    // Remove items that failed to generate data (marked with skip)
    const finalQueue = renderQueue.filter(
      (item) => !item.skip && (item.type !== 'image' || item.options.data)
    );

    finalQueue.sort((a, b) => {
      if (a.zIndex !== b.zIndex) return a.zIndex - b.zIndex;
      return a.domOrder - b.domOrder;
    });

    // 4. Add to Slide
    for (const item of finalQueue) {
      if (item.type === 'shape') slide.addShape(item.shapeType, item.options);
      if (item.type === 'image') slide.addImage(item.options);
      if (item.type === 'text') slide.addText(item.textParts, item.options);
      if (item.type === 'table') {
        slide.addTable(item.tableData.rows, {
          x: item.options.x,
          y: item.options.y,
          w: item.options.w,
          colW: item.tableData.colWidths, // Essential for correct layout
          autoPage: false,
          // Remove default table styles so our extracted CSS applies cleanly
          border: { type: "none" },
          fill: { color: "FFFFFF", transparency: 100 }
        });
      }
    }
  }

  /**
   * Optimized html2canvas wrapper
   * Includes fix for cropped icons by adjusting styles in the cloned document.
   */
  async function elementToCanvasImage(node, widthPx, heightPx) {
    return new Promise((resolve) => {
      // 1. Assign a temp ID to locate the node inside the cloned document
      const originalId = node.id;
      const tempId = 'pptx-capture-' + Math.random().toString(36).substr(2, 9);
      node.id = tempId;

      const width = Math.max(Math.ceil(widthPx), 1);
      const height = Math.max(Math.ceil(heightPx), 1);
      const style = window.getComputedStyle(node);

      html2canvas(node, {
        backgroundColor: null,
        logging: false,
        scale: 3, // Higher scale for sharper icons
        useCORS: true, // critical for external fonts/images
        onclone: (clonedDoc) => {
          const clonedNode = clonedDoc.getElementById(tempId);
          if (clonedNode) {
            // --- FIX: PREVENT ICON CLIPPING ---
            // 1. Force overflow visible so glyphs bleeding out aren't cut
            clonedNode.style.overflow = 'visible';

            // 2. Adjust alignment for Icons to prevent baseline clipping
            // (Applies to <i>, <span>, or standard icon classes)
            const tag = clonedNode.tagName;
            if (tag === 'I' || tag === 'SPAN' || clonedNode.className.includes('fa-')) {
              // Flex center helps align the glyph exactly in the middle of the box
              // preventing top/bottom cropping due to line-height mismatches.
              clonedNode.style.display = 'inline-flex';
              clonedNode.style.justifyContent = 'center';
              clonedNode.style.alignItems = 'center';

              // Remove margins that might offset the capture
              clonedNode.style.margin = '0';

              // Ensure the font fits
              clonedNode.style.lineHeight = '1';
              clonedNode.style.verticalAlign = 'middle';
            }
          }
        },
      })
        .then((canvas) => {
          // Restore the original ID
          if (originalId) node.id = originalId;
          else node.removeAttribute('id');

          const destCanvas = document.createElement('canvas');
          destCanvas.width = width;
          destCanvas.height = height;
          const ctx = destCanvas.getContext('2d');

          // Draw captured canvas.
          // We simply draw it to fill the box. Since we centered it in 'onclone',
          // the glyph should now be visible within the bounds.
          ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, width, height);

          // --- Border Radius Clipping (Existing Logic) ---
          let tl = parseFloat(style.borderTopLeftRadius) || 0;
          let tr = parseFloat(style.borderTopRightRadius) || 0;
          let br = parseFloat(style.borderBottomRightRadius) || 0;
          let bl = parseFloat(style.borderBottomLeftRadius) || 0;

          const f = Math.min(
            width / (tl + tr) || Infinity,
            height / (tr + br) || Infinity,
            width / (br + bl) || Infinity,
            height / (bl + tl) || Infinity
          );

          if (f < 1) {
            tl *= f;
            tr *= f;
            br *= f;
            bl *= f;
          }

          if (tl + tr + br + bl > 0) {
            ctx.globalCompositeOperation = 'destination-in';
            ctx.beginPath();
            ctx.moveTo(tl, 0);
            ctx.lineTo(width - tr, 0);
            ctx.arcTo(width, 0, width, tr, tr);
            ctx.lineTo(width, height - br);
            ctx.arcTo(width, height, width - br, height, br);
            ctx.lineTo(bl, height);
            ctx.arcTo(0, height, 0, height - bl, bl);
            ctx.lineTo(0, tl);
            ctx.arcTo(0, 0, tl, 0, tl);
            ctx.closePath();
            ctx.fill();
          }

          resolve(destCanvas.toDataURL('image/png'));
        })
        .catch((e) => {
          if (originalId) node.id = originalId;
          else node.removeAttribute('id');
          console.warn('Canvas capture failed for node', node, e);
          resolve(null);
        });
    });
  }

  /**
   * Helper to identify elements that should be rendered as icons (Images).
   * Detects Custom Elements AND generic tags (<i>, <span>) with icon classes/pseudo-elements.
   */
  function isIconElement(node) {
    // 1. Custom Elements (hyphenated tags) or Explicit Library Tags
    const tag = node.tagName.toUpperCase();
    if (
      tag.includes('-') ||
      [
        'MATERIAL-ICON',
        'ICONIFY-ICON',
        'REMIX-ICON',
        'ION-ICON',
        'EVA-ICON',
        'BOX-ICON',
        'FA-ICON',
      ].includes(tag)
    ) {
      return true;
    }

    // 2. Class-based Icons (FontAwesome, Bootstrap, Material symbols) on <i> or <span>
    if (tag === 'I' || tag === 'SPAN') {
      const cls = node.getAttribute('class') || '';
      if (
        typeof cls === 'string' &&
        (cls.includes('fa-') ||
          cls.includes('fas') ||
          cls.includes('far') ||
          cls.includes('fab') ||
          cls.includes('bi-') ||
          cls.includes('material-icons') ||
          cls.includes('icon'))
      ) {
        // Double-check: Must have pseudo-element content to be a CSS icon
        const before = window.getComputedStyle(node, '::before').content;
        const after = window.getComputedStyle(node, '::after').content;
        const hasContent = (c) => c && c !== 'none' && c !== 'normal' && c !== '""';

        if (hasContent(before) || hasContent(after)) return true;
      }
    }

    return false;
  }

  /**
   * Replaces createRenderItem.
   * Returns { items: [], job: () => Promise, stopRecursion: boolean }
   */
  function prepareRenderItem(
    node,
    config,
    domOrder,
    pptx,
    effectiveZIndex,
    computedStyle,
    globalOptions = {}
  ) {
    // 1. Text Node Handling
    if (node.nodeType === 3) {
      const textContent = node.nodeValue.trim();
      if (!textContent) return null;

      const parent = node.parentElement;
      if (!parent) return null;

      if (isTextContainer(parent)) return null; // Parent handles it

      const range = document.createRange();
      range.selectNode(node);
      const rect = range.getBoundingClientRect();
      range.detach();

      const style = window.getComputedStyle(parent);
      const widthPx = rect.width;
      const heightPx = rect.height;
      const unrotatedW = widthPx * PX_TO_INCH * config.scale;
      const unrotatedH = heightPx * PX_TO_INCH * config.scale;

      const x = config.offX + (rect.left - config.rootX) * PX_TO_INCH * config.scale;
      const y = config.offY + (rect.top - config.rootY) * PX_TO_INCH * config.scale;

      return {
        items: [
          {
            type: 'text',
            zIndex: effectiveZIndex,
            domOrder,
            textParts: [
              {
                text: textContent,
                options: getTextStyle(style, config.scale),
              },
            ],
            options: { x, y, w: unrotatedW, h: unrotatedH, margin: 0, autoFit: false },
          },
        ],
        stopRecursion: false,
      };
    }

    if (node.nodeType !== 1) return null;
    const style = computedStyle; // Use pre-computed style

    const rect = node.getBoundingClientRect();
    if (rect.width < 0.5 || rect.height < 0.5) return null;

    const zIndex = effectiveZIndex;
    const rotation = getRotation(style.transform);
    const elementOpacity = parseFloat(style.opacity);
    const safeOpacity = isNaN(elementOpacity) ? 1 : elementOpacity;

    const widthPx = node.offsetWidth || rect.width;
    const heightPx = node.offsetHeight || rect.height;
    const unrotatedW = widthPx * PX_TO_INCH * config.scale;
    const unrotatedH = heightPx * PX_TO_INCH * config.scale;
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    let x = config.offX + (centerX - config.rootX) * PX_TO_INCH * config.scale - unrotatedW / 2;
    let y = config.offY + (centerY - config.rootY) * PX_TO_INCH * config.scale - unrotatedH / 2;
    let w = unrotatedW;
    let h = unrotatedH;

    const items = [];

    if (node.tagName === 'TABLE') {
      const tableData = extractTableData(node, config.scale);

      // Calculate total table width to ensure X position is correct
      // (Though x calculation above usually handles it, tables can be finicky)
      return {
        items: [
          {
            type: 'table',
            zIndex: effectiveZIndex,
            domOrder,
            tableData: tableData,
            options: { x, y, w: unrotatedW, h: unrotatedH }
          }
        ],
        stopRecursion: true // Important: Don't process TR/TD as separate shapes
      };
    }

    if ((node.tagName === 'UL' || node.tagName === 'OL') && !isComplexHierarchy(node)) {
      const listItems = [];
      const liChildren = Array.from(node.children).filter((c) => c.tagName === 'LI');

      liChildren.forEach((child, index) => {
        const liStyle = window.getComputedStyle(child);
        const liRect = child.getBoundingClientRect();
        const parentRect = node.getBoundingClientRect(); // node is UL/OL

        // 1. Determine Bullet Config
        let bullet = { type: 'bullet' };
        const listStyleType = liStyle.listStyleType || 'disc';

        if (node.tagName === 'OL' || listStyleType === 'decimal') {
          bullet = { type: 'number' };
        } else if (listStyleType === 'none') {
          bullet = false;
        } else {
          let code = '2022'; // disc
          if (listStyleType === 'circle') code = '25CB';
          if (listStyleType === 'square') code = '25A0';

          // --- CHANGE: Color & Size Logic (Option > ::marker > CSS color) ---
          let finalHex = '000000';
          let markerFontSize = null;

          // A. Check Global Option override
          if (globalOptions?.listConfig?.color) {
            finalHex = parseColor(globalOptions.listConfig.color).hex || '000000';
          }
          // B. Check ::marker pseudo element (supported in modern browsers)
          else {
            const markerStyle = window.getComputedStyle(child, '::marker');
            const markerColor = parseColor(markerStyle.color);
            if (markerColor.hex) {
              finalHex = markerColor.hex;
            } else {
              // C. Fallback to LI text color
              const colorObj = parseColor(liStyle.color);
              if (colorObj.hex) finalHex = colorObj.hex;
            }

            // Check ::marker font-size
            const markerFs = parseFloat(markerStyle.fontSize);
            if (!isNaN(markerFs) && markerFs > 0) {
              // Convert px->pt for PPTX
              markerFontSize = markerFs * 0.75 * config.scale;
            }
          }

          bullet = { code, color: finalHex };
          if (markerFontSize) {
            bullet.fontSize = markerFontSize;
          }
        }

        // 2. Calculate Dynamic Indent (Respects padding-left)
        // Visual Indent = Distance from UL left edge to LI Content left edge.
        // PptxGenJS 'indent' = Space between bullet and text? 
        // Actually PptxGenJS 'indent' allows setting the hanging indent.
        // We calculate the TOTAL visual offset from the parent container.
        // 1 px = 0.75 pt (approx, standard DTP).
        // We must scale it by config.scale.
        const visualIndentPx = liRect.left - parentRect.left;
        /*
           Standard indent in PPT is ~27pt.
           If visualIndentPx is small (e.g. 10px padding), we want small indent.
           If visualIndentPx is large (40px padding), we want large indent.
           We treat 'indent' as the value to pass to PptxGenJS.
        */
        const computedIndentPt = visualIndentPx * 0.75 * config.scale;

        if (bullet && computedIndentPt > 0) {
          bullet.indent = computedIndentPt;
          // Also support custom margin between bullet and text if provided in listConfig?
          // For now, computedIndentPt covers the visual placement.
        }

        // 3. Extract Text Parts
        const parts = collectListParts(child, liStyle, config.scale);

        if (parts.length > 0) {
          parts.forEach((p) => {
            if (!p.options) p.options = {};
          });

          // A. Apply Bullet
          // Workaround: pptxgenjs bullets inherit the style of the text run they are attached to.
          // To support ::marker styles (color, size) that differ from the text, we create
          // a "dummy" text run at the start of the list item that carries the bullet configuration.
          if (bullet) {
            const firstPartInfo = parts[0].options;

            // Create a dummy run. We use a Zero Width Space to ensure it's rendered but invisible.
            // This "run" will hold the bullet and its specific color/size.
            const bulletRun = {
              text: '\u200B',
              options: {
                ...firstPartInfo, // Inherit base props (fontFace, etc.)
                color: bullet.color || firstPartInfo.color,
                fontSize: bullet.fontSize || firstPartInfo.fontSize,
                bullet: bullet
              }
            };

            // Don't duplicate transparent or empty color from firstPart if bullet has one
            if (bullet.color) bulletRun.options.color = bullet.color;
            if (bullet.fontSize) bulletRun.options.fontSize = bullet.fontSize;

            // Prepend
            parts.unshift(bulletRun);
          }

          // B. Apply Spacing
          let ptBefore = 0;
          let ptAfter = 0;

          // A. Check Global Options (Expected in Points)
          if (globalOptions.listConfig?.spacing) {
            if (typeof globalOptions.listConfig.spacing.before === 'number') {
              ptBefore = globalOptions.listConfig.spacing.before;
            }
            if (typeof globalOptions.listConfig.spacing.after === 'number') {
              ptAfter = globalOptions.listConfig.spacing.after;
            }
          }
          // B. Fallback to CSS Margins (Convert px -> pt)
          else {
            const mt = parseFloat(liStyle.marginTop) || 0;
            const mb = parseFloat(liStyle.marginBottom) || 0;
            if (mt > 0) ptBefore = mt * 0.75 * config.scale;
            if (mb > 0) ptAfter = mb * 0.75 * config.scale;
          }

          if (ptBefore > 0) parts[0].options.paraSpaceBefore = ptBefore;
          if (ptAfter > 0) parts[0].options.paraSpaceAfter = ptAfter;

          if (index < liChildren.length - 1) {
            parts[parts.length - 1].options.breakLine = true;
          }

          listItems.push(...parts);
        }
      });

      if (listItems.length > 0) {
        // Add background if exists
        const bgColorObj = parseColor(style.backgroundColor);
        if (bgColorObj.hex && bgColorObj.opacity > 0) {
          items.push({
            type: 'shape',
            zIndex,
            domOrder,
            shapeType: 'rect',
            options: { x, y, w, h, fill: { color: bgColorObj.hex } },
          });
        }

        items.push({
          type: 'text',
          zIndex: zIndex + 1,
          domOrder,
          textParts: listItems,
          options: {
            x,
            y,
            w,
            h,
            align: 'left',
            valign: 'top',
            margin: 0,
            autoFit: false,
            wrap: true,
          },
        });

        return { items, stopRecursion: true };
      }
    }

    if (node.tagName === 'CANVAS') {
      const item = {
        type: 'image',
        zIndex,
        domOrder,
        options: { x, y, w, h, rotate: rotation, data: null }
      };

      const job = async () => {
        try {
          // Direct data extraction from the canvas element
          // This preserves the exact current state of the chart
          const dataUrl = node.toDataURL('image/png');

          // Basic validation
          if (dataUrl && dataUrl.length > 10) {
            item.options.data = dataUrl;
          } else {
            item.skip = true;
          }
        } catch (e) {
          // Tainted canvas (CORS issues) will throw here
          console.warn('Failed to capture canvas content:', e);
          item.skip = true;
        }
      };

      return { items: [item], job, stopRecursion: true };
    }

    // --- ASYNC JOB: SVG Tags ---
    if (node.nodeName.toUpperCase() === 'SVG') {
      const item = {
        type: 'image',
        zIndex,
        domOrder,
        options: { data: null, x, y, w, h, rotate: rotation },
      };

      const job = async () => {
        const processed = await svgToPng(node);
        if (processed) item.options.data = processed;
        else item.skip = true;
      };

      return { items: [item], job, stopRecursion: true };
    }

    // --- ASYNC JOB: IMG Tags ---
    if (node.tagName === 'IMG') {
      let radii = {
        tl: parseFloat(style.borderTopLeftRadius) || 0,
        tr: parseFloat(style.borderTopRightRadius) || 0,
        br: parseFloat(style.borderBottomRightRadius) || 0,
        bl: parseFloat(style.borderBottomLeftRadius) || 0,
      };

      const hasAnyRadius = radii.tl > 0 || radii.tr > 0 || radii.br > 0 || radii.bl > 0;
      if (!hasAnyRadius) {
        const parent = node.parentElement;
        const parentStyle = window.getComputedStyle(parent);
        if (parentStyle.overflow !== 'visible') {
          const pRadii = {
            tl: parseFloat(parentStyle.borderTopLeftRadius) || 0,
            tr: parseFloat(parentStyle.borderTopRightRadius) || 0,
            br: parseFloat(parentStyle.borderBottomRightRadius) || 0,
            bl: parseFloat(parentStyle.borderBottomLeftRadius) || 0,
          };
          const pRect = parent.getBoundingClientRect();
          if (Math.abs(pRect.width - rect.width) < 5 && Math.abs(pRect.height - rect.height) < 5) {
            radii = pRadii;
          }
        }
      }

      const objectFit = style.objectFit || 'fill'; // default CSS behavior is fill
      const objectPosition = style.objectPosition || '50% 50%';

      const item = {
        type: 'image',
        zIndex,
        domOrder,
        options: { x, y, w, h, rotate: rotation, data: null },
      };

      const job = async () => {
        const processed = await getProcessedImage(
          node.src,
          widthPx,
          heightPx,
          radii,
          objectFit,
          objectPosition
        );
        if (processed) item.options.data = processed;
        else item.skip = true;
      };

      return { items: [item], job, stopRecursion: true };
    }

    // --- ASYNC JOB: Icons and Other Elements ---
    if (isIconElement(node)) {
      const item = {
        type: 'image',
        zIndex,
        domOrder,
        options: { x, y, w, h, rotate: rotation, data: null },
      };
      const job = async () => {
        const pngData = await elementToCanvasImage(node, widthPx, heightPx);
        if (pngData) item.options.data = pngData;
        else item.skip = true;
      };
      return { items: [item], job, stopRecursion: true };
    }

    // Radii logic
    const borderRadiusValue = parseFloat(style.borderRadius) || 0;
    const borderBottomLeftRadius = parseFloat(style.borderBottomLeftRadius) || 0;
    const borderBottomRightRadius = parseFloat(style.borderBottomRightRadius) || 0;
    const borderTopLeftRadius = parseFloat(style.borderTopLeftRadius) || 0;
    const borderTopRightRadius = parseFloat(style.borderTopRightRadius) || 0;

    const hasPartialBorderRadius =
      (borderBottomLeftRadius > 0 && borderBottomLeftRadius !== borderRadiusValue) ||
      (borderBottomRightRadius > 0 && borderBottomRightRadius !== borderRadiusValue) ||
      (borderTopLeftRadius > 0 && borderTopLeftRadius !== borderRadiusValue) ||
      (borderTopRightRadius > 0 && borderTopRightRadius !== borderRadiusValue) ||
      (borderRadiusValue === 0 &&
        (borderBottomLeftRadius ||
          borderBottomRightRadius ||
          borderTopLeftRadius ||
          borderTopRightRadius));

    // --- PRIORITY SVG: Solid Fill with Partial Border Radius (Vector Cone/Tab) ---
    // Fix for "missing cone": Prioritize SVG vector generation over Raster Canvas for simple shapes with partial radii.
    // This avoids html2canvas failures on empty divs.
    const tempBg = parseColor(style.backgroundColor);
    const isTxt = isTextContainer(node);

    if (hasPartialBorderRadius && tempBg.hex && !isTxt) {
      const shapeSvg = generateCustomShapeSVG(
        widthPx,
        heightPx,
        tempBg.hex,
        tempBg.opacity,
        {
          tl: parseFloat(style.borderTopLeftRadius) || 0,
          tr: parseFloat(style.borderTopRightRadius) || 0,
          br: parseFloat(style.borderBottomRightRadius) || 0,
          bl: parseFloat(style.borderBottomLeftRadius) || 0,
        }
      );

      return {
        items: [{
          type: 'image',
          zIndex,
          domOrder,
          options: { data: shapeSvg, x, y, w, h, rotate: rotation },
        }],
        stopRecursion: true // Treat as leaf
      };
    }

    // --- ASYNC JOB: Clipped Divs via Canvas ---
    if (hasPartialBorderRadius && isClippedByParent(node)) {
      const marginLeft = parseFloat(style.marginLeft) || 0;
      const marginTop = parseFloat(style.marginTop) || 0;
      x += marginLeft * PX_TO_INCH * config.scale;
      y += marginTop * PX_TO_INCH * config.scale;

      const item = {
        type: 'image',
        zIndex,
        domOrder,
        options: { x, y, w, h, rotate: rotation, data: null },
      };

      const job = async () => {
        const canvasImageData = await elementToCanvasImage(node, widthPx, heightPx);
        if (canvasImageData) item.options.data = canvasImageData;
        else item.skip = true;
      };

      return { items: [item], job, stopRecursion: true };
    }

    // --- SYNC: Standard CSS Extraction ---
    const bgColorObj = parseColor(style.backgroundColor);
    const bgClip = style.webkitBackgroundClip || style.backgroundClip;
    const isBgClipText = bgClip === 'text';
    const hasGradient =
      !isBgClipText && style.backgroundImage && style.backgroundImage.includes('linear-gradient');

    const borderColorObj = parseColor(style.borderColor);
    const borderWidth = parseFloat(style.borderWidth);
    const hasBorder = borderWidth > 0 && borderColorObj.hex;

    const borderInfo = getBorderInfo(style, config.scale);
    const hasUniformBorder = borderInfo.type === 'uniform';
    const hasCompositeBorder = borderInfo.type === 'composite';

    const shadowStr = style.boxShadow;
    const hasShadow = shadowStr && shadowStr !== 'none';
    const softEdge = getSoftEdges(style.filter, config.scale);

    let isImageWrapper = false;
    const imgChild = Array.from(node.children).find((c) => c.tagName === 'IMG');
    if (imgChild) {
      const childW = imgChild.offsetWidth || imgChild.getBoundingClientRect().width;
      const childH = imgChild.offsetHeight || imgChild.getBoundingClientRect().height;
      if (childW >= widthPx - 2 && childH >= heightPx - 2) isImageWrapper = true;
    }

    let textPayload = null;
    const isText = isTextContainer(node);

    if (isText) {
      const textParts = [];
      let trimNextLeading = false;

      node.childNodes.forEach((child, index) => {
        // Handle <br> tags
        if (child.tagName === 'BR') {
          // 1. Trim trailing space from the *previous* text part to prevent double wrapping
          if (textParts.length > 0) {
            const lastPart = textParts[textParts.length - 1];
            if (lastPart.text && typeof lastPart.text === 'string') {
              lastPart.text = lastPart.text.trimEnd();
            }
          }

          textParts.push({ text: '', options: { breakLine: true } });

          // 2. Signal to trim leading space from the *next* text part
          trimNextLeading = true;
          return;
        }

        let textVal = child.nodeType === 3 ? child.nodeValue : child.textContent;
        let nodeStyle = child.nodeType === 1 ? window.getComputedStyle(child) : style;
        textVal = textVal.replace(/[\n\r\t]+/g, ' ').replace(/\s{2,}/g, ' ');

        // Trimming logic
        if (index === 0) textVal = textVal.trimStart();
        if (trimNextLeading) {
          textVal = textVal.trimStart();
          trimNextLeading = false;
        }

        if (index === node.childNodes.length - 1) textVal = textVal.trimEnd();
        if (nodeStyle.textTransform === 'uppercase') textVal = textVal.toUpperCase();
        if (nodeStyle.textTransform === 'lowercase') textVal = textVal.toLowerCase();

        if (textVal.length > 0) {
          const textOpts = getTextStyle(nodeStyle, config.scale);

          // BUG FIX: Numbers 1 and 2 having background.
          // If this is a naked Text Node (nodeType 3), it inherits style from the parent container.
          // The parent container's background is already rendered as the Shape Fill.
          // We must NOT render it again as a Text Highlight, otherwise it looks like a solid marker on top of the shape.
          if (child.nodeType === 3 && textOpts.highlight) {
            delete textOpts.highlight;
          }

          textParts.push({ text: textVal, options: textOpts });
        }
      });

      if (textParts.length > 0) {
        let align = style.textAlign || 'left';
        if (align === 'start') align = 'left';
        if (align === 'end') align = 'right';
        let valign = 'top';
        if (style.alignItems === 'center') valign = 'middle';
        if (style.justifyContent === 'center' && style.display.includes('flex')) align = 'center';

        const pt = parseFloat(style.paddingTop) || 0;
        const pb = parseFloat(style.paddingBottom) || 0;
        if (Math.abs(pt - pb) < 2 && bgColorObj.hex) valign = 'middle';

        let padding = getPadding(style, config.scale);
        if (align === 'center' && valign === 'middle') padding = [0, 0, 0, 0];

        textPayload = { text: textParts, align, valign, inset: padding };
      }
    }

    if (hasGradient || (softEdge && bgColorObj.hex && !isImageWrapper)) {
      let bgData = null;
      let padIn = 0;
      if (softEdge) {
        const svgInfo = generateBlurredSVG(
          widthPx,
          heightPx,
          bgColorObj.hex,
          borderRadiusValue,
          softEdge
        );
        bgData = svgInfo.data;
        padIn = svgInfo.padding * PX_TO_INCH * config.scale;
      } else {
        bgData = generateGradientSVG(
          widthPx,
          heightPx,
          style.backgroundImage,
          borderRadiusValue,
          hasBorder ? { color: borderColorObj.hex, width: borderWidth } : null
        );
      }

      if (bgData) {
        items.push({
          type: 'image',
          zIndex,
          domOrder,
          options: {
            data: bgData,
            x: x - padIn,
            y: y - padIn,
            w: w + padIn * 2,
            h: h + padIn * 2,
            rotate: rotation,
          },
        });
      }

      if (textPayload) {
        textPayload.text[0].options.fontSize =
          Math.floor(textPayload.text[0]?.options?.fontSize) || 12;
        items.push({
          type: 'text',
          zIndex: zIndex + 1,
          domOrder,
          textParts: textPayload.text,
          options: {
            x,
            y,
            w,
            h,
            align: textPayload.align,
            valign: textPayload.valign,
            inset: textPayload.inset,
            rotate: rotation,
            margin: 0,
            wrap: true,
            autoFit: false,
          },
        });
      }
      if (hasCompositeBorder) {
        const borderItems = createCompositeBorderItems(
          borderInfo.sides,
          x,
          y,
          w,
          h,
          config.scale,
          zIndex,
          domOrder
        );
        items.push(...borderItems);
      }
    } else if (
      (bgColorObj.hex && !isImageWrapper) ||
      hasUniformBorder ||
      hasCompositeBorder ||
      hasShadow ||
      textPayload
    ) {
      const finalAlpha = safeOpacity * bgColorObj.opacity;
      const transparency = (1 - finalAlpha) * 100;
      const useSolidFill = bgColorObj.hex && !isImageWrapper;

      if (hasPartialBorderRadius && useSolidFill && !textPayload) {
        const shapeSvg = generateCustomShapeSVG(
          widthPx,
          heightPx,
          bgColorObj.hex,
          bgColorObj.opacity,
          {
            tl: parseFloat(style.borderTopLeftRadius) || 0,
            tr: parseFloat(style.borderTopRightRadius) || 0,
            br: parseFloat(style.borderBottomRightRadius) || 0,
            bl: parseFloat(style.borderBottomLeftRadius) || 0,
          }
        );

        items.push({
          type: 'image',
          zIndex,
          domOrder,
          options: { data: shapeSvg, x, y, w, h, rotate: rotation },
        });
      } else {
        const shapeOpts = {
          x,
          y,
          w,
          h,
          rotate: rotation,
          fill: useSolidFill
            ? { color: bgColorObj.hex, transparency: transparency }
            : { type: 'none' },
          line: hasUniformBorder ? borderInfo.options : null,
        };

        if (hasShadow) shapeOpts.shadow = getVisibleShadow(shadowStr, config.scale);

        // 1. Calculate dimensions first
        const minDimension = Math.min(widthPx, heightPx);

        let rawRadius = parseFloat(style.borderRadius) || 0;
        const isPercentage = style.borderRadius && style.borderRadius.toString().includes('%');

        // 2. Normalize radius to pixels
        let radiusPx = rawRadius;
        if (isPercentage) {
          radiusPx = (rawRadius / 100) * minDimension;
        }

        let shapeType = pptx.ShapeType.rect;

        // 3. Determine Shape Logic
        const isSquare = Math.abs(widthPx - heightPx) < 1;
        const isFullyRound = radiusPx >= minDimension / 2;

        // CASE A: It is an Ellipse if:
        // 1. It is explicitly "50%" (standard CSS way to make ovals/circles)
        // 2. OR it is a perfect square and fully rounded (a circle)
        if (isFullyRound && (isPercentage || isSquare)) {
          shapeType = pptx.ShapeType.ellipse;
        }
        // CASE B: It is a Rounded Rectangle (including "Pill" shapes)
        else if (radiusPx > 0) {
          shapeType = pptx.ShapeType.roundRect;
          let r = radiusPx / minDimension;
          if (r > 0.5) r = 0.5;
          if (minDimension < 100) r = r * 0.25; // Small size adjustment for small shapes

          shapeOpts.rectRadius = r;
        }

        if (textPayload) {
          textPayload.text[0].options.fontSize =
            Math.floor(textPayload.text[0]?.options?.fontSize) || 12;
          const textOptions = {
            shape: shapeType,
            ...shapeOpts,
            rotate: rotation,
            align: textPayload.align,
            valign: textPayload.valign,
            inset: textPayload.inset,
            margin: 0,
            wrap: true,
            autoFit: false,
          };
          items.push({
            type: 'text',
            zIndex,
            domOrder,
            textParts: textPayload.text,
            options: textOptions,
          });
        } else if (!hasPartialBorderRadius) {
          items.push({
            type: 'shape',
            zIndex,
            domOrder,
            shapeType,
            options: shapeOpts,
          });
        }
      }

      if (hasCompositeBorder) {
        const borderSvgData = generateCompositeBorderSVG(
          widthPx,
          heightPx,
          borderRadiusValue,
          borderInfo.sides
        );
        if (borderSvgData) {
          items.push({
            type: 'image',
            zIndex: zIndex + 1,
            domOrder,
            options: { data: borderSvgData, x, y, w, h, rotate: rotation },
          });
        }
      }
    }

    return { items, stopRecursion: !!textPayload };
  }

  function isComplexHierarchy(root) {
    // Use a simple tree traversal to find forbidden elements in the list structure
    const stack = [root];
    while (stack.length > 0) {
      const el = stack.pop();

      // 1. Layouts: Flex/Grid on LIs
      if (el.tagName === 'LI') {
        const s = window.getComputedStyle(el);
        if (s.display === 'flex' || s.display === 'grid' || s.display === 'inline-flex') return true;
      }

      // 2. Media / Icons
      if (['IMG', 'SVG', 'CANVAS', 'VIDEO', 'IFRAME'].includes(el.tagName)) return true;
      if (isIconElement(el)) return true;

      // 3. Nested Lists (Flattening logic doesn't support nested bullets well yet)
      if (el !== root && (el.tagName === 'UL' || el.tagName === 'OL')) return true;

      // Recurse, but don't go too deep if not needed
      for (let i = 0; i < el.children.length; i++) {
        stack.push(el.children[i]);
      }
    }
    return false;
  }

  function collectListParts(node, parentStyle, scale) {
    const parts = [];

    // Check for CSS Content (::before) - often used for icons
    if (node.nodeType === 1) {
      const beforeStyle = window.getComputedStyle(node, '::before');
      const content = beforeStyle.content;
      if (content && content !== 'none' && content !== 'normal' && content !== '""') {
        // Strip quotes
        const cleanContent = content.replace(/^['"]|['"]$/g, '');
        if (cleanContent.trim()) {
          parts.push({
            text: cleanContent + ' ', // Add space after icon
            options: getTextStyle(window.getComputedStyle(node), scale),
          });
        }
      }
    }

    node.childNodes.forEach((child) => {
      if (child.nodeType === 3) {
        // Text
        const val = child.nodeValue.replace(/[\n\r\t]+/g, ' ').replace(/\s{2,}/g, ' ');
        if (val) {
          // Use parent style if child is text node, otherwise current style
          const styleToUse = node.nodeType === 1 ? window.getComputedStyle(node) : parentStyle;
          parts.push({
            text: val,
            options: getTextStyle(styleToUse, scale),
          });
        }
      } else if (child.nodeType === 1) {
        // Element (span, i, b)
        // Recurse
        parts.push(...collectListParts(child, parentStyle, scale));
      }
    });

    return parts;
  }

  function createCompositeBorderItems(sides, x, y, w, h, scale, zIndex, domOrder) {
    const items = [];
    const pxToInch = 1 / 96;
    const common = { zIndex: zIndex + 1, domOrder, shapeType: 'rect' };

    if (sides.top.width > 0)
      items.push({
        ...common,
        options: { x, y, w, h: sides.top.width * pxToInch * scale, fill: { color: sides.top.color } },
      });
    if (sides.right.width > 0)
      items.push({
        ...common,
        options: {
          x: x + w - sides.right.width * pxToInch * scale,
          y,
          w: sides.right.width * pxToInch * scale,
          h,
          fill: { color: sides.right.color },
        },
      });
    if (sides.bottom.width > 0)
      items.push({
        ...common,
        options: {
          x,
          y: y + h - sides.bottom.width * pxToInch * scale,
          w,
          h: sides.bottom.width * pxToInch * scale,
          fill: { color: sides.bottom.color },
        },
      });
    if (sides.left.width > 0)
      items.push({
        ...common,
        options: {
          x,
          y,
          w: sides.left.width * pxToInch * scale,
          h,
          fill: { color: sides.left.color },
        },
      });

    return items;
  }

  exports.exportToPptx = exportToPptx;

}));
